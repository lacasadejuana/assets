(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define("init_public_map", [], f);
    } else if ("object" == typeof exports) {
      exports["init_public_map"] = f();
    } else {
      g["init_public_map"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    "use strict";
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid2 ? "Symbol(src)_1." + uid2 : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map3 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map3), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray4(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray4(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result2 = data2[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data2, key) ? data2[key] : undefined2;
        }
        function hashHas(key) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty2.call(data2, key);
        }
        function hashSet(key, value) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index == lastIndex) {
            data2.pop();
          } else {
            splice.call(data2, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          return index < 0 ? undefined2 : data2[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          if (index < 0) {
            ++this.size;
            data2.push([key, value]);
          } else {
            data2[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map3 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data2 = getMapData(this, key), size3 = data2.size;
          data2.set(key, value);
          this.size += data2.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data2 = this.__data__, result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs = data2.__data__;
            if (!Map3 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs);
          }
          data2.set(key, value);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray4(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get4(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat2 = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray4(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat2 || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat2 ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat2 ? getAllKeysIn : getAllKeys : isFlat2 ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end) {
          var length = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start2 > end ? 0 : toLength(end);
          while (start2 < end) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray4(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start2, end) {
          return number >= nativeMin(start2, end) && number < nativeMax(start2, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data2 = matchData[index];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data2 = matchData[index];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray4(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end) {
          var index = -1, length = array.length;
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start2 > end ? 0 : end - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray4(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set4 = iteratee2 ? null : createSet(array);
            if (set4) {
              return setToArray(set4);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray4(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start2 && end >= length ? array : baseSlice(array, start2, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined2;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray4(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
              end = step = undefined2;
            }
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
            return baseRange(start2, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data2 = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data2 ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data2 = array[length], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data2 = map2.__data__;
          return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data2 = transforms[index], size3 = data2.size;
            switch (data2.type) {
              case "drop":
                start2 += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start2 + size3);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end - size3);
                break;
            }
          }
          return { "start": start2, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray4(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray4(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data2[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform2) {
          start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start2 + index];
            }
            index = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index < start2) {
              otherArgs[index] = args[index];
            }
            otherArgs[start2] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp2 = nativeNow(), remaining = HOT_SPAN - (stamp2 - lastCalled);
            lastCalled = stamp2;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size3 = size3 === undefined2 ? length : size3;
          while (++index < size3) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size3);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray4(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end = length;
          }
          return baseFill(array, value, start2, end);
        }
        function findIndex3(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf2(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
            start2 = 0;
            end = length;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start2, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap2(value, interceptor2) {
          interceptor2(value);
          return value;
        }
        function thru(value, interceptor2) {
          return interceptor2(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor2 = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor2);
          }
          value = value.slice(start2, +start2 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor2],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray4(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex3);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray4(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray4(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray4(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray4(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray4(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray4(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray4(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind4 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind4));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay4 = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once2(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray4(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle3(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray4(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray4 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray4(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has2(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set3(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray4(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start2, end) {
          start2 = toFinite(start2);
          if (end === undefined2) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start2, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase3 = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase3 = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template2(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind4(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches2(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray4(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix2) {
          var id = ++idCounter;
          return toString(prefix2) + id;
        }
        var add2 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind4;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay4;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches2;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once2;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set3;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap2;
        lodash.throttle = throttle3;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add2;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase3;
        lodash.capitalize = capitalize2;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex3;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has2;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf2;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray4;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap2;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol2;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase3;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size2;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template2;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim2;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray4(value);
            var interceptor2 = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor2], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor2);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray4(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray4(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// src/js/leaflet/init_public_map.ts
var init_public_map_exports = {};
__export(init_public_map_exports, {
  Alpine: () => module_default8
});
module.exports = __toCommonJS(init_public_map_exports);

// node_modules/@aerni/alpine-resize/dist/module.esm.js
function src_default(Alpine3) {
  Alpine3.directive("resize", (el, { expression }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    const evaluate2 = evaluateLater2(expression);
    const observer2 = new ResizeObserver((entries) => {
      entries.forEach((entry) => evaluate2(() => {
      }, { params: [entry] }));
    });
    observer2.observe(el);
    cleanup2(() => {
      observer2.disconnect();
    });
  });
}
var module_default = src_default;

// node_modules/@alpinejs/collapse/dist/module.esm.js
function src_default2(Alpine3) {
  Alpine3.directive("collapse", collapse);
  collapse.inline = (el, { modifiers }) => {
    if (!modifiers.includes("min"))
      return;
    el._x_doShow = () => {
    };
    el._x_doHide = () => {
    };
  };
  function collapse(el, { modifiers }) {
    let duration = modifierValue(modifiers, "duration", 250) / 1e3;
    let floor = modifierValue(modifiers, "min", 0);
    let fullyHide = !modifiers.includes("min");
    if (!el._x_isShown)
      el.style.height = `${floor}px`;
    if (!el._x_isShown && fullyHide)
      el.hidden = true;
    if (!el._x_isShown)
      el.style.overflow = "hidden";
    let setFunction = (el2, styles) => {
      let revertFunction = Alpine3.setStyles(el2, styles);
      return styles.height ? () => {
      } : revertFunction;
    };
    let transitionStyles = {
      transitionProperty: "height",
      transitionDuration: `${duration}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    el._x_transition = {
      in(before = () => {
      }, after = () => {
      }) {
        if (fullyHide)
          el.hidden = false;
        if (fullyHide)
          el.style.display = null;
        let current = el.getBoundingClientRect().height;
        el.style.height = "auto";
        let full = el.getBoundingClientRect().height;
        if (current === full) {
          current = floor;
        }
        Alpine3.transition(el, Alpine3.setStyles, {
          during: transitionStyles,
          start: { height: current + "px" },
          end: { height: full + "px" }
        }, () => el._x_isShown = true, () => {
          if (el.getBoundingClientRect().height == full) {
            el.style.overflow = null;
          }
        });
      },
      out(before = () => {
      }, after = () => {
      }) {
        let full = el.getBoundingClientRect().height;
        Alpine3.transition(el, setFunction, {
          during: transitionStyles,
          start: { height: full + "px" },
          end: { height: floor + "px" }
        }, () => el.style.overflow = "hidden", () => {
          el._x_isShown = false;
          if (el.style.height == `${floor}px` && fullyHide) {
            el.style.display = "none";
            el.hidden = true;
          }
        });
      }
    };
  }
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "min") {
    let match = rawValue.match(/([0-9]+)px/);
    if (match)
      return match[1];
  }
  return rawValue;
}
var module_default2 = src_default2;

// node_modules/@alpinejs/focus/dist/module.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return e.key === "Tab" || e.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
            return isTabbable(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e) {
    var target = getActualTarget(e);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e) {
    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
      e.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
function src_default3(Alpine3) {
  let lastFocused;
  let currentFocused;
  window.addEventListener("focusin", () => {
    lastFocused = currentFocused;
    currentFocused = document.activeElement;
  });
  Alpine3.magic("focus", (el) => {
    let within = el;
    return {
      __noscroll: false,
      __wrapAround: false,
      within(el2) {
        within = el2;
        return this;
      },
      withoutScrolling() {
        this.__noscroll = true;
        return this;
      },
      noscroll() {
        this.__noscroll = true;
        return this;
      },
      withWrapAround() {
        this.__wrapAround = true;
        return this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(el2) {
        return isFocusable(el2);
      },
      previouslyFocused() {
        return lastFocused;
      },
      lastFocused() {
        return lastFocused;
      },
      focused() {
        return currentFocused;
      },
      focusables() {
        if (Array.isArray(within))
          return within;
        return focusable(within, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(el2) {
        let els = this.all();
        return els[0] && els[0].isSameNode(el2);
      },
      isLast(el2) {
        let els = this.all();
        return els.length && els.slice(-1)[0].isSameNode(el2);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
          return list[0];
        }
        return list[list.indexOf(current) + 1];
      },
      getPrevious() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === 0) {
          return list.slice(-1)[0];
        }
        return list[list.indexOf(current) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(el2) {
        if (!el2)
          return;
        setTimeout(() => {
          if (!el2.hasAttribute("tabindex"))
            el2.setAttribute("tabindex", "0");
          el2.focus({ preventScroll: this._noscroll });
        });
      }
    };
  });
  Alpine3.directive("trap", Alpine3.skipDuringClone(
    (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluator = evaluateLater2(expression);
      let oldValue = false;
      let options = {
        escapeDeactivates: false,
        allowOutsideClick: true,
        fallbackFocus: () => el
      };
      let autofocusEl = el.querySelector("[autofocus]");
      if (autofocusEl)
        options.initialFocus = autofocusEl;
      let trap = createFocusTrap(el, options);
      let undoInert = () => {
      };
      let undoDisableScrolling = () => {
      };
      const releaseFocus = () => {
        undoInert();
        undoInert = () => {
        };
        undoDisableScrolling();
        undoDisableScrolling = () => {
        };
        trap.deactivate({
          returnFocus: !modifiers.includes("noreturn")
        });
      };
      effect3(() => evaluator((value) => {
        if (oldValue === value)
          return;
        if (value && !oldValue) {
          setTimeout(() => {
            if (modifiers.includes("inert"))
              undoInert = setInert(el);
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            trap.activate();
          });
        }
        if (!value && oldValue) {
          releaseFocus();
        }
        oldValue = !!value;
      }));
      cleanup2(releaseFocus);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
      if (modifiers.includes("inert") && evaluate2(expression))
        setInert(el);
    }
  ));
}
function setInert(el) {
  let undos = [];
  crawlSiblingsUp(el, (sibling) => {
    let cache = sibling.hasAttribute("aria-hidden");
    sibling.setAttribute("aria-hidden", "true");
    undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
  });
  return () => {
    while (undos.length)
      undos.pop()();
  };
}
function crawlSiblingsUp(el, callback) {
  if (el.isSameNode(document.body) || !el.parentNode)
    return;
  Array.from(el.parentNode.children).forEach((sibling) => {
    if (sibling.isSameNode(el)) {
      crawlSiblingsUp(el.parentNode, callback);
    } else {
      callback(sibling);
    }
  });
}
function disableScrolling() {
  let overflow = document.documentElement.style.overflow;
  let paddingRight = document.documentElement.style.paddingRight;
  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.overflow = "hidden";
  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
  return () => {
    document.documentElement.style.overflow = overflow;
    document.documentElement.style.paddingRight = paddingRight;
  };
}
var module_default3 = src_default3;

// node_modules/@alpinejs/intersect/dist/module.esm.js
function src_default4(Alpine3) {
  Alpine3.directive("intersect", (el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater2(expression);
    let options = {
      rootMargin: getRootMargin(modifiers),
      threshold: getThreshhold(modifiers)
    };
    let observer2 = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting === (value === "leave"))
          return;
        evaluate2();
        modifiers.includes("once") && observer2.disconnect();
      });
    }, options);
    observer2.observe(el);
    cleanup2(() => {
      observer2.disconnect();
    });
  });
}
function getThreshhold(modifiers) {
  if (modifiers.includes("full"))
    return 0.99;
  if (modifiers.includes("half"))
    return 0.5;
  if (!modifiers.includes("threshold"))
    return 0;
  let threshold = modifiers[modifiers.indexOf("threshold") + 1];
  if (threshold === "100")
    return 1;
  if (threshold === "0")
    return 0;
  return Number(`.${threshold}`);
}
function getLengthValue(rawValue) {
  let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
  return match ? match[1] + (match[2] || "px") : void 0;
}
function getRootMargin(modifiers) {
  const key = "margin";
  const fallback = "0px 0px 0px 0px";
  const index = modifiers.indexOf(key);
  if (index === -1)
    return fallback;
  let values = [];
  for (let i = 1; i < 5; i++) {
    values.push(getLengthValue(modifiers[index + i] || ""));
  }
  values = values.filter((v) => v !== void 0);
  return values.length ? values.join(" ").trim() : fallback;
}
var module_default4 = src_default4;

// node_modules/@alpinejs/persist/dist/module.esm.js
function src_default5(Alpine3) {
  let persist = () => {
    let alias;
    let storage = localStorage;
    return Alpine3.interceptor((initialValue, getter, setter, path, key) => {
      let lookup = alias || `_x_${path}`;
      let initial = storageHas(lookup, storage) ? storageGet(lookup, storage) : initialValue;
      setter(initial);
      Alpine3.effect(() => {
        let value = getter();
        storageSet(lookup, value, storage);
        setter(value);
      });
      return initial;
    }, (func) => {
      func.as = (key) => {
        alias = key;
        return func;
      }, func.using = (target) => {
        storage = target;
        return func;
      };
    });
  };
  Object.defineProperty(Alpine3, "$persist", { get: () => persist() });
  Alpine3.magic("persist", persist);
  Alpine3.persist = (key, { get: get4, set: set3 }, storage = localStorage) => {
    let initial = storageHas(key, storage) ? storageGet(key, storage) : get4();
    set3(initial);
    Alpine3.effect(() => {
      let value = get4();
      storageSet(key, value, storage);
      set3(value);
    });
  };
}
function storageHas(key, storage) {
  return storage.getItem(key) !== null;
}
function storageGet(key, storage) {
  return JSON.parse(storage.getItem(key, storage));
}
function storageSet(key, value, storage) {
  storage.setItem(key, JSON.stringify(value));
}
var module_default5 = src_default5;

// node_modules/@ryangjchandler/alpine-mask/dist/module.esm.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
var __commonJS2 = (callback, module2) => () => {
  if (!module2) {
    module2 = { exports: {} };
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var require_cleave = __commonJS2((exports, module2) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module2 === "object")
      module2.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["Cleave"] = factory();
    else
      root["Cleave"] = factory();
  })(exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module22 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module22.exports, module22, module22.exports, __webpack_require__);
        module22.loaded = true;
        return module22.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module22, exports2, __webpack_require__) {
        (function(global2) {
          "use strict";
          var Cleave2 = function(element, opts) {
            var owner = this;
            var hasMultipleElements = false;
            if (typeof element === "string") {
              owner.element = document.querySelector(element);
              hasMultipleElements = document.querySelectorAll(element).length > 1;
            } else {
              if (typeof element.length !== "undefined" && element.length > 0) {
                owner.element = element[0];
                hasMultipleElements = element.length > 1;
              } else {
                owner.element = element;
              }
            }
            if (!owner.element) {
              throw new Error("[cleave.js] Please check the element");
            }
            if (hasMultipleElements) {
              try {
                console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
              } catch (e) {
              }
            }
            opts.initValue = owner.element.value;
            owner.properties = Cleave2.DefaultProperties.assign({}, opts);
            owner.init();
          };
          Cleave2.prototype = {
            init: function() {
              var owner = this, pps = owner.properties;
              if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
                owner.onInput(pps.initValue);
                return;
              }
              pps.maxLength = Cleave2.Util.getMaxLength(pps.blocks);
              owner.isAndroid = Cleave2.Util.isAndroid();
              owner.lastInputValue = "";
              owner.isBackward = "";
              owner.onChangeListener = owner.onChange.bind(owner);
              owner.onKeyDownListener = owner.onKeyDown.bind(owner);
              owner.onFocusListener = owner.onFocus.bind(owner);
              owner.onCutListener = owner.onCut.bind(owner);
              owner.onCopyListener = owner.onCopy.bind(owner);
              owner.initSwapHiddenInput();
              owner.element.addEventListener("input", owner.onChangeListener);
              owner.element.addEventListener("keydown", owner.onKeyDownListener);
              owner.element.addEventListener("focus", owner.onFocusListener);
              owner.element.addEventListener("cut", owner.onCutListener);
              owner.element.addEventListener("copy", owner.onCopyListener);
              owner.initPhoneFormatter();
              owner.initDateFormatter();
              owner.initTimeFormatter();
              owner.initNumeralFormatter();
              if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {
                owner.onInput(pps.initValue);
              }
            },
            initSwapHiddenInput: function() {
              var owner = this, pps = owner.properties;
              if (!pps.swapHiddenInput)
                return;
              var inputFormatter = owner.element.cloneNode(true);
              owner.element.parentNode.insertBefore(inputFormatter, owner.element);
              owner.elementSwapHidden = owner.element;
              owner.elementSwapHidden.type = "hidden";
              owner.element = inputFormatter;
              owner.element.id = "";
            },
            initNumeralFormatter: function() {
              var owner = this, pps = owner.properties;
              if (!pps.numeral) {
                return;
              }
              pps.numeralFormatter = new Cleave2.NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);
            },
            initTimeFormatter: function() {
              var owner = this, pps = owner.properties;
              if (!pps.time) {
                return;
              }
              pps.timeFormatter = new Cleave2.TimeFormatter(pps.timePattern, pps.timeFormat);
              pps.blocks = pps.timeFormatter.getBlocks();
              pps.blocksLength = pps.blocks.length;
              pps.maxLength = Cleave2.Util.getMaxLength(pps.blocks);
            },
            initDateFormatter: function() {
              var owner = this, pps = owner.properties;
              if (!pps.date) {
                return;
              }
              pps.dateFormatter = new Cleave2.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
              pps.blocks = pps.dateFormatter.getBlocks();
              pps.blocksLength = pps.blocks.length;
              pps.maxLength = Cleave2.Util.getMaxLength(pps.blocks);
            },
            initPhoneFormatter: function() {
              var owner = this, pps = owner.properties;
              if (!pps.phone) {
                return;
              }
              try {
                pps.phoneFormatter = new Cleave2.PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);
              } catch (ex) {
                throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
              }
            },
            onKeyDown: function(event) {
              var owner = this, charCode = event.which || event.keyCode;
              owner.lastInputValue = owner.element.value;
              owner.isBackward = charCode === 8;
            },
            onChange: function(event) {
              var owner = this, pps = owner.properties, Util = Cleave2.Util;
              owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
              var postDelimiter = Util.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
              if (owner.isBackward && postDelimiter) {
                pps.postDelimiterBackspace = postDelimiter;
              } else {
                pps.postDelimiterBackspace = false;
              }
              this.onInput(this.element.value);
            },
            onFocus: function() {
              var owner = this, pps = owner.properties;
              owner.lastInputValue = owner.element.value;
              if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {
                this.onInput(pps.prefix);
              }
              Cleave2.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
            },
            onCut: function(e) {
              if (!Cleave2.Util.checkFullSelection(this.element.value))
                return;
              this.copyClipboardData(e);
              this.onInput("");
            },
            onCopy: function(e) {
              if (!Cleave2.Util.checkFullSelection(this.element.value))
                return;
              this.copyClipboardData(e);
            },
            copyClipboardData: function(e) {
              var owner = this, pps = owner.properties, Util = Cleave2.Util, inputValue = owner.element.value, textToCopy = "";
              if (!pps.copyDelimiter) {
                textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
              } else {
                textToCopy = inputValue;
              }
              try {
                if (e.clipboardData) {
                  e.clipboardData.setData("Text", textToCopy);
                } else {
                  window.clipboardData.setData("Text", textToCopy);
                }
                e.preventDefault();
              } catch (ex) {
              }
            },
            onInput: function(value) {
              var owner = this, pps = owner.properties, Util = Cleave2.Util;
              var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);
              if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
                value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);
              }
              if (pps.phone) {
                if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
                  pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
                } else {
                  pps.result = pps.phoneFormatter.format(value);
                }
                owner.updateValueState();
                return;
              }
              if (pps.numeral) {
                if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
                  pps.result = "";
                } else {
                  pps.result = pps.numeralFormatter.format(value);
                }
                owner.updateValueState();
                return;
              }
              if (pps.date) {
                value = pps.dateFormatter.getValidatedDate(value);
              }
              if (pps.time) {
                value = pps.timeFormatter.getValidatedTime(value);
              }
              value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);
              value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
              value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value;
              value = pps.uppercase ? value.toUpperCase() : value;
              value = pps.lowercase ? value.toLowerCase() : value;
              if (pps.prefix) {
                if (pps.tailPrefix) {
                  value = value + pps.prefix;
                } else {
                  value = pps.prefix + value;
                }
                if (pps.blocksLength === 0) {
                  pps.result = value;
                  owner.updateValueState();
                  return;
                }
              }
              if (pps.creditCard) {
                owner.updateCreditCardPropsByValue(value);
              }
              value = Util.headStr(value, pps.maxLength);
              pps.result = Util.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);
              owner.updateValueState();
            },
            updateCreditCardPropsByValue: function(value) {
              var owner = this, pps = owner.properties, Util = Cleave2.Util, creditCardInfo;
              if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {
                return;
              }
              creditCardInfo = Cleave2.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
              pps.blocks = creditCardInfo.blocks;
              pps.blocksLength = pps.blocks.length;
              pps.maxLength = Util.getMaxLength(pps.blocks);
              if (pps.creditCardType !== creditCardInfo.type) {
                pps.creditCardType = creditCardInfo.type;
                pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
              }
            },
            updateValueState: function() {
              var owner = this, Util = Cleave2.Util, pps = owner.properties;
              if (!owner.element) {
                return;
              }
              var endPos = owner.element.selectionEnd;
              var oldValue = owner.element.value;
              var newValue = pps.result;
              endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
              if (owner.isAndroid) {
                window.setTimeout(function() {
                  owner.element.value = newValue;
                  Util.setSelection(owner.element, endPos, pps.document, false);
                  owner.callOnValueChanged();
                }, 1);
                return;
              }
              owner.element.value = newValue;
              if (pps.swapHiddenInput)
                owner.elementSwapHidden.value = owner.getRawValue();
              Util.setSelection(owner.element, endPos, pps.document, false);
              owner.callOnValueChanged();
            },
            callOnValueChanged: function() {
              var owner = this, pps = owner.properties;
              pps.onValueChanged.call(owner, {
                target: {
                  name: owner.element.name,
                  value: pps.result,
                  rawValue: owner.getRawValue()
                }
              });
            },
            setPhoneRegionCode: function(phoneRegionCode) {
              var owner = this, pps = owner.properties;
              pps.phoneRegionCode = phoneRegionCode;
              owner.initPhoneFormatter();
              owner.onChange();
            },
            setRawValue: function(value) {
              var owner = this, pps = owner.properties;
              value = value !== void 0 && value !== null ? value.toString() : "";
              if (pps.numeral) {
                value = value.replace(".", pps.numeralDecimalMark);
              }
              pps.postDelimiterBackspace = false;
              owner.element.value = value;
              owner.onInput(value);
            },
            getRawValue: function() {
              var owner = this, pps = owner.properties, Util = Cleave2.Util, rawValue = owner.element.value;
              if (pps.rawValueTrimPrefix) {
                rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
              }
              if (pps.numeral) {
                rawValue = pps.numeralFormatter.getRawValue(rawValue);
              } else {
                rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
              }
              return rawValue;
            },
            getISOFormatDate: function() {
              var owner = this, pps = owner.properties;
              return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
            },
            getISOFormatTime: function() {
              var owner = this, pps = owner.properties;
              return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
            },
            getFormattedValue: function() {
              return this.element.value;
            },
            destroy: function() {
              var owner = this;
              owner.element.removeEventListener("input", owner.onChangeListener);
              owner.element.removeEventListener("keydown", owner.onKeyDownListener);
              owner.element.removeEventListener("focus", owner.onFocusListener);
              owner.element.removeEventListener("cut", owner.onCutListener);
              owner.element.removeEventListener("copy", owner.onCopyListener);
            },
            toString: function() {
              return "[Cleave Object]";
            }
          };
          Cleave2.NumeralFormatter = __webpack_require__(1);
          Cleave2.DateFormatter = __webpack_require__(2);
          Cleave2.TimeFormatter = __webpack_require__(3);
          Cleave2.PhoneFormatter = __webpack_require__(4);
          Cleave2.CreditCardDetector = __webpack_require__(5);
          Cleave2.Util = __webpack_require__(6);
          Cleave2.DefaultProperties = __webpack_require__(7);
          (typeof global2 === "object" && global2 ? global2 : window)["Cleave"] = Cleave2;
          module22.exports = Cleave2;
        }).call(exports2, function() {
          return this;
        }());
      },
      function(module22, exports2) {
        "use strict";
        var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix2, signBeforePrefix, tailPrefix, delimiter) {
          var owner = this;
          owner.numeralDecimalMark = numeralDecimalMark || ".";
          owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
          owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
          owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
          owner.numeralPositiveOnly = !!numeralPositiveOnly;
          owner.stripLeadingZeroes = stripLeadingZeroes !== false;
          owner.prefix = prefix2 || prefix2 === "" ? prefix2 : "";
          owner.signBeforePrefix = !!signBeforePrefix;
          owner.tailPrefix = !!tailPrefix;
          owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
          owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
        };
        NumeralFormatter.groupStyle = {
          thousand: "thousand",
          lakh: "lakh",
          wan: "wan",
          none: "none"
        };
        NumeralFormatter.prototype = {
          getRawValue: function(value) {
            return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
          },
          format: function(value) {
            var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
            value = value.replace(/[A-Za-z]/g, "").replace(owner.numeralDecimalMark, "M").replace(/[^\dM-]/g, "").replace(/^\-/, "N").replace(/\-/g, "").replace("N", owner.numeralPositiveOnly ? "" : "-").replace("M", owner.numeralDecimalMark);
            if (owner.stripLeadingZeroes) {
              value = value.replace(/^(-)?0+(?=\d)/, "$1");
            }
            partSign = value.slice(0, 1) === "-" ? "-" : "";
            if (typeof owner.prefix != "undefined") {
              if (owner.signBeforePrefix) {
                partSignAndPrefix = partSign + owner.prefix;
              } else {
                partSignAndPrefix = owner.prefix + partSign;
              }
            } else {
              partSignAndPrefix = partSign;
            }
            partInteger = value;
            if (value.indexOf(owner.numeralDecimalMark) >= 0) {
              parts = value.split(owner.numeralDecimalMark);
              partInteger = parts[0];
              partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
            }
            if (partSign === "-") {
              partInteger = partInteger.slice(1);
            }
            if (owner.numeralIntegerScale > 0) {
              partInteger = partInteger.slice(0, owner.numeralIntegerScale);
            }
            switch (owner.numeralThousandsGroupStyle) {
              case NumeralFormatter.groupStyle.lakh:
                partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
                break;
              case NumeralFormatter.groupStyle.wan:
                partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
                break;
              case NumeralFormatter.groupStyle.thousand:
                partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
                break;
            }
            if (owner.tailPrefix) {
              return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
            }
            return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
          }
        };
        module22.exports = NumeralFormatter;
      },
      function(module22, exports2) {
        "use strict";
        var DateFormatter = function(datePattern, dateMin, dateMax) {
          var owner = this;
          owner.date = [];
          owner.blocks = [];
          owner.datePattern = datePattern;
          owner.dateMin = dateMin.split("-").reverse().map(function(x) {
            return parseInt(x, 10);
          });
          if (owner.dateMin.length === 2)
            owner.dateMin.unshift(0);
          owner.dateMax = dateMax.split("-").reverse().map(function(x) {
            return parseInt(x, 10);
          });
          if (owner.dateMax.length === 2)
            owner.dateMax.unshift(0);
          owner.initBlocks();
        };
        DateFormatter.prototype = {
          initBlocks: function() {
            var owner = this;
            owner.datePattern.forEach(function(value) {
              if (value === "Y") {
                owner.blocks.push(4);
              } else {
                owner.blocks.push(2);
              }
            });
          },
          getISOFormatDate: function() {
            var owner = this, date = owner.date;
            return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
          },
          getBlocks: function() {
            return this.blocks;
          },
          getValidatedDate: function(value) {
            var owner = this, result = "";
            value = value.replace(/[^\d]/g, "");
            owner.blocks.forEach(function(length, index) {
              if (value.length > 0) {
                var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
                switch (owner.datePattern[index]) {
                  case "d":
                    if (sub === "00") {
                      sub = "01";
                    } else if (parseInt(sub0, 10) > 3) {
                      sub = "0" + sub0;
                    } else if (parseInt(sub, 10) > 31) {
                      sub = "31";
                    }
                    break;
                  case "m":
                    if (sub === "00") {
                      sub = "01";
                    } else if (parseInt(sub0, 10) > 1) {
                      sub = "0" + sub0;
                    } else if (parseInt(sub, 10) > 12) {
                      sub = "12";
                    }
                    break;
                }
                result += sub;
                value = rest;
              }
            });
            return this.getFixedDateString(result);
          },
          getFixedDateString: function(value) {
            var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
            if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
              dayStartIndex = datePattern[0] === "d" ? 0 : 2;
              monthStartIndex = 2 - dayStartIndex;
              day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
              month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
              date = this.getFixedDate(day, month, 0);
            }
            if (value.length === 8) {
              datePattern.forEach(function(type, index) {
                switch (type) {
                  case "d":
                    dayIndex = index;
                    break;
                  case "m":
                    monthIndex = index;
                    break;
                  default:
                    yearIndex = index;
                    break;
                }
              });
              yearStartIndex = yearIndex * 2;
              dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
              monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
              day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
              month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
              year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
              fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
              date = this.getFixedDate(day, month, year);
            }
            if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
              monthStartIndex = datePattern[0] === "m" ? 0 : 2;
              yearStartIndex = 2 - monthStartIndex;
              month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
              year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
              fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
              date = [0, month, year];
            }
            if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
              monthStartIndex = datePattern[0] === "m" ? 0 : 4;
              yearStartIndex = 2 - 0.5 * monthStartIndex;
              month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
              year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
              fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
              date = [0, month, year];
            }
            date = owner.getRangeFixedDate(date);
            owner.date = date;
            var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
              switch (current) {
                case "d":
                  return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
                case "m":
                  return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
                case "y":
                  return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
                case "Y":
                  return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
              }
            }, "");
            return result;
          },
          getRangeFixedDate: function(date) {
            var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
            if (!date.length || dateMin.length < 3 && dateMax.length < 3)
              return date;
            if (datePattern.find(function(x) {
              return x.toLowerCase() === "y";
            }) && date[2] === 0)
              return date;
            if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0])))
              return dateMax;
            if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0])))
              return dateMin;
            return date;
          },
          getFixedDate: function(day, month, year) {
            day = Math.min(day, 31);
            month = Math.min(month, 12);
            year = parseInt(year || 0, 10);
            if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {
              day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
            }
            return [day, month, year];
          },
          isLeapYear: function(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
          },
          addLeadingZero: function(number) {
            return (number < 10 ? "0" : "") + number;
          },
          addLeadingZeroForYear: function(number, fullYearMode) {
            if (fullYearMode) {
              return (number < 10 ? "000" : number < 100 ? "00" : number < 1e3 ? "0" : "") + number;
            }
            return (number < 10 ? "0" : "") + number;
          }
        };
        module22.exports = DateFormatter;
      },
      function(module22, exports2) {
        "use strict";
        var TimeFormatter = function(timePattern, timeFormat) {
          var owner = this;
          owner.time = [];
          owner.blocks = [];
          owner.timePattern = timePattern;
          owner.timeFormat = timeFormat;
          owner.initBlocks();
        };
        TimeFormatter.prototype = {
          initBlocks: function() {
            var owner = this;
            owner.timePattern.forEach(function() {
              owner.blocks.push(2);
            });
          },
          getISOFormatTime: function() {
            var owner = this, time = owner.time;
            return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
          },
          getBlocks: function() {
            return this.blocks;
          },
          getTimeFormatOptions: function() {
            var owner = this;
            if (String(owner.timeFormat) === "12") {
              return {
                maxHourFirstDigit: 1,
                maxHours: 12,
                maxMinutesFirstDigit: 5,
                maxMinutes: 60
              };
            }
            return {
              maxHourFirstDigit: 2,
              maxHours: 23,
              maxMinutesFirstDigit: 5,
              maxMinutes: 60
            };
          },
          getValidatedTime: function(value) {
            var owner = this, result = "";
            value = value.replace(/[^\d]/g, "");
            var timeFormatOptions = owner.getTimeFormatOptions();
            owner.blocks.forEach(function(length, index) {
              if (value.length > 0) {
                var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
                switch (owner.timePattern[index]) {
                  case "h":
                    if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
                      sub = "0" + sub0;
                    } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
                      sub = timeFormatOptions.maxHours + "";
                    }
                    break;
                  case "m":
                  case "s":
                    if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
                      sub = "0" + sub0;
                    } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
                      sub = timeFormatOptions.maxMinutes + "";
                    }
                    break;
                }
                result += sub;
                value = rest;
              }
            });
            return this.getFixedTimeString(result);
          },
          getFixedTimeString: function(value) {
            var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
            if (value.length === 6) {
              timePattern.forEach(function(type, index) {
                switch (type) {
                  case "s":
                    secondIndex = index * 2;
                    break;
                  case "m":
                    minuteIndex = index * 2;
                    break;
                  case "h":
                    hourIndex = index * 2;
                    break;
                }
              });
              hourStartIndex = hourIndex;
              minuteStartIndex = minuteIndex;
              secondStartIndex = secondIndex;
              second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
              minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
              hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
              time = this.getFixedTime(hour, minute, second);
            }
            if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
              timePattern.forEach(function(type, index) {
                switch (type) {
                  case "m":
                    minuteIndex = index * 2;
                    break;
                  case "h":
                    hourIndex = index * 2;
                    break;
                }
              });
              hourStartIndex = hourIndex;
              minuteStartIndex = minuteIndex;
              second = 0;
              minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
              hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
              time = this.getFixedTime(hour, minute, second);
            }
            owner.time = time;
            return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
              switch (current) {
                case "s":
                  return previous + owner.addLeadingZero(time[2]);
                case "m":
                  return previous + owner.addLeadingZero(time[1]);
                case "h":
                  return previous + owner.addLeadingZero(time[0]);
              }
            }, "");
          },
          getFixedTime: function(hour, minute, second) {
            second = Math.min(parseInt(second || 0, 10), 60);
            minute = Math.min(minute, 60);
            hour = Math.min(hour, 60);
            return [hour, minute, second];
          },
          addLeadingZero: function(number) {
            return (number < 10 ? "0" : "") + number;
          }
        };
        module22.exports = TimeFormatter;
      },
      function(module22, exports2) {
        "use strict";
        var PhoneFormatter = function(formatter, delimiter) {
          var owner = this;
          owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
          owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
          owner.formatter = formatter;
        };
        PhoneFormatter.prototype = {
          setFormatter: function(formatter) {
            this.formatter = formatter;
          },
          format: function(phoneNumber) {
            var owner = this;
            owner.formatter.clear();
            phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
            phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
            phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
            var result = "", current, validated = false;
            for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {
              current = owner.formatter.inputDigit(phoneNumber.charAt(i));
              if (/[\s()-]/g.test(current)) {
                result = current;
                validated = true;
              } else {
                if (!validated) {
                  result = current;
                }
              }
            }
            result = result.replace(/[()]/g, "");
            result = result.replace(/[\s-]/g, owner.delimiter);
            return result;
          }
        };
        module22.exports = PhoneFormatter;
      },
      function(module22, exports2) {
        "use strict";
        var CreditCardDetector = {
          blocks: {
            uatp: [4, 5, 6],
            amex: [4, 6, 5],
            diners: [4, 6, 4],
            discover: [4, 4, 4, 4],
            mastercard: [4, 4, 4, 4],
            dankort: [4, 4, 4, 4],
            instapayment: [4, 4, 4, 4],
            jcb15: [4, 6, 5],
            jcb: [4, 4, 4, 4],
            maestro: [4, 4, 4, 4],
            visa: [4, 4, 4, 4],
            mir: [4, 4, 4, 4],
            unionPay: [4, 4, 4, 4],
            general: [4, 4, 4, 4]
          },
          re: {
            uatp: /^(?!1800)1\d{0,14}/,
            amex: /^3[47]\d{0,13}/,
            discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
            diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
            mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
            dankort: /^(5019|4175|4571)\d{0,12}/,
            instapayment: /^63[7-9]\d{0,13}/,
            jcb15: /^(?:2131|1800)\d{0,11}/,
            jcb: /^(?:35\d{0,2})\d{0,12}/,
            maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
            mir: /^220[0-4]\d{0,12}/,
            visa: /^4\d{0,15}/,
            unionPay: /^(62|81)\d{0,14}/
          },
          getStrictBlocks: function(block) {
            var total = block.reduce(function(prev, current) {
              return prev + current;
            }, 0);
            return block.concat(19 - total);
          },
          getInfo: function(value, strictMode) {
            var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
            strictMode = !!strictMode;
            for (var key in re) {
              if (re[key].test(value)) {
                var matchedBlocks = blocks[key];
                return {
                  type: key,
                  blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
                };
              }
            }
            return {
              type: "unknown",
              blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
            };
          }
        };
        module22.exports = CreditCardDetector;
      },
      function(module22, exports2) {
        "use strict";
        var Util = {
          noop: function() {
          },
          strip: function(value, re) {
            return value.replace(re, "");
          },
          getPostDelimiter: function(value, delimiter, delimiters) {
            if (delimiters.length === 0) {
              return value.slice(-delimiter.length) === delimiter ? delimiter : "";
            }
            var matchedDelimiter = "";
            delimiters.forEach(function(current) {
              if (value.slice(-current.length) === current) {
                matchedDelimiter = current;
              }
            });
            return matchedDelimiter;
          },
          getDelimiterREByDelimiter: function(delimiter) {
            return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
          },
          getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
            if (oldValue.length === prevPos) {
              return newValue.length;
            }
            return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
          },
          getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
            var oldRawValue, newRawValue, lengthOffset;
            oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
            newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
            lengthOffset = oldRawValue.length - newRawValue.length;
            return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
          },
          stripDelimiters: function(value, delimiter, delimiters) {
            var owner = this;
            if (delimiters.length === 0) {
              var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
              return value.replace(delimiterRE, "");
            }
            delimiters.forEach(function(current) {
              current.split("").forEach(function(letter) {
                value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
              });
            });
            return value;
          },
          headStr: function(str, length) {
            return str.slice(0, length);
          },
          getMaxLength: function(blocks) {
            return blocks.reduce(function(previous, current) {
              return previous + current;
            }, 0);
          },
          getPrefixStrippedValue: function(value, prefix2, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
            if (prefixLength === 0) {
              return value;
            }
            if (value === prefix2 && value !== "") {
              return "";
            }
            if (signBeforePrefix && value.slice(0, 1) == "-") {
              var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
              return "-" + this.getPrefixStrippedValue(value.slice(1), prefix2, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
            }
            if (prevResult.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
              if (noImmediatePrefix && !prevResult && value)
                return value;
              return "";
            } else if (prevResult.slice(-prefixLength) !== prefix2 && tailPrefix) {
              if (noImmediatePrefix && !prevResult && value)
                return value;
              return "";
            }
            var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
            if (value.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
              return prevValue.slice(prefixLength);
            } else if (value.slice(-prefixLength) !== prefix2 && tailPrefix) {
              return prevValue.slice(0, -prefixLength - 1);
            }
            return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
          },
          getFirstDiffIndex: function(prev, current) {
            var index = 0;
            while (prev.charAt(index) === current.charAt(index)) {
              if (prev.charAt(index++) === "") {
                return -1;
              }
            }
            return index;
          },
          getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
            var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
            if (blocksLength === 0) {
              return value;
            }
            blocks.forEach(function(length, index) {
              if (value.length > 0) {
                var sub = value.slice(0, length), rest = value.slice(length);
                if (multipleDelimiters) {
                  currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
                } else {
                  currentDelimiter = delimiter;
                }
                if (delimiterLazyShow) {
                  if (index > 0) {
                    result += currentDelimiter;
                  }
                  result += sub;
                } else {
                  result += sub;
                  if (sub.length === length && index < blocksLength - 1) {
                    result += currentDelimiter;
                  }
                }
                value = rest;
              }
            });
            return result;
          },
          fixPrefixCursor: function(el, prefix2, delimiter, delimiters) {
            if (!el) {
              return;
            }
            var val = el.value, appendix = delimiter || (delimiters[0] || " ");
            if (!el.setSelectionRange || !prefix2 || prefix2.length + appendix.length <= val.length) {
              return;
            }
            var len = val.length * 2;
            setTimeout(function() {
              el.setSelectionRange(len, len);
            }, 1);
          },
          checkFullSelection: function(value) {
            try {
              var selection = window.getSelection() || document.getSelection() || {};
              return selection.toString().length === value.length;
            } catch (ex) {
            }
            return false;
          },
          setSelection: function(element, position, doc) {
            if (element !== this.getActiveElement(doc)) {
              return;
            }
            if (element && element.value.length <= position) {
              return;
            }
            if (element.createTextRange) {
              var range = element.createTextRange();
              range.move("character", position);
              range.select();
            } else {
              try {
                element.setSelectionRange(position, position);
              } catch (e) {
                console.warn("The input element type does not support selection");
              }
            }
          },
          getActiveElement: function(parent) {
            var activeElement = parent.activeElement;
            if (activeElement && activeElement.shadowRoot) {
              return this.getActiveElement(activeElement.shadowRoot);
            }
            return activeElement;
          },
          isAndroid: function() {
            return navigator && /android/i.test(navigator.userAgent);
          },
          isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
            if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
              return false;
            }
            return currentInputValue === lastInputValue.slice(0, -1);
          }
        };
        module22.exports = Util;
      },
      function(module22, exports2) {
        (function(global2) {
          "use strict";
          var DefaultProperties = {
            assign: function(target, opts) {
              target = target || {};
              opts = opts || {};
              target.creditCard = !!opts.creditCard;
              target.creditCardStrictMode = !!opts.creditCardStrictMode;
              target.creditCardType = "";
              target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {
              };
              target.phone = !!opts.phone;
              target.phoneRegionCode = opts.phoneRegionCode || "AU";
              target.phoneFormatter = {};
              target.time = !!opts.time;
              target.timePattern = opts.timePattern || ["h", "m", "s"];
              target.timeFormat = opts.timeFormat || "24";
              target.timeFormatter = {};
              target.date = !!opts.date;
              target.datePattern = opts.datePattern || ["d", "m", "Y"];
              target.dateMin = opts.dateMin || "";
              target.dateMax = opts.dateMax || "";
              target.dateFormatter = {};
              target.numeral = !!opts.numeral;
              target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
              target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
              target.numeralDecimalMark = opts.numeralDecimalMark || ".";
              target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
              target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
              target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
              target.signBeforePrefix = !!opts.signBeforePrefix;
              target.tailPrefix = !!opts.tailPrefix;
              target.swapHiddenInput = !!opts.swapHiddenInput;
              target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
              target.uppercase = !!opts.uppercase;
              target.lowercase = !!opts.lowercase;
              target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
              target.noImmediatePrefix = !!opts.noImmediatePrefix;
              target.prefixLength = target.prefix.length;
              target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
              target.copyDelimiter = !!opts.copyDelimiter;
              target.initValue = opts.initValue !== void 0 && opts.initValue !== null ? opts.initValue.toString() : "";
              target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
              target.delimiterLength = target.delimiter.length;
              target.delimiterLazyShow = !!opts.delimiterLazyShow;
              target.delimiters = opts.delimiters || [];
              target.blocks = opts.blocks || [];
              target.blocksLength = target.blocks.length;
              target.root = typeof global2 === "object" && global2 ? global2 : window;
              target.document = opts.document || target.root.document;
              target.maxLength = 0;
              target.backspace = false;
              target.result = "";
              target.onValueChanged = opts.onValueChanged || function() {
              };
              return target;
            }
          };
          module22.exports = DefaultProperties;
        }).call(exports2, function() {
          return this;
        }());
      }
    ]);
  });
});
var import_cleave = __toModule(require_cleave());
var findModifierArgument = (modifiers, target, offset = 1) => {
  return modifiers[modifiers.indexOf(target) + offset];
};
var buildConfigFromModifiers = (modifiers, expression, evaluate2) => {
  const config = {};
  if (modifiers.includes("card")) {
    config.creditCard = true;
    config.creditCardStrictMode = modifiers.includes("strict");
  } else if (modifiers.includes("date")) {
    config.date = true;
    config.datePattern = expression ? evaluate2(expression) : null;
  } else if (modifiers.includes("time")) {
    config.time = true;
    config.timePattern = expression ? evaluate2(expression) : null;
  } else if (modifiers.includes("numeral")) {
    config.numeral = true;
    if (modifiers.includes("thousands")) {
      config.numeralThousandsGroupStyle = findModifierArgument(modifiers, "thousands");
    }
    if (modifiers.includes("delimiter")) {
      config.delimiter = findModifierArgument(modifiers, "delimiter") === "dot" ? "." : ",";
    }
    if (modifiers.includes("decimal")) {
      config.numeralDecimalMark = findModifierArgument(modifiers, "decimal") === "comma" ? "," : ".";
    }
    if (modifiers.includes("positive")) {
      config.numeralPositiveOnly = true;
    }
    if (modifiers.includes("prefix")) {
      config.prefix = findModifierArgument(modifiers, "prefix");
    }
  } else if (modifiers.includes("blocks")) {
    config.blocks = evaluate2(expression);
  }
  return config;
};
var valueChangedCallback = (el) => {
  return (event) => {
    if (!el._x_model) {
      return;
    }
    el._x_model.set(event.target.rawValue);
  };
};
function src_default6(Alpine3) {
  Alpine3.magic("mask", (el) => {
    if (el.__cleave) {
      return el.__cleave;
    }
  });
  Alpine3.directive("mask", (el, { modifiers, expression }, { effect: effect3, evaluate: evaluate2 }) => {
    if (el._x_model) {
      const directive2 = Alpine3.prefixed("model");
      Object.keys(el._x_attributeCleanups).forEach((key) => {
        if (key.startsWith(directive2)) {
          el._x_attributeCleanups[directive2][0]();
          delete el._x_attributeCleanups[directive2];
        }
      });
      el._x_forceModelUpdate = () => {
      };
    }
    const config = modifiers.length === 0 ? {
      ...evaluate2(expression),
      onValueChanged: valueChangedCallback(el)
    } : {
      ...buildConfigFromModifiers(modifiers, expression, evaluate2),
      onValueChanged: valueChangedCallback(el)
    };
    if (!el.__cleave) {
      el.__cleave = new import_cleave.default(el, config);
    }
    if (el._x_model) {
      effect3(() => {
        Alpine3.mutateDom(() => el.__cleave.setRawValue(el._x_model.get()));
      });
    }
  });
}
var module_default6 = src_default6;

// node_modules/@ryangjchandler/alpine-tooltip/dist/module.esm.js
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __markAsModule2 = (target) => __defProp3(target, "__esModule", { value: true });
var __commonJS3 = (callback, module2) => () => {
  if (!module2) {
    module2 = { exports: {} };
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar2 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames3(module2))
      if (!__hasOwnProp3.call(target, key) && key !== "default")
        __defProp3(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc3(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule2 = (module2) => {
  return __exportStar2(__markAsModule2(__defProp3(module2 != null ? __create3(__getProtoOf3(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var require_popper = __commonJS3((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  function getBoundingClientRect(element) {
    var rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      y: rect.top
    };
  }
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function getWindowScroll(node) {
    var win2 = getWindow(node);
    var scrollLeft = win2.pageXOffset;
    var scrollTop = win2.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win2 = getWindow(scrollParent);
    var target = isBody ? [win2].concat(win2.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start2 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start2, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce2(fn) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c) {
      return p.replace(/%s/, c);
    }, str);
  }
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      Object.keys(modifier).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }
  function uniqueBy(arr, fn) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  function getViewportRect(element) {
    var win2 = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win2.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var referenceElement = state.elements.reference;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(referenceElement);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions2(options2) {
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn === "function") {
              state = fn({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        update: debounce2(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect22 = _ref3.effect;
          if (typeof effect22 === "function") {
            var cleanupFn = effect22({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn) {
          return fn();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var passive = {
    passive: true
  };
  function effect$2(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect$2,
    data: {}
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win2 = window;
    var dpr = win2.devicePixelRatio || 1;
    return {
      x: round(round(x * dpr) / dpr) || 0,
      y: round(round(y * dpr) / dpr) || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win2 = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top) {
        sideY = bottom;
        y -= offsetParent[heightProp] - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left) {
        sideX = right;
        x -= offsetParent[widthProp] - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win2.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref4) {
    var state = _ref4.state, options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$1(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style22, property) {
          style22[property] = "";
          return style22;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$1,
    requires: ["computeStyles"]
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data2 = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data2[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data2;
  }
  var offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash[matched];
    });
  }
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start2;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var data2 = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis || checkAltAxis) {
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min$1 = popperOffsets2[mainAxis] + overflow[mainSide];
      var max$1 = popperOffsets2[mainAxis] - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
      var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
      if (checkMainAxis) {
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets2[mainAxis] = preventedOffset;
        data2[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data2[altAxis] = _preventedOffset - _offset;
      }
    }
    state.modifiersData[name] = data2;
  }
  var preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect3(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect3,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
  var createPopper$1 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers$1
  });
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  exports.applyStyles = applyStyles$1;
  exports.arrow = arrow$1;
  exports.computeStyles = computeStyles$1;
  exports.createPopper = createPopper;
  exports.createPopperLite = createPopper$1;
  exports.defaultModifiers = defaultModifiers;
  exports.detectOverflow = detectOverflow;
  exports.eventListeners = eventListeners;
  exports.flip = flip$1;
  exports.hide = hide$1;
  exports.offset = offset$1;
  exports.popperGenerator = popperGenerator;
  exports.popperOffsets = popperOffsets$1;
  exports.preventOverflow = preventOverflow$1;
});
var require_tippy_cjs = __commonJS3((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var core = require_popper();
  var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  function hasOwnProperty2(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn, ms) {
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone2 = Object.assign({}, obj);
    keys.forEach(function(key) {
      delete clone2[key];
    });
    return clone2;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var ua = isBrowser ? navigator.userAgent : "";
  var isIE = /MSIE |Trident\//.test(ua);
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      "line-height: 1.5",
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: function appendTo() {
      return document.body;
    },
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, {}, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin2) {
      var name = plugin2.name, defaultValue = plugin2.defaultValue;
      if (name) {
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, {}, pluginProps2);
  }
  function getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty2(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin2) {
          return plugin2.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow = div();
    if (value === true) {
      arrow.className = ARROW_CLASS;
    } else {
      arrow.className = SVG_ARROW_CLASS;
      if (isElement(value)) {
        arrow.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow, value);
      }
    }
    return arrow;
  }
  function setContent(content, props) {
    if (isElement(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper), box2 = _getChildren.box, content2 = _getChildren.content, arrow = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow) {
        box2.removeChild(arrow);
      }
    }
    return {
      popper,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference, passedProps) {
    var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id,
      reference,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      clearDelayTimeouts,
      setProps,
      setContent: setContent2,
      show,
      hide,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper.setAttribute("data-tippy-root", "");
    popper.id = "tippy-" + instance.id;
    instance.popper = popper;
    reference._tippy = instance;
    popper._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin2) {
      return plugin2.fn(instance);
    });
    var hasAriaExpanded = reference.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper.addEventListener("mouseleave", function(event) {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch2 = instance.props.touch;
      return Array.isArray(touch2) ? touch2 : [touch2, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles() {
      popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? "" : "none";
      popper.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(void 0, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      if (instance.props.interactive && popper.contains(event.target)) {
        return;
      }
      if (getCurrentTarget().contains(event.target)) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener("mousedown", onDocumentPress, true);
      doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener("mousedown", onDocumentPress, true);
      doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on3(eventType, handler4, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler4, options);
        listeners.push({
          node,
          eventType,
          handler: handler4,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on3("touchstart", onTrigger, {
          passive: true
        });
        on3("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on3(eventType, onTrigger);
        switch (eventType) {
          case "mouseenter":
            on3("mouseleave", onMouseLeave);
            break;
          case "focus":
            on3(isIE ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on3("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler4 = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler4, options);
      });
      listeners = [];
    }
    function onTrigger(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper).map(function(popper2) {
        var _instance$popperInsta;
        var instance2 = popper2._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper2.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: "offset",
        options: {
          offset
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow) {
        modifiers.push({
          name: "arrow",
          options: {
            element: arrow,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = core.createPopper(computedReference, popper, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === "parent") {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
      }
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay4 = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay4 = touchDelay;
      }
      if (delay4) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay4);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay4 = getDelay(false);
      if (delay4) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay4);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent2(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper.offsetHeight;
        popper.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        instance.state.isMounted = true;
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles();
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper.parentNode) {
        popper.parentNode.removeChild(popper);
      }
      mountedInstances = mountedInstances.filter(function(i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy2(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference) {
      var instance = reference && createTippy(reference, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement(targets) ? instances[0] : instances;
  }
  tippy2.defaultProps = defaultProps;
  tippy2.setDefaultProps = setDefaultProps;
  tippy2.currentInput = currentInput;
  var hideAll = function hideAll2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, excludedReferenceOrInstance = _ref.exclude, duration = _ref.duration;
    mountedInstances.forEach(function(instance) {
      var isExcluded = false;
      if (excludedReferenceOrInstance) {
        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
      }
      if (!isExcluded) {
        var originalDuration = instance.props.duration;
        instance.setProps({
          duration
        });
        instance.hide();
        if (!instance.state.isDestroyed) {
          instance.setProps({
            duration: originalDuration
          });
        }
      }
    });
  };
  var applyStylesModifier = Object.assign({}, core.applyStyles, {
    effect: function effect3(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  var createSingleton = function createSingleton2(tippyInstances, optionalProps) {
    var _optionalProps$popper;
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    if (true) {
      errorWhen(!Array.isArray(tippyInstances), ["The first argument passed to createSingleton() must be an array of", "tippy instances. The passed value was", String(tippyInstances)].join(" "));
    }
    var individualInstances = tippyInstances;
    var references = [];
    var currentTarget;
    var overrides = optionalProps.overrides;
    var interceptSetPropsCleanups = [];
    var shownOnCreate = false;
    function setReferences() {
      references = individualInstances.map(function(instance) {
        return instance.reference;
      });
    }
    function enableInstances(isEnabled) {
      individualInstances.forEach(function(instance) {
        if (isEnabled) {
          instance.enable();
        } else {
          instance.disable();
        }
      });
    }
    function interceptSetProps(singleton2) {
      return individualInstances.map(function(instance) {
        var originalSetProps2 = instance.setProps;
        instance.setProps = function(props) {
          originalSetProps2(props);
          if (instance.reference === currentTarget) {
            singleton2.setProps(props);
          }
        };
        return function() {
          instance.setProps = originalSetProps2;
        };
      });
    }
    function prepareInstance(singleton2, target) {
      var index = references.indexOf(target);
      if (target === currentTarget) {
        return;
      }
      currentTarget = target;
      var overrideProps = (overrides || []).concat("content").reduce(function(acc, prop) {
        acc[prop] = individualInstances[index].props[prop];
        return acc;
      }, {});
      singleton2.setProps(Object.assign({}, overrideProps, {
        getReferenceClientRect: typeof overrideProps.getReferenceClientRect === "function" ? overrideProps.getReferenceClientRect : function() {
          return target.getBoundingClientRect();
        }
      }));
    }
    enableInstances(false);
    setReferences();
    var plugin2 = {
      fn: function fn() {
        return {
          onDestroy: function onDestroy() {
            enableInstances(true);
          },
          onHidden: function onHidden() {
            currentTarget = null;
          },
          onClickOutside: function onClickOutside(instance) {
            if (instance.props.showOnCreate && !shownOnCreate) {
              shownOnCreate = true;
              currentTarget = null;
            }
          },
          onShow: function onShow(instance) {
            if (instance.props.showOnCreate && !shownOnCreate) {
              shownOnCreate = true;
              prepareInstance(instance, references[0]);
            }
          },
          onTrigger: function onTrigger(instance, event) {
            prepareInstance(instance, event.currentTarget);
          }
        };
      }
    };
    var singleton = tippy2(div(), Object.assign({}, removeProperties(optionalProps, ["overrides"]), {
      plugins: [plugin2].concat(optionalProps.plugins || []),
      triggerTarget: references,
      popperOptions: Object.assign({}, optionalProps.popperOptions, {
        modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
      })
    }));
    var originalShow = singleton.show;
    singleton.show = function(target) {
      originalShow();
      if (!currentTarget && target == null) {
        return prepareInstance(singleton, references[0]);
      }
      if (currentTarget && target == null) {
        return;
      }
      if (typeof target === "number") {
        return references[target] && prepareInstance(singleton, references[target]);
      }
      if (individualInstances.includes(target)) {
        var ref = target.reference;
        return prepareInstance(singleton, ref);
      }
      if (references.includes(target)) {
        return prepareInstance(singleton, target);
      }
    };
    singleton.showNext = function() {
      var first = references[0];
      if (!currentTarget) {
        return singleton.show(0);
      }
      var index = references.indexOf(currentTarget);
      singleton.show(references[index + 1] || first);
    };
    singleton.showPrevious = function() {
      var last = references[references.length - 1];
      if (!currentTarget) {
        return singleton.show(last);
      }
      var index = references.indexOf(currentTarget);
      var target = references[index - 1] || last;
      singleton.show(target);
    };
    var originalSetProps = singleton.setProps;
    singleton.setProps = function(props) {
      overrides = props.overrides || overrides;
      originalSetProps(props);
    };
    singleton.setInstances = function(nextInstances) {
      enableInstances(true);
      interceptSetPropsCleanups.forEach(function(fn) {
        return fn();
      });
      individualInstances = nextInstances;
      enableInstances(false);
      setReferences();
      interceptSetProps(singleton);
      singleton.setProps({
        triggerTarget: references
      });
    };
    interceptSetPropsCleanups = interceptSetProps(singleton);
    return singleton;
  };
  var BUBBLING_EVENTS_MAP = {
    mouseover: "mouseenter",
    focusin: "focus",
    click: "click"
  };
  function delegate(targets, props) {
    if (true) {
      errorWhen(!(props && props.target), ["You must specity a `target` prop indicating a CSS selector string matching", "the target elements that should receive a tippy."].join(" "));
    }
    var listeners = [];
    var childTippyInstances = [];
    var disabled = false;
    var target = props.target;
    var nativeProps = removeProperties(props, ["target"]);
    var parentProps = Object.assign({}, nativeProps, {
      trigger: "manual",
      touch: false
    });
    var childProps = Object.assign({}, nativeProps, {
      showOnCreate: true
    });
    var returnValue = tippy2(targets, parentProps);
    var normalizedReturnValue = normalizeToArray(returnValue);
    function onTrigger(event) {
      if (!event.target || disabled) {
        return;
      }
      var targetNode = event.target.closest(target);
      if (!targetNode) {
        return;
      }
      var trigger2 = targetNode.getAttribute("data-tippy-trigger") || props.trigger || defaultProps.trigger;
      if (targetNode._tippy) {
        return;
      }
      if (event.type === "touchstart" && typeof childProps.touch === "boolean") {
        return;
      }
      if (event.type !== "touchstart" && trigger2.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
        return;
      }
      var instance = tippy2(targetNode, childProps);
      if (instance) {
        childTippyInstances = childTippyInstances.concat(instance);
      }
    }
    function on3(node, eventType, handler4, options) {
      if (options === void 0) {
        options = false;
      }
      node.addEventListener(eventType, handler4, options);
      listeners.push({
        node,
        eventType,
        handler: handler4,
        options
      });
    }
    function addEventListeners(instance) {
      var reference = instance.reference;
      on3(reference, "touchstart", onTrigger, TOUCH_OPTIONS);
      on3(reference, "mouseover", onTrigger);
      on3(reference, "focusin", onTrigger);
      on3(reference, "click", onTrigger);
    }
    function removeEventListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler4 = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler4, options);
      });
      listeners = [];
    }
    function applyMutations(instance) {
      var originalDestroy = instance.destroy;
      var originalEnable = instance.enable;
      var originalDisable = instance.disable;
      instance.destroy = function(shouldDestroyChildInstances) {
        if (shouldDestroyChildInstances === void 0) {
          shouldDestroyChildInstances = true;
        }
        if (shouldDestroyChildInstances) {
          childTippyInstances.forEach(function(instance2) {
            instance2.destroy();
          });
        }
        childTippyInstances = [];
        removeEventListeners();
        originalDestroy();
      };
      instance.enable = function() {
        originalEnable();
        childTippyInstances.forEach(function(instance2) {
          return instance2.enable();
        });
        disabled = false;
      };
      instance.disable = function() {
        originalDisable();
        childTippyInstances.forEach(function(instance2) {
          return instance2.disable();
        });
        disabled = true;
      };
      addEventListeners(instance);
    }
    normalizedReturnValue.forEach(applyMutations);
    return returnValue;
  }
  var animateFill = {
    name: "animateFill",
    defaultValue: false,
    fn: function fn(instance) {
      var _instance$props$rende;
      if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
        if (true) {
          errorWhen(instance.props.animateFill, "The `animateFill` plugin requires the default render function.");
        }
        return {};
      }
      var _getChildren = getChildren(instance.popper), box = _getChildren.box, content = _getChildren.content;
      var backdrop = instance.props.animateFill ? createBackdropElement() : null;
      return {
        onCreate: function onCreate() {
          if (backdrop) {
            box.insertBefore(backdrop, box.firstElementChild);
            box.setAttribute("data-animatefill", "");
            box.style.overflow = "hidden";
            instance.setProps({
              arrow: false,
              animation: "shift-away"
            });
          }
        },
        onMount: function onMount() {
          if (backdrop) {
            var transitionDuration = box.style.transitionDuration;
            var duration = Number(transitionDuration.replace("ms", ""));
            content.style.transitionDelay = Math.round(duration / 10) + "ms";
            backdrop.style.transitionDuration = transitionDuration;
            setVisibilityState([backdrop], "visible");
          }
        },
        onShow: function onShow() {
          if (backdrop) {
            backdrop.style.transitionDuration = "0ms";
          }
        },
        onHide: function onHide() {
          if (backdrop) {
            setVisibilityState([backdrop], "hidden");
          }
        }
      };
    }
  };
  function createBackdropElement() {
    var backdrop = div();
    backdrop.className = BACKDROP_CLASS;
    setVisibilityState([backdrop], "hidden");
    return backdrop;
  }
  var mouseCoords = {
    clientX: 0,
    clientY: 0
  };
  var activeInstances = [];
  function storeMouseCoords(_ref) {
    var clientX = _ref.clientX, clientY = _ref.clientY;
    mouseCoords = {
      clientX,
      clientY
    };
  }
  function addMouseCoordsListener(doc) {
    doc.addEventListener("mousemove", storeMouseCoords);
  }
  function removeMouseCoordsListener(doc) {
    doc.removeEventListener("mousemove", storeMouseCoords);
  }
  var followCursor2 = {
    name: "followCursor",
    defaultValue: false,
    fn: function fn(instance) {
      var reference = instance.reference;
      var doc = getOwnerDocument(instance.props.triggerTarget || reference);
      var isInternalUpdate = false;
      var wasFocusEvent = false;
      var isUnmounted = true;
      var prevProps = instance.props;
      function getIsInitialBehavior() {
        return instance.props.followCursor === "initial" && instance.state.isVisible;
      }
      function addListener() {
        doc.addEventListener("mousemove", onMouseMove);
      }
      function removeListener() {
        doc.removeEventListener("mousemove", onMouseMove);
      }
      function unsetGetReferenceClientRect() {
        isInternalUpdate = true;
        instance.setProps({
          getReferenceClientRect: null
        });
        isInternalUpdate = false;
      }
      function onMouseMove(event) {
        var isCursorOverReference = event.target ? reference.contains(event.target) : true;
        var followCursor3 = instance.props.followCursor;
        var clientX = event.clientX, clientY = event.clientY;
        var rect = reference.getBoundingClientRect();
        var relativeX = clientX - rect.left;
        var relativeY = clientY - rect.top;
        if (isCursorOverReference || !instance.props.interactive) {
          instance.setProps({
            getReferenceClientRect: function getReferenceClientRect() {
              var rect2 = reference.getBoundingClientRect();
              var x = clientX;
              var y = clientY;
              if (followCursor3 === "initial") {
                x = rect2.left + relativeX;
                y = rect2.top + relativeY;
              }
              var top = followCursor3 === "horizontal" ? rect2.top : y;
              var right = followCursor3 === "vertical" ? rect2.right : x;
              var bottom = followCursor3 === "horizontal" ? rect2.bottom : y;
              var left = followCursor3 === "vertical" ? rect2.left : x;
              return {
                width: right - left,
                height: bottom - top,
                top,
                right,
                bottom,
                left
              };
            }
          });
        }
      }
      function create2() {
        if (instance.props.followCursor) {
          activeInstances.push({
            instance,
            doc
          });
          addMouseCoordsListener(doc);
        }
      }
      function destroy() {
        activeInstances = activeInstances.filter(function(data2) {
          return data2.instance !== instance;
        });
        if (activeInstances.filter(function(data2) {
          return data2.doc === doc;
        }).length === 0) {
          removeMouseCoordsListener(doc);
        }
      }
      return {
        onCreate: create2,
        onDestroy: destroy,
        onBeforeUpdate: function onBeforeUpdate() {
          prevProps = instance.props;
        },
        onAfterUpdate: function onAfterUpdate(_, _ref2) {
          var followCursor3 = _ref2.followCursor;
          if (isInternalUpdate) {
            return;
          }
          if (followCursor3 !== void 0 && prevProps.followCursor !== followCursor3) {
            destroy();
            if (followCursor3) {
              create2();
              if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
                addListener();
              }
            } else {
              removeListener();
              unsetGetReferenceClientRect();
            }
          }
        },
        onMount: function onMount() {
          if (instance.props.followCursor && !wasFocusEvent) {
            if (isUnmounted) {
              onMouseMove(mouseCoords);
              isUnmounted = false;
            }
            if (!getIsInitialBehavior()) {
              addListener();
            }
          }
        },
        onTrigger: function onTrigger(_, event) {
          if (isMouseEvent(event)) {
            mouseCoords = {
              clientX: event.clientX,
              clientY: event.clientY
            };
          }
          wasFocusEvent = event.type === "focus";
        },
        onHidden: function onHidden() {
          if (instance.props.followCursor) {
            unsetGetReferenceClientRect();
            removeListener();
            isUnmounted = true;
          }
        }
      };
    }
  };
  function getProps(props, modifier) {
    var _props$popperOptions;
    return {
      popperOptions: Object.assign({}, props.popperOptions, {
        modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function(_ref) {
          var name = _ref.name;
          return name !== modifier.name;
        }), [modifier])
      })
    };
  }
  var inlinePositioning = {
    name: "inlinePositioning",
    defaultValue: false,
    fn: function fn(instance) {
      var reference = instance.reference;
      function isEnabled() {
        return !!instance.props.inlinePositioning;
      }
      var placement;
      var cursorRectIndex = -1;
      var isInternalUpdate = false;
      var modifier = {
        name: "tippyInlinePositioning",
        enabled: true,
        phase: "afterWrite",
        fn: function fn2(_ref2) {
          var state = _ref2.state;
          if (isEnabled()) {
            if (placement !== state.placement) {
              instance.setProps({
                getReferenceClientRect: function getReferenceClientRect() {
                  return _getReferenceClientRect(state.placement);
                }
              });
            }
            placement = state.placement;
          }
        }
      };
      function _getReferenceClientRect(placement2) {
        return getInlineBoundingClientRect(getBasePlacement(placement2), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
      }
      function setInternalProps(partialProps) {
        isInternalUpdate = true;
        instance.setProps(partialProps);
        isInternalUpdate = false;
      }
      function addModifier() {
        if (!isInternalUpdate) {
          setInternalProps(getProps(instance.props, modifier));
        }
      }
      return {
        onCreate: addModifier,
        onAfterUpdate: addModifier,
        onTrigger: function onTrigger(_, event) {
          if (isMouseEvent(event)) {
            var rects = arrayFrom(instance.reference.getClientRects());
            var cursorRect = rects.find(function(rect) {
              return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
            });
            cursorRectIndex = rects.indexOf(cursorRect);
          }
        },
        onUntrigger: function onUntrigger() {
          cursorRectIndex = -1;
        }
      };
    }
  };
  function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
    if (clientRects.length < 2 || currentBasePlacement === null) {
      return boundingRect;
    }
    if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
      return clientRects[cursorRectIndex] || boundingRect;
    }
    switch (currentBasePlacement) {
      case "top":
      case "bottom": {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === "top";
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top,
          bottom,
          left,
          right,
          width,
          height
        };
      }
      case "left":
      case "right": {
        var minLeft = Math.min.apply(Math, clientRects.map(function(rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function(rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function(rect) {
          return currentBasePlacement === "left" ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;
        var _width = _right - _left;
        var _height = _bottom - _top;
        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }
      default: {
        return boundingRect;
      }
    }
  }
  var sticky = {
    name: "sticky",
    defaultValue: false,
    fn: function fn(instance) {
      var reference = instance.reference, popper = instance.popper;
      function getReference() {
        return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
      }
      function shouldCheck(value) {
        return instance.props.sticky === true || instance.props.sticky === value;
      }
      var prevRefRect = null;
      var prevPopRect = null;
      function updatePosition() {
        var currentRefRect = shouldCheck("reference") ? getReference().getBoundingClientRect() : null;
        var currentPopRect = shouldCheck("popper") ? popper.getBoundingClientRect() : null;
        if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
          if (instance.popperInstance) {
            instance.popperInstance.update();
          }
        }
        prevRefRect = currentRefRect;
        prevPopRect = currentPopRect;
        if (instance.state.isMounted) {
          requestAnimationFrame(updatePosition);
        }
      }
      return {
        onMount: function onMount() {
          if (instance.props.sticky) {
            updatePosition();
          }
        }
      };
    }
  };
  function areRectsDifferent(rectA, rectB) {
    if (rectA && rectB) {
      return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
    }
    return true;
  }
  tippy2.setDefaultProps({
    render
  });
  exports.animateFill = animateFill;
  exports.createSingleton = createSingleton;
  exports.default = tippy2;
  exports.delegate = delegate;
  exports.followCursor = followCursor2;
  exports.hideAll = hideAll;
  exports.inlinePositioning = inlinePositioning;
  exports.roundArrow = ROUND_ARROW;
  exports.sticky = sticky;
});
var import_tippy2 = __toModule2(require_tippy_cjs());
var import_tippy = __toModule2(require_tippy_cjs());
var buildConfigFromModifiers2 = (modifiers) => {
  const config = {
    plugins: []
  };
  const getModifierArgument = (modifier) => {
    return modifiers[modifiers.indexOf(modifier) + 1];
  };
  if (modifiers.includes("animation")) {
    config.animation = getModifierArgument("animation");
  }
  if (modifiers.includes("duration")) {
    config.duration = parseInt(getModifierArgument("duration"));
  }
  if (modifiers.includes("delay")) {
    const delay4 = getModifierArgument("delay");
    config.delay = delay4.includes("-") ? delay4.split("-").map((n) => parseInt(n)) : parseInt(delay4);
  }
  if (modifiers.includes("cursor")) {
    config.plugins.push(import_tippy.followCursor);
    const next = getModifierArgument("cursor");
    if (["x", "initial"].includes(next)) {
      config.followCursor = next === "x" ? "horizontal" : "initial";
    } else {
      config.followCursor = true;
    }
  }
  if (modifiers.includes("on")) {
    config.trigger = getModifierArgument("on");
  }
  if (modifiers.includes("arrowless")) {
    config.arrow = false;
  }
  if (modifiers.includes("html")) {
    config.allowHTML = true;
  }
  if (modifiers.includes("interactive")) {
    config.interactive = true;
  }
  if (modifiers.includes("border") && config.interactive) {
    config.interactiveBorder = parseInt(getModifierArgument("border"));
  }
  if (modifiers.includes("debounce") && config.interactive) {
    config.interactiveDebounce = parseInt(getModifierArgument("debounce"));
  }
  if (modifiers.includes("max-width")) {
    config.maxWidth = parseInt(getModifierArgument("max-width"));
  }
  if (modifiers.includes("theme")) {
    config.theme = getModifierArgument("theme");
  }
  if (modifiers.includes("placement")) {
    config.placement = getModifierArgument("placement");
  }
  return config;
};
function Tooltip(Alpine3) {
  Alpine3.magic("tooltip", (el) => {
    return (content, config = {}) => {
      const instance = (0, import_tippy2.default)(el, {
        content,
        trigger: "manual",
        ...config
      });
      instance.show();
      setTimeout(() => {
        instance.hide();
        setTimeout(() => instance.destroy(), config.duration || 300);
      }, config.timeout || 2e3);
    };
  });
  Alpine3.directive("tooltip", (el, { modifiers, expression }, { evaluateLater: evaluateLater2, effect: effect3 }) => {
    const config = modifiers.length > 0 ? buildConfigFromModifiers2(modifiers) : {};
    if (!el.__x_tippy) {
      el.__x_tippy = (0, import_tippy2.default)(el, config);
    }
    const enableTooltip = () => el.__x_tippy.enable();
    const disableTooltip = () => el.__x_tippy.disable();
    const setupTooltip = (content) => {
      if (!content) {
        disableTooltip();
      } else {
        enableTooltip();
        el.__x_tippy.setContent(content);
      }
    };
    if (modifiers.includes("raw")) {
      setupTooltip(expression);
    } else {
      const getContent = evaluateLater2(expression);
      effect3(() => {
        getContent((content) => {
          if (typeof content === "object") {
            el.__x_tippy.setProps(content);
            enableTooltip();
          } else {
            setupTooltip(content);
          }
        });
      });
    }
  });
}
Tooltip.defaultProps = (props) => {
  import_tippy2.default.setDefaultProps(props);
  return Tooltip;
};
var src_default7 = Tooltip;
var module_default7 = src_default7;

// node_modules/alpinejs/dist/module.esm.js
var flushPending = false;
var flushing = false;
var queue = [];
var lastFlushedIndex = -1;
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  let index = queue.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex)
    queue.splice(index, 1);
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i = 0; i < queue.length; i++) {
    queue[i]();
    lastFlushedIndex = i;
  }
  queue.length = 0;
  lastFlushedIndex = -1;
  flushing = false;
}
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  } });
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup2 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i) => i());
      };
    }
    el._x_effects.add(effectReference);
    cleanup2 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup2();
  }];
}
function watch(getter, callback) {
  let firstTime = true;
  let oldValue;
  let effectReference = effect(() => {
    let value = getter();
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  });
  return () => release(effectReference);
}
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds.push(callback);
  }
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i) => i());
      delete el._x_attributeCleanups[name];
    }
  });
}
function cleanupElement(el) {
  if (el._x_cleanups) {
    while (el._x_cleanups.length)
      el._x_cleanups.pop()();
  }
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var queuedMutations = [];
function flushObserver() {
  let records = observer.takeRecords();
  queuedMutations.push(() => records.length > 0 && onMutate(records));
  let queueLengthWhenTriggered = queuedMutations.length;
  queueMicrotask(() => {
    if (queuedMutations.length === queueLengthWhenTriggered) {
      while (queuedMutations.length > 0)
        queuedMutations.shift()();
    }
  });
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = /* @__PURE__ */ new Set();
  let removedNodes = /* @__PURE__ */ new Set();
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i = 0; i < mutations.length; i++) {
    if (mutations[i].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i].type === "childList") {
      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.add(node));
      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.add(node));
    }
    if (mutations[i].type === "attributes") {
      let el = mutations[i].target;
      let name = mutations[i].attributeName;
      let oldValue = mutations[i].oldValue;
      let add2 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove2 = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add2();
      } else if (el.hasAttribute(name)) {
        remove2();
        add2();
      } else {
        remove2();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i) => i(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.has(node))
      continue;
    onElRemoveds.forEach((i) => i(node));
  }
  addedNodes.forEach((node) => {
    node._x_ignoreSelf = true;
    node._x_ignore = true;
  });
  for (let node of addedNodes) {
    if (removedNodes.has(node))
      continue;
    if (!node.isConnected)
      continue;
    delete node._x_ignoreSelf;
    delete node._x_ignore;
    onElAddeds.forEach((i) => i(node));
    node._x_ignore = true;
    node._x_ignoreSelf = true;
  }
  addedNodes.forEach((node) => {
    delete node._x_ignoreSelf;
    delete node._x_ignore;
  });
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data2, referenceNode) {
  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
  };
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  return new Proxy({ objects }, mergeProxyTrap);
}
var mergeProxyTrap = {
  ownKeys({ objects }) {
    return Array.from(
      new Set(objects.flatMap((i) => Object.keys(i)))
    );
  },
  has({ objects }, name) {
    if (name == Symbol.unscopables)
      return false;
    return objects.some(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
    );
  },
  get({ objects }, name, thisProxy) {
    if (name == "toJSON")
      return collapseProxies;
    return Reflect.get(
      objects.find(
        (obj) => Reflect.has(obj, name)
      ) || {},
      name,
      thisProxy
    );
  },
  set({ objects }, name, value, thisProxy) {
    const target = objects.find(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name)
    ) || objects[objects.length - 1];
    const descriptor = Object.getOwnPropertyDescriptor(target, name);
    if (descriptor?.set && descriptor?.get)
      return descriptor.set.call(thisProxy, value) || true;
    return Reflect.set(target, name, value);
  }
};
function collapseProxies() {
  let keys = Reflect.ownKeys(this);
  return keys.reduce((acc, key) => {
    acc[key] = Reflect.get(this, key);
    return acc;
  }, {});
}
function initInterceptors(data2) {
  let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      if (typeof value === "object" && value !== null && value.__v_skip)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data2, path, key);
      } else {
        if (isObject2(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data2);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data2, path, key) {
      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data2, path, key) => {
        let innerValue = initialValue.initialize(data2, path, key);
        obj.initialValue = innerValue;
        return initialize(data2, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  Object.entries(magics).forEach(([name, callback]) => {
    let memoizedUtilities = null;
    function getUtilities() {
      if (memoizedUtilities) {
        return memoizedUtilities;
      } else {
        let [utilities, cleanup2] = getElementBoundUtilities(el);
        memoizedUtilities = { interceptor, ...utilities };
        onElRemoved(el, cleanup2);
        return memoizedUtilities;
      }
    }
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, getUtilities());
      },
      enumerable: false
    });
  });
  return obj;
}
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e) {
    handleError(e, el, expression);
  }
}
function handleError(error2, el, expression = void 0) {
  error2 = Object.assign(
    error2 ?? { message: "No error message given." },
    { el, expression }
  );
  console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error2;
  }, 0);
}
var shouldAutoEvaluateFunctions = true;
function dontAutoEvaluateFunctions(callback) {
  let cache = shouldAutoEvaluateFunctions;
  shouldAutoEvaluateFunctions = false;
  let result = callback();
  shouldAutoEvaluateFunctions = cache;
  return result;
}
function evaluate(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      let func2 = new AsyncFunction(
        ["__self", "scope"],
        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
      );
      Object.defineProperty(func2, "name", {
        value: `[Alpine] ${expression}`
      });
      return func2;
    } catch (error2) {
      handleError(error2, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope2, ...dataStack]);
    if (typeof func === "function") {
      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope2, params, el) {
  if (shouldAutoEvaluateFunctions && typeof value === "function") {
    let result = value.apply(scope2, params);
    if (result instanceof Promise) {
      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i) => receiver(i));
  } else {
    receiver(value);
  }
}
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
  return {
    before(directive2) {
      if (!directiveHandlers[directive2]) {
        console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
        return;
      }
      const pos = directiveOrder.indexOf(directive2);
      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directiveExists(name) {
  return Object.keys(directiveHandlers).includes(name);
}
function directives(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives2.map((directive2) => {
    return getDirectiveHandler(el, directive2);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = /* @__PURE__ */ new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities(el) {
  let cleanups = [];
  let cleanup2 = (callback) => cleanups.push(callback);
  let [effect3, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect3,
    cleanup: cleanup2,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate.bind(evaluate, el)
  };
  let doCleanup = () => cleanups.forEach((i) => i());
  return [utilities, doCleanup];
}
function getDirectiveHandler(el, directive2) {
  let noop = () => {
  };
  let handler4 = directiveHandlers[directive2.type] || noop;
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  onAttributeRemoved(el, directive2.original, cleanup2);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler4.inline && handler4.inline(el, directive2, utilities);
    handler4 = handler4.bind(handler4, el, directive2, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
  };
  fullHandler.runCleanups = cleanup2;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into = (i) => i;
function toTransformedAttributes(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
      return transform(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({ name }) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i) => i.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport"
];
function byPriority(a, b) {
  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      // Allows events to pass the shadow DOM barrier.
      composed: true,
      cancelable: true
    })
  );
}
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback, false);
    node = node.nextElementSibling;
  }
}
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started = false;
function start() {
  if (started)
    warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started = true;
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle2) => handle2());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
  setTimeout(() => {
    warnAboutMissingPlugins();
  });
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
var initInterceptors2 = [];
function interceptInit(callback) {
  initInterceptors2.push(callback);
}
function initTree(el, walker = walk, intercept = () => {
}) {
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      intercept(el2, skip);
      initInterceptors2.forEach((i) => i(el2, skip));
      directives(el2, el2.attributes).forEach((handle2) => handle2());
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root, walker = walk) {
  walker(root, (el) => {
    cleanupAttributes(el);
    cleanupElement(el);
  });
}
function warnAboutMissingPlugins() {
  let pluginDirectives = [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ];
  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
    if (directiveExists(directive2))
      return;
    selectors.some((selector) => {
      if (document.querySelector(selector)) {
        warn(`found "${selector}", but missing ${plugin2} plugin`);
        return true;
      }
    });
  });
}
var tickStack = [];
var isHolding = false;
function nextTick(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
  return new Promise((res2) => {
    tickStack.push(() => {
      callback();
      res2();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let split = (classString2) => classString2.split(" ").filter(Boolean);
  let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i) => {
    if (el.classList.contains(i)) {
      el.classList.remove(i);
      removed.push(i);
    }
  });
  forAdd.forEach((i) => {
    if (!el.classList.contains(i)) {
      el.classList.add(i);
      added.push(i);
    }
  });
  return () => {
    removed.forEach((i) => el.classList.add(i));
    added.forEach((i) => el.classList.remove(i));
  };
}
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "function")
    expression = evaluate2(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    "enter": (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    "leave": (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue2(modifiers, "scale", 95) / 100 : 1;
  let delay4 = modifierValue2(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue2(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue2(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue2(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay4}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay4}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick2(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
    el._x_transition.out(() => {
    }, () => resolve(hide));
    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick2(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i]) => i?.());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e) => {
          if (!e.isFromCancelledTransition)
            throw e;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start2);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      ;
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay4 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay4);
      reachedEnd = true;
    });
  });
}
function modifierValue2(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function onlyDuringClone(callback) {
  return (...args) => isCloning && callback(...args);
}
var interceptors = [];
function interceptClone(callback) {
  interceptors.push(callback);
}
function cloneNode(from, to) {
  interceptors.forEach((i) => i(from, to));
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    initTree(to, (el, callback) => {
      callback(el, () => {
      });
    });
  });
  isCloning = false;
}
var isCloningLegacy = false;
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  isCloningLegacy = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
  isCloningLegacy = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache);
}
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty(el, name, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (el.type === "radio") {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      if (typeof value === "boolean") {
        el.checked = safeParseBoolean(el.value) === value;
      } else {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    }
  } else if (el.type === "checkbox") {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value === void 0 ? "" : value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttributeAndProperty(el, name, value) {
  bindAttribute(el, name, value);
  setPropertyIfChanged(el, name, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function safeParseBoolean(rawValue) {
  if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
    return true;
  }
  if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
    return false;
  }
  return rawValue ? Boolean(rawValue) : null;
}
function isBooleanAttr(attrName) {
  const booleanAttributes = [
    "disabled",
    "checked",
    "required",
    "readonly",
    "open",
    "selected",
    "autofocus",
    "itemscope",
    "multiple",
    "novalidate",
    "allowfullscreen",
    "allowpaymentrequest",
    "formnovalidate",
    "autoplay",
    "controls",
    "loop",
    "muted",
    "playsinline",
    "default",
    "ismap",
    "reversed",
    "async",
    "defer",
    "nomodule"
  ];
  return booleanAttributes.includes(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding(el, name, fallback);
}
function extractProp(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions(() => {
      return evaluate(el, binding.expression);
    });
  }
  return getAttributeBinding(el, name, fallback);
}
function getAttributeBinding(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash;
  let innerHash;
  let reference = effect(() => {
    let outer = outerGet();
    let inner = innerGet();
    if (firstRun) {
      innerSet(cloneIfObject(outer));
      firstRun = false;
    } else {
      let outerHashLatest = JSON.stringify(outer);
      let innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        innerSet(cloneIfObject(outer));
      } else if (outerHashLatest !== innerHashLatest) {
        outerSet(cloneIfObject(inner));
      } else {
      }
    }
    outerHash = JSON.stringify(outerGet());
    innerHash = JSON.stringify(innerGet());
  });
  return () => {
    release(reference);
  };
}
function cloneIfObject(value) {
  return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
}
function plugin(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i) => i(alpine_default));
}
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
  initInterceptors(stores[name]);
}
function getStores() {
  return stores;
}
var binds = {};
function bind2(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    return applyBindingsObject(name, getBindings());
  } else {
    binds[name] = getBindings;
  }
  return () => {
  };
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives(el, attributes, original).map((handle2) => {
    cleanupRunners.push(handle2.runCleanups);
    handle2();
  });
  return () => {
    while (cleanupRunners.length)
      cleanupRunners.pop()();
  };
}
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine2 = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.14.1",
  flushAndStopDeferringMutations,
  dontAutoEvaluateFunctions,
  disableEffectScheduling,
  startObservingMutations,
  stopObservingMutations,
  setReactivityEngine,
  onAttributeRemoved,
  onAttributesAdded,
  closestDataStack,
  skipDuringClone,
  onlyDuringClone,
  addRootSelector,
  addInitSelector,
  interceptClone,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  interceptInit,
  setEvaluator,
  mergeProxies,
  extractProp,
  findClosest,
  onElRemoved,
  closestRoot,
  destroyTree,
  interceptor,
  // INTERNAL: not public API and is subject to change without major release.
  transition,
  // INTERNAL
  setStyles,
  // INTERNAL
  mutateDom,
  directive,
  entangle,
  throttle,
  debounce,
  evaluate,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  // INTERNAL
  cloneNode,
  // INTERNAL
  bound: getBinding,
  $data: scope,
  watch,
  walk,
  data,
  bind: bind2
};
var alpine_default = Alpine2;
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap = /* @__PURE__ */ new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol(true ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
function isEffect(fn) {
  return fn && fn._isEffect === true;
}
function effect2(fn, options = EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }
  const effect3 = createReactiveEffect(fn, options);
  if (!options.lazy) {
    effect3();
  }
  return effect3;
}
function stop(effect3) {
  if (effect3.active) {
    cleanup(effect3);
    if (effect3.options.onStop) {
      effect3.options.onStop();
    }
    effect3.active = false;
  }
}
var uid = 0;
function createReactiveEffect(fn, options) {
  const effect3 = function reactiveEffect() {
    if (!effect3.active) {
      return fn();
    }
    if (!effectStack.includes(effect3)) {
      cleanup(effect3);
      try {
        enableTracking();
        effectStack.push(effect3);
        activeEffect = effect3;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };
  effect3.id = uid++;
  effect3.allowRecurse = !!options.allowRecurse;
  effect3._isEffect = true;
  effect3.active = true;
  effect3.raw = fn;
  effect3.deps = [];
  effect3.options = options;
  return effect3;
}
function cleanup(effect3) {
  const { deps } = effect3;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect3);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!shouldTrack || activeEffect === void 0) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add2 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect3) => {
        if (effect3 !== activeEffect || effect3.allowRecurse) {
          effects.add(effect3);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add2);
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add2(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add2(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          add2(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          add2(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const run = (effect3) => {
    if (effect3.options.onTrigger) {
      effect3.options.onTrigger({
        effect: effect3,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect3.options.scheduler) {
      effect3.options.scheduler(effect3);
    } else {
      effect3();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
var get2 = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res2 = arr[key](...args);
      if (res2 === -1 || res2 === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res2;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res2 = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res2;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get32(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res2 = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res2;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res2;
    }
    if (isRef(res2)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res2.value : res2;
    }
    if (isObject(res2)) {
      return isReadonly ? readonly(res2) : reactive2(res2);
    }
    return res2;
  };
}
var set2 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys2(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get2,
  set: set2,
  deleteProperty,
  has,
  ownKeys: ownKeys2
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (true) {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (true) {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => isObject(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get32 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get32.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get32 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get32 ? get32.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (target && target[
    "__v_isReadonly"
    /* IS_READONLY */
  ]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* RAW */
  ] && !(isReadonly && target[
    "__v_isReactive"
    /* IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  return observed && toRaw(observed[
    "__v_raw"
    /* RAW */
  ]) || observed;
}
function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}
magic("nextTick", () => nextTick);
magic("dispatch", (el) => dispatch.bind(dispatch, el));
magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
  let evaluate2 = evaluateLater2(key);
  let getter = () => {
    let value;
    evaluate2((i) => value = i);
    return value;
  };
  let unwatch = watch(getter, callback);
  cleanup2(unwatch);
});
magic("store", getStores);
magic("data", (el) => scope(el));
magic("root", (el) => closestRoot(el));
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  findClosest(el, (i) => {
    if (i._x_refs)
      refObjects.push(i._x_refs);
  });
  return refObjects;
}
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}
magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
  let cacheKey = `${name}${key ? `-${key}` : ""}`;
  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
});
interceptClone((from, to) => {
  if (from._x_id) {
    to._x_id = from._x_id;
  }
});
function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
  if (!el._x_id)
    el._x_id = {};
  if (el._x_id[cacheKey])
    return el._x_id[cacheKey];
  let output = callback();
  el._x_id[cacheKey] = output;
  cleanup2(() => {
    delete el._x_id[cacheKey];
  });
  return output;
}
magic("el", (el) => el);
warnMissingPluginMagic("Focus", "focus", "focus");
warnMissingPluginMagic("Persist", "persist", "persist");
function warnMissingPluginMagic(name, magicName, slug) {
  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
  let func = evaluateLater2(expression);
  let innerGet = () => {
    let result;
    func((i) => result = i);
    return result;
  };
  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { "__placeholder": val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle(
      {
        get() {
          return outerGet();
        },
        set(value) {
          outerSet(value);
        }
      },
      {
        get() {
          return innerGet();
        },
        set(value) {
          innerSet(value);
        }
      }
    );
    cleanup2(releaseEntanglement);
  });
});
directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = getTarget(expression);
  let clone2 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone2;
  clone2._x_teleportBack = el;
  el.setAttribute("data-teleport-template", true);
  clone2.setAttribute("data-teleport-target", true);
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone2.addEventListener(eventName, (e) => {
        e.stopPropagation();
        el.dispatchEvent(new e.constructor(e.type, e));
      });
    });
  }
  addScopeToNode(clone2, {}, el);
  let placeInDom = (clone3, target2, modifiers2) => {
    if (modifiers2.includes("prepend")) {
      target2.parentNode.insertBefore(clone3, target2);
    } else if (modifiers2.includes("append")) {
      target2.parentNode.insertBefore(clone3, target2.nextSibling);
    } else {
      target2.appendChild(clone3);
    }
  };
  mutateDom(() => {
    placeInDom(clone2, target, modifiers);
    skipDuringClone(() => {
      initTree(clone2);
      clone2._x_ignore = true;
    })();
  });
  el._x_teleportPutBack = () => {
    let target2 = getTarget(expression);
    mutateDom(() => {
      placeInDom(el._x_teleport, target2, modifiers);
    });
  };
  cleanup2(() => clone2.remove());
});
var teleportContainerDuringClone = document.createElement("div");
function getTarget(expression) {
  let target = skipDuringClone(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone;
  })();
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  return target;
}
var handler = () => {
};
handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup2(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);
directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
  effect3(evaluateLater(el, expression));
}));
function on(el, event, modifiers, callback) {
  let listenerTarget = el;
  let handler4 = (e) => callback(e);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
  if (modifiers.includes("dot"))
    event = dotSyntax(event);
  if (modifiers.includes("camel"))
    event = camelCase2(event);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = debounce(handler4, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = throttle(handler4, wait);
  }
  if (modifiers.includes("prevent"))
    handler4 = wrapHandler(handler4, (next, e) => {
      e.preventDefault();
      next(e);
    });
  if (modifiers.includes("stop"))
    handler4 = wrapHandler(handler4, (next, e) => {
      e.stopPropagation();
      next(e);
    });
  if (modifiers.includes("once")) {
    handler4 = wrapHandler(handler4, (next, e) => {
      next(e);
      listenerTarget.removeEventListener(event, handler4, options);
    });
  }
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler4 = wrapHandler(handler4, (next, e) => {
      if (el.contains(e.target))
        return;
      if (e.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e);
    });
  }
  if (modifiers.includes("self"))
    handler4 = wrapHandler(handler4, (next, e) => {
      e.target === el && next(e);
    });
  if (isKeyEvent(event) || isClickEvent(event)) {
    handler4 = wrapHandler(handler4, (next, e) => {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
        return;
      }
      next(e);
    });
  }
  listenerTarget.addEventListener(event, handler4, options);
  return () => {
    listenerTarget.removeEventListener(event, handler4, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  if ([" ", "_"].includes(
    subject
  ))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event) {
  return ["keydown", "keyup"].includes(event);
}
function isClickEvent(event) {
  return ["contextmenu", "click", "mouse"].some((i) => event.includes(i));
}
function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
  let keyModifiers = modifiers.filter((i) => {
    return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(i);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (isClickEvent(e.type))
        return false;
      if (keyToModifiers(e.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    "ctrl": "control",
    "slash": "/",
    "space": " ",
    "spacebar": " ",
    "cmd": "meta",
    "esc": "escape",
    "up": "arrow-up",
    "down": "arrow-down",
    "left": "arrow-left",
    "right": "arrow-right",
    "period": ".",
    "comma": ",",
    "equal": "=",
    "minus": "-",
    "underscore": "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { "__placeholder": value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning ? () => {
  } : on(el, event, modifiers, (e) => {
    setValue(getInputValue(el, modifiers, e, getValue()));
  });
  if (modifiers.includes("fill")) {
    if ([void 0, null, ""].includes(getValue()) || el.type === "checkbox" && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
      setValue(
        getInputValue(el, modifiers, { target: el }, getValue())
      );
    }
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup2(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on(el.form, "reset", [], (e) => {
      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
    });
    cleanup2(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom(() => bind(el, "value", value));
    delete window.fromModel;
  };
  effect3(() => {
    let value = getValue();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue(el, modifiers, event, currentValue) {
  return mutateDom(() => {
    if (event instanceof CustomEvent && event.detail !== void 0)
      return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
    else if (el.type === "checkbox") {
      if (Array.isArray(currentValue)) {
        let newValue = null;
        if (modifiers.includes("number")) {
          newValue = safeParseNumber(event.target.value);
        } else if (modifiers.includes("boolean")) {
          newValue = safeParseBoolean(event.target.value);
        } else {
          newValue = event.target.value;
        }
        return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
      } else {
        return event.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      if (modifiers.includes("number")) {
        return Array.from(event.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        });
      } else if (modifiers.includes("boolean")) {
        return Array.from(event.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseBoolean(rawValue);
        });
      }
      return Array.from(event.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let newValue;
      if (el.type === "radio") {
        if (event.target.checked) {
          newValue = event.target.value;
        } else {
          newValue = currentValue;
        }
      } else {
        newValue = event.target.value;
      }
      if (modifiers.includes("number")) {
        return safeParseNumber(newValue);
      } else if (modifiers.includes("boolean")) {
        return safeParseBoolean(newValue);
      } else if (modifiers.includes("trim")) {
        return newValue.trim();
      } else {
        return newValue;
      }
    }
  });
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate2(expression, {}, false);
  }
  return evaluate2(expression, {}, false);
}));
directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});
directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes(startingWith(":", into(prefix("bind:"))));
var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    getBindings((bindings) => {
      applyBindingsObject(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate2 = evaluateLater(el, expression);
  effect3(() => evaluate2((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom(() => bind(el, value, result, modifiers));
  }));
  cleanup2(() => {
    el._x_undoAddedClasses && el._x_undoAddedClasses();
    el._x_undoAddedStyles && el._x_undoAddedStyles();
  });
};
handler2.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive("bind", handler2);
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector(() => `[${prefix("data")}]`);
directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
  if (shouldSkipRegisteringDataDuringClone(el))
    return;
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data2 = evaluate(el, expression, { scope: dataProviderContext });
  if (data2 === void 0 || data2 === true)
    data2 = {};
  injectMagics(data2, el);
  let reactiveData = reactive(data2);
  initInterceptors(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate(el, reactiveData["init"]);
  cleanup2(() => {
    reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
    undo();
  });
});
interceptClone((from, to) => {
  if (from._x_dataStack) {
    to._x_dataStack = from._x_dataStack;
    to.setAttribute("data-has-alpine-state", true);
  }
});
function shouldSkipRegisteringDataDuringClone(el) {
  if (!isCloning)
    return false;
  if (isCloningLegacy)
    return true;
  return el.hasAttribute("data-has-alpine-state");
}
directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
  let evaluate2 = evaluateLater(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once(
    (value) => value ? show() : hide(),
    (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    }
  );
  let oldValue;
  let firstTime = true;
  effect3(() => evaluate2((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(
    el,
    // the x-bind:key expression is stored for our use instead of evaluated.
    el._x_keyExpression || "index"
  );
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup2(() => {
    Object.values(el._x_lookup).forEach((el2) => el2.remove());
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject2 = (i) => typeof i === "object" && !Array.isArray(i);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i) => i + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject2(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => {
          if (keys.includes(value2))
            warn("Duplicate key on x-for", el);
          keys.push(value2);
        }, { scope: { index: key, ...scope2 } });
        scopes.push(scope2);
      });
    } else {
      for (let i = 0; i < items.length; i++) {
        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
        evaluateKey((value) => {
          if (keys.includes(value))
            warn("Duplicate key on x-for", el);
          keys.push(value);
        }, { scope: { index: i, ...scope2 } });
        scopes.push(scope2);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i = 0; i < prevKeys.length; i++) {
      let key = prevKeys[i];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i, 0, key);
        adds.push([lastKey, i]);
      } else if (prevIndex !== i) {
        let keyInSpot = prevKeys.splice(i, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i = 0; i < removes.length; i++) {
      let key = removes[i];
      if (!!lookup[key]._x_effects) {
        lookup[key]._x_effects.forEach(dequeueJob);
      }
      lookup[key].remove();
      lookup[key] = null;
      delete lookup[key];
    }
    for (let i = 0; i < moves.length; i++) {
      let [keyInSpot, keyForSpot] = moves[i];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        if (!elForSpot)
          warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i = 0; i < adds.length; i++) {
      let [lastKey2, index] = adds[i];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope2 = scopes[index];
      let key = keys[index];
      let clone2 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive(scope2);
      addScopeToNode(clone2, reactiveScope, templateEl);
      clone2._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom(() => {
        lastEl.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone2;
    }
    for (let i = 0; i < sames.length; i++) {
      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res2 = {};
  res2.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res2.item = item.replace(forIteratorRE, "").trim();
    res2.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res2.collection = iteratorMatch[2].trim();
    }
  } else {
    res2.item = item;
  }
  return res2;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
    names.forEach((name, i) => {
      scopeVariables[name] = item[i];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler3() {
}
handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup2(() => delete root._x_refs[expression]);
};
directive("ref", handler3);
directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-if can only be used on a <template> tag", el);
  let evaluate2 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone2 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      el.after(clone2);
      skipDuringClone(() => initTree(clone2))();
    });
    el._x_currentIfEl = clone2;
    el._x_undoIf = () => {
      walk(clone2, (node) => {
        if (!!node._x_effects) {
          node._x_effects.forEach(dequeueJob);
        }
      });
      clone2.remove();
      delete el._x_currentIfEl;
    };
    return clone2;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect3(() => evaluate2((value) => {
    value ? show() : hide();
  }));
  cleanup2(() => el._x_undoIf && el._x_undoIf());
});
directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
  let names = evaluate2(expression);
  names.forEach((name) => setIdRoot(el, name));
});
interceptClone((from, to) => {
  if (from._x_ids) {
    to._x_ids = from._x_ids;
  }
});
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
  let evaluate2 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e) => {
    evaluate2(() => {
    }, { scope: { "$event": e }, params: [e] });
  });
  cleanup2(() => removeListener());
}));
warnMissingPluginDirective("Collapse", "collapse", "collapse");
warnMissingPluginDirective("Intersect", "intersect", "intersect");
warnMissingPluginDirective("Focus", "trap", "focus");
warnMissingPluginDirective("Mask", "mask", "mask");
function warnMissingPluginDirective(name, directiveName, slug) {
  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default.setEvaluator(normalEvaluator);
alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
var src_default8 = alpine_default;
var module_default8 = src_default8;

// src/js/components/DttColumn.ts
function inferDireccionAndPropietario(value = "") {
  value = value || "";
  if (!(value || "").includes(" - ") && (value || "").includes("-"))
    value = value.replace(
      /([^\s]+)\s*-\s*([^\s]+)/,
      "$1 - $2"
    );
  let valueArray = (value || "").split(" - ");
  let [
    direccion = "",
    propietario = ""
  ] = !valueArray[1] || /\d+/.test(valueArray[0]) || !/\d+/.test(valueArray[1]) ? [
    valueArray[0],
    valueArray[1]
  ] : [valueArray[1], valueArray[0]];
  return { direccion, propietario };
}
var DttColumn = class {
  constructor(options) {
    this._visible = true;
    this.input_type = "text" /* Text */;
    this.editable = true;
    const {
      name,
      data: data2,
      title,
      visible = true,
      className,
      sortable,
      render,
      width,
      targets,
      slug_name,
      input_type,
      checkbox,
      attr_type = "negocio",
      editable = true,
      is_default = false,
      ...attrs
    } = options;
    Object.entries(attrs).forEach(([attr_name, attr_value]) => {
      this[attr_name] = attr_value;
    });
    this.editable = editable;
    this.is_default = is_default;
    this.slug_name = slug_name;
    this.width = width;
    this.title = this.name = name;
    if (data2) {
      this.data = data2;
      this.field = data2;
    } else if (checkbox) {
      this.checkbox = checkbox;
    }
    this.attr_type = attr_type;
    this.title = title;
    this.visible = visible;
    this.class = this.className = className;
    this.sortable = sortable;
    this.targets = targets;
    this.input_type = input_type || "text";
    this.render = render || this.defaultRendered;
    this.formatter = (value, row) => {
      return this.render(value, null, row, null);
    };
    const key = [slug_name, attr_type].filter(Boolean).join(",");
  }
  /*set visible(visible: boolean) {
      //console.trace(this.slug_name + ' setting visible', visible)
      this._visible = visible;
  }
  get visible() {
      return this._visible;
  }*/
  defaultRendered(data2, type, row, meta) {
    return data2;
  }
  get $store() {
    return {
      columnas_actuales: Alpine.store("columnas_actuales"),
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      active_filter: Alpine.store("active_filter"),
      maps: Alpine.store("maps"),
      user: Alpine.store("user")
    };
  }
};

// src/js/components/alpine.store.ts
console.zdebug = console.info.bind(
  console,
  "%cDEBUG:",
  "color:#A39;font-weight:bold;"
);
console.zsuccess = console.info.bind(
  console,
  "%cSUCCESS:",
  "color:#16a34a;font-weight:bold;"
);
console.zlog = console.log.bind(
  console,
  "%cLOG:",
  "color:#090;font-weight:bold;"
);
console.zinfo = console.info.bind(
  console,
  "%cINFO:",
  "color:#33C;font-weight:bold;"
);
console.zwarn = console.warn.bind(
  console,
  "%cWARN:",
  "color:orange;font-weight:bold;"
);
console.ztable = console.table.bind(
  console,
  "%cTABLE:",
  "color:orange;font-weight:bold;"
);
console.timeEnd = console.timeEnd.bind(
  console,
  "%ctimeEnd:",
  "color:cyan;font-weight:bold;"
);

// src/js/components/alpine_definitions/bindConsole.ts
function bindConsole(className, classNameColor) {
  if (!console.timerInfo) {
    Object.defineProperty(console, "timerInfo", {
      get: function() {
        return Function.prototype.bind.call(
          console.log,
          console,
          "%c" + Number(performance.now() / 1e3).toFixed(1) + " Timer:",
          "color:#03C;font-weight:bold;"
        );
      }
    });
  }
  return {
    ...console,
    debug: console.debug.bind(console, `%c${className}:`, "color:#A39;font-weight:bold;"),
    log: console.log.bind(console, `%c${className}:`, "color:#090;font-weight:bold;"),
    info: console.info.bind(console, `%c${className}:`, classNameColor ?? "color:#33C;font-weight:bold;"),
    warn: console.warn.bind(console, `%c${className}:`, "color:orange;font-weight:bold;"),
    error: console.error.bind(console, `%c${className}:`, "color:red;font-weight:bold;"),
    timerInfo: console.timerInfo.bind(console, `%c${className}:`, classNameColor ?? "color:#33C;font-weight:bold;")
  };
}

// src/js/components/alpine_definitions/definitions.search_types.ts
var VSearchType = /* @__PURE__ */ ((VSearchType3) => {
  VSearchType3["BETWEEN"] = "15";
  VSearchType3["GREATER_THAN"] = "5";
  VSearchType3["GREATER_THAN_OR_EQUAL"] = "7";
  VSearchType3["HAS_ATTACHMENTS"] = "23";
  VSearchType3["IN_RANGE"] = "25";
  VSearchType3["IS_AFTER"] = "18";
  VSearchType3["IS_BEFORE"] = "17";
  VSearchType3["IS_EQUAL"] = "21";
  VSearchType3["IS_NOT_EQUAL"] = "22";
  VSearchType3["IS_NOT_NULL"] = "14";
  VSearchType3["IS_NULL"] = "13";
  VSearchType3["JSON_CONTAINS"] = "19";
  VSearchType3["JSON_NOT_CONTAINS"] = "20";
  VSearchType3["LESS_THAN"] = "6";
  VSearchType3["LESS_THAN_OR_EQUAL"] = "8";
  VSearchType3["LIKE"] = "3";
  VSearchType3["NOT_BETWEEN"] = "16";
  VSearchType3["NOT_IN"] = "2";
  VSearchType3["NOT_LIKE"] = "4";
  VSearchType3["IN"] = "1";
  return VSearchType3;
})(VSearchType || {});
var VTypeSearch = Object.entries(VSearchType).reduce((a, [k, v]) => ({ ...a, [v]: k }), {});

// src/js/components/alpine_definitions/logLevel.ts
var fakeConsole = {
  ...console,
  log: (args) => {
    null;
  },
  info: (args) => {
    null;
  },
  debug: (args) => {
    null;
  },
  warn: (args) => {
    null;
  },
  error: (args) => {
    null;
  }
};

// src/js/components/hardCodedDateFields.ts
var hardCodedDateFields = [
  //{ slug_name: "created_at", attr_type: "negocio", name: "Fecha Creacin" },
  {
    slug_name: "updated_at",
    attr_type: "negocio",
    name: "\xDAltima actualizaci\xF3n",
    id_input_type: "6" /* INPUT_DATE_TIME */,
    visible: false,
    readonly: true
  }
  //{ slug_name: "fecha_esperada_venta", attr_type: "negocio_attr", name: "F. Esperada venta" }
].map((item) => {
  let { slug_name, attr_type } = item;
  return {
    data: slug_name,
    field: slug_name,
    id: 0,
    related_model: null,
    readonly: 0,
    input_type: "date",
    ...item,
    key: `${slug_name},${attr_type}`,
    id_input_type: 5,
    inputType: "date",
    form_component: "dateInputComponent",
    visible: item.visible
  };
}).sort((a, b) => {
  return a.slug_name.localeCompare(b.slug_name);
});

// src/js/components/openToast.ts
function openToastRaw(options = {}) {
  if (typeof options === "string") {
    let textmsg = options;
    options = {
      type: "info",
      text: textmsg,
      delay: 2e3,
      from: null,
      description: "",
      callback: () => {
      }
    };
  }
  let {
    type = "info",
    text = "Solicitud guardada exitosamente",
    delay: delay4 = 2e3,
    from = null,
    description = "",
    callback = () => {
    }
  } = options;
  if (from)
    console.info("openToast called from " + from);
  globalThis.dispatchEvent(
    new CustomEvent("notice", {
      detail: {
        type,
        title: text,
        description,
        delay: delay4
      }
    })
  );
  if (callback) {
    setTimeout(callback, delay4);
  }
}
var openToast = module_default8.debounce(openToastRaw, 400);
globalThis.openToast = openToast;

// src/js/components/plugins/addEditableBehavior.ts
var requestAnimationPromise = globalThis.requestAnimationPromise;

// src/js/components/plugins/phoneToPrettyPhone.ts
function phoneToPrettyPhone(phone) {
  if (phone && /(\+*5*6*){0,1}([1-9])(\d{4})(\d{4})/.exec(phone.replace(
    /\s/g,
    ""
  ))) {
    let [_, code, prefix2, group1, group2] = /(\+*5*6*){0,1}([1-9])(\d{4})(\d{4})/.exec(phone.replace(
      /\s/g,
      ""
    ));
    phone = ["+56", prefix2, group1, group2].join(" ");
  }
  return phone;
}
globalThis.phoneToPrettyPhone = phoneToPrettyPhone;

// src/js/components/plugins/tap.ts
var tap = (element, callback) => {
  if (callback)
    callback(element);
  return element;
};

// src/js/components/plugins/waitFor.ts
async function waitFor2(delay4 = 500, cb = () => {
}) {
  return new Promise((res2) => {
    setTimeout(() => res2(cb), delay4);
  });
}

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/logLevel.ts
var LogLevels = {
  ERROR: 5,
  WARN: 4,
  INFO: 3,
  DEBUG: 2,
  TRACE: 1
};
var fakeConsole2 = {
  ...console,
  log: (args) => {
    null;
  },
  info: (args) => {
    null;
  },
  debug: (args) => {
    null;
  },
  warn: (args) => {
    null;
  },
  error: (args) => {
    null;
  }
};

// src/js/components/decorators/ContactOption.ts
function processOption(option) {
  let entry = typeof option === "string" ? { name: option, value: option, id: option } : {
    //@ts-ignore
    name: option.name || option.label || option.value || option,
    //@ts-ignore
    label: option.label || option.name || option.value || option,
    //@ts-ignore
    value: option.value || option.id || option.name || option,
    //@ts-ignore
    id: option.value || option.id || option.name || option
  };
  if (typeof option === "object" && option && option.opt_group)
    entry.opt_group = option.opt_group;
  if (/^\d+$/.test(entry.id))
    entry.id = Number(entry.id);
  if (/^\d+$/.test(entry.value))
    entry.value = Number(entry.value);
  return entry;
}
function processContactOption(option) {
  const optionObject = typeof option === "string" ? { nombre_completo: option, id: option, name: option } : {
    nombre_completo: option.nombre_completo,
    id: option.id,
    email: option.email,
    name: option.nombre_completo
  };
  return optionObject;
}

// src/js/components/decorators/ErrorResponse.ts
var ErrorResponse = class extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
};

// src/js/components/alpine_definitions/OptionGroups.ts
var optgroups = [
  //{ group: 'otros', id: 'otros', name: 'Otros' },
  {
    group: "fechas_negocio",
    id: "fechas_negocio",
    name: "Fechas Negocio"
  },
  {
    group: "general",
    id: "general",
    name: "General"
  },
  {
    group: "propiedad",
    id: "propiedad",
    name: "Datos Propiedad"
  },
  {
    group: "comercial",
    id: "comercial",
    name: "Info Comercial"
  },
  {
    group: "contacto",
    id: "contacto",
    name: "Contactos Asociados"
  }
];
var defaultSlugs = [
  "id",
  "nombre",
  "tipo_negocio",
  //'id_tipo_negocio',
  "tipo_propiedad",
  //'id_tipo_propiedad',
  "etapa_negocio",
  //'id_etapa_negocio',
  "fecha_creacion",
  "fecha_actualizacion",
  "fecha_creacion_visual",
  "fechaCreacion"
];

// src/js/components/decorators/decorateCampo.ts
function decorateCampo(campo) {
  campo.id_input_type = String(campo.id_input_type);
  const {
    slug_name = "",
    attr_type,
    id_input_type,
    input_type,
    name
  } = campo;
  let { visible, width } = campo;
  if (!slug_name) {
    console.warn({ campo });
    return campo;
  }
  let group = "general";
  if (slug_name === "nombre") {
    group = "general";
  } else if (attr_type === "propiedad_attr" || slug_name.includes("direccion") || attr_type === "propiedad" || slug_name.includes("m2")) {
    group = "propiedad";
  } else if (slug_name.includes("esperada") && slug_name.includes("venta") || slug_name.includes("precio") || slug_name.includes("monto") || slug_name.includes("gasto") || slug_name.includes("contribuciones") || slug_name.includes("credito") || slug_name.includes("pago") || slug_name.includes("abono") || slug_name.includes("uf") || slug_name.includes("costo") || slug_name.includes("valor")) {
    group = "comercial";
  } else if (String(input_type).toLowerCase().includes("date") || ["5" /* INPUT_DATE */, "6" /* INPUT_DATE_TIME */].includes(id_input_type)) {
    group = "fechas_negocio";
  } else if ((attr_type || "").includes("contacto") || (input_type || "").includes("contacto")) {
    group = "contacto";
  }
  let optgroup = optgroups.find((g) => g.id === group);
  if (!optgroup)
    group = "general";
  let editable = true;
  if (campo.readonly) {
    editable = false;
  }
  let black_list = defaultSlugs;
  if (black_list.includes(slug_name)) {
    editable = false;
  }
  const key = [slug_name, attr_type].filter(Boolean).join(",");
  let data2 = campo.slug_name;
  if (campo.id_input_type === "8" /* INPUT_CHECKBOX */) {
    campo.properties = [
      { id: "NOT NULL", name: "Checked" },
      { id: "NULL", name: "Unchecked" }
    ];
  }
  let template_id;
  switch (campo.id_input_type) {
    case "1" /* INPUT_SELECT */:
    case "14" /* INPUT_RADIO_BUTTONGROUP */:
    case "12" /* INPUT_STATIC_PARAMS */:
      if ([
        "id_tipo_negocio",
        "id_tipo_propiedad",
        "id_etapa_negocio"
      ].includes(String(campo.slug_name))) {
        template_id = "#input_main_fields";
      } else {
        template_id = "#input_select";
      }
      break;
    case "10" /* INPUT_CONTACTO_ASOCIADO */:
      template_id = "#input_contacto";
      break;
    case "2" /* INPUT_TEXT */:
    case "4" /* INPUT_TEXT_AREA */:
      template_id = "#input_textarea";
      break;
    case "9" /* INPUT_SELECT_MULTIPLE */:
      template_id = "#input_multiselect";
      break;
    case "8" /* INPUT_CHECKBOX */:
      template_id = "#input_checkbox";
      break;
    case "7" /* INPUT_NUMBER */:
      if (campo.slug_name !== "id") {
        template_id = "#input_number";
      }
      break;
    case "5" /* INPUT_DATE */:
    case "6" /* INPUT_DATE_TIME */:
      if (campo.readonly) {
        template_id = "#input_readonly";
      } else {
        template_id = "#input_dates";
      }
      break;
    default:
      break;
  }
  return {
    ...campo,
    editable,
    data: data2,
    field: data2,
    key,
    group,
    template_id,
    className: [name].join(" "),
    width,
    title: campo.name
  };
}
globalThis.decorateCampo = decorateCampo;

// src/js/components/decorators/staticFetchWrapper.ts
globalThis.readCookie = (name) => {
  return ((document.cookie || "").split("; ").find((row) => row.startsWith(`${name}=`)) || "").split("=")[1];
};
globalThis.setCookie = (name, value, days = 365) => {
  var expires;
  if (days) {
    var date = /* @__PURE__ */ new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
    expires = "; expires=" + date.toGMTString();
  } else {
    expires = "";
  }
  document.cookie = name + "=" + value + expires + "; path=/ ; SameSite=Lax; Secure";
};
function getTokenValue() {
  let tokenMetaValue = document.querySelector('meta[name="csrf"]') && document.querySelector('meta[name="csrf"]').content;
  let jwtMetaValue = document.querySelector('meta[name="jwt"]') && document.querySelector('meta[name="jwt"]').content;
  let tokenElementValue = document.querySelector('[name="_token"]') && document.querySelector('[name="_token"]').value;
  return tokenMetaValue || tokenElementValue;
}
function getJwtValue() {
  return document.querySelector('meta[name="jwt"]') && document.querySelector('meta[name="jwt"]').content;
}
async function staticFetchWrapper(endpoint, options) {
  let tokenValue = getTokenValue();
  const sanctumToken = document.querySelector('meta[name="test_user_token"]');
  if (!tokenValue && !sanctumToken)
    console.warn(endpoint + ": no token found (attempting anyway)");
  if (globalThis.readCookie("debug_lcdj")) {
    globalThis.setCookie("x-csrf-token", document.querySelector('meta[name="csrf"]') && document.querySelector('meta[name="csrf"]').content, 1);
  }
  let headers = {
    "Content-Type": "application/json; charset=UTF-8",
    "charset": "utf-8",
    "expect": "application/json",
    "accept": "application/json",
    ...options.headers
  };
  let jwtValue = getJwtValue();
  if (options.useJwt && jwtValue) {
    headers["Authorization"] = `Bearer ${jwtValue}`;
  } else if (sanctumToken) {
    headers["Authorization"] = `Bearer ${sanctumToken.content}`;
  } else {
    headers["X-CSRF-TOKEN"] = tokenValue;
  }
  let mergedReqInit = {
    method: options.method ?? "GET",
    headers,
    body: options.body
  };
  if (typeof options.body !== "string") {
    mergedReqInit.body = JSON.stringify(options.body);
  }
  return fetch(endpoint, mergedReqInit).then(async (res2) => {
    if (!location.href.includes("public") && !res2.ok) {
      if (res2.status == 401) {
        return location.href = "/logout";
      }
      throw new ErrorResponse(res2.statusText, res2.status);
    }
    return res2.json();
  }).catch((err) => {
    console.error(err);
    throw err;
  });
}

// src/js/components/stores/BaseClass.ts
var BaseClass = class _BaseClass {
  constructor() {
    this.className = "BaseClass";
    this.silent = false;
    this.loglevel = 3 /* INFO */;
    this.timerColor = "color:blue;font-weight:bold";
    this.classNameColor = "color:blue;font-weight:bold;";
    this.onReadyHandlers = [];
    this.eventListeners = {};
  }
  async onReady(handler4) {
    return this.once("ready", handler4);
  }
  /**
   * Handlers declared on an event that is fulfilled should be invoked inmediately
   */
  get verifiers() {
    return {
      "ready": this.ready
    };
  }
  on(event, handler4) {
    this.eventListeners[event] = this.eventListeners[event] || [];
    if (handler4) {
      return this.tap(() => {
        if (typeof handler4 !== "function") {
          this.console.warn("handler is not a function", handler4);
        }
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return handler4(this);
        this.eventListeners[event].push(handler4);
      });
    } else {
      return new Promise((res2) => {
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return res2(this);
        this.eventListeners[event].push(res2);
      });
    }
  }
  once(event, handler4) {
    this.eventListeners[event] = this.eventListeners[event] || [];
    if (handler4) {
      return this.tap(() => {
        if (typeof handler4 !== "function") {
          this.console.warn("handler is not a function", handler4);
        }
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return handler4(this);
        handler4.once = true;
        this.eventListeners[event].push(handler4);
      });
    } else {
      return new Promise((res2) => {
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return res2(this);
        res2.once = true;
        this.eventListeners[event].push(res2);
      });
    }
  }
  processEventListeners(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event] || !this.eventListeners[event].length)
      return;
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    this.eventListeners[event] = otherHandlers;
    if (onceHandlers.length) {
      this.marquee(" firing " + onceHandlers.length + " onceHandlers for " + event + " event ");
      while (onceHandlers.length) {
        let onceHandler = onceHandlers.shift();
        if (typeof onceHandler !== "function")
          continue;
        try {
          requestAnimationFrame(() => onceHandler(callbackArgument));
        } catch (e) {
          console.error("error in onceHandler", e);
        }
      }
    }
    if (otherHandlers.length) {
      this.marquee(" firing " + otherHandlers.length + " regular handlers for " + event + " event ");
      otherHandlers.forEach((cb) => requestAnimationFrame(() => cb(callbackArgument)));
    }
    this.marquee(" done firing " + event + " event ");
  }
  processEventListenersAlt(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event] || !this.eventListeners[event].length)
      return;
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    this.marquee(" firing " + onceHandlers.length + " onceHandlers for " + event + " event ");
    while (onceHandlers.length) {
      let onceHandler = onceHandlers.shift();
      requestAnimationFrame(() => onceHandler(callbackArgument));
    }
    this.marquee(" firing " + otherHandlers.length + " regular handlers for " + event + " event ");
    otherHandlers.forEach((cb) => requestAnimationFrame(() => cb(callbackArgument)));
    this.eventListeners[event] = otherHandlers;
  }
  processHandler(handler4) {
    if (typeof handler4 === "function") {
      handler4(this);
    }
    requestAnimationFrame(() => this.processEventListeners("ready", this));
  }
  marquee(message, ...args) {
    console.marquee({
      [Number(performance.now() / 1e3).toFixed(1)]: this.timerColor,
      [String(this.constructor.name)]: this.classNameColor,
      [message]: ""
      //@ts-ignore
    }, ...args);
  }
  get console() {
    return this.silent ? fakeConsole2 : this._console;
  }
  debug(...arg) {
    this.loglevel >= LogLevels.DEBUG && this.console.debug(...arg);
  }
  log(...arg) {
    this.loglevel >= LogLevels.INFO && this.console.log(...arg);
  }
  error(...arg) {
    this.loglevel >= LogLevels.ERROR && this.console.error(...arg);
  }
  warn(...arg) {
    this.loglevel >= LogLevels.WARN && this.console.warn(...arg);
  }
  info(...arg) {
    this.loglevel >= LogLevels.INFO && this.console.info(...arg);
  }
  init() {
    this.console.log("init");
  }
  get $store() {
    return {
      tipos_busqueda: Alpine.store("tipos_busqueda"),
      columnas_actuales: Alpine.store("columnas_actuales"),
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      roles_negocio: Alpine.store("roles_negocio"),
      active_filter: Alpine.store("active_filter"),
      maps: Alpine.store("maps"),
      user: Alpine.store("user")
    };
  }
  tap(handler4) {
    if (typeof handler4 !== "function") {
      console.warn("handler is not a function", { handler: handler4 });
      return this;
    }
    return tap(this, handler4);
  }
  /**
   * Boilerplate for generic json fetch. Won't work with other content types.
   * @param endpoint 
   * @param options 
   * @returns 
   */
  fetchWrapper(endpoint, options) {
    return _BaseClass.staticFetchWrapper(endpoint, options);
  }
  static staticFetchWrapper(endpoint, options) {
    return staticFetchWrapper(endpoint, options);
  }
};
Object.defineProperty(BaseClass.prototype, "init", { enumerable: true });

// src/js/components/entities/NegocioColumn.ts
var NegocioColumn = class extends DttColumn {
  constructor(options) {
    super(options);
    this.id_input_type = options.id_input_type;
    this.attr_type = options.attr_type;
    this.properties = options.properties;
    if (this.id_input_type === "8" /* INPUT_CHECKBOX */) {
      this.properties = [
        { id: "NOT NULL", name: "Checked" },
        { id: "NULL", name: "Unchecked" }
      ];
    }
    if (this.slug_name === "dias-publicado")
      this.name = "D\xEDas Publicado";
    this.populateOptions();
    this.inferTemplateId();
    this.group = assignGroup(this);
    this.editable = !this.readonly && !defaultSlugs.includes(this.slug_name);
    this.key = [this.slug_name, this.attr_type].filter(Boolean).join(",");
    this.data = this.slug_name;
    this.field = this.slug_name;
    this.folder_slug = options.folder_slug;
  }
  populateOptions() {
    if (this.properties && Array.isArray(this.properties)) {
      this.optionMap = new Map(this.options.map((o) => [o.id, o.name]));
    }
  }
  get options() {
    if (!this.properties || !Array.isArray(this.properties))
      return [];
    return this.id_input_type == "10" /* INPUT_CONTACTO_ASOCIADO */ ? Object.values(this.properties).map(processContactOption) : Object.values(this.properties).map(processOption);
  }
  get componentName() {
    return `inputs.${this.form_component}`;
  }
  get inputName() {
    return null !== this.attr_type ? `${this.attr_type}-${this.slug_name}` : this.slug_name;
  }
  get filesInputName() {
    return this.attachesFiles ? this.inputName + "-files" : null;
  }
  inferTemplateId() {
    switch (this.id_input_type) {
      case "1" /* INPUT_SELECT */:
      case "14" /* INPUT_RADIO_BUTTONGROUP */:
      case "12" /* INPUT_STATIC_PARAMS */:
        if (String(this.slug_name) === "id_etapa_negocio") {
          this.template_id = "#input_etapa_negocio";
        } else if ([
          "id_tipo_negocio",
          "id_tipo_propiedad"
        ].includes(String(this.slug_name))) {
          this.template_id = "#input_main_fields";
        } else {
          this.template_id = "#input_select";
        }
        break;
      case "10" /* INPUT_CONTACTO_ASOCIADO */:
        this.template_id = "#input_contacto";
        break;
      case "2" /* INPUT_TEXT */:
      case "4" /* INPUT_TEXT_AREA */:
        this.template_id = "#input_textarea";
        break;
      case "9" /* INPUT_SELECT_MULTIPLE */:
        this.template_id = "#input_multiselect";
        break;
      case "8" /* INPUT_CHECKBOX */:
        this.template_id = "#input_checkbox";
        break;
      case "7" /* INPUT_NUMBER */:
        if (this.slug_name !== "id") {
          this.template_id = "#input_number";
        }
        break;
      case "5" /* INPUT_DATE */:
      case "6" /* INPUT_DATE_TIME */:
        if (this.readonly) {
          this.template_id = "#input_readonly";
        } else {
          this.template_id = "#input_dates";
        }
        break;
      default:
        break;
    }
  }
  getShownValue(negocio) {
    if (typeof negocio === "number")
      negocio = this.$store.negocios.get(negocio);
    negocio = negocio || { _extra_props: {} };
    let baseline = negocio[this.slug_name] || (negocio._extra_props || {})[this.slug_name] || "";
    if (this.isSelectOrRadioButtonGroup || this.isContact) {
      if (!this.optionMap) {
        console.warn("Campo select sin opciones", this);
        return baseline;
      }
      return this.optionMap.get(negocio[this.slug_name] || "") || this.optionMap.get(String(negocio[this.slug_name]) || "") || this.optionMap.get(Number(negocio[this.slug_name]) || "") || "";
    }
    if (this.isMultiSelectField) {
      let value = negocio[this.slug_name] || [];
      return Array.isArray(value) ? value.map((id) => this.optionMap.get(id) || "").join(", ") : value;
    }
    if (typeof negocio[this.slug_name] === "string") {
      return baseline.replace("[null]", "").replace("null", "");
    }
    return baseline;
  }
  get attachesFiles() {
    return !!this.attach_files;
  }
  get isMultiSelectField() {
    return "9" /* INPUT_SELECT_MULTIPLE */ === String(this.id_input_type);
  }
  get isDateOrDatetimeField() {
    return "5" /* INPUT_DATE */ === String(this.id_input_type) || "6" /* INPUT_DATE_TIME */ === String(this.id_input_type);
  }
  get isTextOrTextArea() {
    return "2" /* INPUT_TEXT */ === String(this.id_input_type) || "4" /* INPUT_TEXT_AREA */ === String(this.id_input_type);
  }
  get isSelectOrRadioButtonGroup() {
    return "12" /* INPUT_STATIC_PARAMS */ === String(this.id_input_type) || "14" /* INPUT_RADIO_BUTTONGROUP */ === String(this.id_input_type) || "1" /* INPUT_SELECT */ === String(this.id_input_type);
  }
  get isCheckbox() {
    return "8" /* INPUT_CHECKBOX */ === String(this.id_input_type);
  }
  get isNumber() {
    return "7" /* INPUT_NUMBER */ === String(this.id_input_type);
  }
  get isContact() {
    return "10" /* INPUT_CONTACTO_ASOCIADO */ === String(this.id_input_type);
  }
};
function assignGroup(column) {
  let { slug_name, attr_type, input_type, id_input_type } = column;
  let group = "general";
  if (slug_name === "nombre") {
    group = "general";
  } else if (attr_type === "propiedad_attr" || slug_name.includes("direccion") || attr_type === "propiedad" || slug_name.includes("m2")) {
    group = "propiedad";
  } else if (slug_name.includes("esperada") && slug_name.includes("venta") || slug_name.includes("precio") || slug_name.includes("monto") || slug_name.includes("gasto") || slug_name.includes("contribuciones") || slug_name.includes("credito") || slug_name.includes("pago") || slug_name.includes("abono") || slug_name.includes("uf") || slug_name.includes("costo") || slug_name.includes("valor")) {
    group = "comercial";
  } else if (String(input_type).toLowerCase().includes("date") || ["5" /* INPUT_DATE */, "6" /* INPUT_DATE_TIME */].includes(id_input_type)) {
    group = "fechas_negocio";
  } else if ((attr_type || "").includes("contacto") || (input_type || "").includes("contacto")) {
    group = "contacto";
  }
  let optgroup = optgroups.find((g) => g.id === group);
  if (!optgroup)
    group = "general";
  return group;
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/js/components/stores/CamposBusquedaStore.ts
var CamposBusquedaStore = class extends BaseClass {
  constructor() {
    super();
    this.className = "CamposBusquedaStore";
    this.silent = false;
    this.loglevel = 4 /* WARN */;
    this.id = v4_default();
    this.properties = [];
    this.fieldMap = /* @__PURE__ */ new Map();
    this.timerColor = "color:blue;font-weight:bold";
    this.classNameColor = "color:purple;font-weight:bold;";
    this.fetching_light_list = false;
    this.ready = false;
    this.classNameColor = "color:purple;font-weight:bold;";
    this._console = bindConsole(this.className, this.classNameColor);
    this.init();
  }
  init() {
    this.marquee(" init ");
    this.lightList = new Promise((res2) => {
    });
  }
  get columnDefs() {
    return this.properties;
  }
  set columnDefs(campos_busqueda) {
    this.properties = campos_busqueda;
  }
  reloadCampos(campos_busqueda, reset = false) {
    if (!campos_busqueda || campos_busqueda.length === 0)
      return;
    if (this.ready)
      return;
    this.properties = Object.values(campos_busqueda).filter((c) => c.slug_name).map((c) => new NegocioColumn(decorateCampo(c))).map((c) => {
      if (defaultSlugs.includes(c.slug_name)) {
        c.readonly = true;
        c.is_default = true;
      }
      this.fieldMap.set(c.slug_name, c);
      return c;
    });
    if (!this.ready) {
      this.ready = true;
      this.marquee(" finished proccesing columnDefs ");
      requestAnimationFrame(() => this.processEventListeners("ready", this));
    }
    return this.properties;
  }
  async fetchLightNegocios() {
    if (this.fetching_light_list)
      return this.lightList;
    this.fetching_light_list = true;
    return staticFetchWrapper("/api/negocios/light_list", {}).then(async (res2) => {
      const jsonRes = tap(await res2, (lightList) => {
        this.find("codigo_interno").properties = Object.values(lightList).filter((option) => option.codigo_interno && String(option.codigo_interno).length === 6).map((option) => {
          return {
            id: option.codigo_interno,
            value: option.codigo_interno,
            label: `${option.codigo_interno}|${option.nombre}`,
            name: `${option.codigo_interno}|${option.nombre}`
          };
        });
        this.find("id").properties = Object.values(lightList).filter((option) => option.id).map((option) => {
          return {
            value: option.id,
            name: `#${option.id}|${option.nombre}`
          };
        });
      });
      return jsonRes.map((row) => {
        let { direccion, propietario } = inferDireccionAndPropietario(row.nombre);
        return { id: row.id, direccion, propietario };
      });
    });
  }
  findMany(cols) {
    return cols.filter((c) => c).map((c) => {
      let col = this.find(c.slug_name || c) || { slug_name: c.slug_name || c, visible: true };
      col.visible = typeof c === "object" ? c.visible ?? true : col.visible;
      return col;
    }).filter((c) => c);
  }
  getMany(ids) {
    return ids.filter((c) => c).map((c) => {
      let col = this.get(c.id || c) || { id: typeof c === "object" ? c.id : c, visible: true };
      col.visible = typeof c === "object" ? c.visible ?? true : col.visible;
      return col;
    }).filter((c) => c);
  }
  computeOptions(campo_busqueda) {
    const campo = this.find(campo_busqueda.split(",")[0]) || { id_input_type: "2" /* INPUT_TEXT */ };
    if (!campo || campo.id_input_type === "1" /* INPUT_SELECT */ && campo.properties === null) {
      console.warn("Campo select sin opciones", campo);
      return [];
    }
    return campo.options;
  }
  getShownValue(negocio, slug_name) {
    const item = this.find(slug_name);
    if (typeof negocio === "number")
      negocio = this.$store.negocios.get(negocio);
    if (item)
      return item.getShownValue(negocio);
    negocio = negocio || {};
    let baseline = negocio[slug_name] || "";
    if (negocio._extra_props) {
      baseline = (negocio[slug_name] ?? negocio._extra_props[slug_name]) || "";
    }
    if (!item) {
      return baseline;
    }
    if (this.isSelectOrRadioButtonGroup(item.id_input_type) || this.isContact(item.id_input_type)) {
      if (!item.optionMap) {
        console.warn("Campo select sin opciones", item);
        return baseline;
      }
      return item.optionMap.get(baseline || "") || item.optionMap.get(baseline || "") || "";
    }
    if (this.isMultiSelectField(item.id_input_type)) {
      let value = negocio[slug_name] || [];
      return Array.isArray(value) ? value.map((id) => item.optionMap.get(id) || "").join(", ") : value;
    }
    if (typeof baseline === "string") {
      return baseline.replace("[null]", "");
    }
    return baseline;
  }
  /**
   * Slug name should be only the clean nombre of the field,
   * but this method cleans the postfix in case it was passed a
   * filter campo de busqueda
   * 
   * @param {string} slug_name 
   * @returns 
   */
  find(slug_name) {
    let exact_match = this.fieldMap.get(slug_name.replace(/^([^,]+),?.*$/, "$1"));
    if (exact_match)
      return exact_match;
    if (slug_name.endsWith("*"))
      return this.properties.find((prop) => prop.slug_name.startsWith(slug_name.replace("*", "")));
    if (slug_name.startsWith("*"))
      return this.properties.find((prop) => prop.slug_name.endsWith(slug_name.replace("*", "")));
    return this.properties.find((prop) => prop.slug_name.includes(slug_name.replaceAll("*", "")));
  }
  has(slug_name) {
    return this.fieldMap.has(slug_name);
  }
  get(id) {
    return this.properties.find((c) => c.id == id);
  }
  get contactos_asociados_fields() {
    return Object.values(this.properties).filter(
      (c) => [
        "10" /* INPUT_CONTACTO_ASOCIADO */
      ].includes(c.id_input_type)
    ).filter(
      (field) => field.group === "contacto"
    );
  }
  get slugs_no_seleccionables() {
    return this.no_seleccionables.map((c) => c.slug_name);
  }
  get columnas_seleccionables() {
    return Object.values(this.properties).filter(
      (campo) => !this.slugs_no_seleccionables.includes(campo.slug_name)
    );
  }
  get all_selectable_fields() {
    return Object.values(this.properties).filter((c) => [
      "1" /* INPUT_SELECT */,
      "2" /* INPUT_TEXT */,
      "4" /* INPUT_TEXT_AREA */,
      "7" /* INPUT_NUMBER */,
      "14" /* INPUT_RADIO_BUTTONGROUP */,
      "12" /* INPUT_STATIC_PARAMS */,
      "8" /* INPUT_CHECKBOX */,
      "12" /* INPUT_STATIC_PARAMS */,
      "5" /* INPUT_DATE */,
      "6" /* INPUT_DATE_TIME */,
      "9" /* INPUT_SELECT_MULTIPLE */
    ].includes(c.id_input_type)).concat(this.contactos_asociados_fields);
  }
  isMultiSelectField(id_input_type) {
    return "9" /* INPUT_SELECT_MULTIPLE */ === String(id_input_type);
  }
  isDateOrDatetimeField(id_input_type) {
    return "5" /* INPUT_DATE */ === String(id_input_type) || "6" /* INPUT_DATE_TIME */ === String(id_input_type);
  }
  isTextOrTextArea(id_input_type) {
    return "2" /* INPUT_TEXT */ === String(id_input_type) || "4" /* INPUT_TEXT_AREA */ === String(id_input_type);
  }
  isSelectOrRadioButtonGroup(id_input_type) {
    return "12" /* INPUT_STATIC_PARAMS */ === String(id_input_type) || "14" /* INPUT_RADIO_BUTTONGROUP */ === String(id_input_type) || "1" /* INPUT_SELECT */ === String(id_input_type);
  }
  isCheckbox(id_input_type) {
    return "8" /* INPUT_CHECKBOX */ === String(id_input_type);
  }
  isNumber(id_input_type) {
    return "7" /* INPUT_NUMBER */ === String(id_input_type);
  }
  isContact(id_input_type) {
    return "10" /* INPUT_CONTACTO_ASOCIADO */ === String(id_input_type);
  }
  get optgroups() {
    return optgroups;
  }
  get no_seleccionables() {
    return this.properties.filter((c) => [
      "nombre",
      "id_tipo_negocio",
      "id_tipo_propiedad",
      "id_etapa_negocio",
      "fecha_creacion",
      "fechaCreacion",
      "fecha_creacion_visual"
    ].concat(this.defaultSlugs).includes(c.slug_name));
  }
  get defaultSlugs() {
    return defaultSlugs;
  }
  printTable(ids) {
    ids = ids.map((id) => id.id || id);
    console.log("buscando", ids.toString());
    let campos = ids.map((id) => this.get(id));
    console.table(campos, ["id", "slug_name", "visible"]);
  }
  /**
   * @todo why stringify and parse?
   */
  get readOnly() {
    return JSON.parse(JSON.stringify(Object.values(this.properties))).filter((c) => c.readonly).map((c) => c.slug_name).concat(this.defaultSlugs);
  }
};
Object.defineProperty(CamposBusquedaStore.prototype, "init", { enumerable: true });

// src/js/components/stores/ColumnasActualesStore.ts
var ColumnasActualesStore = class extends CamposBusquedaStore {
  constructor() {
    super();
    this.className = "ColumnasActualesStore";
    this.id = v4_default();
    this.timerColor = "color:emerald;font-weight:bold";
    this.classNameColor = "color:darkcyan;font-weight:bold;";
    this.ready = false;
    this.classNameColor = "color:darkcyan;font-weight:bold;";
    this.timerColor = "color:emerald;font-weight:bold;";
    this._console = bindConsole(this.className, this.classNameColor);
    this.previouslyInvisible = ["id", "fecha_creacion_visual", "fechaCreacion"];
  }
  init() {
    this.marquee(" init store " + this.classNameColor);
  }
  get columnDefs() {
    return this.properties;
  }
  set columnDefs(campos_busqueda) {
    this.properties = campos_busqueda;
  }
  async setDefaultColumns(default_columns) {
    this.default_columns = Array.from(new Set(default_columns));
    return this;
  }
  get active_filter() {
    return Alpine.store("active_filter");
  }
  get columnVisibility() {
    return this.columnDefs.reduce((acc, col) => {
      acc[col.slug_name] = !!col.visible;
      return acc;
    }, {});
  }
  get sortedColumnDefs() {
    return this.columnDefs.slice(0).sort((a, b) => Number(a.position ?? 19) - Number(b.position ?? 19));
  }
  reloadCampos(columnas_visibles, reset = false) {
    if (columnas_visibles.length === 0)
      return this.columnDefs;
    this.columnas_visibles = Array.from(new Set(columnas_visibles.filter((c) => !defaultSlugs.includes(c.slug_name))));
    let visible_slugs = this.columnas_visibles.map((c) => c.slug_name), default_slugs = this.default_columns.map((c) => c.slug_name);
    let properties = this.$store.campos_busqueda.findMany(Array.from(new Set(default_slugs.filter((c) => !visible_slugs.includes(c)).concat(visible_slugs))));
    this.properties = (this.default_columns || []).filter((c) => !visible_slugs.includes(c.slug_name)).map((c, index) => {
      c.is_default = true;
      c.position = index;
      if (["created_at", "fechaCreacion", "fecha_creacion_visual"].includes(c.slug_name))
        c.position = 3 + index;
      return c;
    }).concat(
      this.columnas_visibles.map((c, index) => {
        c.position = index + this.default_columns.length;
        return c;
      })
    ).sort((a, b) => {
      return a.position - b.position;
    });
    this.properties = this.properties.map((col, index) => {
      let dttCol = this.campos_busqueda.find(col.slug_name) ?? new NegocioColumn(decorateCampo(col));
      if (default_slugs.includes(dttCol.slug_name))
        dttCol.is_default = true;
      if (col.visible !== void 0) {
        if (["created_at", "fechaCreacion", "fecha_creacion_visual"].includes(dttCol.slug_name))
          col.visible = false;
        dttCol.visible = col.visible;
      }
      if (!this.active_filter || !this.active_filter.columnas_actuales)
        return dttCol;
      let colFiltro = this.active_filter.columnas_actuales.find((c) => c.id == dttCol.id);
      if (colFiltro) {
        dttCol.visible = colFiltro.visible;
      }
      if (["created_at", "fechaCreacion", "fecha_creacion_visual"].includes(dttCol.slug_name))
        dttCol.visible = false;
      return dttCol;
    });
    this.properties.sort((a, b) => {
      return a.position - b.position;
    });
    if (!reset)
      this.properties.forEach((c) => {
        c.visible = !this.previouslyInvisible.includes(c.slug_name);
        let col = this.campos_busqueda.find(c.slug_name);
        if (col)
          col.visible = c.visible;
        if (["created_at", "fechaCreacion", "fecha_creacion_visual"].includes(c.slug_name))
          c.visible = false;
      });
    if (!this.ready) {
      this.ready = true;
      this.once("ready", () => {
        this.syncWithActiveFilter();
        this.marquee(" Finished processings columnas_visibles definition ");
      });
      this.processEventListeners("ready", this);
    } else {
      this.processEventListeners("columns_updated", this);
    }
    return this.properties;
  }
  get visible_slugs() {
    return this.columnDefs.filter((c) => c.visible).map((c) => c.slug_name);
  }
  /**
   * @todo since ActiveFilterStore is actually empty the first time this method is called, 
   * perhaps the synchronization should happen in the other direction
   */
  syncWithActiveFilter() {
    Promise.all([
      this.once("ready"),
      this.active_filter.once("ready")
    ]).then(() => {
      this.properties = (this.properties || []).map((col) => {
        if (!this.active_filter || !this.active_filter.columnas_actuales)
          return col;
        let colFiltro = this.active_filter.columnas_actuales.find((c) => c.id == col.id);
        if (colFiltro) {
          col.visible = colFiltro.visible;
        }
        if (["created_at", "fechaCreacion", "fecha_creacion_visual"].includes(col.slug_name))
          col.visible = false;
        return col;
      });
      this.processEventListeners("columns_updated", this);
    });
  }
  get campos_busqueda() {
    return Alpine.store("campos_busqueda");
  }
  get defaultSlugs() {
    return this.default_columns.map((c) => c.slug_name).concat(defaultSlugs);
  }
  get campos_del_filtro() {
    const discard_default_slugs = this.default_columns.map((c) => c.slug_name);
    return this.columnDefs.filter((item) => !discard_default_slugs.includes(item.slug_name));
  }
  setAllFieldsOn(except = ["id"]) {
    this.properties.filter((c) => !except.includes(c.slug_name)).forEach((c) => c.visible = true);
  }
  setAllFieldsOff() {
    this.properties.forEach((c) => c.visible = false);
  }
  printTable() {
    console.table(this.properties, ["id", "slug_name", "position", "visible", "editable", "is_default"]);
  }
  refreshInvisibles() {
    this.previouslyInvisible = this.properties.filter((c) => !c.visible).map((c) => c.slug_name);
    return this;
  }
  /**
   * @returns {Array<string>} the list of slugs for the current set of columns
   */
  get currentSlugs() {
    return [...(this.columnDefs || []).map((c) => c.slug_name)];
  }
  isDefaultField(slug_name) {
    return this.defaultSlugs.includes(slug_name);
  }
  /**
   * Non default columns as provided by the backend
   */
  get column_groups() {
    return Alpine.store("campos_busqueda").optgroups.map((group) => {
      return {
        ...group,
        group_options: this.columnDefs.filter((p) => p.group === group.id)
      };
    });
  }
  isVisible(slug_name) {
    let property = this.find(slug_name) || { visible: void 0 };
    return property.visible;
  }
  /**
  * Slug name should be only the clean nombre of the field,
  * but this method cleans the postfix in case it was passed a
  * filter campo de busqueda
  * 
  * @param {string} slug_name 
  * @returns 
  */
  find(slug_name) {
    slug_name = slug_name.replace(/^([^,]+),?.*$/, "$1");
    return this.columnDefs.find((c) => c.slug_name === slug_name) || {};
  }
  get(id) {
    return this.columnDefs.find((c) => c.id == id);
  }
  has(slug_name) {
    return this.columnDefs.find((c) => c.slug_name === slug_name) !== void 0;
  }
  toggle(slug_name) {
    let current_column = this.find(slug_name);
    current_column.visible = !current_column.visible;
    let col = this.campos_busqueda.find(slug_name);
    col.visible = current_column.visible;
  }
  at(index = 0) {
    return this.columnDefs[index];
  }
  get columnIds() {
    return this.columnDefs.map((c) => c.id);
  }
  async moveColumn(oldIndex, newIndex) {
    this.refreshInvisibles();
    this.columnDefs.forEach((c) => c.visible = false);
    let moved = this.columnDefs.splice(oldIndex, 1)[0];
    console.info(
      `%c se ha movido %c${moved.slug_name} %c hasta despu\xE9s de %c ${(this.columnDefs[newIndex - 1] || { name: "el final" }).slug_name}`,
      "",
      "color:#336699;background-color:#fff;font-weight:bold;",
      "",
      `color:#0a0;font-weight:bold;`
    );
    waitFor2(100);
    this.columnDefs.splice(newIndex, 0, moved);
    this.columnDefs.forEach((c) => {
      c.visible = !this.previouslyInvisible.includes(c.slug_name);
    });
  }
  /**
   * Fields admisible to be shown in the map view info window
   */
  get featureProperties() {
    return this.columnDefs.filter(
      (c) => c.id_input_type !== "8" /* INPUT_CHECKBOX */ && c.id_input_type !== "9" /* INPUT_SELECT_MULTIPLE */
    ).reduce((accum, campo) => {
      accum[campo.slug_name.replace(
        "fecha_creacion_visual",
        "created_at"
      )] = (campo.name || "").replace(/^F\.\s/, "Fecha ");
      return accum;
    }, {});
  }
};
function columnas_actuales() {
  return new ColumnasActualesStore();
}

// src/js/components/entities/DummyNegocio.ts
var DummyNegocio = class extends BaseClass {
  constructor(negocio, slugs = []) {
    super();
    this.className = "DummyNegocio";
    this.savingPromise = null;
    this.initial = /* @__PURE__ */ new Map();
    this.savingMessage = "";
    this.slugs = slugs || Object.keys(negocio);
    this.id = negocio.id;
    this.tipo_negocio = negocio.tipo_negocio;
    this.tipo_propiedad = negocio.tipo_propiedad;
    this.etapa_negocio = negocio.etapa_negocio;
    this.id_tipo_negocio = negocio.id_tipo_negocio;
    this.id_tipo_propiedad = negocio.id_tipo_propiedad;
    this.id_etapa_negocio = negocio.id_etapa_negocio;
    this.searchstring = negocio.searchstring;
    this.thumbnail = negocio.thumbnail;
    this.timestamp = Number(new Date(negocio.timestamp).getTime() / 1e3).toFixed(0);
    this.fecha_creacion_visual = String(negocio.fecha_creacion_visual ?? (this.fechaCreacion ?? (negocio.created_at ?? (negocio._extra_props || {}).created_at)));
    this.fecha_creacion_visual = this.fechaCreacion = this.fecha_creacion = this.created_at = this.fecha_creacion_visual.replace(/(\d{4})-(\d{2})-(\d{2})/, "$3-$2-$1");
    let { propietario, direccion } = inferDireccionAndPropietario(negocio.nombre);
    this.propietario = propietario;
    this.address = direccion;
    this._negocio = negocio;
    this.controls = /* @__PURE__ */ new Map();
    let negocioNormalized = negocio;
    if (slugs) {
      negocioNormalized = slugs ? slugs.reduce((accum, slug_name) => {
        accum[slug_name] = negocio[slug_name];
        this[slug_name] = negocio[slug_name];
        return accum;
      }, {}) : negocio;
    }
    this.initial = new Map(Object.entries(negocioNormalized));
    this._extra_props = Object.keys(negocio).filter((key) => !Object.keys(negocioNormalized).includes(key)).reduce((accum, key) => {
      accum[key] = negocio[key];
      return accum;
    }, {});
  }
  populateFromAddress() {
    this.direccion = this.direccion || this.address;
  }
  match(criteria) {
    return Object.entries(criteria).every(([key, value]) => {
      return this[key] === value;
    });
  }
  get(slug_name) {
    return this[slug_name];
  }
  getWithExtra(slug_name) {
    return this[slug_name] || this._extra_props[slug_name];
  }
  get changes() {
    let dirty = {};
    for (let [slug_name, value] of this.initial) {
      let current = typeof this[slug_name] === "string" && String(this[slug_name]).trim() === "" ? null : this[slug_name];
      if (value != current) {
        dirty[slug_name] = this[slug_name];
      }
    }
    return dirty;
  }
  printChanges() {
    let changes = [];
    for (let [slug_name, value] of this.initial) {
      let current = typeof this[slug_name] === "string" && String(this[slug_name]).trim() === "" ? null : this[slug_name];
      if (value != current) {
        changes.push({ slug_name, initial: value, current });
      }
    }
    console.table(changes);
  }
  get saveable_properties() {
    let { nombre, id, fechaCreacion, lat, lng, id_etapa_negocio, fecha_creacion_visual, ...properties } = this.slugs.reduce((accum, slug) => {
      accum[slug] = this[slug];
      return accum;
    }, {});
    return properties;
  }
  get editable_inputs() {
    return this.$store.columnas_actuales.columnDefs.filter((c) => c.editable && Object.keys(this.saveable_properties).includes(c.slug_name));
  }
  get negocio() {
    return this;
  }
  set negocio(value) {
    console.log("set negocio", value);
    throw new Error("No se puede modificar el negocio");
  }
  toJSON() {
    return this.negocio;
  }
  shown_value(slug_name) {
    return this.$store.campos_busqueda.getShownValue(this, slug_name);
  }
  set(slug_name, value, verbose = true) {
    if (verbose) {
      console.trace("Setting", slug_name, "to", value);
    } else {
      console.log("Setting", slug_name, "to", value);
    }
    this[slug_name] = value;
    return this;
  }
  init() {
  }
  toFeature() {
    throw new Error("not implemented");
  }
  async validateInputs({ property }) {
    let currentValue = this[property];
    let campo = this.$store.columnas_actuales.find(property);
    if (!campo)
      return Promise.reject(new Error("no se encontr\xF3 el campo:" + property));
    let canBeEdited = campo.editable || this.$store.columnas_actuales.isContact(campo.id_input_type) && currentValue === null;
    if (!canBeEdited) {
      console.warn(campo);
      return Promise.reject(new Error("Propiedad no editable: " + property));
    }
    let prefixed_property = [campo.attr_type, property].join(".");
    return { prefixed_property };
  }
  async setProperty(property, value) {
    throw new Error("not implemented");
  }
  syncInitialValues() {
    return this.$store.columnas_actuales.columnDefs.filter((c) => c.editable && !c.readonly && Object.keys(this.saveable_properties).includes(c.slug_name)).map((c) => c.slug_name).reduce((accum, slug_name) => {
      let property_sample = this.$store.negocios.checked.map((n) => n[slug_name]);
      let property_set = new Set(property_sample);
      if (property_set.size === 1) {
        accum[slug_name] = property_sample[0];
        this.set(slug_name, property_sample[0], false);
        this.initial.set(slug_name, property_sample[0]);
      } else {
        this.set(slug_name, null, false);
        this.initial.set(slug_name, null);
      }
      return accum;
    }, {});
  }
  get modalTitle() {
    return this.savingMessage ? this.savingMessage : `Editando ${this.$store.negocios.checked.length} negocios`;
  }
  async save(mock = false) {
    if (Object.keys(this.changes).length === 0 && !mock) {
      console.log("no hay cambios");
      return;
    }
    if (this.changes.id_etapa_negocio)
      return globalThis.cambio_etapa_check({ id: this.id, id_etapa_negocio: this.changes.id_etapa_negocio });
    let changes = await Object.entries(this.changes).reduce(async (accum, [property, value]) => {
      accum = await accum;
      let campo = this.$store.columnas_actuales.find(property);
      if (!campo)
        return accum;
      let prefixed_property = [campo.attr_type, property].join(".");
      accum[prefixed_property] = value;
      return accum;
    }, {});
    console.zinfo("changes", changes);
    let totalChecked = this.$store.negocios.checked.length, saved = 0;
    for (let negocio of this.$store.negocios.checked) {
      Object.entries(this.changes).forEach(([property, value]) => {
        if (/^\d+$/.test(String(value)))
          value = Number(value);
        negocio[property] = value;
        console.log("set", property, value);
      });
      await waitFor2(1e3);
      this.savingMessage = `Guardando negocio ${saved++} de ${totalChecked}`;
      console.log(this.savingMessage, this.modalTitle);
      await negocio.save().catch((err) => {
        console.warn(err);
      }).finally(() => {
        negocio.checked = false;
      });
    }
    this.savingMessage = "";
    Object.entries(this.changes).forEach(([property, value]) => {
      this[property] = this.initial[property];
    });
    return;
  }
};

// src/js/components/entities/Negocio.ts
var Negocio = class extends DummyNegocio {
  constructor(negocio, slugs = []) {
    super(negocio, slugs);
    this.className = "Negocio";
    this.savingPromise = null;
    this.initial = /* @__PURE__ */ new Map();
    this._checked = false;
    let negocioNormalized = negocio;
    if (slugs) {
      negocioNormalized = slugs ? slugs.reduce((accum, slug_name) => {
        accum[slug_name] = negocio[slug_name];
        this[slug_name] = negocio[slug_name];
        return accum;
      }, {}) : negocio;
      this.searchstring = this.computeSearchString(negocioNormalized);
    }
    if (this._extra_props.created_at) {
      negocioNormalized.created_at = negocioNormalized.fechaCreacion = negocioNormalized.fecha_creacion_visual = String(this._extra_props.created_at).replace(/(\d{4})-(\d{2})-(\d{2})/, "$3-$2-$1");
    }
    this.initial = new Map(Object.entries(negocioNormalized));
  }
  get checked() {
    return this._checked;
  }
  set checked(checked) {
    if (checked === this._checked)
      return;
    this._checked = checked;
    if (!checked)
      globalThis.alpineBsTable.bsTable.bootstrapTable("uncheckBy", {
        field: "id",
        values: [this.id]
      });
  }
  computeSearchString(negocioNormalized) {
    return this.slugs.reduce(
      (accum, slug) => accum + " " + Alpine.store("campos_busqueda").getShownValue(negocioNormalized, slug),
      ""
    ).normalize("NFD").replace(/\n+/, " ").replace(/\s+/g, " ").replace(/\p{Diacritic}/gu, "").toLowerCase();
  }
  get latitud() {
    return this.lat || this._extra_props.lat;
  }
  get longitud() {
    return this.lng || this._extra_props.lng;
  }
  toFeature() {
    const merged_props = { ...this, ...this._extra_props };
    let {
      //searchstring,
      nombre,
      id,
      ...props
    } = merged_props;
    let geometry = {
      type: "Point",
      coordinates: [this.longitud, this.latitud]
    };
    let propertyKeys = Object.keys(
      this.$store.columnas_actuales.featureProperties
    ).concat([
      "nombre",
      "comuna",
      "seudonimo-propiedad",
      "link-img-portada-wordpress"
    ]);
    let properties = Object.entries(props).filter(([slug_name, value]) => {
      return true;
    }).reduce((accum, [slug_name, value]) => {
      accum[slug_name] = this.$store.campos_busqueda.getShownValue(
        this,
        slug_name
      );
      return accum;
    }, {});
    return {
      type: "Feature",
      id,
      properties,
      geometry
    };
  }
  async getBarrio() {
    if (!this.latitud || !this.longitud)
      return Promise.reject(new Error("No hay coordenadas"));
    await fetch(`https://workers.lacasadejuana.cl/geo/coords/${this.longitud}/${this.latitud}`);
  }
  get token() {
    return document.querySelector('[name="_token"]').value;
  }
  async setProperty(property, value) {
    return this.validateInputs({ property }).then(({ prefixed_property }) => {
      console.log({
        property,
        from: this[property],
        to: value
      });
      if (property === "id_etapa_negocio") {
        this.set("id_etapa_negocio", this.initial.get("id_etapa_negocio"));
        return globalThis.cambio_etapa_check({
          id: this.id,
          id_etapa_negocio: value
        });
      }
      if (!this.savingPromise) {
        this.savingPromise = globalThis.patchNegocio(
          {
            id: this.id,
            [prefixed_property]: value
          },
          true
        );
      }
      if (this[property] === value) {
        this.savingPromise = null;
        return true;
      }
      return this.savingPromise.then((result) => {
        if (!result)
          return false;
        openToast({
          type: "success",
          text: "Se ha actualizado el campo " + property,
          description: "en el Negocio " + this.id,
          delay: 2e3
        });
        this[property] = value;
        this.savingPromise = null;
        return true;
      });
    }).catch((err) => {
      openToast({
        type: "error",
        text: "No se pudo actualizar el negocio " + this.id,
        description: err.message,
        delay: 2e3
      });
      this.savingPromise = null;
      return false;
    });
  }
  /**
   * There's no campo_busqueda for "region" but this method handles it in case it's needed in the future
   * @param param0 
   * @returns 
   */
  async saveAddress({
    lat,
    lng,
    direccion,
    comuna,
    region,
    barrio
  }) {
    let changes = await Object.entries({ lat, lng, direccion, comuna, barrio }).reduce(
      async (accum, [property, value]) => {
        accum = await accum;
        let campo = this.$store.campos_busqueda.find(
          property
        );
        if (!campo)
          return accum;
        let prefixed_property = [campo.attr_type, property].join(".");
        accum[prefixed_property] = value;
        return accum;
      },
      {}
    );
    console.log(changes);
    if (!this.savingPromise) {
      this.savingPromise = globalThis.patchNegocio(
        {
          id: this.id,
          ...changes
        },
        true
      );
    }
    return this.savingPromise.then((result) => {
      if (!result)
        return false;
      openToast({
        type: "success",
        text: `Se actualiz\xF3 el negocio ${this.id}`,
        description: "(direcci\xF3n, comuna y coordenadas)",
        delay: 2e3
      });
      Object.entries({ lat, lng, direccion, comuna }).forEach(([property, value]) => {
        this[property] = value;
        this.initial.set(property, value);
      });
      this.savingPromise = null;
      return true;
    }).catch((err) => {
      openToast({
        type: "error",
        text: "No se pudo actualizar el negocio " + this.id,
        description: err.message,
        delay: 2e3
      });
      this.savingPromise = null;
      return false;
    });
  }
  async save() {
    if (Object.keys(this.changes).length === 0) {
      console.log("Negocio " + this.id + ": no hay cambios");
      return;
    }
    if (this.changes.id_etapa_negocio)
      return globalThis.cambio_etapa_check({
        id: this.id,
        //@ts-ignore
        id_etapa_negocio: this.changes.id_etapa_negocio
      });
    let changes = await Object.entries(this.changes).reduce(
      async (accum, [property, value]) => {
        accum = await accum;
        let campo = this.$store.columnas_actuales.find(
          property
        );
        if (["id_tipo_negocio", "id_tipo_propiedad"].includes(
          campo.slug_name
        ) && this.id_etapa_negocio >= 3)
          return accum;
        if (!campo)
          return accum;
        let prefixed_property = [campo.attr_type, property].join(".");
        accum[prefixed_property] = value;
        return accum;
      },
      {}
    );
    console.log(changes);
    if (!this.savingPromise) {
      this.savingPromise = globalThis.patchNegocio(
        {
          id: this.id,
          ...changes
        },
        true
      );
    }
    return this.savingPromise.then((result) => {
      if (!result)
        return false;
      openToast({
        type: "success",
        text: `Se actualiz\xF3 el negocio ${this.id}`,
        delay: 2e3
      });
      Object.entries(this.changes).forEach(([property, value]) => {
        this[property] = value;
        this.initial.set(property, value);
      });
      this.savingPromise = null;
      return true;
    }).catch((err) => {
      openToast({
        type: "error",
        text: "No se pudo actualizar el negocio " + this.id,
        description: err.message,
        delay: 2e3
      });
      this.savingPromise = null;
      return false;
    });
  }
  submitContacto(slug_name, id_persona) {
    let id_negocio = this.negocio.id;
    let campo = this.$store.columnas_actuales.find(
      slug_name
    );
    if (!campo)
      return Promise.reject(
        new Error("No se encontr\xF3 el campo: " + slug_name)
      );
    let id_rol_negocio = campo.id_rol_negocio;
    if (!id_rol_negocio)
      return Promise.reject(
        new Error(
          "No se encontr\xF3 el rol negocio del campo " + slug_name
        )
      );
    const nombreRol = ifDefined(this.$store.roles_negocio, (rolesStore) => rolesStore.get(Number(id_rol_negocio)).name);
    console.info({ id_negocio, id_persona, id_rol_negocio });
    return fetch(location.origin + "/negocio/nuevoContacto/" + this.id, {
      method: "POST",
      headers: {
        "X-CSRF-TOKEN": this.token,
        accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        id_negocio,
        buscador_persona: id_persona,
        id_rol_negocio
      })
    }).then((res2) => res2.json()).then((res2) => {
      return tap(
        res2,
        (res3) => openToast({
          type: res3.type || "warning",
          text: "Se modific\xF3 un contacto del negocio " + this.id,
          from: "submitContacto",
          description: "rol " + nombreRol,
          delay: 2e3
        })
      );
    });
  }
};

// src/js/components/stores/NegocioStore.ts
var NegocioStore = class extends BaseClass {
  constructor() {
    super();
    this.className = "NegocioStore";
    this.model = null;
    this.total = 0;
    this.state = {
      from: 0,
      to: 0,
      total: 0
    };
    this.per_page = 0;
    this.last_page = 0;
    this.current_page = 1;
    this.properties = [];
    this.activeFilterIcon = "fa fa-filter";
    this.ready = false;
    this.complete = false;
    this.limit = null;
    this.dummy = null;
    this.next_page_url = location.origin + "/api/negocios";
    this.urlInstance = new URL(location.href);
    this.apiSortBy = "created_at";
    this.timerColor = "color:cobalt;font-weight:bold";
    this.classNameColor = "color:cobalt;font-weight:bold;";
    this.fetchPromises = {};
    this.fetchResults = {};
    this.abortController = null;
    this.buffer = [];
    this.ready = false;
    this.complete = false;
    this.classNameColor = "color:cobalt;font-weight:bold;";
    this._console = bindConsole(this.className, this.classNameColor);
    this.init();
  }
  get deals_with_coordinates() {
    return this.data.filter((n) => n.lat && n.lng || n._extra_props.lat && n._extra_props.lng);
  }
  init() {
    this.marquee(" init ");
  }
  async fetchAll(page = 0) {
    return this.next().then((res2) => {
      if (this.next_page_url || this.complete === false)
        return this.fetchAll();
      this.processEventListeners("complete", this.properties);
      return this.properties;
    });
  }
  setOptions({
    per_page,
    total,
    last_page,
    request_id,
    next_page_url
  }) {
    this.per_page = per_page;
    this.total = total;
    this.last_page = last_page;
    this.request_id = request_id;
    this.next_page_url = next_page_url;
    return this;
  }
  openModalEdition() {
    this.dummy.syncInitialValues();
    this.model = this.dummy;
  }
  get to() {
    return this.properties[this.properties.length - 1] || 5e5;
  }
  stopFetching(cb) {
    this.ready = true;
    this.next_page_url = null;
    this.complete = true;
    cb && cb([]);
    this.marquee("processing onComplete handlers ");
    this.processEventListeners("complete", this.properties);
    this.$store.active_filter.clearLoading(2500);
    return [];
  }
  async restart() {
    let total = this.$store.active_filter.estimate;
    this.next_page_url = location.origin + `/maps/api/negocios?from=${Number(Date.now() / 1e3).toFixed(0)}&total=${total}&limit=5000`;
    this.complete = false;
    this.ready = true;
    this.properties = [];
    return this.fetchAll();
  }
  async next(page = 1, cb) {
    if (!globalThis.backendPaginator || globalThis.backendPaginator.total === void 0 || globalThis.logging_out) {
      return this.stopFetching(cb);
    }
    if (!this.next_page_url) {
      this.stopFetching(cb);
      return this.properties;
    }
    let token = document.querySelector('meta[name="csrf"]') && document.querySelector('meta[name="csrf"]').content;
    const next_page_url = this.next_page_url;
    if (this.fetchPromises[next_page_url])
      return this.fetchPromises[next_page_url];
    this.marquee(`dataLength: ${this.data.length} fetching ${this.next_page_url}`);
    let url = new URL(next_page_url);
    url.searchParams.set("total", String(this.total));
    url.searchParams.set("limit", "500");
    let current_progress = this.properties.length / (this.total ?? 50);
    this.$store.active_filter.setLoading(this.properties.length < 100 ? 30 : current_progress, "Cargando negocios");
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    this.fetchPromises[this.next_page_url] = fetch(url.toString(), {
      signal,
      headers: {
        "Content-Type": "application/json",
        expect: "application/json",
        "X-CSRF-TOKEN": token
      }
    }).then(async (res2) => {
      if (!res2.ok) {
        return this.stopFetching(cb);
      }
      const data2 = await this.processResult(res2, next_page_url);
      if (data2.length === 0) {
        return this.stopFetching(cb);
      }
      cb && cb(data2);
      this.ready = true;
      return this.data.length === 0 ? this.reload(data2) : this.append(data2);
    }).catch((err) => {
      return this.stopFetching(cb);
    });
    return this.fetchPromises[this.next_page_url];
  }
  get data() {
    return this.properties;
  }
  normalizeNegocio(row, slug_names) {
    row.fecha_creacion_visual = new Date(row.created_at).toLocaleDateString("es-CL");
    row.fechaCreacion = new Date(row.created_at).toLocaleDateString("es-CL");
    return new Negocio(row, this.$store.columnas_actuales.currentSlugs);
  }
  async recreateNegocios() {
    this.$store.active_filter.setLoading(
      1 / 3,
      "Regenerando negocios"
    );
    let currentSlugs = Array.from(new Set(module_default8.raw(this.$store.columnas_actuales.currentSlugs.concat(this.$store.active_filter.currentSlugs))));
    this.properties.forEach((row) => {
      Object.entries({
        ...Object.fromEntries(row.initial),
        ...row._extra_props
      }).filter(([key]) => currentSlugs.includes(key)).forEach(([key, value]) => {
        row.initial.set(key, value);
      });
    });
    return this.processEventListeners("complete", this.properties);
  }
  append(rows) {
    return new Promise((res2) => {
      return this.$store.active_filter.once("ready").then(() => {
        this.$store.active_filter.setLoading(
          1 / 3,
          "Cargando negocios"
        );
        let currentSlugs = Array.from(new Set(module_default8.raw(this.$store.columnas_actuales.currentSlugs.concat(this.$store.active_filter.currentSlugs))));
        let newRows = Object.values(rows).filter((r) => !this.ids.includes(r.id));
        let newRowsNormalized = newRows.map((row) => this.normalizeNegocio(row, currentSlugs));
        this.properties = this.properties.concat(newRowsNormalized);
        res2(newRowsNormalized);
      });
    });
  }
  reload(rows) {
    return new Promise((res2) => {
      return this.$store.active_filter.once("ready").then(() => {
        let currentSlugs = Array.from(new Set(module_default8.raw(this.$store.columnas_actuales.currentSlugs.concat(this.$store.active_filter.currentSlugs))));
        this.$store.active_filter.setLoading(
          1 / 3,
          "Cargando negocios"
        );
        this.dummy = new DummyNegocio({ id: 0 }, currentSlugs);
        this.properties = rows.map((row) => this.normalizeNegocio(row, currentSlugs));
        if (!this.ready) {
          this.ready = true;
          this.marquee(" Finished ingesting first batch ");
          this.processEventListeners("ready", this.properties);
        } else {
          this.processEventListeners("reload", this.properties);
        }
        res2(this.properties);
      });
    });
  }
  get checked() {
    return this.properties.filter((n) => n.checked);
  }
  getDummy() {
    return this.dummy;
  }
  get url() {
    this.urlInstance = new URL(this.next_page_url);
    return this.urlInstance;
  }
  async fetchFilteredRecords(endpoint, {
    state,
    method,
    headers,
    page
  } = { page: 1, state: {}, method: "GET", headers: [] }) {
    endpoint = endpoint || new URL(this.$store.active_filter.searchUrl, location.origin).toString();
    state = state || {};
    state.limit = state.limit || 100;
    let url = new URL(endpoint), body = typeof state === "string" ? state : JSON.stringify(state);
    if (page !== 0) {
      url.searchParams.set("page", page.toFixed(0));
    }
    this.abortController = new AbortController();
    this.current_page = page || 1;
    const signal = this.abortController.signal;
    const result = await staticFetchWrapper(url.toString(), {
      signal,
      method: method || "post",
      body
    }).then(async (res2) => {
      const data2 = await this.processResult(res2);
      this.current_page === 1 ? this.reload(data2) : this.append(data2);
      if (!this.next_page_url) {
        this.stopFetching();
        return this.properties;
      }
      state.from = this.from;
      state.total = this.total;
      this.current_page++;
      return this.fetchFilteredRecords(endpoint, { state, method, headers, page: this.current_page });
    });
    return result;
  }
  async processResult(res2, last_page_url) {
    const result = typeof res2.json === "function" ? await res2.json() : res2;
    if (result.data) {
      result.data = Object.values(result.data);
      this.per_page = result.per_page;
      this.last_page = result.last_page;
      this.current_page = result.current_page;
      this.next_page_url = result.next_page_url;
      this.total = result.total;
      this.from = result.from;
      if (last_page_url) {
        this.fetchResults[last_page_url] = {
          per_page: result.per_page,
          last_page: result.last_page,
          next_page_url: result.next_page_url,
          total: result.total,
          request_id: result.request_id
        };
      }
      return result.data;
    }
    return [];
  }
  toJson(id) {
    return this.toJSON(id);
  }
  toJSON(id) {
    let negocio = this.getRaw(id);
    let { lng, lat, searchstring, ...props } = negocio;
    let geometry = { type: "Point", coordinates: [lng, lat] };
    let properties = module_default8.store("columnas_actuales").columnDefs.reduce((accum, c) => {
      let { slug_name, name, properties: properties2, input_type, id_input_type, ...rest } = c;
      accum[slug_name] = negocio[slug_name];
      if (id_input_type === "1" && Array.isArray(properties2)) {
        let selected_value = properties2.find((p) => p.id === negocio[slug_name]);
        accum[slug_name] = selected_value ? selected_value.name : negocio[slug_name];
      }
      return accum;
    }, {});
    return {
      type: "Feature",
      id,
      properties,
      geometry
    };
  }
  get ids() {
    return this.data.map((n) => n.id);
  }
  /**
   * Provided to avoid breaking changes
   */
  getRaw(id) {
    return this.properties.find((n) => n.id === id);
  }
  get(id) {
    if (id === 0)
      return this.getDummy();
    return this.properties.find((n) => n.id === id);
  }
  at(index) {
    return this.data[index];
  }
  splice(id) {
    let position = this.ids.indexOf(id);
    if (position) {
      this.properties.splice(position, 1);
    }
  }
  /**
   * the new value comes from coalescing the allowed properties, stripping readonly keys and replacing them using their getter
   * @param    {Object}    data    
   **/
  set(id, data2 = {}) {
    throw new Error(`Deprecated. Use Negocio.set(slug_name, value)`);
  }
  async setProperty(id, property, value) {
    return this.get(id).setProperty(property, value);
  }
  setModel(model) {
    this.model = model;
    return this;
  }
};
var createNegociosStore = () => {
  return new NegocioStore();
};

// src/js/components/stores/PersonaStore.ts
var PersonaStore = class extends BaseClass {
  constructor() {
    super();
    this.className = "PersonaStore";
    this.silent = false;
    this.loglevel = 4 /* WARN */;
    this.persona = {};
    this._console = bindConsole(this.className);
    console.marquee({
      [Number(performance.now() / 1e3).toFixed(1)]: "color:blue;font-weight:bold",
      " created store ": "",
      [String(this.constructor.name)]: "color:purple;font-weight:bold;"
    });
  }
  init() {
  }
  get extra_attributes() {
    return this.persona.extra_attributes || {};
  }
  mergeAttributes(attrs) {
    this.persona.extra_attributes = {
      ...this.persona.extra_attributes,
      ...attrs
    };
  }
  mergeAttributesIfMissing(attrs) {
    Object.entries(attrs).forEach(([key, value]) => {
      this.persona.extra_attributes[key] = this.persona.extra_attributes[key] ?? value;
    });
  }
  get nombre_completo() {
    return this.persona.nombre + " " + this.persona.apellidos;
  }
  setProperties(persona) {
    this.persona = persona;
    this.id = persona.id || null;
    this.persona.extra_attributes = this.persona.extra_attributes || {};
    this.syncAttributes();
    this.persona.extra_attributes.id_rol_negocio = Object.values((this.persona.extra_attributes || {}).id_rol_negocio || []);
  }
  /**
   * Syncs extra attributes in both notations 
   * e.g. persona[extra-attributes->comuna] and persona.extra_attributes.comuna
   */
  syncAttributes() {
    Object.entries(this.persona || {}).forEach(([key, value]) => {
      if (key.startsWith("extra_attributes->")) {
        this.persona.extra_attributes[key.replace("extra_attributes->", "")] = this.persona.extra_attributes[key.replace("extra_attributes->", "")] ?? value;
      }
    });
    Object.entries(this.persona.extra_attributes || {}).forEach(([key, value]) => {
      this.persona[`extra_attributes->${key}`] = this.persona[`extra_attributes->${key}`] ?? value;
    });
  }
  get(key, defaultValue = null) {
    return this.persona[key] || defaultValue;
  }
  get mapLink() {
    let { lat, lng, map_link } = this.persona.extra_attributes;
    if (map_link)
      return map_link;
    if (lat && lng)
      return encodeURI(`https://www.google.com/maps/search/?api=1&query='${this.persona.direccion}'`);
  }
  get payload() {
    return this.persona;
  }
  save_property(frm, remove_label = false) {
    let tokenElement = frm.querySelector('[name="_token"]');
    if (!(tokenElement instanceof HTMLInputElement) || !tokenElement.value)
      throw new Error("No se encontr\xF3 el token de seguridad");
    const sanctumToken = document.querySelector('meta[name="test_user_token"]');
    const headers = {
      // 'Content-Type': 'application/json; charset=UTF-8',
    };
    if (sanctumToken) {
      headers["Authorization"] = `Bearer ${sanctumToken.content}`;
    } else {
      headers["X-CSRF-TOKEN"] = `${tokenElement.value}`;
    }
    const propfields = new FormData(frm);
    propfields.delete("negocio-id_etapa_negocio");
    propfields.delete("modal_etapas");
    return fetch(frm.action, {
      method: String(propfields.get("_method") || "POST"),
      headers,
      body: propfields
    }).then((res2) => res2.json()).then(async (jsonRes) => {
      return jsonRes;
    });
  }
  get changed() {
    let changed = /* @__PURE__ */ new Map();
    for (let [key, value] of Object.entries(this.persona)) {
      let cleanKey = key;
      let initialValue = this.persona[key];
      if (initialValue === null && !value)
        continue;
      if (initialValue != value) {
        changed.set(cleanKey, value);
      }
    }
    return Object.fromEntries(changed);
  }
};
Object.defineProperty(PersonaStore.prototype, "init", { enumerable: true });

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/VSearchType.ts
var VSearchType2 = /* @__PURE__ */ ((VSearchType3) => {
  VSearchType3["BETWEEN"] = "15";
  VSearchType3["GREATER_THAN"] = "5";
  VSearchType3["GREATER_THAN_OR_EQUAL"] = "7";
  VSearchType3["HAS_ATTACHMENTS"] = "23";
  VSearchType3["IN_RANGE"] = "25";
  VSearchType3["IS_AFTER"] = "18";
  VSearchType3["IS_BEFORE"] = "17";
  VSearchType3["IS_EQUAL"] = "21";
  VSearchType3["IS_NOT_EQUAL"] = "22";
  VSearchType3["IS_NOT_NULL"] = "14";
  VSearchType3["IS_NULL"] = "13";
  VSearchType3["JSON_CONTAINS"] = "19";
  VSearchType3["JSON_NOT_CONTAINS"] = "20";
  VSearchType3["LESS_THAN"] = "6";
  VSearchType3["LESS_THAN_OR_EQUAL"] = "8";
  VSearchType3["LIKE"] = "3";
  VSearchType3["NOT_BETWEEN"] = "16";
  VSearchType3["NOT_IN"] = "2";
  VSearchType3["NOT_LIKE"] = "4";
  VSearchType3["IN"] = "1";
  return VSearchType3;
})(VSearchType2 || {});

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/VTypeSearch.ts
var VTypeSearch2 = Object.entries(VSearchType2).reduce((a, [k, v]) => ({ ...a, [v]: k }), {});

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/VRenderType.ts
var VRenderType = /* @__PURE__ */ ((VRenderType2) => {
  VRenderType2["renderNull"] = "renderNull";
  VRenderType2["renderSelect"] = "renderSelect";
  VRenderType2["renderSingleDate"] = "renderSingleDate";
  VRenderType2["renderDateRange"] = "renderDateRange";
  VRenderType2["renderNumber"] = "renderNumber";
  VRenderType2["renderContacto"] = "renderContacto";
  VRenderType2["renderButtonGroup"] = "renderButtonGroup";
  VRenderType2["renderText"] = "renderText";
  VRenderType2["renderNumericInterval"] = "renderNumericInterval";
  return VRenderType2;
})(VRenderType || {});

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/definitions.search_types.ts
var IN = "1";
var NOT_IN = "2";
var LIKE = "3";
var NOT_LIKE = "4";
var GREATER_THAN = "5";
var LESS_THAN = "6";
var GREATER_THAN_OR_EQUAL = "7";
var LESS_THAN_OR_EQUAL = "8";
var IS_NULL = "13";
var IS_NOT_NULL = "14";
var BETWEEN = "15";
var NOT_BETWEEN = "16";
var IS_BEFORE = "17";
var IS_AFTER = "18";
var JSON_CONTAINS = "19";
var JSON_NOT_CONTAINS = "20";
var IS_EQUAL = "21";
var IS_NOT_EQUAL = "22";
var HAS_ATTACHMENTS = "23";
var IN_RANGE = "25";
var search_types = {
  BETWEEN,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  HAS_ATTACHMENTS,
  IS_AFTER,
  IS_BEFORE,
  IS_EQUAL,
  IS_NOT_EQUAL,
  IS_NOT_NULL,
  IS_NULL,
  JSON_CONTAINS,
  JSON_NOT_CONTAINS,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LIKE,
  NOT_BETWEEN,
  NOT_IN,
  NOT_LIKE,
  IN,
  IN_RANGE
};

// src/js/components/entities/EnrichedFilter.ts
var import_lodash = __toESM(require_lodash());
var EnrichedFilter = class {
  constructor(filtro) {
    this.filter_id = String(filtro.id);
    filtro.valor_busquedaFn = (negocio) => true;
    this._filtro = filtro;
    this._campo_busqueda = filtro.campo_busqueda;
    this._tipo_busqueda = filtro.tipo_busqueda;
    this._conector = filtro.conector;
    this._valor_busqueda = filtro.valor_busqueda;
    this.disabled = filtro.disabled;
    this.index = filtro.index;
    this.$store.active_filter = Alpine.store("active_filter");
    this.$store.tipos_busqueda = Alpine.store("tipos_busqueda");
  }
  get id() {
    return this.filter_id;
  }
  get parent_id() {
    return Number(this.$store.active_filter.id);
  }
  get conector() {
    return this._conector || this._filtro.conector;
  }
  set conector(conector) {
    this._conector = conector;
    this._filtro.conector = conector;
  }
  get valor_busqueda() {
    return this._valor_busqueda || this._filtro.valor_busqueda;
  }
  set valor_busqueda(valor_busqueda) {
    this._valor_busqueda = valor_busqueda;
    this._filtro.valor_busqueda = valor_busqueda;
  }
  get "$store"() {
    return {
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      columnas_actuales: Alpine.store("columnas_actuales"),
      active_filter: Alpine.store("active_filter"),
      tipos_busqueda: Alpine.store("tipos_busqueda")
    };
  }
  get campo_busqueda() {
    return this._campo_busqueda;
  }
  set campo_busqueda(newCampo) {
    if (this._campo_busqueda !== newCampo) {
      this._campo_busqueda = newCampo;
      console.colorInfo("#00C", "EnrichedFilter", { "setting new campo ": newCampo, shouldRender: this.shouldRender });
      this.valor_busqueda = "";
      this.tipo_busqueda = "13" /* IS_NULL */;
    }
  }
  get tipo_busqueda() {
    return this._tipo_busqueda;
  }
  set tipo_busqueda(newType) {
    if (this._tipo_busqueda === newType)
      return;
    this._tipo_busqueda = newType;
    console.colorInfo("#00C", "EnrichedFilter", { "setting new tipo_busqueda ": newType, shouldRender: this.shouldRender, valor_busqueda: this.valor_busqueda });
    if (!(0, import_lodash.isArray)(this.valor_busqueda))
      this.valor_busqueda = [];
  }
  get filtro() {
    return this;
  }
  get slug_name() {
    return (this.campo_busqueda || "").replace(/^([^,]+).*$/, "$1") || this.campo_busqueda.split(",")[0];
  }
  get id_input_type() {
    return (this.campo || { id_input_type: "2" /* INPUT_TEXT */ }).id_input_type;
  }
  get id_rol_negocio() {
    return (this.campo || { id_rol_negocio: null }).id_rol_negocio;
  }
  get slug() {
    return this.slug_name;
  }
  get attr_type() {
    return this.campo ? this.campo.attr_type : this.campo_busqueda.split(",")[1] ?? "negocio";
  }
  get campo() {
    return this.filtro && this.campo_busqueda ? this.$store.campos_busqueda.find(this.campo_busqueda) : { id_input_type: "2" /* INPUT_TEXT */ };
  }
  get tipo() {
    return this.$store.tipos_busqueda.get(this.tipo_busqueda).name;
  }
  get operation() {
    return this.$store.tipos_busqueda.getOperation(this.tipo_busqueda);
  }
  get properties() {
    return this.campo && Array.isArray(this.campo.properties) ? this.campo.properties : [];
  }
  get items() {
    return (Array.isArray(this.valor_busqueda) ? this.valor_busqueda : [this.valor_busqueda]).map(String);
  }
  get options() {
    return this.campo ? this.campo.options : [];
  }
  get operadores_busqueda() {
    return this.$store.tipos_busqueda.operadores_para(
      this.campo || { id_input_type: 0 }
    ) || {
      ["13" /* IS_NULL */]: "Vac\xEDo/Nulo",
      ["14" /* IS_NOT_NULL */]: "No es vac\xEDo/Nulo"
    };
  }
  /*get index() {
      return (this.filtro || {}).index;
  }
  set index(value) {
      this.filtro.index = value;
  }
  get disabled() {
      return !!(this.filtro || {}).disabled
  }
  set disabled(value) {
      this.filtro.disabled = !!value
  }*/
  get operadores() {
    return this.operadores_busqueda;
  }
  get isValid() {
    return this.campo_busqueda && this.campo_busqueda !== ",negocio" && this.slug_name && (this.valor_busqueda !== null && this.valor_busqueda !== void 0 || String(this.tipo_busqueda) === "13" /* IS_NULL */ || String(this.tipo_busqueda) === "14" /* IS_NOT_NULL */);
  }
  get input_type() {
    return this.campo ? this.campo.input_type : "text";
  }
  get payload() {
    let {
      id,
      conector,
      campo_busqueda,
      tipo_busqueda,
      valor_busqueda,
      slug_name,
      attr_type,
      id_input_type,
      id_rol_negocio,
      disabled,
      input_type,
      operation,
      index
    } = this;
    return {
      id,
      index,
      conector,
      campo_busqueda,
      tipo_busqueda,
      input_type,
      valor_busqueda: valor_busqueda === null ? null : typeof valor_busqueda === "object" ? Object.values(valor_busqueda) : valor_busqueda,
      slug_name,
      id_input_type,
      attr_type,
      id_rol_negocio,
      operation,
      disabled
    };
  }
  get templateId() {
    if (this.renderButtonGroup)
      return "#render_button_group";
    if (this.renderSelect)
      return "#render_select";
    if (this.renderContacto)
      return "#render_contacto";
    if (this.renderDateRange)
      return "#render_date_range";
    if (this.renderSingleDate)
      return "#render_date";
    if (this.renderNull)
      return "#render_null";
    if (this.renderNumber)
      return "#render_number";
    if (this.renderText)
      return "#render_text";
    return "#render_text";
  }
  getTemplateContent() {
    return document.querySelector(this.templateId).innerHTML;
  }
  get templateContent() {
    return document.querySelector(this.templateId).innerHTML;
  }
  get VRenderType() {
    return VRenderType;
  }
  get shouldRender() {
    if (!this.campo)
      return "renderNull";
    let {
      renderNumericInterval,
      renderSelect,
      renderSingleDate,
      renderDateRange,
      renderNumber,
      renderContacto,
      renderNull,
      renderText,
      renderButtonGroup
    } = this;
    let shouldRender = Object.entries({
      renderNull,
      renderSelect,
      renderSingleDate,
      renderDateRange,
      renderNumericInterval,
      renderNumber,
      renderContacto,
      renderButtonGroup,
      renderText
      //@ts-ignore
    }).find(([key, value]) => value === true);
    return shouldRender ? shouldRender[0] : "renderText";
  }
  get renderSelect() {
    if (!this.campo)
      return false;
    return (this.campo.isSelectOrRadioButtonGroup || this.campo.isMultiSelectField || this.campo.isCheckbox || !this.renderContacto && [search_types.IN, search_types.NOT_IN].includes(String(this.tipo_busqueda)) && (this.campo.options || []).length) && !this.renderNull && !this.renderButtonGroup;
  }
  get renderButtonGroup() {
    if (!this.campo)
      return false;
    return [
      search_types.HAS_ATTACHMENTS
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderSingleDate() {
    if (!this.campo)
      return false;
    return this.campo && this.campo.isDateOrDatetimeField && ![
      search_types.BETWEEN,
      search_types.NOT_BETWEEN
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderDateRange() {
    if (!this.campo)
      return false;
    return this.campo && this.campo.isDateOrDatetimeField && [
      search_types.BETWEEN,
      search_types.NOT_BETWEEN
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderNumber() {
    if (!this.campo)
      return false;
    return this.campo.isNumber && !this.renderNull && search_types.IN_RANGE !== String(this.tipo_busqueda);
  }
  get renderNumericInterval() {
    if (!this.campo)
      return false;
    return this.campo.isNumber && !this.renderNull && search_types.IN_RANGE === String(this.tipo_busqueda);
  }
  get renderNull() {
    if (!this.campo)
      return true;
    return [
      search_types.IS_NULL,
      search_types.IS_NOT_NULL
    ].includes(String(this.tipo_busqueda));
  }
  get renderContacto() {
    if (!this.campo)
      return false;
    return this.campo.isContact && !this.renderNull;
  }
  get renderText() {
    return !this.renderSelect && !this.renderNull && !this.renderNumber && !this.renderDateRange && !this.renderSingleDate && !this.renderContacto && !this.renderNull;
  }
};
Object.defineProperty(EnrichedFilter.prototype, "tipo", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "input_type", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "shouldRender", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "payload", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "operadores_busqueda", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "operation", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "tipo_busqueda", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "campo_busqueda", { enumerable: true });

// src/js/components/stores/activeFilterStore.ts
var ActiveFilterStore = class extends BaseClass {
  constructor() {
    super();
    this.opened_once = false;
    this.filters_open = false;
    this.className = "ActiveFilterStore";
    this.ready = false;
    this.estimate = 0;
    //updated_at: Date;
    this.properties = {
      columnas_actuales: []
    };
    this.filtrosDisponibles = [];
    this.default_changed = false;
    this.filterMap = null;
    this.filterIndex = -1;
    this.filterIds = [];
    this.estimatePromise = null;
    this.controls = /* @__PURE__ */ new Map();
    this.redrawing = false;
    this.searchUrl = "/api/negocios/apply_filter";
    this.display_filters_accordion = false;
    this.loadingProgress = 0;
    this.loadingText = "";
    this._console = bindConsole(this.className);
    this.marquee(" created store ");
    globalThis.$store = globalThis.$store || {};
    globalThis.$store.active_filter = this;
    this.filterMap = /* @__PURE__ */ new Map();
    this.redrawingTimeout = null;
    this.debouncedDisableRedrawing = () => {
      if (this.redrawingTimeout)
        clearTimeout(this.redrawingTimeout);
      this.redrawingTimeout = setTimeout(() => this.disableRedrawing(), 500);
    };
  }
  get user_id() {
    return this.properties.user_id;
  }
  get nextIndex() {
    return tap(
      ++this.filterIndex,
      (index) => console.log("nextIndex", index)
    );
  }
  resetControl() {
    this.controls = /* @__PURE__ */ new Map();
    this.on("ready", () => {
    });
  }
  disableRedrawing() {
    this.marquee("disableRedrawing");
    this.redrawing = false;
  }
  get verifiers() {
    return {
      ready: !!this.ready,
      filters_loaded: this.filtrosDisponibles.length > 0
    };
  }
  replaceDisponible(filtro) {
    let position = this.filtrosDisponibles.map((f) => Number(f.id)).indexOf(Number(filtro.id));
    if (position !== -1) {
      let extracted = this.filtrosDisponibles.splice(position, 1);
      filtro.highlighted = true;
      this.filtrosDisponibles.splice(position, 0, filtro);
      this.processEventListeners("filters_loaded", this);
    } else {
      this.filtrosDisponibles.unshift(filtro);
      this.processEventListeners("filters_loaded", this);
    }
  }
  loadFiltrosDisponibles(filtrosDisponibles) {
    let filtrosNormalized = filtrosDisponibles.map((filtro) => {
      let {
        query_string,
        id,
        updated_at,
        user_id,
        name,
        created_at,
        opt_group = "Otros",
        areas_subareas,
        user,
        ...rest
      } = filtro, author = user?.name, {
        user_id: fake_user_id,
        id: fake_id,
        rol,
        personas,
        //@ts-ignore
        _method,
        filter,
        ...properties
      } = query_string;
      return {
        id,
        name,
        public: !!rest.public,
        user_id,
        ...properties,
        opt_group,
        areas_subareas,
        author,
        created_at,
        updated_at
      };
    });
    this.filtrosDisponibles = filtrosNormalized;
    this.processEventListeners("filters_loaded", this);
    return this;
  }
  once(event, handler4) {
    if (event === "filters_loaded" && this.filtrosDisponibles.length > 0 || event === "ready" && this.ready) {
      return Promise.resolve(typeof handler4 === "function" ? handler4(this) : this);
    }
    return super.once(event, handler4);
  }
  xprocessEventListeners(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event])
      return;
    this.log(`processing ${event} handlers, ${this.eventListeners[event].length} remaining`);
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    while (onceHandlers.length) {
      onceHandlers.shift()(callbackArgument);
    }
    otherHandlers.forEach((cb) => cb(callbackArgument));
    this.eventListeners[event] = otherHandlers;
  }
  get emptyFilter() {
    return {
      id: null,
      name: "Nuevo filtro " + (/* @__PURE__ */ new Date()).toLocaleString("es-CL").replace(",", "").substr(0, 16),
      opt_group: "Otros",
      public: null,
      author: null,
      filtros: [{
        conector: "AND",
        valor_busqueda: null,
        tipo_busqueda: "14" /* IS_NOT_NULL */,
        campo_busqueda: "id_tipo_negocio,negocio",
        slug_name: "id_tipo_negocio",
        attr_type: "negocio",
        id_input_type: "1" /* INPUT_SELECT */
      }],
      columnas_visibles: [70],
      columnas_actuales: [{
        slug_name: "id_tipo_negocio",
        id: 70,
        visible: true
      }],
      areas_subareas: null,
      //@ts-ignore
      estimate: this.$store.negocios.properties.length,
      grouped_filters: [],
      filtros_and_or: [],
      user_id: null,
      created_at: null,
      updated_at: null
    };
  }
  getEstimate(options) {
    this.estimatePromise = this.estimatePromise ?? this.getEstimateOriginal(options);
    return this.estimatePromise;
  }
  get estimate_icon() {
    return this.estimatePromise ? "fa fa-spinner fa-spin" : "fa fa-calculator";
  }
  get payloadForNewFilter() {
    let { id, ...payload } = this.estimatePayload;
    return payload;
  }
  /**
  * @returns {Array<string>} the list of slugs for the current set of columns
  */
  get currentSlugs() {
    return [...(this.columnas_actuales || []).map((c) => c.slug_name)];
  }
  get estimatePayload() {
    let {
      filtros,
      user_id,
      columnas_actuales: columnas_actuales2,
      columnas_visibles,
      id,
      name
    } = this.properties;
    filtros = this.filtros.filter((f) => !f.disabled && f.campo_busqueda).map((filtro) => {
      let f = filtro._filtro || filtro;
      f.conector = f.conector || f._conector || "and";
      f.campo_busqueda = (filtro.campo_busqueda || f.campo_busqueda || f._campo_busqueda).replace("fechaCreacion", "created_at");
      f.tipo_busqueda = filtro.tipo_busqueda || f.tipo_busqueda || f._tipo_busqueda;
      f.valor_busqueda = filtro.valor_busqueda || f.valor_busqueda || f._valor_busqueda;
      let [slug_name, attr_type] = f.campo_busqueda.split(",");
      f.slug_name = slug_name;
      f.attr_type = attr_type;
      return f;
    }).filter((f) => f.campo_busqueda && f.campo_busqueda !== ",negocio").map((f) => module_default8.raw(f));
    return module_default8.raw({
      id: this.id,
      name: this.name,
      opt_group: this.opt_group,
      areas_subareas: this.areas_subareas,
      filtros,
      public: this.public,
      columnas_actuales: module_default8.raw(this.columnas_actuales),
      columnas_visibles: module_default8.raw(this.columnas_visibles)
    });
  }
  normalizeSearchPayload(state) {
    state.columnas_actuales = module_default8.raw(state.columnas_actuales.length ? state.columnas_actuales : this.columnas_visibles).map((c) => {
      return { id: Number(c.id), visible: c.visible, slug_name: c.slug_name };
    });
    state.columnas_visibles = module_default8.raw(state.columnas_visibles.length ? state.columnas_visibles : this.columnas_visibles).map((c) => Number(c));
    let missingVisible = state.columnas_visibles.filter((c) => !state.columnas_actuales.find((c2) => c2.id == c));
    if (missingVisible.length)
      this.console.warn("missingVisible", missingVisible);
    let missing_actuales = state.columnas_actuales.filter((c) => state.columnas_visibles.indexOf(c.id) === -1).map((c) => c.id);
    if (missing_actuales.length)
      this.console.warn("missing_actuales", missing_actuales);
    state.filter = 1;
    state.from = state.from || Number(Date.now() / 1e3).toFixed(0);
    state.limit = Math.max(this.estimate ?? 100, state.limit || 1e3);
    this.console.log({ state });
    return state;
  }
  setLoading(progress, text) {
    if (progress < 1) {
      progress = Math.min(100, (100 - this.loadingProgress) * progress);
    }
    this.loadingProgress = progress;
    this.loadingText = text ?? "cargando";
    if (this.$store.user)
      this.$store.user.displayLoadingMessage = false;
  }
  clearLoading(delay4 = 100) {
    this.loadingProgress = this.loadingProgress + (100 - this.loadingProgress) / 2;
    setTimeout(() => {
      this.loadingProgress = 0;
      this.loadingText = "";
      if (this.$store.user)
        this.$store.user.displayLoadingMessage = false;
    }, delay4 ?? 100);
  }
  computeEndpoint() {
    let endpoint = location.origin + "/api/negocios/apply_filter";
    if (this.searchUrl)
      endpoint = location.origin + this.searchUrl.replace(location.origin, "");
    return endpoint;
  }
  submitSearch(state = {}) {
    const payload = this.estimatePayload;
    state = this.normalizeSearchPayload({ ...payload, ...state });
    if (!state.columnas_visibles.length) {
      this.setLoading(1 / 4, "Buscando negocios");
      this.console.warn("submitSearch: retry with  " + this.columnas_visibles.length + " current columnas_visibles");
      return waitFor2(100).then(() => this.submitSearch(this.estimatePayload));
    }
    console.table(state.columnas_actuales);
    this.info("submitSearch", state);
    this.$store.negocios.complete = false;
    this.setLoading(1 / 2, "Buscando negocios");
    return this.$store.negocios.fetchFilteredRecords(this.computeEndpoint(), {
      method: "post",
      headers: {},
      state,
      page: 1
    }).then(async (result) => {
      setTimeout(() => this.$store.negocios.total = this.$store.negocios.properties.length, 1e3);
      return result;
    }).catch((e) => {
      this.clearLoading();
    });
  }
  async getEstimateOriginal(options) {
    const estimate_url = new URL(
      location.origin + "/api/filtros/estimate_filter"
    );
    estimate_url.pathname += `/${this.properties.id}`;
    if (options.include_columns) {
      estimate_url.searchParams.append("include_columns", "1");
    }
    setTimeout(() => {
      this.estimatePromise = null;
    }, 2e3);
    return BaseClass.staticFetchWrapper(estimate_url.toString(), {
      method: "POST",
      body: JSON.stringify(this.estimatePayload)
    }).then((results) => {
      results = results;
      let { total, new_total, default_filter_id, columnas_visibles } = results || {};
      this.marquee("estimate", {
        total,
        new_total,
        default_filter_id,
        columnas_visibles
      });
      this.estimatePromise = null;
      this.estimate = total;
      let freshResult = { estimate: this.estimate, columnas_visibles };
      this.processEventListeners("probe", freshResult);
      this.redrawing = false;
      return freshResult;
    }).catch((err) => {
      this.redrawing = false;
      this.estimatePromise = null;
      let fallbackResult = {
        estimate: this.estimate,
        columnas_visibles: options.include_columns ? this.$store.columnas_actuales.columnDefs : this.columnas_visibles
      };
      return fallbackResult;
    });
  }
  async updateColumnDefs() {
    return new Promise((res2) => {
      this.$store.columnas_actuales.once("columns_updated", () => res2(this.get_or_infer_columnas_actuales()));
      if (!this.$store.columnas_actuales.ready) {
        setTimeout(() => {
          this.$store.columnas_actuales.processEventListeners("columns_updated", this.$store.columnas_actuales.columnDefs);
        }, 200);
      }
      this.$store.columnas_actuales.reloadCampos(this.get_or_infer_columnas_actuales(), true);
      setTimeout(() => res2(this.columnas_actuales), 200);
    });
  }
  async submitTwice() {
    this.$store.columnas_actuales.once("columns_updated", async () => {
      this.$store.negocios.ready = false;
      await this.submitSearch({ limit: 5500, from: Number(Date.now() / 1e3).toFixed(0) });
      setTimeout(() => this.submitSearch({ limit: 5500, from: Number(Date.now() / 1e3).toFixed(0) }).then(() => globalThis.filterProgress.width = 100));
    });
    this.updateColumnDefs();
  }
  get filtros() {
    return this.filterIds.map((id) => this.filterMap.get(id));
  }
  set filtros(filtros) {
    console.log("set filtros", filtros);
    this.filterIds = [];
    let newFiltros = filtros.map((f, index) => {
      this.filterIds.push(String(f.id));
      return f;
    });
    this.properties.filtros = newFiltros;
    this.filterMap = new Map(newFiltros.map((f) => [f.id, f]));
  }
  get updated_at() {
    return this.properties.updated_at;
  }
  set updated_at(updated_at) {
    this.properties.updated_at = updated_at;
  }
  updateProperties(newProperties) {
    let {
      columnas_visibles,
      id,
      name,
      user_id,
      filtros,
      updated_at,
      created_at,
      opt_group,
      areas_subareas,
      public: isPublic,
      author,
      columnas_actuales: columnas_actuales2,
      ...otherProps
    } = newProperties || this.properties;
    this.author = author;
    console.marquee({
      'Filter name is "': "",
      [name]: "color:blue;font-weight:bold",
      '"': ""
    });
    if (!id)
      isPublic = true;
    this.properties = {
      columnas_actuales: module_default8.raw(columnas_actuales2),
      columnas_visibles: module_default8.raw(columnas_visibles),
      updated_at,
      created_at,
      id,
      name,
      user_id,
      author,
      filtros: module_default8.raw(filtros),
      //@ts-ignore
      filtros2: filtros,
      opt_group,
      areas_subareas,
      public: isPublic,
      ...otherProps
    };
    this.properties.columnas_visibles = Array.isArray(columnas_visibles) && columnas_visibles.length ? module_default8.raw(columnas_visibles) : [
      61,
      139,
      70,
      71,
      65,
      62
    ];
    this.properties.columnas_visibles = Array.from(
      new Set(
        [...this.properties.columnas_visibles].map((c) => String(c))
      )
    );
    this.columnas_actuales = this.infer_columnas_actuales(columnas_actuales2);
    this.properties.columnas_actuales = columnas_actuales2;
    this.properties.opt_group = this.properties.opt_group || "Otros";
    this.properties.areas_subareas = this.properties.areas_subareas || [];
    this.author = this.properties.author;
    this.id = id;
    this.name = name;
    this.created_at = created_at;
    this.updated_at = updated_at;
    this.public = !!isPublic;
    try {
      this.properties.filtros = this.properties.filtros || [];
      this.normalizeFiltros(filtros ?? []);
    } catch (e) {
      console.error(e);
    }
    this.columnas_actuales.forEach((c) => {
      c.id = Number(c.id);
      c.visible = c.visible ?? true;
      if (this.$store.campos_busqueda.get(c.id)) {
        let { slug_name } = this.$store.campos_busqueda.get(c.id);
        c.slug_name = slug_name;
      }
    });
    this.reloadCampos();
    if (!this.ready) {
      this.ready = true;
      this.processEventListeners("ready", this);
    }
  }
  onReady(handler4) {
    return this.once("ready", handler4);
  }
  normalizeFiltros(filtros) {
    this.filterMap = /* @__PURE__ */ new Map();
    this.filterIds = [];
    filtros = filtros || this.properties.filtros;
    if (!filtros.length)
      filtros.push(this.createDummyFilter());
    this.properties.filtros = filtros.map(
      (f, index) => {
        f.conector = f.conector || "AND";
        f.index = index;
        this.filterIds.push(String(f.id));
        return f;
      }
    );
    this.properties.filtros.forEach(
      (filtro) => this.filterMap.set(filtro.id, filtro)
    );
  }
  syncFiltrosWithAvailableInfo() {
    let availableFiltro = this.get(this.id);
    if (availableFiltro) {
      this.normalizeFiltros(availableFiltro.filtros);
      this.columnas_visibles = availableFiltro.columnas_visibles;
      this.columnas_actuales = availableFiltro.columnas_actuales;
    }
  }
  appendFiltro() {
    if (!Array.isArray(this.filterIds)) {
      this.filterIds = [];
      this.normalizeFiltros();
    }
    let lengthBefore = this.filterMap.size;
    let newFiltro = this.createDummyFilter();
    newFiltro.index = lengthBefore;
    newFiltro.id = v4_default();
    newFiltro.parent_id = Number(this.id);
    const filtro = new EnrichedFilter(newFiltro);
    this.properties.filtros.push(filtro);
    this.filterMap.set(filtro.id, filtro);
    this.filterIds.push(filtro.id);
    return filtro;
  }
  reloadCampos() {
    this.$store.columnas_actuales.syncWithActiveFilter();
  }
  rollBack() {
    this.setActive(this.id);
  }
  toggleRedrawing() {
    this.redrawing = true;
    this.debouncedDisableRedrawing();
  }
  getActive() {
    return this.get(this.id);
  }
  getSafeProperies(id) {
    id = Number(id ?? this.id);
    let { filtros, ...newProperties } = this.get(id) || {};
    filtros = (filtros || []).map((filtro) => {
      return { ...module_default8.raw(filtro) };
    });
    return { id, filtros, ...newProperties };
  }
  async setActive(id) {
    id = Number(id ?? this.id);
    let { filtros, ...newProperties } = this.get(id) || {};
    this.ready = false;
    this.once("ready", () => this.updateColumnDefs());
    this.$store.tipos_busqueda.once("ready").then(() => {
      this.updateProperties(this.getSafeProperies(Number(id)));
      this.id = id;
      this.name = this.properties.name;
      this.resetSelectedColumns();
      this.default_changed = true;
    });
    return this.redrawing = true;
  }
  resetSelectedColumns() {
    if (this.controls.has("columnas_disponibles_control")) {
      this.controls.get("columnas_disponibles_control").resetSelectedOptions(
        [...this.columnas_visibles].join(",")
      );
    }
  }
  get(id) {
    if (id == 0)
      return this.emptyFilter;
    return this.filtrosDisponibles.find(
      (f) => Number(f.id) === Number(id || this.id)
    );
  }
  /**
   * Reads a cookie in the user's browser to decide if
   * the page should be reloaded after a filter is saved, or when
   * the default filter is changed
   */
  get prevent_reload() {
    return true;
  }
  reloadAvailableFilters(setActive = null) {
    this.filtrosDisponibles = [];
    setActive = setActive || this.id;
    return BaseClass.staticFetchWrapper(
      "/api/filtros/get_available_filters",
      {
        headers: {
          "cache-control": "no-cache"
        }
      }
    ).then(async (filtros) => {
      if (setActive) {
        this.once("filters_loaded", () => this.setActive(setActive));
      }
      await this.loadFiltrosDisponibles(filtros);
      return filtros;
    });
  }
  getCurrentFilter() {
    globalThis.activeFilterPromise = staticFetchWrapper(
      "/api/filtros/current_filter",
      {}
    ).then((res2) => {
      console.timerInfo("received activeFilterPromise result from sw", res2.id);
      return res2;
    });
  }
  async init() {
    this.marquee(" init ");
    this.updateProperties(this.properties);
    this.properties.filtros = (this.properties || {}).filtros || [];
  }
  removeAt(id, retry = 0) {
    this.filterIds = this.filterIds.filter((fid) => fid !== id);
    this.properties.filtros = this.properties.filtros.filter(
      (f) => f.id !== id
    );
    return this.filterMap.delete(id);
  }
  moveFilter(from, to) {
    let filterIds = [...this.filterIds].slice(0);
    let moved = filterIds.splice(from, 1)[0];
    filterIds.splice(to, 0, moved);
    this.filterIds = filterIds;
    this.properties.filtros = this.filterIds.map((id) => {
      return this.properties.filtros.find((f) => f.id == id);
    });
    console.table(this.filtros.map((f) => f.campo_busqueda));
  }
  get columnas_visibles() {
    return Array.from(new Set(this.properties.columnas_visibles));
  }
  set columnas_visibles(columnas_visibles) {
    this.properties.columnas_visibles = Array.from(
      new Set(columnas_visibles)
    );
  }
  get columnas_actuales() {
    return this.infer_columnas_actuales(this.properties.columnas_actuales);
  }
  set columnas_actuales(columnas_actuales2) {
    this.properties.columnas_actuales = this.infer_columnas_actuales(columnas_actuales2);
    this.columnas_visibles = this.columnas_actuales.map((c) => c.id);
  }
  get_or_infer_columnas_actuales() {
    if (!this.columnas_actuales)
      this.columnas_actuales = this.infer_columnas_actuales();
    return this.columnas_actuales;
  }
  sync_columnas_actuales() {
    this.columnas_actuales = this.infer_columnas_actuales();
    return this.columnas_actuales;
  }
  infer_columnas_actuales(columnas_actuales2) {
    columnas_actuales2 = Array.isArray(columnas_actuales2) ? columnas_actuales2 : Array.isArray(this.properties.columnas_actuales) ? this.properties.columnas_actuales : this.$store.columnas_actuales.columnDefs;
    let actuales = Array.from(new Set(this.columnas_visibles)).map((c) => Number(c)).map((c) => {
      let actual = columnas_actuales2.find((ca) => ca.id == c) || {
        id: c,
        visible: true
      };
      let campo = this.$store.campos_busqueda.get(c);
      return {
        id: c,
        slug_name: campo?.slug_name.replace(
          "fechaCracion",
          "created_at"
        ),
        visible: actual.visible ?? true
      };
    });
    return Array.from(new Set(actuales));
  }
  get name() {
    return this.properties.name;
  }
  set name(name) {
    if (name && name !== this.properties.name) {
      this.properties.name = name;
    }
  }
  get public() {
    return !!this.properties.public;
  }
  set public(flag) {
    this.properties.public = !!flag;
  }
  get opt_group() {
    return this.properties.opt_group;
  }
  set opt_group(opt_group) {
    this.properties.opt_group = opt_group;
  }
  get areas_subareas() {
    return this.properties.areas_subareas;
  }
  set areas_subareas(areas_subareas) {
    this.properties.areas_subareas = areas_subareas;
  }
  createDummyFilter() {
    return dummyFilter();
  }
  enrichFilter(filtro) {
    return;
  }
  printColumns() {
    let combinedColumns = this.columnas_visibles.map((c) => {
      let actual = this.columnas_actuales.find((ca) => ca.id == c);
      return {
        id_visible: c,
        id_actual: actual?.id,
        slug_name: actual?.slug_name,
        visible: actual?.visible
      };
    });
    console.table(combinedColumns);
  }
  printTable(filters = null) {
    printFilters(
      (filters ?? this.enrichedFilters).map((f) => {
        let filtro = f._filtro || f;
        filtro.tipo = f.operation || f.tipo;
        return filtro;
      }),
      ["attr_type", "slug_name", "tipo", "valor_busqueda", "conector"]
    );
  }
  at(index) {
    return this.filtros[index] || {};
  }
  get enrichedFilters() {
    return this.properties.filtros;
  }
  suggestNewName() {
    return [
      (this.name || "nuevo filtro ").split(" v202")[0],
      (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").replace("T", " ").substr(0, 14)
    ].join(" v");
  }
  async setDefaultFilter(id) {
    return Promise.resolve().then(() => {
      return Promise.resolve();
    }).then(() => {
      return staticFetchWrapper("/api/filtros/change_default_filter", {
        method: "POST",
        body: JSON.stringify({ default_filter: id })
      });
    }).then((jsonRes) => {
      openToast({
        //@ts-ignore
        type: jsonRes.type,
        //@ts-ignore
        text: "Cambio de filtro guardado",
        description: jsonRes.message,
        delay: 4e3,
        from: "selectorFiltroDefault"
      });
      return;
    });
  }
  populateEmptyFilter() {
    let emptyFilter = this.emptyFilter;
    if (globalThis.defaultFieldsPromise) {
      globalThis.defaultFieldsPromise.then((fields) => {
        emptyFilter.columnas_actuales = fields.map((field) => {
          let { slug_name, id, visible } = field;
          return { slug_name, id, visible };
        });
        emptyFilter.columnas_visibles = fields.map((f) => f.id);
        this.updateProperties(emptyFilter);
      });
    } else {
      this.updateProperties(emptyFilter);
    }
    this.redrawing = true;
    this.searchUrl = null;
  }
};
Object.defineProperty(ActiveFilterStore.prototype, "id", { enumerable: true, writable: true });
Object.defineProperty(ActiveFilterStore.prototype, "name", { enumerable: true, writable: true });

// src/js/components/index.ts
var ifDefined = (element, callback, fallback) => {
  if (element) {
    return callback(element);
  }
  return typeof fallback === "function" ? fallback() : fallback;
};
globalThis.ifDefined = ifDefined;

// node_modules/leaflet/dist/leaflet-src.esm.js
function extend(dest) {
  var i, j, len, src;
  for (j = 1, len = arguments.length; j < len; j++) {
    src = arguments[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}
var create$2 = Object.create || function() {
  function F() {
  }
  return function(proto) {
    F.prototype = proto;
    return new F();
  };
}();
function bind3(fn, obj) {
  var slice = Array.prototype.slice;
  if (fn.bind) {
    return fn.bind.apply(fn, slice.call(arguments, 1));
  }
  var args = slice.call(arguments, 2);
  return function() {
    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  };
}
var lastId = 0;
function stamp(obj) {
  if (!("_leaflet_id" in obj)) {
    obj["_leaflet_id"] = ++lastId;
  }
  return obj._leaflet_id;
}
function throttle2(fn, time, context) {
  var lock, args, wrapperFn, later;
  later = function() {
    lock = false;
    if (args) {
      wrapperFn.apply(context, args);
      args = false;
    }
  };
  wrapperFn = function() {
    if (lock) {
      args = arguments;
    } else {
      fn.apply(context, arguments);
      setTimeout(later, time);
      lock = true;
    }
  };
  return wrapperFn;
}
function wrapNum(x, range, includeMax) {
  var max = range[1], min = range[0], d = max - min;
  return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}
function falseFn() {
  return false;
}
function formatNum(num, precision) {
  if (precision === false) {
    return num;
  }
  var pow = Math.pow(10, precision === void 0 ? 6 : precision);
  return Math.round(num * pow) / pow;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function splitWords(str) {
  return trim(str).split(/\s+/);
}
function setOptions(obj, options) {
  if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
    obj.options = obj.options ? create$2(obj.options) : {};
  }
  for (var i in options) {
    obj.options[i] = options[i];
  }
  return obj.options;
}
function getParamString(obj, existingUrl, uppercase) {
  var params = [];
  for (var i in obj) {
    params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
  }
  return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
}
var templateRe = /\{ *([\w_ -]+) *\}/g;
function template(str, data2) {
  return str.replace(templateRe, function(str2, key) {
    var value = data2[key];
    if (value === void 0) {
      throw new Error("No value provided for variable " + str2);
    } else if (typeof value === "function") {
      value = value(data2);
    }
    return value;
  });
}
var isArray3 = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};
function indexOf(array, el) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === el) {
      return i;
    }
  }
  return -1;
}
var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
function getPrefixed(name) {
  return window["webkit" + name] || window["moz" + name] || window["ms" + name];
}
var lastTime = 0;
function timeoutDefer(fn) {
  var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
  lastTime = time + timeToCall;
  return window.setTimeout(fn, timeToCall);
}
var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
  window.clearTimeout(id);
};
function requestAnimFrame(fn, context, immediate) {
  if (immediate && requestFn === timeoutDefer) {
    fn.call(context);
  } else {
    return requestFn.call(window, bind3(fn, context));
  }
}
function cancelAnimFrame(id) {
  if (id) {
    cancelFn.call(window, id);
  }
}
function Class() {
}
Class.extend = function(props) {
  var NewClass = function() {
    setOptions(this);
    if (this.initialize) {
      this.initialize.apply(this, arguments);
    }
    this.callInitHooks();
  };
  var parentProto = NewClass.__super__ = this.prototype;
  var proto = create$2(parentProto);
  proto.constructor = NewClass;
  NewClass.prototype = proto;
  for (var i in this) {
    if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
      NewClass[i] = this[i];
    }
  }
  if (props.statics) {
    extend(NewClass, props.statics);
  }
  if (props.includes) {
    checkDeprecatedMixinEvents(props.includes);
    extend.apply(null, [proto].concat(props.includes));
  }
  extend(proto, props);
  delete proto.statics;
  delete proto.includes;
  if (proto.options) {
    proto.options = parentProto.options ? create$2(parentProto.options) : {};
    extend(proto.options, props.options);
  }
  proto._initHooks = [];
  proto.callInitHooks = function() {
    if (this._initHooksCalled) {
      return;
    }
    if (parentProto.callInitHooks) {
      parentProto.callInitHooks.call(this);
    }
    this._initHooksCalled = true;
    for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
      proto._initHooks[i2].call(this);
    }
  };
  return NewClass;
};
Class.include = function(props) {
  var parentOptions = this.prototype.options;
  extend(this.prototype, props);
  if (props.options) {
    this.prototype.options = parentOptions;
    this.mergeOptions(props.options);
  }
  return this;
};
Class.mergeOptions = function(options) {
  extend(this.prototype.options, options);
  return this;
};
Class.addInitHook = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  var init = typeof fn === "function" ? fn : function() {
    this[fn].apply(this, args);
  };
  this.prototype._initHooks = this.prototype._initHooks || [];
  this.prototype._initHooks.push(init);
  return this;
};
function checkDeprecatedMixinEvents(includes) {
  if (typeof L === "undefined" || !L || !L.Mixin) {
    return;
  }
  includes = isArray3(includes) ? includes : [includes];
  for (var i = 0; i < includes.length; i++) {
    if (includes[i] === L.Mixin.Events) {
      console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
    }
  }
}
var Events = {
  /* @method on(type: String, fn: Function, context?: Object): this
   * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
   *
   * @alternative
   * @method on(eventMap: Object): this
   * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
   */
  on: function(types, fn, context) {
    if (typeof types === "object") {
      for (var type in types) {
        this._on(type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      for (var i = 0, len = types.length; i < len; i++) {
        this._on(types[i], fn, context);
      }
    }
    return this;
  },
  /* @method off(type: String, fn?: Function, context?: Object): this
   * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
   *
   * @alternative
   * @method off(eventMap: Object): this
   * Removes a set of type/listener pairs.
   *
   * @alternative
   * @method off: this
   * Removes all listeners to all events on the object. This includes implicitly attached events.
   */
  off: function(types, fn, context) {
    if (!arguments.length) {
      delete this._events;
    } else if (typeof types === "object") {
      for (var type in types) {
        this._off(type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      var removeAll = arguments.length === 1;
      for (var i = 0, len = types.length; i < len; i++) {
        if (removeAll) {
          this._off(types[i]);
        } else {
          this._off(types[i], fn, context);
        }
      }
    }
    return this;
  },
  // attach listener (without syntactic sugar now)
  _on: function(type, fn, context, _once) {
    if (typeof fn !== "function") {
      console.warn("wrong listener type: " + typeof fn);
      return;
    }
    if (this._listens(type, fn, context) !== false) {
      return;
    }
    if (context === this) {
      context = void 0;
    }
    var newListener = { fn, ctx: context };
    if (_once) {
      newListener.once = true;
    }
    this._events = this._events || {};
    this._events[type] = this._events[type] || [];
    this._events[type].push(newListener);
  },
  _off: function(type, fn, context) {
    var listeners, i, len;
    if (!this._events) {
      return;
    }
    listeners = this._events[type];
    if (!listeners) {
      return;
    }
    if (arguments.length === 1) {
      if (this._firingCount) {
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        }
      }
      delete this._events[type];
      return;
    }
    if (typeof fn !== "function") {
      console.warn("wrong listener type: " + typeof fn);
      return;
    }
    var index = this._listens(type, fn, context);
    if (index !== false) {
      var listener = listeners[index];
      if (this._firingCount) {
        listener.fn = falseFn;
        this._events[type] = listeners = listeners.slice();
      }
      listeners.splice(index, 1);
    }
  },
  // @method fire(type: String, data?: Object, propagate?: Boolean): this
  // Fires an event of the specified type. You can optionally provide a data
  // object  the first argument of the listener function will contain its
  // properties. The event can optionally be propagated to event parents.
  fire: function(type, data2, propagate) {
    if (!this.listens(type, propagate)) {
      return this;
    }
    var event = extend({}, data2, {
      type,
      target: this,
      sourceTarget: data2 && data2.sourceTarget || this
    });
    if (this._events) {
      var listeners = this._events[type];
      if (listeners) {
        this._firingCount = this._firingCount + 1 || 1;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];
          var fn = l.fn;
          if (l.once) {
            this.off(type, fn, l.ctx);
          }
          fn.call(l.ctx || this, event);
        }
        this._firingCount--;
      }
    }
    if (propagate) {
      this._propagateEvent(event);
    }
    return this;
  },
  // @method listens(type: String, propagate?: Boolean): Boolean
  // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
  // Returns `true` if a particular event type has any listeners attached to it.
  // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
  listens: function(type, fn, context, propagate) {
    if (typeof type !== "string") {
      console.warn('"string" type argument expected');
    }
    var _fn = fn;
    if (typeof fn !== "function") {
      propagate = !!fn;
      _fn = void 0;
      context = void 0;
    }
    var listeners = this._events && this._events[type];
    if (listeners && listeners.length) {
      if (this._listens(type, _fn, context) !== false) {
        return true;
      }
    }
    if (propagate) {
      for (var id in this._eventParents) {
        if (this._eventParents[id].listens(type, fn, context, propagate)) {
          return true;
        }
      }
    }
    return false;
  },
  // returns the index (number) or false
  _listens: function(type, fn, context) {
    if (!this._events) {
      return false;
    }
    var listeners = this._events[type] || [];
    if (!fn) {
      return !!listeners.length;
    }
    if (context === this) {
      context = void 0;
    }
    for (var i = 0, len = listeners.length; i < len; i++) {
      if (listeners[i].fn === fn && listeners[i].ctx === context) {
        return i;
      }
    }
    return false;
  },
  // @method once(): this
  // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
  once: function(types, fn, context) {
    if (typeof types === "object") {
      for (var type in types) {
        this._on(type, types[type], fn, true);
      }
    } else {
      types = splitWords(types);
      for (var i = 0, len = types.length; i < len; i++) {
        this._on(types[i], fn, context, true);
      }
    }
    return this;
  },
  // @method addEventParent(obj: Evented): this
  // Adds an event parent - an `Evented` that will receive propagated events
  addEventParent: function(obj) {
    this._eventParents = this._eventParents || {};
    this._eventParents[stamp(obj)] = obj;
    return this;
  },
  // @method removeEventParent(obj: Evented): this
  // Removes an event parent, so it will stop receiving propagated events
  removeEventParent: function(obj) {
    if (this._eventParents) {
      delete this._eventParents[stamp(obj)];
    }
    return this;
  },
  _propagateEvent: function(e) {
    for (var id in this._eventParents) {
      this._eventParents[id].fire(e.type, extend({
        layer: e.target,
        propagatedFrom: e.target
      }, e), true);
    }
  }
};
Events.addEventListener = Events.on;
Events.removeEventListener = Events.clearAllEventListeners = Events.off;
Events.addOneTimeEventListener = Events.once;
Events.fireEvent = Events.fire;
Events.hasEventListeners = Events.listens;
var Evented = Class.extend(Events);
function Point(x, y, round) {
  this.x = round ? Math.round(x) : x;
  this.y = round ? Math.round(y) : y;
}
var trunc = Math.trunc || function(v) {
  return v > 0 ? Math.floor(v) : Math.ceil(v);
};
Point.prototype = {
  // @method clone(): Point
  // Returns a copy of the current point.
  clone: function() {
    return new Point(this.x, this.y);
  },
  // @method add(otherPoint: Point): Point
  // Returns the result of addition of the current and the given points.
  add: function(point) {
    return this.clone()._add(toPoint(point));
  },
  _add: function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
  },
  // @method subtract(otherPoint: Point): Point
  // Returns the result of subtraction of the given point from the current.
  subtract: function(point) {
    return this.clone()._subtract(toPoint(point));
  },
  _subtract: function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
  },
  // @method divideBy(num: Number): Point
  // Returns the result of division of the current point by the given number.
  divideBy: function(num) {
    return this.clone()._divideBy(num);
  },
  _divideBy: function(num) {
    this.x /= num;
    this.y /= num;
    return this;
  },
  // @method multiplyBy(num: Number): Point
  // Returns the result of multiplication of the current point by the given number.
  multiplyBy: function(num) {
    return this.clone()._multiplyBy(num);
  },
  _multiplyBy: function(num) {
    this.x *= num;
    this.y *= num;
    return this;
  },
  // @method scaleBy(scale: Point): Point
  // Multiply each coordinate of the current point by each coordinate of
  // `scale`. In linear algebra terms, multiply the point by the
  // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  // defined by `scale`.
  scaleBy: function(point) {
    return new Point(this.x * point.x, this.y * point.y);
  },
  // @method unscaleBy(scale: Point): Point
  // Inverse of `scaleBy`. Divide each coordinate of the current point by
  // each coordinate of `scale`.
  unscaleBy: function(point) {
    return new Point(this.x / point.x, this.y / point.y);
  },
  // @method round(): Point
  // Returns a copy of the current point with rounded coordinates.
  round: function() {
    return this.clone()._round();
  },
  _round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  // @method floor(): Point
  // Returns a copy of the current point with floored coordinates (rounded down).
  floor: function() {
    return this.clone()._floor();
  },
  _floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  // @method ceil(): Point
  // Returns a copy of the current point with ceiled coordinates (rounded up).
  ceil: function() {
    return this.clone()._ceil();
  },
  _ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  // @method trunc(): Point
  // Returns a copy of the current point with truncated coordinates (rounded towards zero).
  trunc: function() {
    return this.clone()._trunc();
  },
  _trunc: function() {
    this.x = trunc(this.x);
    this.y = trunc(this.y);
    return this;
  },
  // @method distanceTo(otherPoint: Point): Number
  // Returns the cartesian distance between the current and the given points.
  distanceTo: function(point) {
    point = toPoint(point);
    var x = point.x - this.x, y = point.y - this.y;
    return Math.sqrt(x * x + y * y);
  },
  // @method equals(otherPoint: Point): Boolean
  // Returns `true` if the given point has the same coordinates.
  equals: function(point) {
    point = toPoint(point);
    return point.x === this.x && point.y === this.y;
  },
  // @method contains(otherPoint: Point): Boolean
  // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  contains: function(point) {
    point = toPoint(point);
    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
  },
  // @method toString(): String
  // Returns a string representation of the point for debugging purposes.
  toString: function() {
    return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
  }
};
function toPoint(x, y, round) {
  if (x instanceof Point) {
    return x;
  }
  if (isArray3(x)) {
    return new Point(x[0], x[1]);
  }
  if (x === void 0 || x === null) {
    return x;
  }
  if (typeof x === "object" && "x" in x && "y" in x) {
    return new Point(x.x, x.y);
  }
  return new Point(x, y, round);
}
function Bounds(a, b) {
  if (!a) {
    return;
  }
  var points = b ? [a, b] : a;
  for (var i = 0, len = points.length; i < len; i++) {
    this.extend(points[i]);
  }
}
Bounds.prototype = {
  // @method extend(point: Point): this
  // Extends the bounds to contain the given point.
  // @alternative
  // @method extend(otherBounds: Bounds): this
  // Extend the bounds to contain the given bounds
  extend: function(obj) {
    var min2, max2;
    if (!obj) {
      return this;
    }
    if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
      min2 = max2 = toPoint(obj);
    } else {
      obj = toBounds(obj);
      min2 = obj.min;
      max2 = obj.max;
      if (!min2 || !max2) {
        return this;
      }
    }
    if (!this.min && !this.max) {
      this.min = min2.clone();
      this.max = max2.clone();
    } else {
      this.min.x = Math.min(min2.x, this.min.x);
      this.max.x = Math.max(max2.x, this.max.x);
      this.min.y = Math.min(min2.y, this.min.y);
      this.max.y = Math.max(max2.y, this.max.y);
    }
    return this;
  },
  // @method getCenter(round?: Boolean): Point
  // Returns the center point of the bounds.
  getCenter: function(round) {
    return toPoint(
      (this.min.x + this.max.x) / 2,
      (this.min.y + this.max.y) / 2,
      round
    );
  },
  // @method getBottomLeft(): Point
  // Returns the bottom-left point of the bounds.
  getBottomLeft: function() {
    return toPoint(this.min.x, this.max.y);
  },
  // @method getTopRight(): Point
  // Returns the top-right point of the bounds.
  getTopRight: function() {
    return toPoint(this.max.x, this.min.y);
  },
  // @method getTopLeft(): Point
  // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
  getTopLeft: function() {
    return this.min;
  },
  // @method getBottomRight(): Point
  // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
  getBottomRight: function() {
    return this.max;
  },
  // @method getSize(): Point
  // Returns the size of the given bounds
  getSize: function() {
    return this.max.subtract(this.min);
  },
  // @method contains(otherBounds: Bounds): Boolean
  // Returns `true` if the rectangle contains the given one.
  // @alternative
  // @method contains(point: Point): Boolean
  // Returns `true` if the rectangle contains the given point.
  contains: function(obj) {
    var min, max;
    if (typeof obj[0] === "number" || obj instanceof Point) {
      obj = toPoint(obj);
    } else {
      obj = toBounds(obj);
    }
    if (obj instanceof Bounds) {
      min = obj.min;
      max = obj.max;
    } else {
      min = max = obj;
    }
    return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
  },
  // @method intersects(otherBounds: Bounds): Boolean
  // Returns `true` if the rectangle intersects the given bounds. Two bounds
  // intersect if they have at least one point in common.
  intersects: function(bounds) {
    bounds = toBounds(bounds);
    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
    return xIntersects && yIntersects;
  },
  // @method overlaps(otherBounds: Bounds): Boolean
  // Returns `true` if the rectangle overlaps the given bounds. Two bounds
  // overlap if their intersection is an area.
  overlaps: function(bounds) {
    bounds = toBounds(bounds);
    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
    return xOverlaps && yOverlaps;
  },
  // @method isValid(): Boolean
  // Returns `true` if the bounds are properly initialized.
  isValid: function() {
    return !!(this.min && this.max);
  },
  // @method pad(bufferRatio: Number): Bounds
  // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  // Negative values will retract the bounds.
  pad: function(bufferRatio) {
    var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
    return toBounds(
      toPoint(min.x - heightBuffer, min.y - widthBuffer),
      toPoint(max.x + heightBuffer, max.y + widthBuffer)
    );
  },
  // @method equals(otherBounds: Bounds): Boolean
  // Returns `true` if the rectangle is equivalent to the given bounds.
  equals: function(bounds) {
    if (!bounds) {
      return false;
    }
    bounds = toBounds(bounds);
    return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
  }
};
function toBounds(a, b) {
  if (!a || a instanceof Bounds) {
    return a;
  }
  return new Bounds(a, b);
}
function LatLngBounds(corner1, corner2) {
  if (!corner1) {
    return;
  }
  var latlngs = corner2 ? [corner1, corner2] : corner1;
  for (var i = 0, len = latlngs.length; i < len; i++) {
    this.extend(latlngs[i]);
  }
}
LatLngBounds.prototype = {
  // @method extend(latlng: LatLng): this
  // Extend the bounds to contain the given point
  // @alternative
  // @method extend(otherBounds: LatLngBounds): this
  // Extend the bounds to contain the given bounds
  extend: function(obj) {
    var sw = this._southWest, ne = this._northEast, sw2, ne2;
    if (obj instanceof LatLng) {
      sw2 = obj;
      ne2 = obj;
    } else if (obj instanceof LatLngBounds) {
      sw2 = obj._southWest;
      ne2 = obj._northEast;
      if (!sw2 || !ne2) {
        return this;
      }
    } else {
      return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
    }
    if (!sw && !ne) {
      this._southWest = new LatLng(sw2.lat, sw2.lng);
      this._northEast = new LatLng(ne2.lat, ne2.lng);
    } else {
      sw.lat = Math.min(sw2.lat, sw.lat);
      sw.lng = Math.min(sw2.lng, sw.lng);
      ne.lat = Math.max(ne2.lat, ne.lat);
      ne.lng = Math.max(ne2.lng, ne.lng);
    }
    return this;
  },
  // @method pad(bufferRatio: Number): LatLngBounds
  // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  // Negative values will retract the bounds.
  pad: function(bufferRatio) {
    var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
    return new LatLngBounds(
      new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
      new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
    );
  },
  // @method getCenter(): LatLng
  // Returns the center point of the bounds.
  getCenter: function() {
    return new LatLng(
      (this._southWest.lat + this._northEast.lat) / 2,
      (this._southWest.lng + this._northEast.lng) / 2
    );
  },
  // @method getSouthWest(): LatLng
  // Returns the south-west point of the bounds.
  getSouthWest: function() {
    return this._southWest;
  },
  // @method getNorthEast(): LatLng
  // Returns the north-east point of the bounds.
  getNorthEast: function() {
    return this._northEast;
  },
  // @method getNorthWest(): LatLng
  // Returns the north-west point of the bounds.
  getNorthWest: function() {
    return new LatLng(this.getNorth(), this.getWest());
  },
  // @method getSouthEast(): LatLng
  // Returns the south-east point of the bounds.
  getSouthEast: function() {
    return new LatLng(this.getSouth(), this.getEast());
  },
  // @method getWest(): Number
  // Returns the west longitude of the bounds
  getWest: function() {
    return this._southWest.lng;
  },
  // @method getSouth(): Number
  // Returns the south latitude of the bounds
  getSouth: function() {
    return this._southWest.lat;
  },
  // @method getEast(): Number
  // Returns the east longitude of the bounds
  getEast: function() {
    return this._northEast.lng;
  },
  // @method getNorth(): Number
  // Returns the north latitude of the bounds
  getNorth: function() {
    return this._northEast.lat;
  },
  // @method contains(otherBounds: LatLngBounds): Boolean
  // Returns `true` if the rectangle contains the given one.
  // @alternative
  // @method contains (latlng: LatLng): Boolean
  // Returns `true` if the rectangle contains the given point.
  contains: function(obj) {
    if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
      obj = toLatLng(obj);
    } else {
      obj = toLatLngBounds(obj);
    }
    var sw = this._southWest, ne = this._northEast, sw2, ne2;
    if (obj instanceof LatLngBounds) {
      sw2 = obj.getSouthWest();
      ne2 = obj.getNorthEast();
    } else {
      sw2 = ne2 = obj;
    }
    return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
  },
  // @method intersects(otherBounds: LatLngBounds): Boolean
  // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
  intersects: function(bounds) {
    bounds = toLatLngBounds(bounds);
    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
    return latIntersects && lngIntersects;
  },
  // @method overlaps(otherBounds: LatLngBounds): Boolean
  // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
  overlaps: function(bounds) {
    bounds = toLatLngBounds(bounds);
    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
    return latOverlaps && lngOverlaps;
  },
  // @method toBBoxString(): String
  // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
  toBBoxString: function() {
    return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
  },
  // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
  // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
  equals: function(bounds, maxMargin) {
    if (!bounds) {
      return false;
    }
    bounds = toLatLngBounds(bounds);
    return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
  },
  // @method isValid(): Boolean
  // Returns `true` if the bounds are properly initialized.
  isValid: function() {
    return !!(this._southWest && this._northEast);
  }
};
function toLatLngBounds(a, b) {
  if (a instanceof LatLngBounds) {
    return a;
  }
  return new LatLngBounds(a, b);
}
function LatLng(lat, lng, alt) {
  if (isNaN(lat) || isNaN(lng)) {
    throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
  }
  this.lat = +lat;
  this.lng = +lng;
  if (alt !== void 0) {
    this.alt = +alt;
  }
}
LatLng.prototype = {
  // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
  // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
  equals: function(obj, maxMargin) {
    if (!obj) {
      return false;
    }
    obj = toLatLng(obj);
    var margin = Math.max(
      Math.abs(this.lat - obj.lat),
      Math.abs(this.lng - obj.lng)
    );
    return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
  },
  // @method toString(): String
  // Returns a string representation of the point (for debugging purposes).
  toString: function(precision) {
    return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
  },
  // @method distanceTo(otherLatLng: LatLng): Number
  // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
  distanceTo: function(other) {
    return Earth.distance(this, toLatLng(other));
  },
  // @method wrap(): LatLng
  // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
  wrap: function() {
    return Earth.wrapLatLng(this);
  },
  // @method toBounds(sizeInMeters: Number): LatLngBounds
  // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
  toBounds: function(sizeInMeters) {
    var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
    return toLatLngBounds(
      [this.lat - latAccuracy, this.lng - lngAccuracy],
      [this.lat + latAccuracy, this.lng + lngAccuracy]
    );
  },
  clone: function() {
    return new LatLng(this.lat, this.lng, this.alt);
  }
};
function toLatLng(a, b, c) {
  if (a instanceof LatLng) {
    return a;
  }
  if (isArray3(a) && typeof a[0] !== "object") {
    if (a.length === 3) {
      return new LatLng(a[0], a[1], a[2]);
    }
    if (a.length === 2) {
      return new LatLng(a[0], a[1]);
    }
    return null;
  }
  if (a === void 0 || a === null) {
    return a;
  }
  if (typeof a === "object" && "lat" in a) {
    return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
  }
  if (b === void 0) {
    return null;
  }
  return new LatLng(a, b, c);
}
var CRS = {
  // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
  // Projects geographical coordinates into pixel coordinates for a given zoom.
  latLngToPoint: function(latlng, zoom2) {
    var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
    return this.transformation._transform(projectedPoint, scale2);
  },
  // @method pointToLatLng(point: Point, zoom: Number): LatLng
  // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
  // zoom into geographical coordinates.
  pointToLatLng: function(point, zoom2) {
    var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
    return this.projection.unproject(untransformedPoint);
  },
  // @method project(latlng: LatLng): Point
  // Projects geographical coordinates into coordinates in units accepted for
  // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
  project: function(latlng) {
    return this.projection.project(latlng);
  },
  // @method unproject(point: Point): LatLng
  // Given a projected coordinate returns the corresponding LatLng.
  // The inverse of `project`.
  unproject: function(point) {
    return this.projection.unproject(point);
  },
  // @method scale(zoom: Number): Number
  // Returns the scale used when transforming projected coordinates into
  // pixel coordinates for a particular zoom. For example, it returns
  // `256 * 2^zoom` for Mercator-based CRS.
  scale: function(zoom2) {
    return 256 * Math.pow(2, zoom2);
  },
  // @method zoom(scale: Number): Number
  // Inverse of `scale()`, returns the zoom level corresponding to a scale
  // factor of `scale`.
  zoom: function(scale2) {
    return Math.log(scale2 / 256) / Math.LN2;
  },
  // @method getProjectedBounds(zoom: Number): Bounds
  // Returns the projection's bounds scaled and transformed for the provided `zoom`.
  getProjectedBounds: function(zoom2) {
    if (this.infinite) {
      return null;
    }
    var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
    return new Bounds(min, max);
  },
  // @method distance(latlng1: LatLng, latlng2: LatLng): Number
  // Returns the distance between two geographical coordinates.
  // @property code: String
  // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
  //
  // @property wrapLng: Number[]
  // An array of two numbers defining whether the longitude (horizontal) coordinate
  // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
  // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
  //
  // @property wrapLat: Number[]
  // Like `wrapLng`, but for the latitude (vertical) axis.
  // wrapLng: [min, max],
  // wrapLat: [min, max],
  // @property infinite: Boolean
  // If true, the coordinate space will be unbounded (infinite in both axes)
  infinite: false,
  // @method wrapLatLng(latlng: LatLng): LatLng
  // Returns a `LatLng` where lat and lng has been wrapped according to the
  // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
  wrapLatLng: function(latlng) {
    var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
    return new LatLng(lat, lng, alt);
  },
  // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  // Returns a `LatLngBounds` with the same size as the given one, ensuring
  // that its center is within the CRS's bounds.
  // Only accepts actual `L.LatLngBounds` instances, not arrays.
  wrapLatLngBounds: function(bounds) {
    var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
    if (latShift === 0 && lngShift === 0) {
      return bounds;
    }
    var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
    return new LatLngBounds(newSw, newNe);
  }
};
var Earth = extend({}, CRS, {
  wrapLng: [-180, 180],
  // Mean Earth Radius, as recommended for use by
  // the International Union of Geodesy and Geophysics,
  // see https://rosettacode.org/wiki/Haversine_formula
  R: 6371e3,
  // distance between two geographical points using spherical law of cosines approximation
  distance: function(latlng1, latlng2) {
    var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return this.R * c;
  }
});
var earthRadius = 6378137;
var SphericalMercator = {
  R: earthRadius,
  MAX_LATITUDE: 85.0511287798,
  project: function(latlng) {
    var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
    return new Point(
      this.R * latlng.lng * d,
      this.R * Math.log((1 + sin) / (1 - sin)) / 2
    );
  },
  unproject: function(point) {
    var d = 180 / Math.PI;
    return new LatLng(
      (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
      point.x * d / this.R
    );
  },
  bounds: function() {
    var d = earthRadius * Math.PI;
    return new Bounds([-d, -d], [d, d]);
  }()
};
function Transformation(a, b, c, d) {
  if (isArray3(a)) {
    this._a = a[0];
    this._b = a[1];
    this._c = a[2];
    this._d = a[3];
    return;
  }
  this._a = a;
  this._b = b;
  this._c = c;
  this._d = d;
}
Transformation.prototype = {
  // @method transform(point: Point, scale?: Number): Point
  // Returns a transformed point, optionally multiplied by the given scale.
  // Only accepts actual `L.Point` instances, not arrays.
  transform: function(point, scale2) {
    return this._transform(point.clone(), scale2);
  },
  // destructive transform (faster)
  _transform: function(point, scale2) {
    scale2 = scale2 || 1;
    point.x = scale2 * (this._a * point.x + this._b);
    point.y = scale2 * (this._c * point.y + this._d);
    return point;
  },
  // @method untransform(point: Point, scale?: Number): Point
  // Returns the reverse transformation of the given point, optionally divided
  // by the given scale. Only accepts actual `L.Point` instances, not arrays.
  untransform: function(point, scale2) {
    scale2 = scale2 || 1;
    return new Point(
      (point.x / scale2 - this._b) / this._a,
      (point.y / scale2 - this._d) / this._c
    );
  }
};
function toTransformation(a, b, c, d) {
  return new Transformation(a, b, c, d);
}
var EPSG3857 = extend({}, Earth, {
  code: "EPSG:3857",
  projection: SphericalMercator,
  transformation: function() {
    var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
    return toTransformation(scale2, 0.5, -scale2, 0.5);
  }()
});
var EPSG900913 = extend({}, EPSG3857, {
  code: "EPSG:900913"
});
function svgCreate(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function pointsToPath(rings, closed) {
  var str = "", i, j, len, len2, points, p;
  for (i = 0, len = rings.length; i < len; i++) {
    points = rings[i];
    for (j = 0, len2 = points.length; j < len2; j++) {
      p = points[j];
      str += (j ? "L" : "M") + p.x + " " + p.y;
    }
    str += closed ? Browser.svg ? "z" : "x" : "";
  }
  return str || "M0 0";
}
var style = document.documentElement.style;
var ie = "ActiveXObject" in window;
var ielt9 = ie && !document.addEventListener;
var edge = "msLaunchUri" in navigator && !("documentMode" in document);
var webkit = userAgentContains("webkit");
var android = userAgentContains("android");
var android23 = userAgentContains("android 2") || userAgentContains("android 3");
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
var opera = !!window.opera;
var chrome = !edge && userAgentContains("chrome");
var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
var safari = !chrome && userAgentContains("safari");
var phantom = userAgentContains("phantom");
var opera12 = "OTransition" in style;
var win = navigator.platform.indexOf("Win") === 0;
var ie3d = ie && "transition" in style;
var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
var gecko3d = "MozPerspective" in style;
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
var mobileWebkit = mobile && webkit;
var mobileWebkit3d = mobile && webkit3d;
var msPointer = !window.PointerEvent && window.MSPointerEvent;
var pointer = !!(window.PointerEvent || msPointer);
var touchNative = "ontouchstart" in window || !!window.TouchEvent;
var touch = !window.L_NO_TOUCH && (touchNative || pointer);
var mobileOpera = mobile && opera;
var mobileGecko = mobile && gecko;
var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
var passiveEvents = function() {
  var supportsPassiveOption = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassiveOption = true;
      }
    });
    window.addEventListener("testPassiveEventSupport", falseFn, opts);
    window.removeEventListener("testPassiveEventSupport", falseFn, opts);
  } catch (e) {
  }
  return supportsPassiveOption;
}();
var canvas$1 = function() {
  return !!document.createElement("canvas").getContext;
}();
var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
var inlineSvg = !!svg$1 && function() {
  var div = document.createElement("div");
  div.innerHTML = "<svg/>";
  return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
}();
var vml = !svg$1 && function() {
  try {
    var div = document.createElement("div");
    div.innerHTML = '<v:shape adj="1"/>';
    var shape = div.firstChild;
    shape.style.behavior = "url(#default#VML)";
    return shape && typeof shape.adj === "object";
  } catch (e) {
    return false;
  }
}();
var mac = navigator.platform.indexOf("Mac") === 0;
var linux = navigator.platform.indexOf("Linux") === 0;
function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}
var Browser = {
  ie,
  ielt9,
  edge,
  webkit,
  android,
  android23,
  androidStock,
  opera,
  chrome,
  gecko,
  safari,
  phantom,
  opera12,
  win,
  ie3d,
  webkit3d,
  gecko3d,
  any3d,
  mobile,
  mobileWebkit,
  mobileWebkit3d,
  msPointer,
  pointer,
  touch,
  touchNative,
  mobileOpera,
  mobileGecko,
  retina,
  passiveEvents,
  canvas: canvas$1,
  svg: svg$1,
  vml,
  inlineSvg,
  mac,
  linux
};
var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
var pEvent = {
  touchstart: POINTER_DOWN,
  touchmove: POINTER_MOVE,
  touchend: POINTER_UP,
  touchcancel: POINTER_CANCEL
};
var handle = {
  touchstart: _onPointerStart,
  touchmove: _handlePointer,
  touchend: _handlePointer,
  touchcancel: _handlePointer
};
var _pointers = {};
var _pointerDocListener = false;
function addPointerListener(obj, type, handler4) {
  if (type === "touchstart") {
    _addPointerDocListener();
  }
  if (!handle[type]) {
    console.warn("wrong event specified:", type);
    return falseFn;
  }
  handler4 = handle[type].bind(this, handler4);
  obj.addEventListener(pEvent[type], handler4, false);
  return handler4;
}
function removePointerListener(obj, type, handler4) {
  if (!pEvent[type]) {
    console.warn("wrong event specified:", type);
    return;
  }
  obj.removeEventListener(pEvent[type], handler4, false);
}
function _globalPointerDown(e) {
  _pointers[e.pointerId] = e;
}
function _globalPointerMove(e) {
  if (_pointers[e.pointerId]) {
    _pointers[e.pointerId] = e;
  }
}
function _globalPointerUp(e) {
  delete _pointers[e.pointerId];
}
function _addPointerDocListener() {
  if (!_pointerDocListener) {
    document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
    document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
    document.addEventListener(POINTER_UP, _globalPointerUp, true);
    document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
    _pointerDocListener = true;
  }
}
function _handlePointer(handler4, e) {
  if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
    return;
  }
  e.touches = [];
  for (var i in _pointers) {
    e.touches.push(_pointers[i]);
  }
  e.changedTouches = [e];
  handler4(e);
}
function _onPointerStart(handler4, e) {
  if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
    preventDefault(e);
  }
  _handlePointer(handler4, e);
}
function makeDblclick(event) {
  var newEvent = {}, prop, i;
  for (i in event) {
    prop = event[i];
    newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  }
  event = newEvent;
  newEvent.type = "dblclick";
  newEvent.detail = 2;
  newEvent.isTrusted = false;
  newEvent._simulated = true;
  return newEvent;
}
var delay3 = 200;
function addDoubleTapListener(obj, handler4) {
  obj.addEventListener("dblclick", handler4);
  var last = 0, detail;
  function simDblclick(e) {
    if (e.detail !== 1) {
      detail = e.detail;
      return;
    }
    if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
      return;
    }
    var path = getPropagationPath(e);
    if (path.some(function(el) {
      return el instanceof HTMLLabelElement && el.attributes.for;
    }) && !path.some(function(el) {
      return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
    })) {
      return;
    }
    var now = Date.now();
    if (now - last <= delay3) {
      detail++;
      if (detail === 2) {
        handler4(makeDblclick(e));
      }
    } else {
      detail = 1;
    }
    last = now;
  }
  obj.addEventListener("click", simDblclick);
  return {
    dblclick: handler4,
    simDblclick
  };
}
function removeDoubleTapListener(obj, handlers) {
  obj.removeEventListener("dblclick", handlers.dblclick);
  obj.removeEventListener("click", handlers.simDblclick);
}
var TRANSFORM = testProp(
  ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
);
var TRANSITION = testProp(
  ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
);
var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
function get3(id) {
  return typeof id === "string" ? document.getElementById(id) : id;
}
function getStyle(el, style2) {
  var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
  if ((!value || value === "auto") && document.defaultView) {
    var css = document.defaultView.getComputedStyle(el, null);
    value = css ? css[style2] : null;
  }
  return value === "auto" ? null : value;
}
function create$1(tagName, className, container) {
  var el = document.createElement(tagName);
  el.className = className || "";
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function remove(el) {
  var parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}
function empty(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
function toFront(el) {
  var parent = el.parentNode;
  if (parent && parent.lastChild !== el) {
    parent.appendChild(el);
  }
}
function toBack(el) {
  var parent = el.parentNode;
  if (parent && parent.firstChild !== el) {
    parent.insertBefore(el, parent.firstChild);
  }
}
function hasClass(el, name) {
  if (el.classList !== void 0) {
    return el.classList.contains(name);
  }
  var className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
function addClass(el, name) {
  if (el.classList !== void 0) {
    var classes = splitWords(name);
    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    var className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
function removeClass(el, name) {
  if (el.classList !== void 0) {
    el.classList.remove(name);
  } else {
    setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
  }
}
function setClass(el, name) {
  if (el.className.baseVal === void 0) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }
}
function getClass(el) {
  if (el.correspondingElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
}
function setOpacity(el, value) {
  if ("opacity" in el.style) {
    el.style.opacity = value;
  } else if ("filter" in el.style) {
    _setOpacityIE(el, value);
  }
}
function _setOpacityIE(el, value) {
  var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
  try {
    filter = el.filters.item(filterName);
  } catch (e) {
    if (value === 1) {
      return;
    }
  }
  value = Math.round(value * 100);
  if (filter) {
    filter.Enabled = value !== 100;
    filter.Opacity = value;
  } else {
    el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
  }
}
function testProp(props) {
  var style2 = document.documentElement.style;
  for (var i = 0; i < props.length; i++) {
    if (props[i] in style2) {
      return props[i];
    }
  }
  return false;
}
function setTransform(el, offset, scale2) {
  var pos = offset || new Point(0, 0);
  el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
}
function setPosition(el, point) {
  el._leaflet_pos = point;
  if (Browser.any3d) {
    setTransform(el, point);
  } else {
    el.style.left = point.x + "px";
    el.style.top = point.y + "px";
  }
}
function getPosition(el) {
  return el._leaflet_pos || new Point(0, 0);
}
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ("onselectstart" in document) {
  disableTextSelection = function() {
    on2(window, "selectstart", preventDefault);
  };
  enableTextSelection = function() {
    off(window, "selectstart", preventDefault);
  };
} else {
  userSelectProperty = testProp(
    ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
  );
  disableTextSelection = function() {
    if (userSelectProperty) {
      var style2 = document.documentElement.style;
      _userSelect = style2[userSelectProperty];
      style2[userSelectProperty] = "none";
    }
  };
  enableTextSelection = function() {
    if (userSelectProperty) {
      document.documentElement.style[userSelectProperty] = _userSelect;
      _userSelect = void 0;
    }
  };
}
var userSelectProperty;
function disableImageDrag() {
  on2(window, "dragstart", preventDefault);
}
function enableImageDrag() {
  off(window, "dragstart", preventDefault);
}
var _outlineElement;
var _outlineStyle;
function preventOutline(element) {
  while (element.tabIndex === -1) {
    element = element.parentNode;
  }
  if (!element.style) {
    return;
  }
  restoreOutline();
  _outlineElement = element;
  _outlineStyle = element.style.outlineStyle;
  element.style.outlineStyle = "none";
  on2(window, "keydown", restoreOutline);
}
function restoreOutline() {
  if (!_outlineElement) {
    return;
  }
  _outlineElement.style.outlineStyle = _outlineStyle;
  _outlineElement = void 0;
  _outlineStyle = void 0;
  off(window, "keydown", restoreOutline);
}
function getSizedParentNode(element) {
  do {
    element = element.parentNode;
  } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  return element;
}
function getScale(element) {
  var rect = element.getBoundingClientRect();
  return {
    x: rect.width / element.offsetWidth || 1,
    y: rect.height / element.offsetHeight || 1,
    boundingClientRect: rect
  };
}
var DomUtil = {
  __proto__: null,
  TRANSFORM,
  TRANSITION,
  TRANSITION_END,
  get: get3,
  getStyle,
  create: create$1,
  remove,
  empty,
  toFront,
  toBack,
  hasClass,
  addClass,
  removeClass,
  setClass,
  getClass,
  setOpacity,
  testProp,
  setTransform,
  setPosition,
  getPosition,
  get disableTextSelection() {
    return disableTextSelection;
  },
  get enableTextSelection() {
    return enableTextSelection;
  },
  disableImageDrag,
  enableImageDrag,
  preventOutline,
  restoreOutline,
  getSizedParentNode,
  getScale
};
function on2(obj, types, fn, context) {
  if (types && typeof types === "object") {
    for (var type in types) {
      addOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    for (var i = 0, len = types.length; i < len; i++) {
      addOne(obj, types[i], fn, context);
    }
  }
  return this;
}
var eventsKey = "_leaflet_events";
function off(obj, types, fn, context) {
  if (arguments.length === 1) {
    batchRemove(obj);
    delete obj[eventsKey];
  } else if (types && typeof types === "object") {
    for (var type in types) {
      removeOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    if (arguments.length === 2) {
      batchRemove(obj, function(type2) {
        return indexOf(types, type2) !== -1;
      });
    } else {
      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    }
  }
  return this;
}
function batchRemove(obj, filterFn) {
  for (var id in obj[eventsKey]) {
    var type = id.split(/\d/)[0];
    if (!filterFn || filterFn(type)) {
      removeOne(obj, type, null, null, id);
    }
  }
}
var mouseSubst = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  wheel: !("onwheel" in window) && "mousewheel"
};
function addOne(obj, type, fn, context) {
  var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
  if (obj[eventsKey] && obj[eventsKey][id]) {
    return this;
  }
  var handler4 = function(e) {
    return fn.call(context || obj, e || window.event);
  };
  var originalHandler = handler4;
  if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
    handler4 = addPointerListener(obj, type, handler4);
  } else if (Browser.touch && type === "dblclick") {
    handler4 = addDoubleTapListener(obj, handler4);
  } else if ("addEventListener" in obj) {
    if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
      obj.addEventListener(mouseSubst[type] || type, handler4, Browser.passiveEvents ? { passive: false } : false);
    } else if (type === "mouseenter" || type === "mouseleave") {
      handler4 = function(e) {
        e = e || window.event;
        if (isExternalTarget(obj, e)) {
          originalHandler(e);
        }
      };
      obj.addEventListener(mouseSubst[type], handler4, false);
    } else {
      obj.addEventListener(type, originalHandler, false);
    }
  } else {
    obj.attachEvent("on" + type, handler4);
  }
  obj[eventsKey] = obj[eventsKey] || {};
  obj[eventsKey][id] = handler4;
}
function removeOne(obj, type, fn, context, id) {
  id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
  var handler4 = obj[eventsKey] && obj[eventsKey][id];
  if (!handler4) {
    return this;
  }
  if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
    removePointerListener(obj, type, handler4);
  } else if (Browser.touch && type === "dblclick") {
    removeDoubleTapListener(obj, handler4);
  } else if ("removeEventListener" in obj) {
    obj.removeEventListener(mouseSubst[type] || type, handler4, false);
  } else {
    obj.detachEvent("on" + type, handler4);
  }
  obj[eventsKey][id] = null;
}
function stopPropagation(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  } else if (e.originalEvent) {
    e.originalEvent._stopped = true;
  } else {
    e.cancelBubble = true;
  }
  return this;
}
function disableScrollPropagation(el) {
  addOne(el, "wheel", stopPropagation);
  return this;
}
function disableClickPropagation(el) {
  on2(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
  el["_leaflet_disable_click"] = true;
  return this;
}
function preventDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
  return this;
}
function stop2(e) {
  preventDefault(e);
  stopPropagation(e);
  return this;
}
function getPropagationPath(ev) {
  if (ev.composedPath) {
    return ev.composedPath();
  }
  var path = [];
  var el = ev.target;
  while (el) {
    path.push(el);
    el = el.parentNode;
  }
  return path;
}
function getMousePosition(e, container) {
  if (!container) {
    return new Point(e.clientX, e.clientY);
  }
  var scale2 = getScale(container), offset = scale2.boundingClientRect;
  return new Point(
    // offset.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - offset.left) / scale2.x - container.clientLeft,
    (e.clientY - offset.top) / scale2.y - container.clientTop
  );
}
var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
function getWheelDelta(e) {
  return Browser.edge ? e.wheelDeltaY / 2 : (
    // Don't trust window-geometry-based delta
    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
      // Pixels
      e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
        // Lines
        e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
          // Pages
          e.deltaX || e.deltaZ ? 0 : (
            // Skip horizontal/depth wheel events
            e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
              // Legacy IE pixels
              e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                // Legacy Moz lines
                e.detail ? e.detail / -32765 * 60 : (
                  // Legacy Moz pages
                  0
                )
              )
            )
          )
        )
      )
    )
  );
}
function isExternalTarget(el, e) {
  var related = e.relatedTarget;
  if (!related) {
    return true;
  }
  try {
    while (related && related !== el) {
      related = related.parentNode;
    }
  } catch (err) {
    return false;
  }
  return related !== el;
}
var PosAnimation = Evented.extend({
  // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
  // Run an animation of a given element to a new position, optionally setting
  // duration in seconds (`0.25` by default) and easing linearity factor (3rd
  // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
  // `0.5` by default).
  run: function(el, newPos, duration, easeLinearity) {
    this.stop();
    this._el = el;
    this._inProgress = true;
    this._duration = duration || 0.25;
    this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
    this._startPos = getPosition(el);
    this._offset = newPos.subtract(this._startPos);
    this._startTime = +/* @__PURE__ */ new Date();
    this.fire("start");
    this._animate();
  },
  // @method stop()
  // Stops the animation (if currently running).
  stop: function() {
    if (!this._inProgress) {
      return;
    }
    this._step(true);
    this._complete();
  },
  _animate: function() {
    this._animId = requestAnimFrame(this._animate, this);
    this._step();
  },
  _step: function(round) {
    var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
    if (elapsed < duration) {
      this._runFrame(this._easeOut(elapsed / duration), round);
    } else {
      this._runFrame(1);
      this._complete();
    }
  },
  _runFrame: function(progress, round) {
    var pos = this._startPos.add(this._offset.multiplyBy(progress));
    if (round) {
      pos._round();
    }
    setPosition(this._el, pos);
    this.fire("step");
  },
  _complete: function() {
    cancelAnimFrame(this._animId);
    this._inProgress = false;
    this.fire("end");
  },
  _easeOut: function(t) {
    return 1 - Math.pow(1 - t, this._easeOutPower);
  }
});
var Map2 = Evented.extend({
  options: {
    // @section Map State Options
    // @option crs: CRS = L.CRS.EPSG3857
    // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
    // sure what it means.
    crs: EPSG3857,
    // @option center: LatLng = undefined
    // Initial geographic center of the map
    center: void 0,
    // @option zoom: Number = undefined
    // Initial map zoom level
    zoom: void 0,
    // @option minZoom: Number = *
    // Minimum zoom level of the map.
    // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
    // the lowest of their `minZoom` options will be used instead.
    minZoom: void 0,
    // @option maxZoom: Number = *
    // Maximum zoom level of the map.
    // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
    // the highest of their `maxZoom` options will be used instead.
    maxZoom: void 0,
    // @option layers: Layer[] = []
    // Array of layers that will be added to the map initially
    layers: [],
    // @option maxBounds: LatLngBounds = null
    // When this option is set, the map restricts the view to the given
    // geographical bounds, bouncing the user back if the user tries to pan
    // outside the view. To set the restriction dynamically, use
    // [`setMaxBounds`](#map-setmaxbounds) method.
    maxBounds: void 0,
    // @option renderer: Renderer = *
    // The default method for drawing vector layers on the map. `L.SVG`
    // or `L.Canvas` by default depending on browser support.
    renderer: void 0,
    // @section Animation Options
    // @option zoomAnimation: Boolean = true
    // Whether the map zoom animation is enabled. By default it's enabled
    // in all browsers that support CSS3 Transitions except Android.
    zoomAnimation: true,
    // @option zoomAnimationThreshold: Number = 4
    // Won't animate zoom if the zoom difference exceeds this value.
    zoomAnimationThreshold: 4,
    // @option fadeAnimation: Boolean = true
    // Whether the tile fade animation is enabled. By default it's enabled
    // in all browsers that support CSS3 Transitions except Android.
    fadeAnimation: true,
    // @option markerZoomAnimation: Boolean = true
    // Whether markers animate their zoom with the zoom animation, if disabled
    // they will disappear for the length of the animation. By default it's
    // enabled in all browsers that support CSS3 Transitions except Android.
    markerZoomAnimation: true,
    // @option transform3DLimit: Number = 2^23
    // Defines the maximum size of a CSS translation transform. The default
    // value should not be changed unless a web browser positions layers in
    // the wrong place after doing a large `panBy`.
    transform3DLimit: 8388608,
    // Precision limit of a 32-bit float
    // @section Interaction Options
    // @option zoomSnap: Number = 1
    // Forces the map's zoom level to always be a multiple of this, particularly
    // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
    // By default, the zoom level snaps to the nearest integer; lower values
    // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
    // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
    zoomSnap: 1,
    // @option zoomDelta: Number = 1
    // Controls how much the map's zoom level will change after a
    // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
    // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
    // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
    zoomDelta: 1,
    // @option trackResize: Boolean = true
    // Whether the map automatically handles browser window resize to update itself.
    trackResize: true
  },
  initialize: function(id, options) {
    options = setOptions(this, options);
    this._handlers = [];
    this._layers = {};
    this._zoomBoundLayers = {};
    this._sizeChanged = true;
    this._initContainer(id);
    this._initLayout();
    this._onResize = bind3(this._onResize, this);
    this._initEvents();
    if (options.maxBounds) {
      this.setMaxBounds(options.maxBounds);
    }
    if (options.zoom !== void 0) {
      this._zoom = this._limitZoom(options.zoom);
    }
    if (options.center && options.zoom !== void 0) {
      this.setView(toLatLng(options.center), options.zoom, { reset: true });
    }
    this.callInitHooks();
    this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
    if (this._zoomAnimated) {
      this._createAnimProxy();
      on2(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
    }
    this._addLayers(this.options.layers);
  },
  // @section Methods for modifying map state
  // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
  // Sets the view of the map (geographical center and zoom) with the given
  // animation options.
  setView: function(center, zoom2, options) {
    zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
    center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
    options = options || {};
    this._stop();
    if (this._loaded && !options.reset && options !== true) {
      if (options.animate !== void 0) {
        options.zoom = extend({ animate: options.animate }, options.zoom);
        options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
      }
      var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
      if (moved) {
        clearTimeout(this._sizeTimer);
        return this;
      }
    }
    this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
    return this;
  },
  // @method setZoom(zoom: Number, options?: Zoom/pan options): this
  // Sets the zoom of the map.
  setZoom: function(zoom2, options) {
    if (!this._loaded) {
      this._zoom = zoom2;
      return this;
    }
    return this.setView(this.getCenter(), zoom2, { zoom: options });
  },
  // @method zoomIn(delta?: Number, options?: Zoom options): this
  // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  zoomIn: function(delta, options) {
    delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
    return this.setZoom(this._zoom + delta, options);
  },
  // @method zoomOut(delta?: Number, options?: Zoom options): this
  // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  zoomOut: function(delta, options) {
    delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
    return this.setZoom(this._zoom - delta, options);
  },
  // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
  // Zooms the map while keeping a specified geographical point on the map
  // stationary (e.g. used internally for scroll zoom and double-click zoom).
  // @alternative
  // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
  // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
  setZoomAround: function(latlng, zoom2, options) {
    var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
    return this.setView(newCenter, zoom2, { zoom: options });
  },
  _getBoundsCenterZoom: function(bounds, options) {
    options = options || {};
    bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
    zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
    if (zoom2 === Infinity) {
      return {
        center: bounds.getCenter(),
        zoom: zoom2
      };
    }
    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
    return {
      center,
      zoom: zoom2
    };
  },
  // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
  // Sets a map view that contains the given geographical bounds with the
  // maximum zoom level possible.
  fitBounds: function(bounds, options) {
    bounds = toLatLngBounds(bounds);
    if (!bounds.isValid()) {
      throw new Error("Bounds are not valid.");
    }
    var target = this._getBoundsCenterZoom(bounds, options);
    return this.setView(target.center, target.zoom, options);
  },
  // @method fitWorld(options?: fitBounds options): this
  // Sets a map view that mostly contains the whole world with the maximum
  // zoom level possible.
  fitWorld: function(options) {
    return this.fitBounds([[-90, -180], [90, 180]], options);
  },
  // @method panTo(latlng: LatLng, options?: Pan options): this
  // Pans the map to a given center.
  panTo: function(center, options) {
    return this.setView(center, this._zoom, { pan: options });
  },
  // @method panBy(offset: Point, options?: Pan options): this
  // Pans the map by a given number of pixels (animated).
  panBy: function(offset, options) {
    offset = toPoint(offset).round();
    options = options || {};
    if (!offset.x && !offset.y) {
      return this.fire("moveend");
    }
    if (options.animate !== true && !this.getSize().contains(offset)) {
      this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
      return this;
    }
    if (!this._panAnim) {
      this._panAnim = new PosAnimation();
      this._panAnim.on({
        "step": this._onPanTransitionStep,
        "end": this._onPanTransitionEnd
      }, this);
    }
    if (!options.noMoveStart) {
      this.fire("movestart");
    }
    if (options.animate !== false) {
      addClass(this._mapPane, "leaflet-pan-anim");
      var newPos = this._getMapPanePos().subtract(offset).round();
      this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
    } else {
      this._rawPanBy(offset);
      this.fire("move").fire("moveend");
    }
    return this;
  },
  // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
  // Sets the view of the map (geographical center and zoom) performing a smooth
  // pan-zoom animation.
  flyTo: function(targetCenter, targetZoom, options) {
    options = options || {};
    if (options.animate === false || !Browser.any3d) {
      return this.setView(targetCenter, targetZoom, options);
    }
    this._stop();
    var from = this.project(this.getCenter()), to = this.project(targetCenter), size2 = this.getSize(), startZoom = this._zoom;
    targetCenter = toLatLng(targetCenter);
    targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
    var w0 = Math.max(size2.x, size2.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
    function r(i) {
      var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
      var log = sq < 1e-9 ? -18 : Math.log(sq);
      return log;
    }
    function sinh(n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    }
    function cosh(n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    }
    function tanh(n) {
      return sinh(n) / cosh(n);
    }
    var r0 = r(0);
    function w(s) {
      return w0 * (cosh(r0) / cosh(r0 + rho * s));
    }
    function u(s) {
      return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
    }
    function easeOut(t) {
      return 1 - Math.pow(1 - t, 1.5);
    }
    var start2 = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
    function frame() {
      var t = (Date.now() - start2) / duration, s = easeOut(t) * S;
      if (t <= 1) {
        this._flyToFrame = requestAnimFrame(frame, this);
        this._move(
          this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
          this.getScaleZoom(w0 / w(s), startZoom),
          { flyTo: true }
        );
      } else {
        this._move(targetCenter, targetZoom)._moveEnd(true);
      }
    }
    this._moveStart(true, options.noMoveStart);
    frame.call(this);
    return this;
  },
  // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
  // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
  // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
  flyToBounds: function(bounds, options) {
    var target = this._getBoundsCenterZoom(bounds, options);
    return this.flyTo(target.center, target.zoom, options);
  },
  // @method setMaxBounds(bounds: LatLngBounds): this
  // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
  setMaxBounds: function(bounds) {
    bounds = toLatLngBounds(bounds);
    if (this.listens("moveend", this._panInsideMaxBounds)) {
      this.off("moveend", this._panInsideMaxBounds);
    }
    if (!bounds.isValid()) {
      this.options.maxBounds = null;
      return this;
    }
    this.options.maxBounds = bounds;
    if (this._loaded) {
      this._panInsideMaxBounds();
    }
    return this.on("moveend", this._panInsideMaxBounds);
  },
  // @method setMinZoom(zoom: Number): this
  // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
  setMinZoom: function(zoom2) {
    var oldZoom = this.options.minZoom;
    this.options.minZoom = zoom2;
    if (this._loaded && oldZoom !== zoom2) {
      this.fire("zoomlevelschange");
      if (this.getZoom() < this.options.minZoom) {
        return this.setZoom(zoom2);
      }
    }
    return this;
  },
  // @method setMaxZoom(zoom: Number): this
  // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
  setMaxZoom: function(zoom2) {
    var oldZoom = this.options.maxZoom;
    this.options.maxZoom = zoom2;
    if (this._loaded && oldZoom !== zoom2) {
      this.fire("zoomlevelschange");
      if (this.getZoom() > this.options.maxZoom) {
        return this.setZoom(zoom2);
      }
    }
    return this;
  },
  // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
  // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
  panInsideBounds: function(bounds, options) {
    this._enforcingBounds = true;
    var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
    if (!center.equals(newCenter)) {
      this.panTo(newCenter, options);
    }
    this._enforcingBounds = false;
    return this;
  },
  // @method panInside(latlng: LatLng, options?: padding options): this
  // Pans the map the minimum amount to make the `latlng` visible. Use
  // padding options to fit the display to more restricted bounds.
  // If `latlng` is already within the (optionally padded) display bounds,
  // the map will not be panned.
  panInside: function(latlng, options) {
    options = options || {};
    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
    if (!paddedBounds.contains(pixelPoint)) {
      this._enforcingBounds = true;
      var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
      var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
      pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
      pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
      this.panTo(this.unproject(pixelCenter), options);
      this._enforcingBounds = false;
    }
    return this;
  },
  // @method invalidateSize(options: Zoom/pan options): this
  // Checks if the map container size changed and updates the map if so 
  // call it after you've changed the map size dynamically, also animating
  // pan by default. If `options.pan` is `false`, panning will not occur.
  // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
  // that it doesn't happen often even if the method is called many
  // times in a row.
  // @alternative
  // @method invalidateSize(animate: Boolean): this
  // Checks if the map container size changed and updates the map if so 
  // call it after you've changed the map size dynamically, also animating
  // pan by default.
  invalidateSize: function(options) {
    if (!this._loaded) {
      return this;
    }
    options = extend({
      animate: false,
      pan: true
    }, options === true ? { animate: true } : options);
    var oldSize = this.getSize();
    this._sizeChanged = true;
    this._lastCenter = null;
    var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
    if (!offset.x && !offset.y) {
      return this;
    }
    if (options.animate && options.pan) {
      this.panBy(offset);
    } else {
      if (options.pan) {
        this._rawPanBy(offset);
      }
      this.fire("move");
      if (options.debounceMoveend) {
        clearTimeout(this._sizeTimer);
        this._sizeTimer = setTimeout(bind3(this.fire, this, "moveend"), 200);
      } else {
        this.fire("moveend");
      }
    }
    return this.fire("resize", {
      oldSize,
      newSize
    });
  },
  // @section Methods for modifying map state
  // @method stop(): this
  // Stops the currently running `panTo` or `flyTo` animation, if any.
  stop: function() {
    this.setZoom(this._limitZoom(this._zoom));
    if (!this.options.zoomSnap) {
      this.fire("viewreset");
    }
    return this._stop();
  },
  // @section Geolocation methods
  // @method locate(options?: Locate options): this
  // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
  // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
  // and optionally sets the map view to the user's location with respect to
  // detection accuracy (or to the world view if geolocation failed).
  // Note that, if your page doesn't use HTTPS, this method will fail in
  // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
  // See `Locate options` for more details.
  locate: function(options) {
    options = this._locateOptions = extend({
      timeout: 1e4,
      watch: false
      // setView: false
      // maxZoom: <Number>
      // maximumAge: 0
      // enableHighAccuracy: false
    }, options);
    if (!("geolocation" in navigator)) {
      this._handleGeolocationError({
        code: 0,
        message: "Geolocation not supported."
      });
      return this;
    }
    var onResponse = bind3(this._handleGeolocationResponse, this), onError = bind3(this._handleGeolocationError, this);
    if (options.watch) {
      this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
    } else {
      navigator.geolocation.getCurrentPosition(onResponse, onError, options);
    }
    return this;
  },
  // @method stopLocate(): this
  // Stops watching location previously initiated by `map.locate({watch: true})`
  // and aborts resetting the map view if map.locate was called with
  // `{setView: true}`.
  stopLocate: function() {
    if (navigator.geolocation && navigator.geolocation.clearWatch) {
      navigator.geolocation.clearWatch(this._locationWatchId);
    }
    if (this._locateOptions) {
      this._locateOptions.setView = false;
    }
    return this;
  },
  _handleGeolocationError: function(error2) {
    if (!this._container._leaflet_id) {
      return;
    }
    var c = error2.code, message = error2.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
    if (this._locateOptions.setView && !this._loaded) {
      this.fitWorld();
    }
    this.fire("locationerror", {
      code: c,
      message: "Geolocation error: " + message + "."
    });
  },
  _handleGeolocationResponse: function(pos) {
    if (!this._container._leaflet_id) {
      return;
    }
    var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
    if (options.setView) {
      var zoom2 = this.getBoundsZoom(bounds);
      this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
    }
    var data2 = {
      latlng,
      bounds,
      timestamp: pos.timestamp
    };
    for (var i in pos.coords) {
      if (typeof pos.coords[i] === "number") {
        data2[i] = pos.coords[i];
      }
    }
    this.fire("locationfound", data2);
  },
  // TODO Appropriate docs section?
  // @section Other Methods
  // @method addHandler(name: String, HandlerClass: Function): this
  // Adds a new `Handler` to the map, given its name and constructor function.
  addHandler: function(name, HandlerClass) {
    if (!HandlerClass) {
      return this;
    }
    var handler4 = this[name] = new HandlerClass(this);
    this._handlers.push(handler4);
    if (this.options[name]) {
      handler4.enable();
    }
    return this;
  },
  // @method remove(): this
  // Destroys the map and clears all related event listeners.
  remove: function() {
    this._initEvents(true);
    if (this.options.maxBounds) {
      this.off("moveend", this._panInsideMaxBounds);
    }
    if (this._containerId !== this._container._leaflet_id) {
      throw new Error("Map container is being reused by another instance");
    }
    try {
      delete this._container._leaflet_id;
      delete this._containerId;
    } catch (e) {
      this._container._leaflet_id = void 0;
      this._containerId = void 0;
    }
    if (this._locationWatchId !== void 0) {
      this.stopLocate();
    }
    this._stop();
    remove(this._mapPane);
    if (this._clearControlPos) {
      this._clearControlPos();
    }
    if (this._resizeRequest) {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = null;
    }
    this._clearHandlers();
    if (this._loaded) {
      this.fire("unload");
    }
    var i;
    for (i in this._layers) {
      this._layers[i].remove();
    }
    for (i in this._panes) {
      remove(this._panes[i]);
    }
    this._layers = [];
    this._panes = [];
    delete this._mapPane;
    delete this._renderer;
    return this;
  },
  // @section Other Methods
  // @method createPane(name: String, container?: HTMLElement): HTMLElement
  // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
  // then returns it. The pane is created as a child of `container`, or
  // as a child of the main map pane if not set.
  createPane: function(name, container) {
    var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
    if (name) {
      this._panes[name] = pane;
    }
    return pane;
  },
  // @section Methods for Getting Map State
  // @method getCenter(): LatLng
  // Returns the geographical center of the map view
  getCenter: function() {
    this._checkIfLoaded();
    if (this._lastCenter && !this._moved()) {
      return this._lastCenter.clone();
    }
    return this.layerPointToLatLng(this._getCenterLayerPoint());
  },
  // @method getZoom(): Number
  // Returns the current zoom level of the map view
  getZoom: function() {
    return this._zoom;
  },
  // @method getBounds(): LatLngBounds
  // Returns the geographical bounds visible in the current map view
  getBounds: function() {
    var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
    return new LatLngBounds(sw, ne);
  },
  // @method getMinZoom(): Number
  // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
  getMinZoom: function() {
    return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
  },
  // @method getMaxZoom(): Number
  // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
  getMaxZoom: function() {
    return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
  },
  // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
  // Returns the maximum zoom level on which the given bounds fit to the map
  // view in its entirety. If `inside` (optional) is set to `true`, the method
  // instead returns the minimum zoom level on which the map view fits into
  // the given bounds in its entirety.
  getBoundsZoom: function(bounds, inside, padding) {
    bounds = toLatLngBounds(bounds);
    padding = toPoint(padding || [0, 0]);
    var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size2 = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size2.x / boundsSize.x, scaley = size2.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
    zoom2 = this.getScaleZoom(scale2, zoom2);
    if (snap) {
      zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
      zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
    }
    return Math.max(min, Math.min(max, zoom2));
  },
  // @method getSize(): Point
  // Returns the current size of the map container (in pixels).
  getSize: function() {
    if (!this._size || this._sizeChanged) {
      this._size = new Point(
        this._container.clientWidth || 0,
        this._container.clientHeight || 0
      );
      this._sizeChanged = false;
    }
    return this._size.clone();
  },
  // @method getPixelBounds(): Bounds
  // Returns the bounds of the current map view in projected pixel
  // coordinates (sometimes useful in layer and overlay implementations).
  getPixelBounds: function(center, zoom2) {
    var topLeftPoint = this._getTopLeftPoint(center, zoom2);
    return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  },
  // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
  // the map pane? "left point of the map layer" can be confusing, specially
  // since there can be negative offsets.
  // @method getPixelOrigin(): Point
  // Returns the projected pixel coordinates of the top left point of
  // the map layer (useful in custom layer and overlay implementations).
  getPixelOrigin: function() {
    this._checkIfLoaded();
    return this._pixelOrigin;
  },
  // @method getPixelWorldBounds(zoom?: Number): Bounds
  // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
  // If `zoom` is omitted, the map's current zoom level is used.
  getPixelWorldBounds: function(zoom2) {
    return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
  },
  // @section Other Methods
  // @method getPane(pane: String|HTMLElement): HTMLElement
  // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
  getPane: function(pane) {
    return typeof pane === "string" ? this._panes[pane] : pane;
  },
  // @method getPanes(): Object
  // Returns a plain object containing the names of all [panes](#map-pane) as keys and
  // the panes as values.
  getPanes: function() {
    return this._panes;
  },
  // @method getContainer: HTMLElement
  // Returns the HTML element that contains the map.
  getContainer: function() {
    return this._container;
  },
  // @section Conversion Methods
  // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
  // Returns the scale factor to be applied to a map transition from zoom level
  // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
  getZoomScale: function(toZoom, fromZoom) {
    var crs = this.options.crs;
    fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
    return crs.scale(toZoom) / crs.scale(fromZoom);
  },
  // @method getScaleZoom(scale: Number, fromZoom: Number): Number
  // Returns the zoom level that the map would end up at, if it is at `fromZoom`
  // level and everything is scaled by a factor of `scale`. Inverse of
  // [`getZoomScale`](#map-getZoomScale).
  getScaleZoom: function(scale2, fromZoom) {
    var crs = this.options.crs;
    fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
    var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
    return isNaN(zoom2) ? Infinity : zoom2;
  },
  // @method project(latlng: LatLng, zoom: Number): Point
  // Projects a geographical coordinate `LatLng` according to the projection
  // of the map's CRS, then scales it according to `zoom` and the CRS's
  // `Transformation`. The result is pixel coordinate relative to
  // the CRS origin.
  project: function(latlng, zoom2) {
    zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
    return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
  },
  // @method unproject(point: Point, zoom: Number): LatLng
  // Inverse of [`project`](#map-project).
  unproject: function(point, zoom2) {
    zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
    return this.options.crs.pointToLatLng(toPoint(point), zoom2);
  },
  // @method layerPointToLatLng(point: Point): LatLng
  // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  // returns the corresponding geographical coordinate (for the current zoom level).
  layerPointToLatLng: function(point) {
    var projectedPoint = toPoint(point).add(this.getPixelOrigin());
    return this.unproject(projectedPoint);
  },
  // @method latLngToLayerPoint(latlng: LatLng): Point
  // Given a geographical coordinate, returns the corresponding pixel coordinate
  // relative to the [origin pixel](#map-getpixelorigin).
  latLngToLayerPoint: function(latlng) {
    var projectedPoint = this.project(toLatLng(latlng))._round();
    return projectedPoint._subtract(this.getPixelOrigin());
  },
  // @method wrapLatLng(latlng: LatLng): LatLng
  // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
  // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
  // CRS's bounds.
  // By default this means longitude is wrapped around the dateline so its
  // value is between -180 and +180 degrees.
  wrapLatLng: function(latlng) {
    return this.options.crs.wrapLatLng(toLatLng(latlng));
  },
  // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  // Returns a `LatLngBounds` with the same size as the given one, ensuring that
  // its center is within the CRS's bounds.
  // By default this means the center longitude is wrapped around the dateline so its
  // value is between -180 and +180 degrees, and the majority of the bounds
  // overlaps the CRS's bounds.
  wrapLatLngBounds: function(latlng) {
    return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  },
  // @method distance(latlng1: LatLng, latlng2: LatLng): Number
  // Returns the distance between two geographical coordinates according to
  // the map's CRS. By default this measures distance in meters.
  distance: function(latlng1, latlng2) {
    return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  },
  // @method containerPointToLayerPoint(point: Point): Point
  // Given a pixel coordinate relative to the map container, returns the corresponding
  // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
  containerPointToLayerPoint: function(point) {
    return toPoint(point).subtract(this._getMapPanePos());
  },
  // @method layerPointToContainerPoint(point: Point): Point
  // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  // returns the corresponding pixel coordinate relative to the map container.
  layerPointToContainerPoint: function(point) {
    return toPoint(point).add(this._getMapPanePos());
  },
  // @method containerPointToLatLng(point: Point): LatLng
  // Given a pixel coordinate relative to the map container, returns
  // the corresponding geographical coordinate (for the current zoom level).
  containerPointToLatLng: function(point) {
    var layerPoint = this.containerPointToLayerPoint(toPoint(point));
    return this.layerPointToLatLng(layerPoint);
  },
  // @method latLngToContainerPoint(latlng: LatLng): Point
  // Given a geographical coordinate, returns the corresponding pixel coordinate
  // relative to the map container.
  latLngToContainerPoint: function(latlng) {
    return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  },
  // @method mouseEventToContainerPoint(ev: MouseEvent): Point
  // Given a MouseEvent object, returns the pixel coordinate relative to the
  // map container where the event took place.
  mouseEventToContainerPoint: function(e) {
    return getMousePosition(e, this._container);
  },
  // @method mouseEventToLayerPoint(ev: MouseEvent): Point
  // Given a MouseEvent object, returns the pixel coordinate relative to
  // the [origin pixel](#map-getpixelorigin) where the event took place.
  mouseEventToLayerPoint: function(e) {
    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  },
  // @method mouseEventToLatLng(ev: MouseEvent): LatLng
  // Given a MouseEvent object, returns geographical coordinate where the
  // event took place.
  mouseEventToLatLng: function(e) {
    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  },
  // map initialization methods
  _initContainer: function(id) {
    var container = this._container = get3(id);
    if (!container) {
      throw new Error("Map container not found.");
    } else if (container._leaflet_id) {
      throw new Error("Map container is already initialized.");
    }
    on2(container, "scroll", this._onScroll, this);
    this._containerId = stamp(container);
  },
  _initLayout: function() {
    var container = this._container;
    this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
    addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
    var position = getStyle(container, "position");
    if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
      container.style.position = "relative";
    }
    this._initPanes();
    if (this._initControlPos) {
      this._initControlPos();
    }
  },
  _initPanes: function() {
    var panes = this._panes = {};
    this._paneRenderers = {};
    this._mapPane = this.createPane("mapPane", this._container);
    setPosition(this._mapPane, new Point(0, 0));
    this.createPane("tilePane");
    this.createPane("overlayPane");
    this.createPane("shadowPane");
    this.createPane("markerPane");
    this.createPane("tooltipPane");
    this.createPane("popupPane");
    if (!this.options.markerZoomAnimation) {
      addClass(panes.markerPane, "leaflet-zoom-hide");
      addClass(panes.shadowPane, "leaflet-zoom-hide");
    }
  },
  // private methods that modify map state
  // @section Map state change events
  _resetView: function(center, zoom2, noMoveStart) {
    setPosition(this._mapPane, new Point(0, 0));
    var loading = !this._loaded;
    this._loaded = true;
    zoom2 = this._limitZoom(zoom2);
    this.fire("viewprereset");
    var zoomChanged = this._zoom !== zoom2;
    this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
    this.fire("viewreset");
    if (loading) {
      this.fire("load");
    }
  },
  _moveStart: function(zoomChanged, noMoveStart) {
    if (zoomChanged) {
      this.fire("zoomstart");
    }
    if (!noMoveStart) {
      this.fire("movestart");
    }
    return this;
  },
  _move: function(center, zoom2, data2, supressEvent) {
    if (zoom2 === void 0) {
      zoom2 = this._zoom;
    }
    var zoomChanged = this._zoom !== zoom2;
    this._zoom = zoom2;
    this._lastCenter = center;
    this._pixelOrigin = this._getNewPixelOrigin(center);
    if (!supressEvent) {
      if (zoomChanged || data2 && data2.pinch) {
        this.fire("zoom", data2);
      }
      this.fire("move", data2);
    } else if (data2 && data2.pinch) {
      this.fire("zoom", data2);
    }
    return this;
  },
  _moveEnd: function(zoomChanged) {
    if (zoomChanged) {
      this.fire("zoomend");
    }
    return this.fire("moveend");
  },
  _stop: function() {
    cancelAnimFrame(this._flyToFrame);
    if (this._panAnim) {
      this._panAnim.stop();
    }
    return this;
  },
  _rawPanBy: function(offset) {
    setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  },
  _getZoomSpan: function() {
    return this.getMaxZoom() - this.getMinZoom();
  },
  _panInsideMaxBounds: function() {
    if (!this._enforcingBounds) {
      this.panInsideBounds(this.options.maxBounds);
    }
  },
  _checkIfLoaded: function() {
    if (!this._loaded) {
      throw new Error("Set map center and zoom first.");
    }
  },
  // DOM event handling
  // @section Interaction events
  _initEvents: function(remove2) {
    this._targets = {};
    this._targets[stamp(this._container)] = this;
    var onOff = remove2 ? off : on2;
    onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
    if (this.options.trackResize) {
      onOff(window, "resize", this._onResize, this);
    }
    if (Browser.any3d && this.options.transform3DLimit) {
      (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
    }
  },
  _onResize: function() {
    cancelAnimFrame(this._resizeRequest);
    this._resizeRequest = requestAnimFrame(
      function() {
        this.invalidateSize({ debounceMoveend: true });
      },
      this
    );
  },
  _onScroll: function() {
    this._container.scrollTop = 0;
    this._container.scrollLeft = 0;
  },
  _onMoveEnd: function() {
    var pos = this._getMapPanePos();
    if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
      this._resetView(this.getCenter(), this.getZoom());
    }
  },
  _findEventTargets: function(e, type) {
    var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
    while (src) {
      target = this._targets[stamp(src)];
      if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
        dragging = true;
        break;
      }
      if (target && target.listens(type, true)) {
        if (isHover && !isExternalTarget(src, e)) {
          break;
        }
        targets.push(target);
        if (isHover) {
          break;
        }
      }
      if (src === this._container) {
        break;
      }
      src = src.parentNode;
    }
    if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
      targets = [this];
    }
    return targets;
  },
  _isClickDisabled: function(el) {
    while (el && el !== this._container) {
      if (el["_leaflet_disable_click"]) {
        return true;
      }
      el = el.parentNode;
    }
  },
  _handleDOMEvent: function(e) {
    var el = e.target || e.srcElement;
    if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
      return;
    }
    var type = e.type;
    if (type === "mousedown") {
      preventOutline(el);
    }
    this._fireDOMEvent(e, type);
  },
  _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
  _fireDOMEvent: function(e, type, canvasTargets) {
    if (e.type === "click") {
      var synth = extend({}, e);
      synth.type = "preclick";
      this._fireDOMEvent(synth, synth.type, canvasTargets);
    }
    var targets = this._findEventTargets(e, type);
    if (canvasTargets) {
      var filtered = [];
      for (var i = 0; i < canvasTargets.length; i++) {
        if (canvasTargets[i].listens(type, true)) {
          filtered.push(canvasTargets[i]);
        }
      }
      targets = filtered.concat(targets);
    }
    if (!targets.length) {
      return;
    }
    if (type === "contextmenu") {
      preventDefault(e);
    }
    var target = targets[0];
    var data2 = {
      originalEvent: e
    };
    if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
      var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
      data2.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
      data2.layerPoint = this.containerPointToLayerPoint(data2.containerPoint);
      data2.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data2.layerPoint);
    }
    for (i = 0; i < targets.length; i++) {
      targets[i].fire(type, data2, true);
      if (data2.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
        return;
      }
    }
  },
  _draggableMoved: function(obj) {
    obj = obj.dragging && obj.dragging.enabled() ? obj : this;
    return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
  },
  _clearHandlers: function() {
    for (var i = 0, len = this._handlers.length; i < len; i++) {
      this._handlers[i].disable();
    }
  },
  // @section Other Methods
  // @method whenReady(fn: Function, context?: Object): this
  // Runs the given function `fn` when the map gets initialized with
  // a view (center and zoom) and at least one layer, or immediately
  // if it's already initialized, optionally passing a function context.
  whenReady: function(callback, context) {
    if (this._loaded) {
      callback.call(context || this, { target: this });
    } else {
      this.on("load", callback, context);
    }
    return this;
  },
  // private methods for getting map state
  _getMapPanePos: function() {
    return getPosition(this._mapPane) || new Point(0, 0);
  },
  _moved: function() {
    var pos = this._getMapPanePos();
    return pos && !pos.equals([0, 0]);
  },
  _getTopLeftPoint: function(center, zoom2) {
    var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
    return pixelOrigin.subtract(this._getMapPanePos());
  },
  _getNewPixelOrigin: function(center, zoom2) {
    var viewHalf = this.getSize()._divideBy(2);
    return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  },
  _latLngToNewLayerPoint: function(latlng, zoom2, center) {
    var topLeft = this._getNewPixelOrigin(center, zoom2);
    return this.project(latlng, zoom2)._subtract(topLeft);
  },
  _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
    var topLeft = this._getNewPixelOrigin(center, zoom2);
    return toBounds([
      this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
    ]);
  },
  // layer point of the current center
  _getCenterLayerPoint: function() {
    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  },
  // offset of the specified place to the current center in pixels
  _getCenterOffset: function(latlng) {
    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  },
  // adjust center for view to get inside bounds
  _limitCenter: function(center, zoom2, bounds) {
    if (!bounds) {
      return center;
    }
    var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
    if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
      return center;
    }
    return this.unproject(centerPoint.add(offset), zoom2);
  },
  // adjust offset for view to get inside bounds
  _limitOffset: function(offset, bounds) {
    if (!bounds) {
      return offset;
    }
    var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
    return offset.add(this._getBoundsOffset(newBounds, bounds));
  },
  // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
  _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
    var projectedMaxBounds = toBounds(
      this.project(maxBounds.getNorthEast(), zoom2),
      this.project(maxBounds.getSouthWest(), zoom2)
    ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
    return new Point(dx, dy);
  },
  _rebound: function(left, right) {
    return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  },
  _limitZoom: function(zoom2) {
    var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
    if (snap) {
      zoom2 = Math.round(zoom2 / snap) * snap;
    }
    return Math.max(min, Math.min(max, zoom2));
  },
  _onPanTransitionStep: function() {
    this.fire("move");
  },
  _onPanTransitionEnd: function() {
    removeClass(this._mapPane, "leaflet-pan-anim");
    this.fire("moveend");
  },
  _tryAnimatedPan: function(center, options) {
    var offset = this._getCenterOffset(center)._trunc();
    if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
      return false;
    }
    this.panBy(offset, options);
    return true;
  },
  _createAnimProxy: function() {
    var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
    this._panes.mapPane.appendChild(proxy);
    this.on("zoomanim", function(e) {
      var prop = TRANSFORM, transform = this._proxy.style[prop];
      setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
      if (transform === this._proxy.style[prop] && this._animatingZoom) {
        this._onZoomTransitionEnd();
      }
    }, this);
    this.on("load moveend", this._animMoveEnd, this);
    this._on("unload", this._destroyAnimProxy, this);
  },
  _destroyAnimProxy: function() {
    remove(this._proxy);
    this.off("load moveend", this._animMoveEnd, this);
    delete this._proxy;
  },
  _animMoveEnd: function() {
    var c = this.getCenter(), z = this.getZoom();
    setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  },
  _catchTransitionEnd: function(e) {
    if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
      this._onZoomTransitionEnd();
    }
  },
  _nothingToAnimate: function() {
    return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
  },
  _tryAnimatedZoom: function(center, zoom2, options) {
    if (this._animatingZoom) {
      return true;
    }
    options = options || {};
    if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
      return false;
    }
    var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
    if (options.animate !== true && !this.getSize().contains(offset)) {
      return false;
    }
    requestAnimFrame(function() {
      this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
    }, this);
    return true;
  },
  _animateZoom: function(center, zoom2, startAnim, noUpdate) {
    if (!this._mapPane) {
      return;
    }
    if (startAnim) {
      this._animatingZoom = true;
      this._animateToCenter = center;
      this._animateToZoom = zoom2;
      addClass(this._mapPane, "leaflet-zoom-anim");
    }
    this.fire("zoomanim", {
      center,
      zoom: zoom2,
      noUpdate
    });
    if (!this._tempFireZoomEvent) {
      this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
    }
    this._move(this._animateToCenter, this._animateToZoom, void 0, true);
    setTimeout(bind3(this._onZoomTransitionEnd, this), 250);
  },
  _onZoomTransitionEnd: function() {
    if (!this._animatingZoom) {
      return;
    }
    if (this._mapPane) {
      removeClass(this._mapPane, "leaflet-zoom-anim");
    }
    this._animatingZoom = false;
    this._move(this._animateToCenter, this._animateToZoom, void 0, true);
    if (this._tempFireZoomEvent) {
      this.fire("zoom");
    }
    delete this._tempFireZoomEvent;
    this.fire("move");
    this._moveEnd(true);
  }
});
function createMap(id, options) {
  return new Map2(id, options);
}
var Control = Class.extend({
  // @section
  // @aka Control Options
  options: {
    // @option position: String = 'topright'
    // The position of the control (one of the map corners). Possible values are `'topleft'`,
    // `'topright'`, `'bottomleft'` or `'bottomright'`
    position: "topright"
  },
  initialize: function(options) {
    setOptions(this, options);
  },
  /* @section
   * Classes extending L.Control will inherit the following methods:
   *
   * @method getPosition: string
   * Returns the position of the control.
   */
  getPosition: function() {
    return this.options.position;
  },
  // @method setPosition(position: string): this
  // Sets the position of the control.
  setPosition: function(position) {
    var map = this._map;
    if (map) {
      map.removeControl(this);
    }
    this.options.position = position;
    if (map) {
      map.addControl(this);
    }
    return this;
  },
  // @method getContainer: HTMLElement
  // Returns the HTMLElement that contains the control.
  getContainer: function() {
    return this._container;
  },
  // @method addTo(map: Map): this
  // Adds the control to the given map.
  addTo: function(map) {
    this.remove();
    this._map = map;
    var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
    addClass(container, "leaflet-control");
    if (pos.indexOf("bottom") !== -1) {
      corner.insertBefore(container, corner.firstChild);
    } else {
      corner.appendChild(container);
    }
    this._map.on("unload", this.remove, this);
    return this;
  },
  // @method remove: this
  // Removes the control from the map it is currently active on.
  remove: function() {
    if (!this._map) {
      return this;
    }
    remove(this._container);
    if (this.onRemove) {
      this.onRemove(this._map);
    }
    this._map.off("unload", this.remove, this);
    this._map = null;
    return this;
  },
  _refocusOnMap: function(e) {
    if (this._map && e && e.screenX > 0 && e.screenY > 0) {
      this._map.getContainer().focus();
    }
  }
});
var control = function(options) {
  return new Control(options);
};
Map2.include({
  // @method addControl(control: Control): this
  // Adds the given control to the map
  addControl: function(control2) {
    control2.addTo(this);
    return this;
  },
  // @method removeControl(control: Control): this
  // Removes the given control from the map
  removeControl: function(control2) {
    control2.remove();
    return this;
  },
  _initControlPos: function() {
    var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
    function createCorner(vSide, hSide) {
      var className = l + vSide + " " + l + hSide;
      corners[vSide + hSide] = create$1("div", className, container);
    }
    createCorner("top", "left");
    createCorner("top", "right");
    createCorner("bottom", "left");
    createCorner("bottom", "right");
  },
  _clearControlPos: function() {
    for (var i in this._controlCorners) {
      remove(this._controlCorners[i]);
    }
    remove(this._controlContainer);
    delete this._controlCorners;
    delete this._controlContainer;
  }
});
var Layers = Control.extend({
  // @section
  // @aka Control.Layers options
  options: {
    // @option collapsed: Boolean = true
    // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
    collapsed: true,
    position: "topright",
    // @option autoZIndex: Boolean = true
    // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
    autoZIndex: true,
    // @option hideSingleBase: Boolean = false
    // If `true`, the base layers in the control will be hidden when there is only one.
    hideSingleBase: false,
    // @option sortLayers: Boolean = false
    // Whether to sort the layers. When `false`, layers will keep the order
    // in which they were added to the control.
    sortLayers: false,
    // @option sortFunction: Function = *
    // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    // that will be used for sorting the layers, when `sortLayers` is `true`.
    // The function receives both the `L.Layer` instances and their names, as in
    // `sortFunction(layerA, layerB, nameA, nameB)`.
    // By default, it sorts layers alphabetically by their name.
    sortFunction: function(layerA, layerB, nameA, nameB) {
      return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
    }
  },
  initialize: function(baseLayers, overlays, options) {
    setOptions(this, options);
    this._layerControlInputs = [];
    this._layers = [];
    this._lastZIndex = 0;
    this._handlingClick = false;
    this._preventClick = false;
    for (var i in baseLayers) {
      this._addLayer(baseLayers[i], i);
    }
    for (i in overlays) {
      this._addLayer(overlays[i], i, true);
    }
  },
  onAdd: function(map) {
    this._initLayout();
    this._update();
    this._map = map;
    map.on("zoomend", this._checkDisabledLayers, this);
    for (var i = 0; i < this._layers.length; i++) {
      this._layers[i].layer.on("add remove", this._onLayerChange, this);
    }
    return this._container;
  },
  addTo: function(map) {
    Control.prototype.addTo.call(this, map);
    return this._expandIfNotCollapsed();
  },
  onRemove: function() {
    this._map.off("zoomend", this._checkDisabledLayers, this);
    for (var i = 0; i < this._layers.length; i++) {
      this._layers[i].layer.off("add remove", this._onLayerChange, this);
    }
  },
  // @method addBaseLayer(layer: Layer, name: String): this
  // Adds a base layer (radio button entry) with the given name to the control.
  addBaseLayer: function(layer, name) {
    this._addLayer(layer, name);
    return this._map ? this._update() : this;
  },
  // @method addOverlay(layer: Layer, name: String): this
  // Adds an overlay (checkbox entry) with the given name to the control.
  addOverlay: function(layer, name) {
    this._addLayer(layer, name, true);
    return this._map ? this._update() : this;
  },
  // @method removeLayer(layer: Layer): this
  // Remove the given layer from the control.
  removeLayer: function(layer) {
    layer.off("add remove", this._onLayerChange, this);
    var obj = this._getLayer(stamp(layer));
    if (obj) {
      this._layers.splice(this._layers.indexOf(obj), 1);
    }
    return this._map ? this._update() : this;
  },
  // @method expand(): this
  // Expand the control container if collapsed.
  expand: function() {
    addClass(this._container, "leaflet-control-layers-expanded");
    this._section.style.height = null;
    var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
    if (acceptableHeight < this._section.clientHeight) {
      addClass(this._section, "leaflet-control-layers-scrollbar");
      this._section.style.height = acceptableHeight + "px";
    } else {
      removeClass(this._section, "leaflet-control-layers-scrollbar");
    }
    this._checkDisabledLayers();
    return this;
  },
  // @method collapse(): this
  // Collapse the control container if expanded.
  collapse: function() {
    removeClass(this._container, "leaflet-control-layers-expanded");
    return this;
  },
  _initLayout: function() {
    var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
    container.setAttribute("aria-haspopup", true);
    disableClickPropagation(container);
    disableScrollPropagation(container);
    var section = this._section = create$1("section", className + "-list");
    if (collapsed) {
      this._map.on("click", this.collapse, this);
      on2(container, {
        mouseenter: this._expandSafely,
        mouseleave: this.collapse
      }, this);
    }
    var link = this._layersLink = create$1("a", className + "-toggle", container);
    link.href = "#";
    link.title = "Layers";
    link.setAttribute("role", "button");
    on2(link, {
      keydown: function(e) {
        if (e.keyCode === 13) {
          this._expandSafely();
        }
      },
      // Certain screen readers intercept the key event and instead send a click event
      click: function(e) {
        preventDefault(e);
        this._expandSafely();
      }
    }, this);
    if (!collapsed) {
      this.expand();
    }
    this._baseLayersList = create$1("div", className + "-base", section);
    this._separator = create$1("div", className + "-separator", section);
    this._overlaysList = create$1("div", className + "-overlays", section);
    container.appendChild(section);
  },
  _getLayer: function(id) {
    for (var i = 0; i < this._layers.length; i++) {
      if (this._layers[i] && stamp(this._layers[i].layer) === id) {
        return this._layers[i];
      }
    }
  },
  _addLayer: function(layer, name, overlay) {
    if (this._map) {
      layer.on("add remove", this._onLayerChange, this);
    }
    this._layers.push({
      layer,
      name,
      overlay
    });
    if (this.options.sortLayers) {
      this._layers.sort(bind3(function(a, b) {
        return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
      }, this));
    }
    if (this.options.autoZIndex && layer.setZIndex) {
      this._lastZIndex++;
      layer.setZIndex(this._lastZIndex);
    }
    this._expandIfNotCollapsed();
  },
  _update: function() {
    if (!this._container) {
      return this;
    }
    empty(this._baseLayersList);
    empty(this._overlaysList);
    this._layerControlInputs = [];
    var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
    for (i = 0; i < this._layers.length; i++) {
      obj = this._layers[i];
      this._addItem(obj);
      overlaysPresent = overlaysPresent || obj.overlay;
      baseLayersPresent = baseLayersPresent || !obj.overlay;
      baseLayersCount += !obj.overlay ? 1 : 0;
    }
    if (this.options.hideSingleBase) {
      baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
      this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
    }
    this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
    return this;
  },
  _onLayerChange: function(e) {
    if (!this._handlingClick) {
      this._update();
    }
    var obj = this._getLayer(stamp(e.target));
    var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
    if (type) {
      this._map.fire(type, obj);
    }
  },
  // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
  _createRadioElement: function(name, checked) {
    var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
    var radioFragment = document.createElement("div");
    radioFragment.innerHTML = radioHtml;
    return radioFragment.firstChild;
  },
  _addItem: function(obj) {
    var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
    if (obj.overlay) {
      input = document.createElement("input");
      input.type = "checkbox";
      input.className = "leaflet-control-layers-selector";
      input.defaultChecked = checked;
    } else {
      input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
    }
    this._layerControlInputs.push(input);
    input.layerId = stamp(obj.layer);
    on2(input, "click", this._onInputClick, this);
    var name = document.createElement("span");
    name.innerHTML = " " + obj.name;
    var holder = document.createElement("span");
    label.appendChild(holder);
    holder.appendChild(input);
    holder.appendChild(name);
    var container = obj.overlay ? this._overlaysList : this._baseLayersList;
    container.appendChild(label);
    this._checkDisabledLayers();
    return label;
  },
  _onInputClick: function() {
    if (this._preventClick) {
      return;
    }
    var inputs = this._layerControlInputs, input, layer;
    var addedLayers = [], removedLayers = [];
    this._handlingClick = true;
    for (var i = inputs.length - 1; i >= 0; i--) {
      input = inputs[i];
      layer = this._getLayer(input.layerId).layer;
      if (input.checked) {
        addedLayers.push(layer);
      } else if (!input.checked) {
        removedLayers.push(layer);
      }
    }
    for (i = 0; i < removedLayers.length; i++) {
      if (this._map.hasLayer(removedLayers[i])) {
        this._map.removeLayer(removedLayers[i]);
      }
    }
    for (i = 0; i < addedLayers.length; i++) {
      if (!this._map.hasLayer(addedLayers[i])) {
        this._map.addLayer(addedLayers[i]);
      }
    }
    this._handlingClick = false;
    this._refocusOnMap();
  },
  _checkDisabledLayers: function() {
    var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
    for (var i = inputs.length - 1; i >= 0; i--) {
      input = inputs[i];
      layer = this._getLayer(input.layerId).layer;
      input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
    }
  },
  _expandIfNotCollapsed: function() {
    if (this._map && !this.options.collapsed) {
      this.expand();
    }
    return this;
  },
  _expandSafely: function() {
    var section = this._section;
    this._preventClick = true;
    on2(section, "click", preventDefault);
    this.expand();
    var that = this;
    setTimeout(function() {
      off(section, "click", preventDefault);
      that._preventClick = false;
    });
  }
});
var layers = function(baseLayers, overlays, options) {
  return new Layers(baseLayers, overlays, options);
};
var Zoom = Control.extend({
  // @section
  // @aka Control.Zoom options
  options: {
    position: "topleft",
    // @option zoomInText: String = '<span aria-hidden="true">+</span>'
    // The text set on the 'zoom in' button.
    zoomInText: '<span aria-hidden="true">+</span>',
    // @option zoomInTitle: String = 'Zoom in'
    // The title set on the 'zoom in' button.
    zoomInTitle: "Zoom in",
    // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
    // The text set on the 'zoom out' button.
    zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
    // @option zoomOutTitle: String = 'Zoom out'
    // The title set on the 'zoom out' button.
    zoomOutTitle: "Zoom out"
  },
  onAdd: function(map) {
    var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
    this._zoomInButton = this._createButton(
      options.zoomInText,
      options.zoomInTitle,
      zoomName + "-in",
      container,
      this._zoomIn
    );
    this._zoomOutButton = this._createButton(
      options.zoomOutText,
      options.zoomOutTitle,
      zoomName + "-out",
      container,
      this._zoomOut
    );
    this._updateDisabled();
    map.on("zoomend zoomlevelschange", this._updateDisabled, this);
    return container;
  },
  onRemove: function(map) {
    map.off("zoomend zoomlevelschange", this._updateDisabled, this);
  },
  disable: function() {
    this._disabled = true;
    this._updateDisabled();
    return this;
  },
  enable: function() {
    this._disabled = false;
    this._updateDisabled();
    return this;
  },
  _zoomIn: function(e) {
    if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
      this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }
  },
  _zoomOut: function(e) {
    if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
      this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }
  },
  _createButton: function(html, title, className, container, fn) {
    var link = create$1("a", className, container);
    link.innerHTML = html;
    link.href = "#";
    link.title = title;
    link.setAttribute("role", "button");
    link.setAttribute("aria-label", title);
    disableClickPropagation(link);
    on2(link, "click", stop2);
    on2(link, "click", fn, this);
    on2(link, "click", this._refocusOnMap, this);
    return link;
  },
  _updateDisabled: function() {
    var map = this._map, className = "leaflet-disabled";
    removeClass(this._zoomInButton, className);
    removeClass(this._zoomOutButton, className);
    this._zoomInButton.setAttribute("aria-disabled", "false");
    this._zoomOutButton.setAttribute("aria-disabled", "false");
    if (this._disabled || map._zoom === map.getMinZoom()) {
      addClass(this._zoomOutButton, className);
      this._zoomOutButton.setAttribute("aria-disabled", "true");
    }
    if (this._disabled || map._zoom === map.getMaxZoom()) {
      addClass(this._zoomInButton, className);
      this._zoomInButton.setAttribute("aria-disabled", "true");
    }
  }
});
Map2.mergeOptions({
  zoomControl: true
});
Map2.addInitHook(function() {
  if (this.options.zoomControl) {
    this.zoomControl = new Zoom();
    this.addControl(this.zoomControl);
  }
});
var zoom = function(options) {
  return new Zoom(options);
};
var Scale = Control.extend({
  // @section
  // @aka Control.Scale options
  options: {
    position: "bottomleft",
    // @option maxWidth: Number = 100
    // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
    maxWidth: 100,
    // @option metric: Boolean = True
    // Whether to show the metric scale line (m/km).
    metric: true,
    // @option imperial: Boolean = True
    // Whether to show the imperial scale line (mi/ft).
    imperial: true
    // @option updateWhenIdle: Boolean = false
    // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
  },
  onAdd: function(map) {
    var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
    this._addScales(options, className + "-line", container);
    map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
    map.whenReady(this._update, this);
    return container;
  },
  onRemove: function(map) {
    map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
  },
  _addScales: function(options, className, container) {
    if (options.metric) {
      this._mScale = create$1("div", className, container);
    }
    if (options.imperial) {
      this._iScale = create$1("div", className, container);
    }
  },
  _update: function() {
    var map = this._map, y = map.getSize().y / 2;
    var maxMeters = map.distance(
      map.containerPointToLatLng([0, y]),
      map.containerPointToLatLng([this.options.maxWidth, y])
    );
    this._updateScales(maxMeters);
  },
  _updateScales: function(maxMeters) {
    if (this.options.metric && maxMeters) {
      this._updateMetric(maxMeters);
    }
    if (this.options.imperial && maxMeters) {
      this._updateImperial(maxMeters);
    }
  },
  _updateMetric: function(maxMeters) {
    var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
    this._updateScale(this._mScale, label, meters / maxMeters);
  },
  _updateImperial: function(maxMeters) {
    var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
    if (maxFeet > 5280) {
      maxMiles = maxFeet / 5280;
      miles = this._getRoundNum(maxMiles);
      this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
    } else {
      feet = this._getRoundNum(maxFeet);
      this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
    }
  },
  _updateScale: function(scale2, text, ratio) {
    scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
    scale2.innerHTML = text;
  },
  _getRoundNum: function(num) {
    var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
    return pow10 * d;
  }
});
var scale = function(options) {
  return new Scale(options);
};
var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
var Attribution = Control.extend({
  // @section
  // @aka Control.Attribution options
  options: {
    position: "bottomright",
    // @option prefix: String|false = 'Leaflet'
    // The HTML text shown before the attributions. Pass `false` to disable.
    prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
  },
  initialize: function(options) {
    setOptions(this, options);
    this._attributions = {};
  },
  onAdd: function(map) {
    map.attributionControl = this;
    this._container = create$1("div", "leaflet-control-attribution");
    disableClickPropagation(this._container);
    for (var i in map._layers) {
      if (map._layers[i].getAttribution) {
        this.addAttribution(map._layers[i].getAttribution());
      }
    }
    this._update();
    map.on("layeradd", this._addAttribution, this);
    return this._container;
  },
  onRemove: function(map) {
    map.off("layeradd", this._addAttribution, this);
  },
  _addAttribution: function(ev) {
    if (ev.layer.getAttribution) {
      this.addAttribution(ev.layer.getAttribution());
      ev.layer.once("remove", function() {
        this.removeAttribution(ev.layer.getAttribution());
      }, this);
    }
  },
  // @method setPrefix(prefix: String|false): this
  // The HTML text shown before the attributions. Pass `false` to disable.
  setPrefix: function(prefix2) {
    this.options.prefix = prefix2;
    this._update();
    return this;
  },
  // @method addAttribution(text: String): this
  // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
  addAttribution: function(text) {
    if (!text) {
      return this;
    }
    if (!this._attributions[text]) {
      this._attributions[text] = 0;
    }
    this._attributions[text]++;
    this._update();
    return this;
  },
  // @method removeAttribution(text: String): this
  // Removes an attribution text.
  removeAttribution: function(text) {
    if (!text) {
      return this;
    }
    if (this._attributions[text]) {
      this._attributions[text]--;
      this._update();
    }
    return this;
  },
  _update: function() {
    if (!this._map) {
      return;
    }
    var attribs = [];
    for (var i in this._attributions) {
      if (this._attributions[i]) {
        attribs.push(i);
      }
    }
    var prefixAndAttribs = [];
    if (this.options.prefix) {
      prefixAndAttribs.push(this.options.prefix);
    }
    if (attribs.length) {
      prefixAndAttribs.push(attribs.join(", "));
    }
    this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
  }
});
Map2.mergeOptions({
  attributionControl: true
});
Map2.addInitHook(function() {
  if (this.options.attributionControl) {
    new Attribution().addTo(this);
  }
});
var attribution = function(options) {
  return new Attribution(options);
};
Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;
control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;
var Handler = Class.extend({
  initialize: function(map) {
    this._map = map;
  },
  // @method enable(): this
  // Enables the handler
  enable: function() {
    if (this._enabled) {
      return this;
    }
    this._enabled = true;
    this.addHooks();
    return this;
  },
  // @method disable(): this
  // Disables the handler
  disable: function() {
    if (!this._enabled) {
      return this;
    }
    this._enabled = false;
    this.removeHooks();
    return this;
  },
  // @method enabled(): Boolean
  // Returns `true` if the handler is enabled
  enabled: function() {
    return !!this._enabled;
  }
  // @section Extension methods
  // Classes inheriting from `Handler` must implement the two following methods:
  // @method addHooks()
  // Called when the handler is enabled, should add event hooks.
  // @method removeHooks()
  // Called when the handler is disabled, should remove the event hooks added previously.
});
Handler.addTo = function(map, name) {
  map.addHandler(name, this);
  return this;
};
var START = Browser.touch ? "touchstart mousedown" : "mousedown";
var Draggable = Evented.extend({
  options: {
    // @section
    // @aka Draggable options
    // @option clickTolerance: Number = 3
    // The max number of pixels a user can shift the mouse pointer during a click
    // for it to be considered a valid click (as opposed to a mouse drag).
    clickTolerance: 3
  },
  // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
  // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
  initialize: function(element, dragStartTarget, preventOutline2, options) {
    setOptions(this, options);
    this._element = element;
    this._dragStartTarget = dragStartTarget || element;
    this._preventOutline = preventOutline2;
  },
  // @method enable()
  // Enables the dragging ability
  enable: function() {
    if (this._enabled) {
      return;
    }
    on2(this._dragStartTarget, START, this._onDown, this);
    this._enabled = true;
  },
  // @method disable()
  // Disables the dragging ability
  disable: function() {
    if (!this._enabled) {
      return;
    }
    if (Draggable._dragging === this) {
      this.finishDrag(true);
    }
    off(this._dragStartTarget, START, this._onDown, this);
    this._enabled = false;
    this._moved = false;
  },
  _onDown: function(e) {
    if (!this._enabled) {
      return;
    }
    this._moved = false;
    if (hasClass(this._element, "leaflet-zoom-anim")) {
      return;
    }
    if (e.touches && e.touches.length !== 1) {
      if (Draggable._dragging === this) {
        this.finishDrag();
      }
      return;
    }
    if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
      return;
    }
    Draggable._dragging = this;
    if (this._preventOutline) {
      preventOutline(this._element);
    }
    disableImageDrag();
    disableTextSelection();
    if (this._moving) {
      return;
    }
    this.fire("down");
    var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
    this._startPoint = new Point(first.clientX, first.clientY);
    this._startPos = getPosition(this._element);
    this._parentScale = getScale(sizedParent);
    var mouseevent = e.type === "mousedown";
    on2(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
    on2(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
  },
  _onMove: function(e) {
    if (!this._enabled) {
      return;
    }
    if (e.touches && e.touches.length > 1) {
      this._moved = true;
      return;
    }
    var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
    if (!offset.x && !offset.y) {
      return;
    }
    if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
      return;
    }
    offset.x /= this._parentScale.x;
    offset.y /= this._parentScale.y;
    preventDefault(e);
    if (!this._moved) {
      this.fire("dragstart");
      this._moved = true;
      addClass(document.body, "leaflet-dragging");
      this._lastTarget = e.target || e.srcElement;
      if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
        this._lastTarget = this._lastTarget.correspondingUseElement;
      }
      addClass(this._lastTarget, "leaflet-drag-target");
    }
    this._newPos = this._startPos.add(offset);
    this._moving = true;
    this._lastEvent = e;
    this._updatePosition();
  },
  _updatePosition: function() {
    var e = { originalEvent: this._lastEvent };
    this.fire("predrag", e);
    setPosition(this._element, this._newPos);
    this.fire("drag", e);
  },
  _onUp: function() {
    if (!this._enabled) {
      return;
    }
    this.finishDrag();
  },
  finishDrag: function(noInertia) {
    removeClass(document.body, "leaflet-dragging");
    if (this._lastTarget) {
      removeClass(this._lastTarget, "leaflet-drag-target");
      this._lastTarget = null;
    }
    off(document, "mousemove touchmove", this._onMove, this);
    off(document, "mouseup touchend touchcancel", this._onUp, this);
    enableImageDrag();
    enableTextSelection();
    var fireDragend = this._moved && this._moving;
    this._moving = false;
    Draggable._dragging = false;
    if (fireDragend) {
      this.fire("dragend", {
        noInertia,
        distance: this._newPos.distanceTo(this._startPos)
      });
    }
  }
});
function clipPolygon(points, bounds, round) {
  var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
  for (i = 0, len = points.length; i < len; i++) {
    points[i]._code = _getBitCode(points[i], bounds);
  }
  for (k = 0; k < 4; k++) {
    edge2 = edges[k];
    clippedPoints = [];
    for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
      a = points[i];
      b = points[j];
      if (!(a._code & edge2)) {
        if (b._code & edge2) {
          p = _getEdgeIntersection(b, a, edge2, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
        clippedPoints.push(a);
      } else if (!(b._code & edge2)) {
        p = _getEdgeIntersection(b, a, edge2, bounds, round);
        p._code = _getBitCode(p, bounds);
        clippedPoints.push(p);
      }
    }
    points = clippedPoints;
  }
  return points;
}
function polygonCenter(latlngs, crs) {
  var i, j, p1, p2, f, area, x, y, center;
  if (!latlngs || latlngs.length === 0) {
    throw new Error("latlngs not passed");
  }
  if (!isFlat(latlngs)) {
    console.warn("latlngs are not flat! Only the first ring will be used");
    latlngs = latlngs[0];
  }
  var centroidLatLng = toLatLng([0, 0]);
  var bounds = toLatLngBounds(latlngs);
  var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  if (areaBounds < 1700) {
    centroidLatLng = centroid(latlngs);
  }
  var len = latlngs.length;
  var points = [];
  for (i = 0; i < len; i++) {
    var latlng = toLatLng(latlngs[i]);
    points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  }
  area = x = y = 0;
  for (i = 0, j = len - 1; i < len; j = i++) {
    p1 = points[i];
    p2 = points[j];
    f = p1.y * p2.x - p2.y * p1.x;
    x += (p1.x + p2.x) * f;
    y += (p1.y + p2.y) * f;
    area += f * 3;
  }
  if (area === 0) {
    center = points[0];
  } else {
    center = [x / area, y / area];
  }
  var latlngCenter = crs.unproject(toPoint(center));
  return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
}
function centroid(coords) {
  var latSum = 0;
  var lngSum = 0;
  var len = 0;
  for (var i = 0; i < coords.length; i++) {
    var latlng = toLatLng(coords[i]);
    latSum += latlng.lat;
    lngSum += latlng.lng;
    len++;
  }
  return toLatLng([latSum / len, lngSum / len]);
}
function simplify(points, tolerance) {
  if (!tolerance || !points.length) {
    return points.slice();
  }
  var sqTolerance = tolerance * tolerance;
  points = _reducePoints(points, sqTolerance);
  points = _simplifyDP(points, sqTolerance);
  return points;
}
function pointToSegmentDistance(p, p1, p2) {
  return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}
function _simplifyDP(points, sqTolerance) {
  var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
  markers[0] = markers[len - 1] = 1;
  _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
  var i, newPoints = [];
  for (i = 0; i < len; i++) {
    if (markers[i]) {
      newPoints.push(points[i]);
    }
  }
  return newPoints;
}
function _simplifyDPStep(points, markers, sqTolerance, first, last) {
  var maxSqDist = 0, index, i, sqDist;
  for (i = first + 1; i <= last - 1; i++) {
    sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    markers[index] = 1;
    _simplifyDPStep(points, markers, sqTolerance, first, index);
    _simplifyDPStep(points, markers, sqTolerance, index, last);
  }
}
function _reducePoints(points, sqTolerance) {
  var reducedPoints = [points[0]];
  for (var i = 1, prev = 0, len = points.length; i < len; i++) {
    if (_sqDist(points[i], points[prev]) > sqTolerance) {
      reducedPoints.push(points[i]);
      prev = i;
    }
  }
  if (prev < len - 1) {
    reducedPoints.push(points[len - 1]);
  }
  return reducedPoints;
}
var _lastCode;
function clipSegment(a, b, bounds, useLastCode, round) {
  var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
  _lastCode = codeB;
  while (true) {
    if (!(codeA | codeB)) {
      return [a, b];
    }
    if (codeA & codeB) {
      return false;
    }
    codeOut = codeA || codeB;
    p = _getEdgeIntersection(a, b, codeOut, bounds, round);
    newCode = _getBitCode(p, bounds);
    if (codeOut === codeA) {
      a = p;
      codeA = newCode;
    } else {
      b = p;
      codeB = newCode;
    }
  }
}
function _getEdgeIntersection(a, b, code, bounds, round) {
  var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
  if (code & 8) {
    x = a.x + dx * (max.y - a.y) / dy;
    y = max.y;
  } else if (code & 4) {
    x = a.x + dx * (min.y - a.y) / dy;
    y = min.y;
  } else if (code & 2) {
    x = max.x;
    y = a.y + dy * (max.x - a.x) / dx;
  } else if (code & 1) {
    x = min.x;
    y = a.y + dy * (min.x - a.x) / dx;
  }
  return new Point(x, y, round);
}
function _getBitCode(p, bounds) {
  var code = 0;
  if (p.x < bounds.min.x) {
    code |= 1;
  } else if (p.x > bounds.max.x) {
    code |= 2;
  }
  if (p.y < bounds.min.y) {
    code |= 4;
  } else if (p.y > bounds.max.y) {
    code |= 8;
  }
  return code;
}
function _sqDist(p1, p2) {
  var dx = p2.x - p1.x, dy = p2.y - p1.y;
  return dx * dx + dy * dy;
}
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
  var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
  if (dot > 0) {
    t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
    if (t > 1) {
      x = p2.x;
      y = p2.y;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p.x - x;
  dy = p.y - y;
  return sqDist ? dx * dx + dy * dy : new Point(x, y);
}
function isFlat(latlngs) {
  return !isArray3(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
}
function _flat(latlngs) {
  console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
  return isFlat(latlngs);
}
function polylineCenter(latlngs, crs) {
  var i, halfDist, segDist, dist, p1, p2, ratio, center;
  if (!latlngs || latlngs.length === 0) {
    throw new Error("latlngs not passed");
  }
  if (!isFlat(latlngs)) {
    console.warn("latlngs are not flat! Only the first ring will be used");
    latlngs = latlngs[0];
  }
  var centroidLatLng = toLatLng([0, 0]);
  var bounds = toLatLngBounds(latlngs);
  var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  if (areaBounds < 1700) {
    centroidLatLng = centroid(latlngs);
  }
  var len = latlngs.length;
  var points = [];
  for (i = 0; i < len; i++) {
    var latlng = toLatLng(latlngs[i]);
    points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  }
  for (i = 0, halfDist = 0; i < len - 1; i++) {
    halfDist += points[i].distanceTo(points[i + 1]) / 2;
  }
  if (halfDist === 0) {
    center = points[0];
  } else {
    for (i = 0, dist = 0; i < len - 1; i++) {
      p1 = points[i];
      p2 = points[i + 1];
      segDist = p1.distanceTo(p2);
      dist += segDist;
      if (dist > halfDist) {
        ratio = (dist - halfDist) / segDist;
        center = [
          p2.x - ratio * (p2.x - p1.x),
          p2.y - ratio * (p2.y - p1.y)
        ];
        break;
      }
    }
  }
  var latlngCenter = crs.unproject(toPoint(center));
  return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
}
var LonLat = {
  project: function(latlng) {
    return new Point(latlng.lng, latlng.lat);
  },
  unproject: function(point) {
    return new LatLng(point.y, point.x);
  },
  bounds: new Bounds([-180, -90], [180, 90])
};
var Mercator = {
  R: 6378137,
  R_MINOR: 6356752314245179e-9,
  bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
  project: function(latlng) {
    var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
    var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
    y = -r * Math.log(Math.max(ts, 1e-10));
    return new Point(latlng.lng * d * r, y);
  },
  unproject: function(point) {
    var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
    for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
      con = e * Math.sin(phi);
      con = Math.pow((1 - con) / (1 + con), e / 2);
      dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
      phi += dphi;
    }
    return new LatLng(phi * d, point.x * d / r);
  }
};
var EPSG3395 = extend({}, Earth, {
  code: "EPSG:3395",
  projection: Mercator,
  transformation: function() {
    var scale2 = 0.5 / (Math.PI * Mercator.R);
    return toTransformation(scale2, 0.5, -scale2, 0.5);
  }()
});
var EPSG4326 = extend({}, Earth, {
  code: "EPSG:4326",
  projection: LonLat,
  transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});
var Simple = extend({}, CRS, {
  projection: LonLat,
  transformation: toTransformation(1, 0, -1, 0),
  scale: function(zoom2) {
    return Math.pow(2, zoom2);
  },
  zoom: function(scale2) {
    return Math.log(scale2) / Math.LN2;
  },
  distance: function(latlng1, latlng2) {
    var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
    return Math.sqrt(dx * dx + dy * dy);
  },
  infinite: true
});
CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;
var Layer = Evented.extend({
  // Classes extending `L.Layer` will inherit the following options:
  options: {
    // @option pane: String = 'overlayPane'
    // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
    pane: "overlayPane",
    // @option attribution: String = null
    // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
    attribution: null,
    bubblingMouseEvents: true
  },
  /* @section
   * Classes extending `L.Layer` will inherit the following methods:
   *
   * @method addTo(map: Map|LayerGroup): this
   * Adds the layer to the given map or layer group.
   */
  addTo: function(map) {
    map.addLayer(this);
    return this;
  },
  // @method remove: this
  // Removes the layer from the map it is currently active on.
  remove: function() {
    return this.removeFrom(this._map || this._mapToAdd);
  },
  // @method removeFrom(map: Map): this
  // Removes the layer from the given map
  //
  // @alternative
  // @method removeFrom(group: LayerGroup): this
  // Removes the layer from the given `LayerGroup`
  removeFrom: function(obj) {
    if (obj) {
      obj.removeLayer(this);
    }
    return this;
  },
  // @method getPane(name? : String): HTMLElement
  // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
  getPane: function(name) {
    return this._map.getPane(name ? this.options[name] || name : this.options.pane);
  },
  addInteractiveTarget: function(targetEl) {
    this._map._targets[stamp(targetEl)] = this;
    return this;
  },
  removeInteractiveTarget: function(targetEl) {
    delete this._map._targets[stamp(targetEl)];
    return this;
  },
  // @method getAttribution: String
  // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
  getAttribution: function() {
    return this.options.attribution;
  },
  _layerAdd: function(e) {
    var map = e.target;
    if (!map.hasLayer(this)) {
      return;
    }
    this._map = map;
    this._zoomAnimated = map._zoomAnimated;
    if (this.getEvents) {
      var events = this.getEvents();
      map.on(events, this);
      this.once("remove", function() {
        map.off(events, this);
      }, this);
    }
    this.onAdd(map);
    this.fire("add");
    map.fire("layeradd", { layer: this });
  }
});
Map2.include({
  // @method addLayer(layer: Layer): this
  // Adds the given layer to the map
  addLayer: function(layer) {
    if (!layer._layerAdd) {
      throw new Error("The provided object is not a Layer.");
    }
    var id = stamp(layer);
    if (this._layers[id]) {
      return this;
    }
    this._layers[id] = layer;
    layer._mapToAdd = this;
    if (layer.beforeAdd) {
      layer.beforeAdd(this);
    }
    this.whenReady(layer._layerAdd, layer);
    return this;
  },
  // @method removeLayer(layer: Layer): this
  // Removes the given layer from the map.
  removeLayer: function(layer) {
    var id = stamp(layer);
    if (!this._layers[id]) {
      return this;
    }
    if (this._loaded) {
      layer.onRemove(this);
    }
    delete this._layers[id];
    if (this._loaded) {
      this.fire("layerremove", { layer });
      layer.fire("remove");
    }
    layer._map = layer._mapToAdd = null;
    return this;
  },
  // @method hasLayer(layer: Layer): Boolean
  // Returns `true` if the given layer is currently added to the map
  hasLayer: function(layer) {
    return stamp(layer) in this._layers;
  },
  /* @method eachLayer(fn: Function, context?: Object): this
   * Iterates over the layers of the map, optionally specifying context of the iterator function.
   * ```
   * map.eachLayer(function(layer){
   *     layer.bindPopup('Hello');
   * });
   * ```
   */
  eachLayer: function(method, context) {
    for (var i in this._layers) {
      method.call(context, this._layers[i]);
    }
    return this;
  },
  _addLayers: function(layers2) {
    layers2 = layers2 ? isArray3(layers2) ? layers2 : [layers2] : [];
    for (var i = 0, len = layers2.length; i < len; i++) {
      this.addLayer(layers2[i]);
    }
  },
  _addZoomLimit: function(layer) {
    if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
      this._zoomBoundLayers[stamp(layer)] = layer;
      this._updateZoomLevels();
    }
  },
  _removeZoomLimit: function(layer) {
    var id = stamp(layer);
    if (this._zoomBoundLayers[id]) {
      delete this._zoomBoundLayers[id];
      this._updateZoomLevels();
    }
  },
  _updateZoomLevels: function() {
    var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
    for (var i in this._zoomBoundLayers) {
      var options = this._zoomBoundLayers[i].options;
      minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
      maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
    }
    this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
    this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
    if (oldZoomSpan !== this._getZoomSpan()) {
      this.fire("zoomlevelschange");
    }
    if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
      this.setZoom(this._layersMaxZoom);
    }
    if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
      this.setZoom(this._layersMinZoom);
    }
  }
});
var LayerGroup = Layer.extend({
  initialize: function(layers2, options) {
    setOptions(this, options);
    this._layers = {};
    var i, len;
    if (layers2) {
      for (i = 0, len = layers2.length; i < len; i++) {
        this.addLayer(layers2[i]);
      }
    }
  },
  // @method addLayer(layer: Layer): this
  // Adds the given layer to the group.
  addLayer: function(layer) {
    var id = this.getLayerId(layer);
    this._layers[id] = layer;
    if (this._map) {
      this._map.addLayer(layer);
    }
    return this;
  },
  // @method removeLayer(layer: Layer): this
  // Removes the given layer from the group.
  // @alternative
  // @method removeLayer(id: Number): this
  // Removes the layer with the given internal ID from the group.
  removeLayer: function(layer) {
    var id = layer in this._layers ? layer : this.getLayerId(layer);
    if (this._map && this._layers[id]) {
      this._map.removeLayer(this._layers[id]);
    }
    delete this._layers[id];
    return this;
  },
  // @method hasLayer(layer: Layer): Boolean
  // Returns `true` if the given layer is currently added to the group.
  // @alternative
  // @method hasLayer(id: Number): Boolean
  // Returns `true` if the given internal ID is currently added to the group.
  hasLayer: function(layer) {
    var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
    return layerId in this._layers;
  },
  // @method clearLayers(): this
  // Removes all the layers from the group.
  clearLayers: function() {
    return this.eachLayer(this.removeLayer, this);
  },
  // @method invoke(methodName: String, ): this
  // Calls `methodName` on every layer contained in this group, passing any
  // additional parameters. Has no effect if the layers contained do not
  // implement `methodName`.
  invoke: function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1), i, layer;
    for (i in this._layers) {
      layer = this._layers[i];
      if (layer[methodName]) {
        layer[methodName].apply(layer, args);
      }
    }
    return this;
  },
  onAdd: function(map) {
    this.eachLayer(map.addLayer, map);
  },
  onRemove: function(map) {
    this.eachLayer(map.removeLayer, map);
  },
  // @method eachLayer(fn: Function, context?: Object): this
  // Iterates over the layers of the group, optionally specifying context of the iterator function.
  // ```js
  // group.eachLayer(function (layer) {
  // 	layer.bindPopup('Hello');
  // });
  // ```
  eachLayer: function(method, context) {
    for (var i in this._layers) {
      method.call(context, this._layers[i]);
    }
    return this;
  },
  // @method getLayer(id: Number): Layer
  // Returns the layer with the given internal ID.
  getLayer: function(id) {
    return this._layers[id];
  },
  // @method getLayers(): Layer[]
  // Returns an array of all the layers added to the group.
  getLayers: function() {
    var layers2 = [];
    this.eachLayer(layers2.push, layers2);
    return layers2;
  },
  // @method setZIndex(zIndex: Number): this
  // Calls `setZIndex` on every layer contained in this group, passing the z-index.
  setZIndex: function(zIndex) {
    return this.invoke("setZIndex", zIndex);
  },
  // @method getLayerId(layer: Layer): Number
  // Returns the internal ID for a layer
  getLayerId: function(layer) {
    return stamp(layer);
  }
});
var FeatureGroup = LayerGroup.extend({
  addLayer: function(layer) {
    if (this.hasLayer(layer)) {
      return this;
    }
    layer.addEventParent(this);
    LayerGroup.prototype.addLayer.call(this, layer);
    return this.fire("layeradd", { layer });
  },
  removeLayer: function(layer) {
    if (!this.hasLayer(layer)) {
      return this;
    }
    if (layer in this._layers) {
      layer = this._layers[layer];
    }
    layer.removeEventParent(this);
    LayerGroup.prototype.removeLayer.call(this, layer);
    return this.fire("layerremove", { layer });
  },
  // @method setStyle(style: Path options): this
  // Sets the given path options to each layer of the group that has a `setStyle` method.
  setStyle: function(style2) {
    return this.invoke("setStyle", style2);
  },
  // @method bringToFront(): this
  // Brings the layer group to the top of all other layers
  bringToFront: function() {
    return this.invoke("bringToFront");
  },
  // @method bringToBack(): this
  // Brings the layer group to the back of all other layers
  bringToBack: function() {
    return this.invoke("bringToBack");
  },
  // @method getBounds(): LatLngBounds
  // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
  getBounds: function() {
    var bounds = new LatLngBounds();
    for (var id in this._layers) {
      var layer = this._layers[id];
      bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
    }
    return bounds;
  }
});
var Icon = Class.extend({
  /* @section
   * @aka Icon options
   *
   * @option iconUrl: String = null
   * **(required)** The URL to the icon image (absolute or relative to your script path).
   *
   * @option iconRetinaUrl: String = null
   * The URL to a retina sized version of the icon image (absolute or relative to your
   * script path). Used for Retina screen devices.
   *
   * @option iconSize: Point = null
   * Size of the icon image in pixels.
   *
   * @option iconAnchor: Point = null
   * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
   * will be aligned so that this point is at the marker's geographical location. Centered
   * by default if size is specified, also can be set in CSS with negative margins.
   *
   * @option popupAnchor: Point = [0, 0]
   * The coordinates of the point from which popups will "open", relative to the icon anchor.
   *
   * @option tooltipAnchor: Point = [0, 0]
   * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
   *
   * @option shadowUrl: String = null
   * The URL to the icon shadow image. If not specified, no shadow image will be created.
   *
   * @option shadowRetinaUrl: String = null
   *
   * @option shadowSize: Point = null
   * Size of the shadow image in pixels.
   *
   * @option shadowAnchor: Point = null
   * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
   * as iconAnchor if not specified).
   *
   * @option className: String = ''
   * A custom class name to assign to both icon and shadow images. Empty by default.
   */
  options: {
    popupAnchor: [0, 0],
    tooltipAnchor: [0, 0],
    // @option crossOrigin: Boolean|String = false
    // Whether the crossOrigin attribute will be added to the tiles.
    // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
    // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
    crossOrigin: false
  },
  initialize: function(options) {
    setOptions(this, options);
  },
  // @method createIcon(oldIcon?: HTMLElement): HTMLElement
  // Called internally when the icon has to be shown, returns a `<img>` HTML element
  // styled according to the options.
  createIcon: function(oldIcon) {
    return this._createIcon("icon", oldIcon);
  },
  // @method createShadow(oldIcon?: HTMLElement): HTMLElement
  // As `createIcon`, but for the shadow beneath it.
  createShadow: function(oldIcon) {
    return this._createIcon("shadow", oldIcon);
  },
  _createIcon: function(name, oldIcon) {
    var src = this._getIconUrl(name);
    if (!src) {
      if (name === "icon") {
        throw new Error("iconUrl not set in Icon options (see the docs).");
      }
      return null;
    }
    var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
    this._setIconStyles(img, name);
    if (this.options.crossOrigin || this.options.crossOrigin === "") {
      img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
    }
    return img;
  },
  _setIconStyles: function(img, name) {
    var options = this.options;
    var sizeOption = options[name + "Size"];
    if (typeof sizeOption === "number") {
      sizeOption = [sizeOption, sizeOption];
    }
    var size2 = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size2 && size2.divideBy(2, true));
    img.className = "leaflet-marker-" + name + " " + (options.className || "");
    if (anchor) {
      img.style.marginLeft = -anchor.x + "px";
      img.style.marginTop = -anchor.y + "px";
    }
    if (size2) {
      img.style.width = size2.x + "px";
      img.style.height = size2.y + "px";
    }
  },
  _createImg: function(src, el) {
    el = el || document.createElement("img");
    el.src = src;
    return el;
  },
  _getIconUrl: function(name) {
    return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
  }
});
function icon(options) {
  return new Icon(options);
}
var IconDefault = Icon.extend({
  options: {
    iconUrl: "marker-icon.png",
    iconRetinaUrl: "marker-icon-2x.png",
    shadowUrl: "marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
    shadowSize: [41, 41]
  },
  _getIconUrl: function(name) {
    if (typeof IconDefault.imagePath !== "string") {
      IconDefault.imagePath = this._detectIconPath();
    }
    return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  },
  _stripUrl: function(path) {
    var strip = function(str, re, idx) {
      var match = re.exec(str);
      return match && match[idx];
    };
    path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
    return path && strip(path, /^(.*)marker-icon\.png$/, 1);
  },
  _detectIconPath: function() {
    var el = create$1("div", "leaflet-default-icon-path", document.body);
    var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
    document.body.removeChild(el);
    path = this._stripUrl(path);
    if (path) {
      return path;
    }
    var link = document.querySelector('link[href$="leaflet.css"]');
    if (!link) {
      return "";
    }
    return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
  }
});
var MarkerDrag = Handler.extend({
  initialize: function(marker) {
    this._marker = marker;
  },
  addHooks: function() {
    var icon2 = this._marker._icon;
    if (!this._draggable) {
      this._draggable = new Draggable(icon2, icon2, true);
    }
    this._draggable.on({
      dragstart: this._onDragStart,
      predrag: this._onPreDrag,
      drag: this._onDrag,
      dragend: this._onDragEnd
    }, this).enable();
    addClass(icon2, "leaflet-marker-draggable");
  },
  removeHooks: function() {
    this._draggable.off({
      dragstart: this._onDragStart,
      predrag: this._onPreDrag,
      drag: this._onDrag,
      dragend: this._onDragEnd
    }, this).disable();
    if (this._marker._icon) {
      removeClass(this._marker._icon, "leaflet-marker-draggable");
    }
  },
  moved: function() {
    return this._draggable && this._draggable._moved;
  },
  _adjustPan: function(e) {
    var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
    var panBounds = toBounds(
      bounds.min._subtract(origin).add(padding),
      bounds.max._subtract(origin).subtract(padding)
    );
    if (!panBounds.contains(iconPos)) {
      var movement = toPoint(
        (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
        (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
      ).multiplyBy(speed);
      map.panBy(movement, { animate: false });
      this._draggable._newPos._add(movement);
      this._draggable._startPos._add(movement);
      setPosition(marker._icon, this._draggable._newPos);
      this._onDrag(e);
      this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
    }
  },
  _onDragStart: function() {
    this._oldLatLng = this._marker.getLatLng();
    this._marker.closePopup && this._marker.closePopup();
    this._marker.fire("movestart").fire("dragstart");
  },
  _onPreDrag: function(e) {
    if (this._marker.options.autoPan) {
      cancelAnimFrame(this._panRequest);
      this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
    }
  },
  _onDrag: function(e) {
    var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
    if (shadow) {
      setPosition(shadow, iconPos);
    }
    marker._latlng = latlng;
    e.latlng = latlng;
    e.oldLatLng = this._oldLatLng;
    marker.fire("move", e).fire("drag", e);
  },
  _onDragEnd: function(e) {
    cancelAnimFrame(this._panRequest);
    delete this._oldLatLng;
    this._marker.fire("moveend").fire("dragend", e);
  }
});
var Marker = Layer.extend({
  // @section
  // @aka Marker options
  options: {
    // @option icon: Icon = *
    // Icon instance to use for rendering the marker.
    // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
    // If not specified, a common instance of `L.Icon.Default` is used.
    icon: new IconDefault(),
    // Option inherited from "Interactive layer" abstract class
    interactive: true,
    // @option keyboard: Boolean = true
    // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
    keyboard: true,
    // @option title: String = ''
    // Text for the browser tooltip that appear on marker hover (no tooltip by default).
    // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
    title: "",
    // @option alt: String = 'Marker'
    // Text for the `alt` attribute of the icon image.
    // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
    alt: "Marker",
    // @option zIndexOffset: Number = 0
    // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
    zIndexOffset: 0,
    // @option opacity: Number = 1.0
    // The opacity of the marker.
    opacity: 1,
    // @option riseOnHover: Boolean = false
    // If `true`, the marker will get on top of others when you hover the mouse over it.
    riseOnHover: false,
    // @option riseOffset: Number = 250
    // The z-index offset used for the `riseOnHover` feature.
    riseOffset: 250,
    // @option pane: String = 'markerPane'
    // `Map pane` where the markers icon will be added.
    pane: "markerPane",
    // @option shadowPane: String = 'shadowPane'
    // `Map pane` where the markers shadow will be added.
    shadowPane: "shadowPane",
    // @option bubblingMouseEvents: Boolean = false
    // When `true`, a mouse event on this marker will trigger the same event on the map
    // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
    bubblingMouseEvents: false,
    // @option autoPanOnFocus: Boolean = true
    // When `true`, the map will pan whenever the marker is focused (via
    // e.g. pressing `tab` on the keyboard) to ensure the marker is
    // visible within the map's bounds
    autoPanOnFocus: true,
    // @section Draggable marker options
    // @option draggable: Boolean = false
    // Whether the marker is draggable with mouse/touch or not.
    draggable: false,
    // @option autoPan: Boolean = false
    // Whether to pan the map when dragging this marker near its edge or not.
    autoPan: false,
    // @option autoPanPadding: Point = Point(50, 50)
    // Distance (in pixels to the left/right and to the top/bottom) of the
    // map edge to start panning the map.
    autoPanPadding: [50, 50],
    // @option autoPanSpeed: Number = 10
    // Number of pixels the map should pan by.
    autoPanSpeed: 10
  },
  /* @section
   *
   * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
   */
  initialize: function(latlng, options) {
    setOptions(this, options);
    this._latlng = toLatLng(latlng);
  },
  onAdd: function(map) {
    this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
    if (this._zoomAnimated) {
      map.on("zoomanim", this._animateZoom, this);
    }
    this._initIcon();
    this.update();
  },
  onRemove: function(map) {
    if (this.dragging && this.dragging.enabled()) {
      this.options.draggable = true;
      this.dragging.removeHooks();
    }
    delete this.dragging;
    if (this._zoomAnimated) {
      map.off("zoomanim", this._animateZoom, this);
    }
    this._removeIcon();
    this._removeShadow();
  },
  getEvents: function() {
    return {
      zoom: this.update,
      viewreset: this.update
    };
  },
  // @method getLatLng: LatLng
  // Returns the current geographical position of the marker.
  getLatLng: function() {
    return this._latlng;
  },
  // @method setLatLng(latlng: LatLng): this
  // Changes the marker position to the given point.
  setLatLng: function(latlng) {
    var oldLatLng = this._latlng;
    this._latlng = toLatLng(latlng);
    this.update();
    return this.fire("move", { oldLatLng, latlng: this._latlng });
  },
  // @method setZIndexOffset(offset: Number): this
  // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
  setZIndexOffset: function(offset) {
    this.options.zIndexOffset = offset;
    return this.update();
  },
  // @method getIcon: Icon
  // Returns the current icon used by the marker
  getIcon: function() {
    return this.options.icon;
  },
  // @method setIcon(icon: Icon): this
  // Changes the marker icon.
  setIcon: function(icon2) {
    this.options.icon = icon2;
    if (this._map) {
      this._initIcon();
      this.update();
    }
    if (this._popup) {
      this.bindPopup(this._popup, this._popup.options);
    }
    return this;
  },
  getElement: function() {
    return this._icon;
  },
  update: function() {
    if (this._icon && this._map) {
      var pos = this._map.latLngToLayerPoint(this._latlng).round();
      this._setPos(pos);
    }
    return this;
  },
  _initIcon: function() {
    var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
    var icon2 = options.icon.createIcon(this._icon), addIcon = false;
    if (icon2 !== this._icon) {
      if (this._icon) {
        this._removeIcon();
      }
      addIcon = true;
      if (options.title) {
        icon2.title = options.title;
      }
      if (icon2.tagName === "IMG") {
        icon2.alt = options.alt || "";
      }
    }
    addClass(icon2, classToAdd);
    if (options.keyboard) {
      icon2.tabIndex = "0";
      icon2.setAttribute("role", "button");
    }
    this._icon = icon2;
    if (options.riseOnHover) {
      this.on({
        mouseover: this._bringToFront,
        mouseout: this._resetZIndex
      });
    }
    if (this.options.autoPanOnFocus) {
      on2(icon2, "focus", this._panOnFocus, this);
    }
    var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
    if (newShadow !== this._shadow) {
      this._removeShadow();
      addShadow = true;
    }
    if (newShadow) {
      addClass(newShadow, classToAdd);
      newShadow.alt = "";
    }
    this._shadow = newShadow;
    if (options.opacity < 1) {
      this._updateOpacity();
    }
    if (addIcon) {
      this.getPane().appendChild(this._icon);
    }
    this._initInteraction();
    if (newShadow && addShadow) {
      this.getPane(options.shadowPane).appendChild(this._shadow);
    }
  },
  _removeIcon: function() {
    if (this.options.riseOnHover) {
      this.off({
        mouseover: this._bringToFront,
        mouseout: this._resetZIndex
      });
    }
    if (this.options.autoPanOnFocus) {
      off(this._icon, "focus", this._panOnFocus, this);
    }
    remove(this._icon);
    this.removeInteractiveTarget(this._icon);
    this._icon = null;
  },
  _removeShadow: function() {
    if (this._shadow) {
      remove(this._shadow);
    }
    this._shadow = null;
  },
  _setPos: function(pos) {
    if (this._icon) {
      setPosition(this._icon, pos);
    }
    if (this._shadow) {
      setPosition(this._shadow, pos);
    }
    this._zIndex = pos.y + this.options.zIndexOffset;
    this._resetZIndex();
  },
  _updateZIndex: function(offset) {
    if (this._icon) {
      this._icon.style.zIndex = this._zIndex + offset;
    }
  },
  _animateZoom: function(opt) {
    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
    this._setPos(pos);
  },
  _initInteraction: function() {
    if (!this.options.interactive) {
      return;
    }
    addClass(this._icon, "leaflet-interactive");
    this.addInteractiveTarget(this._icon);
    if (MarkerDrag) {
      var draggable = this.options.draggable;
      if (this.dragging) {
        draggable = this.dragging.enabled();
        this.dragging.disable();
      }
      this.dragging = new MarkerDrag(this);
      if (draggable) {
        this.dragging.enable();
      }
    }
  },
  // @method setOpacity(opacity: Number): this
  // Changes the opacity of the marker.
  setOpacity: function(opacity) {
    this.options.opacity = opacity;
    if (this._map) {
      this._updateOpacity();
    }
    return this;
  },
  _updateOpacity: function() {
    var opacity = this.options.opacity;
    if (this._icon) {
      setOpacity(this._icon, opacity);
    }
    if (this._shadow) {
      setOpacity(this._shadow, opacity);
    }
  },
  _bringToFront: function() {
    this._updateZIndex(this.options.riseOffset);
  },
  _resetZIndex: function() {
    this._updateZIndex(0);
  },
  _panOnFocus: function() {
    var map = this._map;
    if (!map) {
      return;
    }
    var iconOpts = this.options.icon.options;
    var size2 = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
    var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
    map.panInside(this._latlng, {
      paddingTopLeft: anchor,
      paddingBottomRight: size2.subtract(anchor)
    });
  },
  _getPopupAnchor: function() {
    return this.options.icon.options.popupAnchor;
  },
  _getTooltipAnchor: function() {
    return this.options.icon.options.tooltipAnchor;
  }
});
var Path = Layer.extend({
  // @section
  // @aka Path options
  options: {
    // @option stroke: Boolean = true
    // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
    stroke: true,
    // @option color: String = '#3388ff'
    // Stroke color
    color: "#3388ff",
    // @option weight: Number = 3
    // Stroke width in pixels
    weight: 3,
    // @option opacity: Number = 1.0
    // Stroke opacity
    opacity: 1,
    // @option lineCap: String= 'round'
    // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
    lineCap: "round",
    // @option lineJoin: String = 'round'
    // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
    lineJoin: "round",
    // @option dashArray: String = null
    // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
    dashArray: null,
    // @option dashOffset: String = null
    // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
    dashOffset: null,
    // @option fill: Boolean = depends
    // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
    fill: false,
    // @option fillColor: String = *
    // Fill color. Defaults to the value of the [`color`](#path-color) option
    fillColor: null,
    // @option fillOpacity: Number = 0.2
    // Fill opacity.
    fillOpacity: 0.2,
    // @option fillRule: String = 'evenodd'
    // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
    fillRule: "evenodd",
    // className: '',
    // Option inherited from "Interactive layer" abstract class
    interactive: true,
    // @option bubblingMouseEvents: Boolean = true
    // When `true`, a mouse event on this path will trigger the same event on the map
    // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
    bubblingMouseEvents: true
  },
  beforeAdd: function(map) {
    this._renderer = map.getRenderer(this);
  },
  onAdd: function() {
    this._renderer._initPath(this);
    this._reset();
    this._renderer._addPath(this);
  },
  onRemove: function() {
    this._renderer._removePath(this);
  },
  // @method redraw(): this
  // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
  redraw: function() {
    if (this._map) {
      this._renderer._updatePath(this);
    }
    return this;
  },
  // @method setStyle(style: Path options): this
  // Changes the appearance of a Path based on the options in the `Path options` object.
  setStyle: function(style2) {
    setOptions(this, style2);
    if (this._renderer) {
      this._renderer._updateStyle(this);
      if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
        this._updateBounds();
      }
    }
    return this;
  },
  // @method bringToFront(): this
  // Brings the layer to the top of all path layers.
  bringToFront: function() {
    if (this._renderer) {
      this._renderer._bringToFront(this);
    }
    return this;
  },
  // @method bringToBack(): this
  // Brings the layer to the bottom of all path layers.
  bringToBack: function() {
    if (this._renderer) {
      this._renderer._bringToBack(this);
    }
    return this;
  },
  getElement: function() {
    return this._path;
  },
  _reset: function() {
    this._project();
    this._update();
  },
  _clickTolerance: function() {
    return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
  }
});
var CircleMarker = Path.extend({
  // @section
  // @aka CircleMarker options
  options: {
    fill: true,
    // @option radius: Number = 10
    // Radius of the circle marker, in pixels
    radius: 10
  },
  initialize: function(latlng, options) {
    setOptions(this, options);
    this._latlng = toLatLng(latlng);
    this._radius = this.options.radius;
  },
  // @method setLatLng(latLng: LatLng): this
  // Sets the position of a circle marker to a new location.
  setLatLng: function(latlng) {
    var oldLatLng = this._latlng;
    this._latlng = toLatLng(latlng);
    this.redraw();
    return this.fire("move", { oldLatLng, latlng: this._latlng });
  },
  // @method getLatLng(): LatLng
  // Returns the current geographical position of the circle marker
  getLatLng: function() {
    return this._latlng;
  },
  // @method setRadius(radius: Number): this
  // Sets the radius of a circle marker. Units are in pixels.
  setRadius: function(radius) {
    this.options.radius = this._radius = radius;
    return this.redraw();
  },
  // @method getRadius(): Number
  // Returns the current radius of the circle
  getRadius: function() {
    return this._radius;
  },
  setStyle: function(options) {
    var radius = options && options.radius || this._radius;
    Path.prototype.setStyle.call(this, options);
    this.setRadius(radius);
    return this;
  },
  _project: function() {
    this._point = this._map.latLngToLayerPoint(this._latlng);
    this._updateBounds();
  },
  _updateBounds: function() {
    var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
    this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
  },
  _update: function() {
    if (this._map) {
      this._updatePath();
    }
  },
  _updatePath: function() {
    this._renderer._updateCircle(this);
  },
  _empty: function() {
    return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
  },
  // Needed by the `Canvas` renderer for interactivity
  _containsPoint: function(p) {
    return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
  }
});
var Circle = CircleMarker.extend({
  initialize: function(latlng, options, legacyOptions) {
    if (typeof options === "number") {
      options = extend({}, legacyOptions, { radius: options });
    }
    setOptions(this, options);
    this._latlng = toLatLng(latlng);
    if (isNaN(this.options.radius)) {
      throw new Error("Circle radius cannot be NaN");
    }
    this._mRadius = this.options.radius;
  },
  // @method setRadius(radius: Number): this
  // Sets the radius of a circle. Units are in meters.
  setRadius: function(radius) {
    this._mRadius = radius;
    return this.redraw();
  },
  // @method getRadius(): Number
  // Returns the current radius of a circle. Units are in meters.
  getRadius: function() {
    return this._mRadius;
  },
  // @method getBounds(): LatLngBounds
  // Returns the `LatLngBounds` of the path.
  getBounds: function() {
    var half = [this._radius, this._radiusY || this._radius];
    return new LatLngBounds(
      this._map.layerPointToLatLng(this._point.subtract(half)),
      this._map.layerPointToLatLng(this._point.add(half))
    );
  },
  setStyle: Path.prototype.setStyle,
  _project: function() {
    var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
    if (crs.distance === Earth.distance) {
      var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
      if (isNaN(lngR) || lngR === 0) {
        lngR = latR / Math.cos(Math.PI / 180 * lat);
      }
      this._point = p.subtract(map.getPixelOrigin());
      this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
      this._radiusY = p.y - top.y;
    } else {
      var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
      this._point = map.latLngToLayerPoint(this._latlng);
      this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
    }
    this._updateBounds();
  }
});
var Polyline = Path.extend({
  // @section
  // @aka Polyline options
  options: {
    // @option smoothFactor: Number = 1.0
    // How much to simplify the polyline on each zoom level. More means
    // better performance and smoother look, and less means more accurate representation.
    smoothFactor: 1,
    // @option noClip: Boolean = false
    // Disable polyline clipping.
    noClip: false
  },
  initialize: function(latlngs, options) {
    setOptions(this, options);
    this._setLatLngs(latlngs);
  },
  // @method getLatLngs(): LatLng[]
  // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
  getLatLngs: function() {
    return this._latlngs;
  },
  // @method setLatLngs(latlngs: LatLng[]): this
  // Replaces all the points in the polyline with the given array of geographical points.
  setLatLngs: function(latlngs) {
    this._setLatLngs(latlngs);
    return this.redraw();
  },
  // @method isEmpty(): Boolean
  // Returns `true` if the Polyline has no LatLngs.
  isEmpty: function() {
    return !this._latlngs.length;
  },
  // @method closestLayerPoint(p: Point): Point
  // Returns the point closest to `p` on the Polyline.
  closestLayerPoint: function(p) {
    var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
    for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
      var points = this._parts[j];
      for (var i = 1, len = points.length; i < len; i++) {
        p1 = points[i - 1];
        p2 = points[i];
        var sqDist = closest(p, p1, p2, true);
        if (sqDist < minDistance) {
          minDistance = sqDist;
          minPoint = closest(p, p1, p2);
        }
      }
    }
    if (minPoint) {
      minPoint.distance = Math.sqrt(minDistance);
    }
    return minPoint;
  },
  // @method getCenter(): LatLng
  // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
  getCenter: function() {
    if (!this._map) {
      throw new Error("Must add layer to map before using getCenter()");
    }
    return polylineCenter(this._defaultShape(), this._map.options.crs);
  },
  // @method getBounds(): LatLngBounds
  // Returns the `LatLngBounds` of the path.
  getBounds: function() {
    return this._bounds;
  },
  // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
  // Adds a given point to the polyline. By default, adds to the first ring of
  // the polyline in case of a multi-polyline, but can be overridden by passing
  // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
  addLatLng: function(latlng, latlngs) {
    latlngs = latlngs || this._defaultShape();
    latlng = toLatLng(latlng);
    latlngs.push(latlng);
    this._bounds.extend(latlng);
    return this.redraw();
  },
  _setLatLngs: function(latlngs) {
    this._bounds = new LatLngBounds();
    this._latlngs = this._convertLatLngs(latlngs);
  },
  _defaultShape: function() {
    return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
  },
  // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
  _convertLatLngs: function(latlngs) {
    var result = [], flat = isFlat(latlngs);
    for (var i = 0, len = latlngs.length; i < len; i++) {
      if (flat) {
        result[i] = toLatLng(latlngs[i]);
        this._bounds.extend(result[i]);
      } else {
        result[i] = this._convertLatLngs(latlngs[i]);
      }
    }
    return result;
  },
  _project: function() {
    var pxBounds = new Bounds();
    this._rings = [];
    this._projectLatlngs(this._latlngs, this._rings, pxBounds);
    if (this._bounds.isValid() && pxBounds.isValid()) {
      this._rawPxBounds = pxBounds;
      this._updateBounds();
    }
  },
  _updateBounds: function() {
    var w = this._clickTolerance(), p = new Point(w, w);
    if (!this._rawPxBounds) {
      return;
    }
    this._pxBounds = new Bounds([
      this._rawPxBounds.min.subtract(p),
      this._rawPxBounds.max.add(p)
    ]);
  },
  // recursively turns latlngs into a set of rings with projected coordinates
  _projectLatlngs: function(latlngs, result, projectedBounds) {
    var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
    if (flat) {
      ring = [];
      for (i = 0; i < len; i++) {
        ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
        projectedBounds.extend(ring[i]);
      }
      result.push(ring);
    } else {
      for (i = 0; i < len; i++) {
        this._projectLatlngs(latlngs[i], result, projectedBounds);
      }
    }
  },
  // clip polyline by renderer bounds so that we have less to render for performance
  _clipPoints: function() {
    var bounds = this._renderer._bounds;
    this._parts = [];
    if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
      return;
    }
    if (this.options.noClip) {
      this._parts = this._rings;
      return;
    }
    var parts = this._parts, i, j, k, len, len2, segment, points;
    for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
      points = this._rings[i];
      for (j = 0, len2 = points.length; j < len2 - 1; j++) {
        segment = clipSegment(points[j], points[j + 1], bounds, j, true);
        if (!segment) {
          continue;
        }
        parts[k] = parts[k] || [];
        parts[k].push(segment[0]);
        if (segment[1] !== points[j + 1] || j === len2 - 2) {
          parts[k].push(segment[1]);
          k++;
        }
      }
    }
  },
  // simplify each clipped part of the polyline for performance
  _simplifyPoints: function() {
    var parts = this._parts, tolerance = this.options.smoothFactor;
    for (var i = 0, len = parts.length; i < len; i++) {
      parts[i] = simplify(parts[i], tolerance);
    }
  },
  _update: function() {
    if (!this._map) {
      return;
    }
    this._clipPoints();
    this._simplifyPoints();
    this._updatePath();
  },
  _updatePath: function() {
    this._renderer._updatePoly(this);
  },
  // Needed by the `Canvas` renderer for interactivity
  _containsPoint: function(p, closed) {
    var i, j, k, len, len2, part, w = this._clickTolerance();
    if (!this._pxBounds || !this._pxBounds.contains(p)) {
      return false;
    }
    for (i = 0, len = this._parts.length; i < len; i++) {
      part = this._parts[i];
      for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
        if (!closed && j === 0) {
          continue;
        }
        if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
          return true;
        }
      }
    }
    return false;
  }
});
Polyline._flat = _flat;
var Polygon = Polyline.extend({
  options: {
    fill: true
  },
  isEmpty: function() {
    return !this._latlngs.length || !this._latlngs[0].length;
  },
  // @method getCenter(): LatLng
  // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
  getCenter: function() {
    if (!this._map) {
      throw new Error("Must add layer to map before using getCenter()");
    }
    return polygonCenter(this._defaultShape(), this._map.options.crs);
  },
  _convertLatLngs: function(latlngs) {
    var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
    if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
      result.pop();
    }
    return result;
  },
  _setLatLngs: function(latlngs) {
    Polyline.prototype._setLatLngs.call(this, latlngs);
    if (isFlat(this._latlngs)) {
      this._latlngs = [this._latlngs];
    }
  },
  _defaultShape: function() {
    return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
  },
  _clipPoints: function() {
    var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
    bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
    this._parts = [];
    if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
      return;
    }
    if (this.options.noClip) {
      this._parts = this._rings;
      return;
    }
    for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
      clipped = clipPolygon(this._rings[i], bounds, true);
      if (clipped.length) {
        this._parts.push(clipped);
      }
    }
  },
  _updatePath: function() {
    this._renderer._updatePoly(this, true);
  },
  // Needed by the `Canvas` renderer for interactivity
  _containsPoint: function(p) {
    var inside = false, part, p1, p2, i, j, k, len, len2;
    if (!this._pxBounds || !this._pxBounds.contains(p)) {
      return false;
    }
    for (i = 0, len = this._parts.length; i < len; i++) {
      part = this._parts[i];
      for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
        p1 = part[j];
        p2 = part[k];
        if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
          inside = !inside;
        }
      }
    }
    return inside || Polyline.prototype._containsPoint.call(this, p, true);
  }
});
var GeoJSON = FeatureGroup.extend({
  /* @section
   * @aka GeoJSON options
   *
   * @option pointToLayer: Function = *
   * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
   * called when data is added, passing the GeoJSON point feature and its `LatLng`.
   * The default is to spawn a default `Marker`:
   * ```js
   * function(geoJsonPoint, latlng) {
   * 	return L.marker(latlng);
   * }
   * ```
   *
   * @option style: Function = *
   * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
   * called internally when data is added.
   * The default value is to not override any defaults:
   * ```js
   * function (geoJsonFeature) {
   * 	return {}
   * }
   * ```
   *
   * @option onEachFeature: Function = *
   * A `Function` that will be called once for each created `Feature`, after it has
   * been created and styled. Useful for attaching events and popups to features.
   * The default is to do nothing with the newly created layers:
   * ```js
   * function (feature, layer) {}
   * ```
   *
   * @option filter: Function = *
   * A `Function` that will be used to decide whether to include a feature or not.
   * The default is to include all features:
   * ```js
   * function (geoJsonFeature) {
   * 	return true;
   * }
   * ```
   * Note: dynamically changing the `filter` option will have effect only on newly
   * added data. It will _not_ re-evaluate already included features.
   *
   * @option coordsToLatLng: Function = *
   * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
   * The default is the `coordsToLatLng` static method.
   *
   * @option markersInheritOptions: Boolean = false
   * Whether default Markers for "Point" type Features inherit from group options.
   */
  initialize: function(geojson, options) {
    setOptions(this, options);
    this._layers = {};
    if (geojson) {
      this.addData(geojson);
    }
  },
  // @method addData( <GeoJSON> data ): this
  // Adds a GeoJSON object to the layer.
  addData: function(geojson) {
    var features = isArray3(geojson) ? geojson : geojson.features, i, len, feature;
    if (features) {
      for (i = 0, len = features.length; i < len; i++) {
        feature = features[i];
        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
          this.addData(feature);
        }
      }
      return this;
    }
    var options = this.options;
    if (options.filter && !options.filter(geojson)) {
      return this;
    }
    var layer = geometryToLayer(geojson, options);
    if (!layer) {
      return this;
    }
    layer.feature = asFeature(geojson);
    layer.defaultOptions = layer.options;
    this.resetStyle(layer);
    if (options.onEachFeature) {
      options.onEachFeature(geojson, layer);
    }
    return this.addLayer(layer);
  },
  // @method resetStyle( <Path> layer? ): this
  // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
  // If `layer` is omitted, the style of all features in the current layer is reset.
  resetStyle: function(layer) {
    if (layer === void 0) {
      return this.eachLayer(this.resetStyle, this);
    }
    layer.options = extend({}, layer.defaultOptions);
    this._setLayerStyle(layer, this.options.style);
    return this;
  },
  // @method setStyle( <Function> style ): this
  // Changes styles of GeoJSON vector layers with the given style function.
  setStyle: function(style2) {
    return this.eachLayer(function(layer) {
      this._setLayerStyle(layer, style2);
    }, this);
  },
  _setLayerStyle: function(layer, style2) {
    if (layer.setStyle) {
      if (typeof style2 === "function") {
        style2 = style2(layer.feature);
      }
      layer.setStyle(style2);
    }
  }
});
function geometryToLayer(geojson, options) {
  var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
  if (!coords && !geometry) {
    return null;
  }
  switch (geometry.type) {
    case "Point":
      latlng = _coordsToLatLng(coords);
      return _pointToLayer(pointToLayer, geojson, latlng, options);
    case "MultiPoint":
      for (i = 0, len = coords.length; i < len; i++) {
        latlng = _coordsToLatLng(coords[i]);
        layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
      }
      return new FeatureGroup(layers2);
    case "LineString":
    case "MultiLineString":
      latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
      return new Polyline(latlngs, options);
    case "Polygon":
    case "MultiPolygon":
      latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
      return new Polygon(latlngs, options);
    case "GeometryCollection":
      for (i = 0, len = geometry.geometries.length; i < len; i++) {
        var geoLayer = geometryToLayer({
          geometry: geometry.geometries[i],
          type: "Feature",
          properties: geojson.properties
        }, options);
        if (geoLayer) {
          layers2.push(geoLayer);
        }
      }
      return new FeatureGroup(layers2);
    case "FeatureCollection":
      for (i = 0, len = geometry.features.length; i < len; i++) {
        var featureLayer = geometryToLayer(geometry.features[i], options);
        if (featureLayer) {
          layers2.push(featureLayer);
        }
      }
      return new FeatureGroup(layers2);
    default:
      throw new Error("Invalid GeoJSON object.");
  }
}
function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
  return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
}
function coordsToLatLng(coords) {
  return new LatLng(coords[1], coords[0], coords[2]);
}
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
  var latlngs = [];
  for (var i = 0, len = coords.length, latlng; i < len; i++) {
    latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
    latlngs.push(latlng);
  }
  return latlngs;
}
function latLngToCoords(latlng, precision) {
  latlng = toLatLng(latlng);
  return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
  var coords = [];
  for (var i = 0, len = latlngs.length; i < len; i++) {
    coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
  }
  if (!levelsDeep && closed && coords.length > 0) {
    coords.push(coords[0].slice());
  }
  return coords;
}
function getFeature(layer, newGeometry) {
  return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
}
function asFeature(geojson) {
  if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
    return geojson;
  }
  return {
    type: "Feature",
    properties: {},
    geometry: geojson
  };
}
var PointToGeoJSON = {
  toGeoJSON: function(precision) {
    return getFeature(this, {
      type: "Point",
      coordinates: latLngToCoords(this.getLatLng(), precision)
    });
  }
};
Marker.include(PointToGeoJSON);
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);
Polyline.include({
  toGeoJSON: function(precision) {
    var multi = !isFlat(this._latlngs);
    var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
    return getFeature(this, {
      type: (multi ? "Multi" : "") + "LineString",
      coordinates: coords
    });
  }
});
Polygon.include({
  toGeoJSON: function(precision) {
    var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
    var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
    if (!holes) {
      coords = [coords];
    }
    return getFeature(this, {
      type: (multi ? "Multi" : "") + "Polygon",
      coordinates: coords
    });
  }
});
LayerGroup.include({
  toMultiPoint: function(precision) {
    var coords = [];
    this.eachLayer(function(layer) {
      coords.push(layer.toGeoJSON(precision).geometry.coordinates);
    });
    return getFeature(this, {
      type: "MultiPoint",
      coordinates: coords
    });
  },
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
  toGeoJSON: function(precision) {
    var type = this.feature && this.feature.geometry && this.feature.geometry.type;
    if (type === "MultiPoint") {
      return this.toMultiPoint(precision);
    }
    var isGeometryCollection = type === "GeometryCollection", jsons = [];
    this.eachLayer(function(layer) {
      if (layer.toGeoJSON) {
        var json = layer.toGeoJSON(precision);
        if (isGeometryCollection) {
          jsons.push(json.geometry);
        } else {
          var feature = asFeature(json);
          if (feature.type === "FeatureCollection") {
            jsons.push.apply(jsons, feature.features);
          } else {
            jsons.push(feature);
          }
        }
      }
    });
    if (isGeometryCollection) {
      return getFeature(this, {
        geometries: jsons,
        type: "GeometryCollection"
      });
    }
    return {
      type: "FeatureCollection",
      features: jsons
    };
  }
});
function geoJSON(geojson, options) {
  return new GeoJSON(geojson, options);
}
var geoJson = geoJSON;
var ImageOverlay = Layer.extend({
  // @section
  // @aka ImageOverlay options
  options: {
    // @option opacity: Number = 1.0
    // The opacity of the image overlay.
    opacity: 1,
    // @option alt: String = ''
    // Text for the `alt` attribute of the image (useful for accessibility).
    alt: "",
    // @option interactive: Boolean = false
    // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
    interactive: false,
    // @option crossOrigin: Boolean|String = false
    // Whether the crossOrigin attribute will be added to the image.
    // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
    // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
    crossOrigin: false,
    // @option errorOverlayUrl: String = ''
    // URL to the overlay image to show in place of the overlay that failed to load.
    errorOverlayUrl: "",
    // @option zIndex: Number = 1
    // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
    zIndex: 1,
    // @option className: String = ''
    // A custom class name to assign to the image. Empty by default.
    className: ""
  },
  initialize: function(url, bounds, options) {
    this._url = url;
    this._bounds = toLatLngBounds(bounds);
    setOptions(this, options);
  },
  onAdd: function() {
    if (!this._image) {
      this._initImage();
      if (this.options.opacity < 1) {
        this._updateOpacity();
      }
    }
    if (this.options.interactive) {
      addClass(this._image, "leaflet-interactive");
      this.addInteractiveTarget(this._image);
    }
    this.getPane().appendChild(this._image);
    this._reset();
  },
  onRemove: function() {
    remove(this._image);
    if (this.options.interactive) {
      this.removeInteractiveTarget(this._image);
    }
  },
  // @method setOpacity(opacity: Number): this
  // Sets the opacity of the overlay.
  setOpacity: function(opacity) {
    this.options.opacity = opacity;
    if (this._image) {
      this._updateOpacity();
    }
    return this;
  },
  setStyle: function(styleOpts) {
    if (styleOpts.opacity) {
      this.setOpacity(styleOpts.opacity);
    }
    return this;
  },
  // @method bringToFront(): this
  // Brings the layer to the top of all overlays.
  bringToFront: function() {
    if (this._map) {
      toFront(this._image);
    }
    return this;
  },
  // @method bringToBack(): this
  // Brings the layer to the bottom of all overlays.
  bringToBack: function() {
    if (this._map) {
      toBack(this._image);
    }
    return this;
  },
  // @method setUrl(url: String): this
  // Changes the URL of the image.
  setUrl: function(url) {
    this._url = url;
    if (this._image) {
      this._image.src = url;
    }
    return this;
  },
  // @method setBounds(bounds: LatLngBounds): this
  // Update the bounds that this ImageOverlay covers
  setBounds: function(bounds) {
    this._bounds = toLatLngBounds(bounds);
    if (this._map) {
      this._reset();
    }
    return this;
  },
  getEvents: function() {
    var events = {
      zoom: this._reset,
      viewreset: this._reset
    };
    if (this._zoomAnimated) {
      events.zoomanim = this._animateZoom;
    }
    return events;
  },
  // @method setZIndex(value: Number): this
  // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
  setZIndex: function(value) {
    this.options.zIndex = value;
    this._updateZIndex();
    return this;
  },
  // @method getBounds(): LatLngBounds
  // Get the bounds that this ImageOverlay covers
  getBounds: function() {
    return this._bounds;
  },
  // @method getElement(): HTMLElement
  // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
  // used by this overlay.
  getElement: function() {
    return this._image;
  },
  _initImage: function() {
    var wasElementSupplied = this._url.tagName === "IMG";
    var img = this._image = wasElementSupplied ? this._url : create$1("img");
    addClass(img, "leaflet-image-layer");
    if (this._zoomAnimated) {
      addClass(img, "leaflet-zoom-animated");
    }
    if (this.options.className) {
      addClass(img, this.options.className);
    }
    img.onselectstart = falseFn;
    img.onmousemove = falseFn;
    img.onload = bind3(this.fire, this, "load");
    img.onerror = bind3(this._overlayOnError, this, "error");
    if (this.options.crossOrigin || this.options.crossOrigin === "") {
      img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
    }
    if (this.options.zIndex) {
      this._updateZIndex();
    }
    if (wasElementSupplied) {
      this._url = img.src;
      return;
    }
    img.src = this._url;
    img.alt = this.options.alt;
  },
  _animateZoom: function(e) {
    var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
    setTransform(this._image, offset, scale2);
  },
  _reset: function() {
    var image = this._image, bounds = new Bounds(
      this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
      this._map.latLngToLayerPoint(this._bounds.getSouthEast())
    ), size2 = bounds.getSize();
    setPosition(image, bounds.min);
    image.style.width = size2.x + "px";
    image.style.height = size2.y + "px";
  },
  _updateOpacity: function() {
    setOpacity(this._image, this.options.opacity);
  },
  _updateZIndex: function() {
    if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
      this._image.style.zIndex = this.options.zIndex;
    }
  },
  _overlayOnError: function() {
    this.fire("error");
    var errorUrl = this.options.errorOverlayUrl;
    if (errorUrl && this._url !== errorUrl) {
      this._url = errorUrl;
      this._image.src = errorUrl;
    }
  },
  // @method getCenter(): LatLng
  // Returns the center of the ImageOverlay.
  getCenter: function() {
    return this._bounds.getCenter();
  }
});
var VideoOverlay = ImageOverlay.extend({
  // @section
  // @aka VideoOverlay options
  options: {
    // @option autoplay: Boolean = true
    // Whether the video starts playing automatically when loaded.
    // On some browsers autoplay will only work with `muted: true`
    autoplay: true,
    // @option loop: Boolean = true
    // Whether the video will loop back to the beginning when played.
    loop: true,
    // @option keepAspectRatio: Boolean = true
    // Whether the video will save aspect ratio after the projection.
    // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
    keepAspectRatio: true,
    // @option muted: Boolean = false
    // Whether the video starts on mute when loaded.
    muted: false,
    // @option playsInline: Boolean = true
    // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
    playsInline: true
  },
  _initImage: function() {
    var wasElementSupplied = this._url.tagName === "VIDEO";
    var vid = this._image = wasElementSupplied ? this._url : create$1("video");
    addClass(vid, "leaflet-image-layer");
    if (this._zoomAnimated) {
      addClass(vid, "leaflet-zoom-animated");
    }
    if (this.options.className) {
      addClass(vid, this.options.className);
    }
    vid.onselectstart = falseFn;
    vid.onmousemove = falseFn;
    vid.onloadeddata = bind3(this.fire, this, "load");
    if (wasElementSupplied) {
      var sourceElements = vid.getElementsByTagName("source");
      var sources = [];
      for (var j = 0; j < sourceElements.length; j++) {
        sources.push(sourceElements[j].src);
      }
      this._url = sourceElements.length > 0 ? sources : [vid.src];
      return;
    }
    if (!isArray3(this._url)) {
      this._url = [this._url];
    }
    if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
      vid.style["objectFit"] = "fill";
    }
    vid.autoplay = !!this.options.autoplay;
    vid.loop = !!this.options.loop;
    vid.muted = !!this.options.muted;
    vid.playsInline = !!this.options.playsInline;
    for (var i = 0; i < this._url.length; i++) {
      var source = create$1("source");
      source.src = this._url[i];
      vid.appendChild(source);
    }
  }
  // @method getElement(): HTMLVideoElement
  // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
  // used by this overlay.
});
var SVGOverlay = ImageOverlay.extend({
  _initImage: function() {
    var el = this._image = this._url;
    addClass(el, "leaflet-image-layer");
    if (this._zoomAnimated) {
      addClass(el, "leaflet-zoom-animated");
    }
    if (this.options.className) {
      addClass(el, this.options.className);
    }
    el.onselectstart = falseFn;
    el.onmousemove = falseFn;
  }
  // @method getElement(): SVGElement
  // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
  // used by this overlay.
});
var DivOverlay = Layer.extend({
  // @section
  // @aka DivOverlay options
  options: {
    // @option interactive: Boolean = false
    // If true, the popup/tooltip will listen to the mouse events.
    interactive: false,
    // @option offset: Point = Point(0, 0)
    // The offset of the overlay position.
    offset: [0, 0],
    // @option className: String = ''
    // A custom CSS class name to assign to the overlay.
    className: "",
    // @option pane: String = undefined
    // `Map pane` where the overlay will be added.
    pane: void 0,
    // @option content: String|HTMLElement|Function = ''
    // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
    // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
    content: ""
  },
  initialize: function(options, source) {
    if (options && (options instanceof LatLng || isArray3(options))) {
      this._latlng = toLatLng(options);
      setOptions(this, source);
    } else {
      setOptions(this, options);
      this._source = source;
    }
    if (this.options.content) {
      this._content = this.options.content;
    }
  },
  // @method openOn(map: Map): this
  // Adds the overlay to the map.
  // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
  openOn: function(map) {
    map = arguments.length ? map : this._source._map;
    if (!map.hasLayer(this)) {
      map.addLayer(this);
    }
    return this;
  },
  // @method close(): this
  // Closes the overlay.
  // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
  // and `layer.closePopup()`/`.closeTooltip()`.
  close: function() {
    if (this._map) {
      this._map.removeLayer(this);
    }
    return this;
  },
  // @method toggle(layer?: Layer): this
  // Opens or closes the overlay bound to layer depending on its current state.
  // Argument may be omitted only for overlay bound to layer.
  // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
  toggle: function(layer) {
    if (this._map) {
      this.close();
    } else {
      if (arguments.length) {
        this._source = layer;
      } else {
        layer = this._source;
      }
      this._prepareOpen();
      this.openOn(layer._map);
    }
    return this;
  },
  onAdd: function(map) {
    this._zoomAnimated = map._zoomAnimated;
    if (!this._container) {
      this._initLayout();
    }
    if (map._fadeAnimated) {
      setOpacity(this._container, 0);
    }
    clearTimeout(this._removeTimeout);
    this.getPane().appendChild(this._container);
    this.update();
    if (map._fadeAnimated) {
      setOpacity(this._container, 1);
    }
    this.bringToFront();
    if (this.options.interactive) {
      addClass(this._container, "leaflet-interactive");
      this.addInteractiveTarget(this._container);
    }
  },
  onRemove: function(map) {
    if (map._fadeAnimated) {
      setOpacity(this._container, 0);
      this._removeTimeout = setTimeout(bind3(remove, void 0, this._container), 200);
    } else {
      remove(this._container);
    }
    if (this.options.interactive) {
      removeClass(this._container, "leaflet-interactive");
      this.removeInteractiveTarget(this._container);
    }
  },
  // @namespace DivOverlay
  // @method getLatLng: LatLng
  // Returns the geographical point of the overlay.
  getLatLng: function() {
    return this._latlng;
  },
  // @method setLatLng(latlng: LatLng): this
  // Sets the geographical point where the overlay will open.
  setLatLng: function(latlng) {
    this._latlng = toLatLng(latlng);
    if (this._map) {
      this._updatePosition();
      this._adjustPan();
    }
    return this;
  },
  // @method getContent: String|HTMLElement
  // Returns the content of the overlay.
  getContent: function() {
    return this._content;
  },
  // @method setContent(htmlContent: String|HTMLElement|Function): this
  // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
  // The function should return a `String` or `HTMLElement` to be used in the overlay.
  setContent: function(content) {
    this._content = content;
    this.update();
    return this;
  },
  // @method getElement: String|HTMLElement
  // Returns the HTML container of the overlay.
  getElement: function() {
    return this._container;
  },
  // @method update: null
  // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
  update: function() {
    if (!this._map) {
      return;
    }
    this._container.style.visibility = "hidden";
    this._updateContent();
    this._updateLayout();
    this._updatePosition();
    this._container.style.visibility = "";
    this._adjustPan();
  },
  getEvents: function() {
    var events = {
      zoom: this._updatePosition,
      viewreset: this._updatePosition
    };
    if (this._zoomAnimated) {
      events.zoomanim = this._animateZoom;
    }
    return events;
  },
  // @method isOpen: Boolean
  // Returns `true` when the overlay is visible on the map.
  isOpen: function() {
    return !!this._map && this._map.hasLayer(this);
  },
  // @method bringToFront: this
  // Brings this overlay in front of other overlays (in the same map pane).
  bringToFront: function() {
    if (this._map) {
      toFront(this._container);
    }
    return this;
  },
  // @method bringToBack: this
  // Brings this overlay to the back of other overlays (in the same map pane).
  bringToBack: function() {
    if (this._map) {
      toBack(this._container);
    }
    return this;
  },
  // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
  _prepareOpen: function(latlng) {
    var source = this._source;
    if (!source._map) {
      return false;
    }
    if (source instanceof FeatureGroup) {
      source = null;
      var layers2 = this._source._layers;
      for (var id in layers2) {
        if (layers2[id]._map) {
          source = layers2[id];
          break;
        }
      }
      if (!source) {
        return false;
      }
      this._source = source;
    }
    if (!latlng) {
      if (source.getCenter) {
        latlng = source.getCenter();
      } else if (source.getLatLng) {
        latlng = source.getLatLng();
      } else if (source.getBounds) {
        latlng = source.getBounds().getCenter();
      } else {
        throw new Error("Unable to get source layer LatLng.");
      }
    }
    this.setLatLng(latlng);
    if (this._map) {
      this.update();
    }
    return true;
  },
  _updateContent: function() {
    if (!this._content) {
      return;
    }
    var node = this._contentNode;
    var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
    if (typeof content === "string") {
      node.innerHTML = content;
    } else {
      while (node.hasChildNodes()) {
        node.removeChild(node.firstChild);
      }
      node.appendChild(content);
    }
    this.fire("contentupdate");
  },
  _updatePosition: function() {
    if (!this._map) {
      return;
    }
    var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
    if (this._zoomAnimated) {
      setPosition(this._container, pos.add(anchor));
    } else {
      offset = offset.add(pos).add(anchor);
    }
    var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
    this._container.style.bottom = bottom + "px";
    this._container.style.left = left + "px";
  },
  _getAnchor: function() {
    return [0, 0];
  }
});
Map2.include({
  _initOverlay: function(OverlayClass, content, latlng, options) {
    var overlay = content;
    if (!(overlay instanceof OverlayClass)) {
      overlay = new OverlayClass(options).setContent(content);
    }
    if (latlng) {
      overlay.setLatLng(latlng);
    }
    return overlay;
  }
});
Layer.include({
  _initOverlay: function(OverlayClass, old, content, options) {
    var overlay = content;
    if (overlay instanceof OverlayClass) {
      setOptions(overlay, options);
      overlay._source = this;
    } else {
      overlay = old && !options ? old : new OverlayClass(options, this);
      overlay.setContent(content);
    }
    return overlay;
  }
});
var Popup = DivOverlay.extend({
  // @section
  // @aka Popup options
  options: {
    // @option pane: String = 'popupPane'
    // `Map pane` where the popup will be added.
    pane: "popupPane",
    // @option offset: Point = Point(0, 7)
    // The offset of the popup position.
    offset: [0, 7],
    // @option maxWidth: Number = 300
    // Max width of the popup, in pixels.
    maxWidth: 300,
    // @option minWidth: Number = 50
    // Min width of the popup, in pixels.
    minWidth: 50,
    // @option maxHeight: Number = null
    // If set, creates a scrollable container of the given height
    // inside a popup if its content exceeds it.
    // The scrollable container can be styled using the
    // `leaflet-popup-scrolled` CSS class selector.
    maxHeight: null,
    // @option autoPan: Boolean = true
    // Set it to `false` if you don't want the map to do panning animation
    // to fit the opened popup.
    autoPan: true,
    // @option autoPanPaddingTopLeft: Point = null
    // The margin between the popup and the top left corner of the map
    // view after autopanning was performed.
    autoPanPaddingTopLeft: null,
    // @option autoPanPaddingBottomRight: Point = null
    // The margin between the popup and the bottom right corner of the map
    // view after autopanning was performed.
    autoPanPaddingBottomRight: null,
    // @option autoPanPadding: Point = Point(5, 5)
    // Equivalent of setting both top left and bottom right autopan padding to the same value.
    autoPanPadding: [5, 5],
    // @option keepInView: Boolean = false
    // Set it to `true` if you want to prevent users from panning the popup
    // off of the screen while it is open.
    keepInView: false,
    // @option closeButton: Boolean = true
    // Controls the presence of a close button in the popup.
    closeButton: true,
    // @option autoClose: Boolean = true
    // Set it to `false` if you want to override the default behavior of
    // the popup closing when another popup is opened.
    autoClose: true,
    // @option closeOnEscapeKey: Boolean = true
    // Set it to `false` if you want to override the default behavior of
    // the ESC key for closing of the popup.
    closeOnEscapeKey: true,
    // @option closeOnClick: Boolean = *
    // Set it if you want to override the default behavior of the popup closing when user clicks
    // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
    // @option className: String = ''
    // A custom CSS class name to assign to the popup.
    className: ""
  },
  // @namespace Popup
  // @method openOn(map: Map): this
  // Alternative to `map.openPopup(popup)`.
  // Adds the popup to the map and closes the previous one.
  openOn: function(map) {
    map = arguments.length ? map : this._source._map;
    if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
      map.removeLayer(map._popup);
    }
    map._popup = this;
    return DivOverlay.prototype.openOn.call(this, map);
  },
  onAdd: function(map) {
    DivOverlay.prototype.onAdd.call(this, map);
    map.fire("popupopen", { popup: this });
    if (this._source) {
      this._source.fire("popupopen", { popup: this }, true);
      if (!(this._source instanceof Path)) {
        this._source.on("preclick", stopPropagation);
      }
    }
  },
  onRemove: function(map) {
    DivOverlay.prototype.onRemove.call(this, map);
    map.fire("popupclose", { popup: this });
    if (this._source) {
      this._source.fire("popupclose", { popup: this }, true);
      if (!(this._source instanceof Path)) {
        this._source.off("preclick", stopPropagation);
      }
    }
  },
  getEvents: function() {
    var events = DivOverlay.prototype.getEvents.call(this);
    if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
      events.preclick = this.close;
    }
    if (this.options.keepInView) {
      events.moveend = this._adjustPan;
    }
    return events;
  },
  _initLayout: function() {
    var prefix2 = "leaflet-popup", container = this._container = create$1(
      "div",
      prefix2 + " " + (this.options.className || "") + " leaflet-zoom-animated"
    );
    var wrapper = this._wrapper = create$1("div", prefix2 + "-content-wrapper", container);
    this._contentNode = create$1("div", prefix2 + "-content", wrapper);
    disableClickPropagation(container);
    disableScrollPropagation(this._contentNode);
    on2(container, "contextmenu", stopPropagation);
    this._tipContainer = create$1("div", prefix2 + "-tip-container", container);
    this._tip = create$1("div", prefix2 + "-tip", this._tipContainer);
    if (this.options.closeButton) {
      var closeButton = this._closeButton = create$1("a", prefix2 + "-close-button", container);
      closeButton.setAttribute("role", "button");
      closeButton.setAttribute("aria-label", "Close popup");
      closeButton.href = "#close";
      closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
      on2(closeButton, "click", function(ev) {
        preventDefault(ev);
        this.close();
      }, this);
    }
  },
  _updateLayout: function() {
    var container = this._contentNode, style2 = container.style;
    style2.width = "";
    style2.whiteSpace = "nowrap";
    var width = container.offsetWidth;
    width = Math.min(width, this.options.maxWidth);
    width = Math.max(width, this.options.minWidth);
    style2.width = width + 1 + "px";
    style2.whiteSpace = "";
    style2.height = "";
    var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
    if (maxHeight && height > maxHeight) {
      style2.height = maxHeight + "px";
      addClass(container, scrolledClass);
    } else {
      removeClass(container, scrolledClass);
    }
    this._containerWidth = this._container.offsetWidth;
  },
  _animateZoom: function(e) {
    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
    setPosition(this._container, pos.add(anchor));
  },
  _adjustPan: function() {
    if (!this.options.autoPan) {
      return;
    }
    if (this._map._panAnim) {
      this._map._panAnim.stop();
    }
    if (this._autopanning) {
      this._autopanning = false;
      return;
    }
    var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
    layerPos._add(getPosition(this._container));
    var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size2 = map.getSize(), dx = 0, dy = 0;
    if (containerPos.x + containerWidth + paddingBR.x > size2.x) {
      dx = containerPos.x + containerWidth - size2.x + paddingBR.x;
    }
    if (containerPos.x - dx - paddingTL.x < 0) {
      dx = containerPos.x - paddingTL.x;
    }
    if (containerPos.y + containerHeight + paddingBR.y > size2.y) {
      dy = containerPos.y + containerHeight - size2.y + paddingBR.y;
    }
    if (containerPos.y - dy - paddingTL.y < 0) {
      dy = containerPos.y - paddingTL.y;
    }
    if (dx || dy) {
      if (this.options.keepInView) {
        this._autopanning = true;
      }
      map.fire("autopanstart").panBy([dx, dy]);
    }
  },
  _getAnchor: function() {
    return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
  }
});
Map2.mergeOptions({
  closePopupOnClick: true
});
Map2.include({
  // @method openPopup(popup: Popup): this
  // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
  // @alternative
  // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
  // Creates a popup with the specified content and options and opens it in the given point on a map.
  openPopup: function(popup, latlng, options) {
    this._initOverlay(Popup, popup, latlng, options).openOn(this);
    return this;
  },
  // @method closePopup(popup?: Popup): this
  // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
  closePopup: function(popup) {
    popup = arguments.length ? popup : this._popup;
    if (popup) {
      popup.close();
    }
    return this;
  }
});
Layer.include({
  // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
  // Binds a popup to the layer with the passed `content` and sets up the
  // necessary event listeners. If a `Function` is passed it will receive
  // the layer as the first argument and should return a `String` or `HTMLElement`.
  bindPopup: function(content, options) {
    this._popup = this._initOverlay(Popup, this._popup, content, options);
    if (!this._popupHandlersAdded) {
      this.on({
        click: this._openPopup,
        keypress: this._onKeyPress,
        remove: this.closePopup,
        move: this._movePopup
      });
      this._popupHandlersAdded = true;
    }
    return this;
  },
  // @method unbindPopup(): this
  // Removes the popup previously bound with `bindPopup`.
  unbindPopup: function() {
    if (this._popup) {
      this.off({
        click: this._openPopup,
        keypress: this._onKeyPress,
        remove: this.closePopup,
        move: this._movePopup
      });
      this._popupHandlersAdded = false;
      this._popup = null;
    }
    return this;
  },
  // @method openPopup(latlng?: LatLng): this
  // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
  openPopup: function(latlng) {
    if (this._popup) {
      if (!(this instanceof FeatureGroup)) {
        this._popup._source = this;
      }
      if (this._popup._prepareOpen(latlng || this._latlng)) {
        this._popup.openOn(this._map);
      }
    }
    return this;
  },
  // @method closePopup(): this
  // Closes the popup bound to this layer if it is open.
  closePopup: function() {
    if (this._popup) {
      this._popup.close();
    }
    return this;
  },
  // @method togglePopup(): this
  // Opens or closes the popup bound to this layer depending on its current state.
  togglePopup: function() {
    if (this._popup) {
      this._popup.toggle(this);
    }
    return this;
  },
  // @method isPopupOpen(): boolean
  // Returns `true` if the popup bound to this layer is currently open.
  isPopupOpen: function() {
    return this._popup ? this._popup.isOpen() : false;
  },
  // @method setPopupContent(content: String|HTMLElement|Popup): this
  // Sets the content of the popup bound to this layer.
  setPopupContent: function(content) {
    if (this._popup) {
      this._popup.setContent(content);
    }
    return this;
  },
  // @method getPopup(): Popup
  // Returns the popup bound to this layer.
  getPopup: function() {
    return this._popup;
  },
  _openPopup: function(e) {
    if (!this._popup || !this._map) {
      return;
    }
    stop2(e);
    var target = e.layer || e.target;
    if (this._popup._source === target && !(target instanceof Path)) {
      if (this._map.hasLayer(this._popup)) {
        this.closePopup();
      } else {
        this.openPopup(e.latlng);
      }
      return;
    }
    this._popup._source = target;
    this.openPopup(e.latlng);
  },
  _movePopup: function(e) {
    this._popup.setLatLng(e.latlng);
  },
  _onKeyPress: function(e) {
    if (e.originalEvent.keyCode === 13) {
      this._openPopup(e);
    }
  }
});
var Tooltip2 = DivOverlay.extend({
  // @section
  // @aka Tooltip options
  options: {
    // @option pane: String = 'tooltipPane'
    // `Map pane` where the tooltip will be added.
    pane: "tooltipPane",
    // @option offset: Point = Point(0, 0)
    // Optional offset of the tooltip position.
    offset: [0, 0],
    // @option direction: String = 'auto'
    // Direction where to open the tooltip. Possible values are: `right`, `left`,
    // `top`, `bottom`, `center`, `auto`.
    // `auto` will dynamically switch between `right` and `left` according to the tooltip
    // position on the map.
    direction: "auto",
    // @option permanent: Boolean = false
    // Whether to open the tooltip permanently or only on mouseover.
    permanent: false,
    // @option sticky: Boolean = false
    // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
    sticky: false,
    // @option opacity: Number = 0.9
    // Tooltip container opacity.
    opacity: 0.9
  },
  onAdd: function(map) {
    DivOverlay.prototype.onAdd.call(this, map);
    this.setOpacity(this.options.opacity);
    map.fire("tooltipopen", { tooltip: this });
    if (this._source) {
      this.addEventParent(this._source);
      this._source.fire("tooltipopen", { tooltip: this }, true);
    }
  },
  onRemove: function(map) {
    DivOverlay.prototype.onRemove.call(this, map);
    map.fire("tooltipclose", { tooltip: this });
    if (this._source) {
      this.removeEventParent(this._source);
      this._source.fire("tooltipclose", { tooltip: this }, true);
    }
  },
  getEvents: function() {
    var events = DivOverlay.prototype.getEvents.call(this);
    if (!this.options.permanent) {
      events.preclick = this.close;
    }
    return events;
  },
  _initLayout: function() {
    var prefix2 = "leaflet-tooltip", className = prefix2 + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
    this._contentNode = this._container = create$1("div", className);
    this._container.setAttribute("role", "tooltip");
    this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
  },
  _updateLayout: function() {
  },
  _adjustPan: function() {
  },
  _setPosition: function(pos) {
    var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
    if (direction === "top") {
      subX = tooltipWidth / 2;
      subY = tooltipHeight;
    } else if (direction === "bottom") {
      subX = tooltipWidth / 2;
      subY = 0;
    } else if (direction === "center") {
      subX = tooltipWidth / 2;
      subY = tooltipHeight / 2;
    } else if (direction === "right") {
      subX = 0;
      subY = tooltipHeight / 2;
    } else if (direction === "left") {
      subX = tooltipWidth;
      subY = tooltipHeight / 2;
    } else if (tooltipPoint.x < centerPoint.x) {
      direction = "right";
      subX = 0;
      subY = tooltipHeight / 2;
    } else {
      direction = "left";
      subX = tooltipWidth + (offset.x + anchor.x) * 2;
      subY = tooltipHeight / 2;
    }
    pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
    removeClass(container, "leaflet-tooltip-right");
    removeClass(container, "leaflet-tooltip-left");
    removeClass(container, "leaflet-tooltip-top");
    removeClass(container, "leaflet-tooltip-bottom");
    addClass(container, "leaflet-tooltip-" + direction);
    setPosition(container, pos);
  },
  _updatePosition: function() {
    var pos = this._map.latLngToLayerPoint(this._latlng);
    this._setPosition(pos);
  },
  setOpacity: function(opacity) {
    this.options.opacity = opacity;
    if (this._container) {
      setOpacity(this._container, opacity);
    }
  },
  _animateZoom: function(e) {
    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
    this._setPosition(pos);
  },
  _getAnchor: function() {
    return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
  }
});
Map2.include({
  // @method openTooltip(tooltip: Tooltip): this
  // Opens the specified tooltip.
  // @alternative
  // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
  // Creates a tooltip with the specified content and options and open it.
  openTooltip: function(tooltip, latlng, options) {
    this._initOverlay(Tooltip2, tooltip, latlng, options).openOn(this);
    return this;
  },
  // @method closeTooltip(tooltip: Tooltip): this
  // Closes the tooltip given as parameter.
  closeTooltip: function(tooltip) {
    tooltip.close();
    return this;
  }
});
Layer.include({
  // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
  // Binds a tooltip to the layer with the passed `content` and sets up the
  // necessary event listeners. If a `Function` is passed it will receive
  // the layer as the first argument and should return a `String` or `HTMLElement`.
  bindTooltip: function(content, options) {
    if (this._tooltip && this.isTooltipOpen()) {
      this.unbindTooltip();
    }
    this._tooltip = this._initOverlay(Tooltip2, this._tooltip, content, options);
    this._initTooltipInteractions();
    if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
      this.openTooltip();
    }
    return this;
  },
  // @method unbindTooltip(): this
  // Removes the tooltip previously bound with `bindTooltip`.
  unbindTooltip: function() {
    if (this._tooltip) {
      this._initTooltipInteractions(true);
      this.closeTooltip();
      this._tooltip = null;
    }
    return this;
  },
  _initTooltipInteractions: function(remove2) {
    if (!remove2 && this._tooltipHandlersAdded) {
      return;
    }
    var onOff = remove2 ? "off" : "on", events = {
      remove: this.closeTooltip,
      move: this._moveTooltip
    };
    if (!this._tooltip.options.permanent) {
      events.mouseover = this._openTooltip;
      events.mouseout = this.closeTooltip;
      events.click = this._openTooltip;
      if (this._map) {
        this._addFocusListeners();
      } else {
        events.add = this._addFocusListeners;
      }
    } else {
      events.add = this._openTooltip;
    }
    if (this._tooltip.options.sticky) {
      events.mousemove = this._moveTooltip;
    }
    this[onOff](events);
    this._tooltipHandlersAdded = !remove2;
  },
  // @method openTooltip(latlng?: LatLng): this
  // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
  openTooltip: function(latlng) {
    if (this._tooltip) {
      if (!(this instanceof FeatureGroup)) {
        this._tooltip._source = this;
      }
      if (this._tooltip._prepareOpen(latlng)) {
        this._tooltip.openOn(this._map);
        if (this.getElement) {
          this._setAriaDescribedByOnLayer(this);
        } else if (this.eachLayer) {
          this.eachLayer(this._setAriaDescribedByOnLayer, this);
        }
      }
    }
    return this;
  },
  // @method closeTooltip(): this
  // Closes the tooltip bound to this layer if it is open.
  closeTooltip: function() {
    if (this._tooltip) {
      return this._tooltip.close();
    }
  },
  // @method toggleTooltip(): this
  // Opens or closes the tooltip bound to this layer depending on its current state.
  toggleTooltip: function() {
    if (this._tooltip) {
      this._tooltip.toggle(this);
    }
    return this;
  },
  // @method isTooltipOpen(): boolean
  // Returns `true` if the tooltip bound to this layer is currently open.
  isTooltipOpen: function() {
    return this._tooltip.isOpen();
  },
  // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
  // Sets the content of the tooltip bound to this layer.
  setTooltipContent: function(content) {
    if (this._tooltip) {
      this._tooltip.setContent(content);
    }
    return this;
  },
  // @method getTooltip(): Tooltip
  // Returns the tooltip bound to this layer.
  getTooltip: function() {
    return this._tooltip;
  },
  _addFocusListeners: function() {
    if (this.getElement) {
      this._addFocusListenersOnLayer(this);
    } else if (this.eachLayer) {
      this.eachLayer(this._addFocusListenersOnLayer, this);
    }
  },
  _addFocusListenersOnLayer: function(layer) {
    var el = typeof layer.getElement === "function" && layer.getElement();
    if (el) {
      on2(el, "focus", function() {
        this._tooltip._source = layer;
        this.openTooltip();
      }, this);
      on2(el, "blur", this.closeTooltip, this);
    }
  },
  _setAriaDescribedByOnLayer: function(layer) {
    var el = typeof layer.getElement === "function" && layer.getElement();
    if (el) {
      el.setAttribute("aria-describedby", this._tooltip._container.id);
    }
  },
  _openTooltip: function(e) {
    if (!this._tooltip || !this._map) {
      return;
    }
    if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
      this._openOnceFlag = true;
      var that = this;
      this._map.once("moveend", function() {
        that._openOnceFlag = false;
        that._openTooltip(e);
      });
      return;
    }
    this._tooltip._source = e.layer || e.target;
    this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
  },
  _moveTooltip: function(e) {
    var latlng = e.latlng, containerPoint, layerPoint;
    if (this._tooltip.options.sticky && e.originalEvent) {
      containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
      layerPoint = this._map.containerPointToLayerPoint(containerPoint);
      latlng = this._map.layerPointToLatLng(layerPoint);
    }
    this._tooltip.setLatLng(latlng);
  }
});
var DivIcon = Icon.extend({
  options: {
    // @section
    // @aka DivIcon options
    iconSize: [12, 12],
    // also can be set through CSS
    // iconAnchor: (Point),
    // popupAnchor: (Point),
    // @option html: String|HTMLElement = ''
    // Custom HTML code to put inside the div element, empty by default. Alternatively,
    // an instance of `HTMLElement`.
    html: false,
    // @option bgPos: Point = [0, 0]
    // Optional relative position of the background, in pixels
    bgPos: null,
    className: "leaflet-div-icon"
  },
  createIcon: function(oldIcon) {
    var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
    if (options.html instanceof Element) {
      empty(div);
      div.appendChild(options.html);
    } else {
      div.innerHTML = options.html !== false ? options.html : "";
    }
    if (options.bgPos) {
      var bgPos = toPoint(options.bgPos);
      div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
    }
    this._setIconStyles(div, "icon");
    return div;
  },
  createShadow: function() {
    return null;
  }
});
Icon.Default = IconDefault;
var GridLayer = Layer.extend({
  // @section
  // @aka GridLayer options
  options: {
    // @option tileSize: Number|Point = 256
    // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
    tileSize: 256,
    // @option opacity: Number = 1.0
    // Opacity of the tiles. Can be used in the `createTile()` function.
    opacity: 1,
    // @option updateWhenIdle: Boolean = (depends)
    // Load new tiles only when panning ends.
    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
    // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
    updateWhenIdle: Browser.mobile,
    // @option updateWhenZooming: Boolean = true
    // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
    updateWhenZooming: true,
    // @option updateInterval: Number = 200
    // Tiles will not update more than once every `updateInterval` milliseconds when panning.
    updateInterval: 200,
    // @option zIndex: Number = 1
    // The explicit zIndex of the tile layer.
    zIndex: 1,
    // @option bounds: LatLngBounds = undefined
    // If set, tiles will only be loaded inside the set `LatLngBounds`.
    bounds: null,
    // @option minZoom: Number = 0
    // The minimum zoom level down to which this layer will be displayed (inclusive).
    minZoom: 0,
    // @option maxZoom: Number = undefined
    // The maximum zoom level up to which this layer will be displayed (inclusive).
    maxZoom: void 0,
    // @option maxNativeZoom: Number = undefined
    // Maximum zoom number the tile source has available. If it is specified,
    // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
    // from `maxNativeZoom` level and auto-scaled.
    maxNativeZoom: void 0,
    // @option minNativeZoom: Number = undefined
    // Minimum zoom number the tile source has available. If it is specified,
    // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
    // from `minNativeZoom` level and auto-scaled.
    minNativeZoom: void 0,
    // @option noWrap: Boolean = false
    // Whether the layer is wrapped around the antimeridian. If `true`, the
    // GridLayer will only be displayed once at low zoom levels. Has no
    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
    // tiles outside the CRS limits.
    noWrap: false,
    // @option pane: String = 'tilePane'
    // `Map pane` where the grid layer will be added.
    pane: "tilePane",
    // @option className: String = ''
    // A custom class name to assign to the tile layer. Empty by default.
    className: "",
    // @option keepBuffer: Number = 2
    // When panning the map, keep this many rows and columns of tiles before unloading them.
    keepBuffer: 2
  },
  initialize: function(options) {
    setOptions(this, options);
  },
  onAdd: function() {
    this._initContainer();
    this._levels = {};
    this._tiles = {};
    this._resetView();
  },
  beforeAdd: function(map) {
    map._addZoomLimit(this);
  },
  onRemove: function(map) {
    this._removeAllTiles();
    remove(this._container);
    map._removeZoomLimit(this);
    this._container = null;
    this._tileZoom = void 0;
  },
  // @method bringToFront: this
  // Brings the tile layer to the top of all tile layers.
  bringToFront: function() {
    if (this._map) {
      toFront(this._container);
      this._setAutoZIndex(Math.max);
    }
    return this;
  },
  // @method bringToBack: this
  // Brings the tile layer to the bottom of all tile layers.
  bringToBack: function() {
    if (this._map) {
      toBack(this._container);
      this._setAutoZIndex(Math.min);
    }
    return this;
  },
  // @method getContainer: HTMLElement
  // Returns the HTML element that contains the tiles for this layer.
  getContainer: function() {
    return this._container;
  },
  // @method setOpacity(opacity: Number): this
  // Changes the [opacity](#gridlayer-opacity) of the grid layer.
  setOpacity: function(opacity) {
    this.options.opacity = opacity;
    this._updateOpacity();
    return this;
  },
  // @method setZIndex(zIndex: Number): this
  // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
  setZIndex: function(zIndex) {
    this.options.zIndex = zIndex;
    this._updateZIndex();
    return this;
  },
  // @method isLoading: Boolean
  // Returns `true` if any tile in the grid layer has not finished loading.
  isLoading: function() {
    return this._loading;
  },
  // @method redraw: this
  // Causes the layer to clear all the tiles and request them again.
  redraw: function() {
    if (this._map) {
      this._removeAllTiles();
      var tileZoom = this._clampZoom(this._map.getZoom());
      if (tileZoom !== this._tileZoom) {
        this._tileZoom = tileZoom;
        this._updateLevels();
      }
      this._update();
    }
    return this;
  },
  getEvents: function() {
    var events = {
      viewprereset: this._invalidateAll,
      viewreset: this._resetView,
      zoom: this._resetView,
      moveend: this._onMoveEnd
    };
    if (!this.options.updateWhenIdle) {
      if (!this._onMove) {
        this._onMove = throttle2(this._onMoveEnd, this.options.updateInterval, this);
      }
      events.move = this._onMove;
    }
    if (this._zoomAnimated) {
      events.zoomanim = this._animateZoom;
    }
    return events;
  },
  // @section Extension methods
  // Layers extending `GridLayer` shall reimplement the following method.
  // @method createTile(coords: Object, done?: Function): HTMLElement
  // Called only internally, must be overridden by classes extending `GridLayer`.
  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  // is specified, it must be called when the tile has finished loading and drawing.
  createTile: function() {
    return document.createElement("div");
  },
  // @section
  // @method getTileSize: Point
  // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
  getTileSize: function() {
    var s = this.options.tileSize;
    return s instanceof Point ? s : new Point(s, s);
  },
  _updateZIndex: function() {
    if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
      this._container.style.zIndex = this.options.zIndex;
    }
  },
  _setAutoZIndex: function(compare) {
    var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
    for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
      zIndex = layers2[i].style.zIndex;
      if (layers2[i] !== this._container && zIndex) {
        edgeZIndex = compare(edgeZIndex, +zIndex);
      }
    }
    if (isFinite(edgeZIndex)) {
      this.options.zIndex = edgeZIndex + compare(-1, 1);
      this._updateZIndex();
    }
  },
  _updateOpacity: function() {
    if (!this._map) {
      return;
    }
    if (Browser.ielt9) {
      return;
    }
    setOpacity(this._container, this.options.opacity);
    var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
    for (var key in this._tiles) {
      var tile = this._tiles[key];
      if (!tile.current || !tile.loaded) {
        continue;
      }
      var fade = Math.min(1, (now - tile.loaded) / 200);
      setOpacity(tile.el, fade);
      if (fade < 1) {
        nextFrame = true;
      } else {
        if (tile.active) {
          willPrune = true;
        } else {
          this._onOpaqueTile(tile);
        }
        tile.active = true;
      }
    }
    if (willPrune && !this._noPrune) {
      this._pruneTiles();
    }
    if (nextFrame) {
      cancelAnimFrame(this._fadeFrame);
      this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
    }
  },
  _onOpaqueTile: falseFn,
  _initContainer: function() {
    if (this._container) {
      return;
    }
    this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
    this._updateZIndex();
    if (this.options.opacity < 1) {
      this._updateOpacity();
    }
    this.getPane().appendChild(this._container);
  },
  _updateLevels: function() {
    var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
    if (zoom2 === void 0) {
      return void 0;
    }
    for (var z in this._levels) {
      z = Number(z);
      if (this._levels[z].el.children.length || z === zoom2) {
        this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
        this._onUpdateLevel(z);
      } else {
        remove(this._levels[z].el);
        this._removeTilesAtZoom(z);
        this._onRemoveLevel(z);
        delete this._levels[z];
      }
    }
    var level = this._levels[zoom2], map = this._map;
    if (!level) {
      level = this._levels[zoom2] = {};
      level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
      level.el.style.zIndex = maxZoom;
      level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
      level.zoom = zoom2;
      this._setZoomTransform(level, map.getCenter(), map.getZoom());
      falseFn(level.el.offsetWidth);
      this._onCreateLevel(level);
    }
    this._level = level;
    return level;
  },
  _onUpdateLevel: falseFn,
  _onRemoveLevel: falseFn,
  _onCreateLevel: falseFn,
  _pruneTiles: function() {
    if (!this._map) {
      return;
    }
    var key, tile;
    var zoom2 = this._map.getZoom();
    if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
      this._removeAllTiles();
      return;
    }
    for (key in this._tiles) {
      tile = this._tiles[key];
      tile.retain = tile.current;
    }
    for (key in this._tiles) {
      tile = this._tiles[key];
      if (tile.current && !tile.active) {
        var coords = tile.coords;
        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
        }
      }
    }
    for (key in this._tiles) {
      if (!this._tiles[key].retain) {
        this._removeTile(key);
      }
    }
  },
  _removeTilesAtZoom: function(zoom2) {
    for (var key in this._tiles) {
      if (this._tiles[key].coords.z !== zoom2) {
        continue;
      }
      this._removeTile(key);
    }
  },
  _removeAllTiles: function() {
    for (var key in this._tiles) {
      this._removeTile(key);
    }
  },
  _invalidateAll: function() {
    for (var z in this._levels) {
      remove(this._levels[z].el);
      this._onRemoveLevel(Number(z));
      delete this._levels[z];
    }
    this._removeAllTiles();
    this._tileZoom = void 0;
  },
  _retainParent: function(x, y, z, minZoom) {
    var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
    coords2.z = +z2;
    var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
    if (tile && tile.active) {
      tile.retain = true;
      return true;
    } else if (tile && tile.loaded) {
      tile.retain = true;
    }
    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }
    return false;
  },
  _retainChildren: function(x, y, z, maxZoom) {
    for (var i = 2 * x; i < 2 * x + 2; i++) {
      for (var j = 2 * y; j < 2 * y + 2; j++) {
        var coords = new Point(i, j);
        coords.z = z + 1;
        var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
        if (tile && tile.active) {
          tile.retain = true;
          continue;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }
        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  },
  _resetView: function(e) {
    var animating = e && (e.pinch || e.flyTo);
    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  },
  _animateZoom: function(e) {
    this._setView(e.center, e.zoom, true, e.noUpdate);
  },
  _clampZoom: function(zoom2) {
    var options = this.options;
    if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
      return options.minNativeZoom;
    }
    if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
      return options.maxNativeZoom;
    }
    return zoom2;
  },
  _setView: function(center, zoom2, noPrune, noUpdate) {
    var tileZoom = Math.round(zoom2);
    if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
      tileZoom = void 0;
    } else {
      tileZoom = this._clampZoom(tileZoom);
    }
    var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
    if (!noUpdate || tileZoomChanged) {
      this._tileZoom = tileZoom;
      if (this._abortLoading) {
        this._abortLoading();
      }
      this._updateLevels();
      this._resetGrid();
      if (tileZoom !== void 0) {
        this._update(center);
      }
      if (!noPrune) {
        this._pruneTiles();
      }
      this._noPrune = !!noPrune;
    }
    this._setZoomTransforms(center, zoom2);
  },
  _setZoomTransforms: function(center, zoom2) {
    for (var i in this._levels) {
      this._setZoomTransform(this._levels[i], center, zoom2);
    }
  },
  _setZoomTransform: function(level, center, zoom2) {
    var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
    if (Browser.any3d) {
      setTransform(level.el, translate, scale2);
    } else {
      setPosition(level.el, translate);
    }
  },
  _resetGrid: function() {
    var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
    var bounds = this._map.getPixelWorldBounds(this._tileZoom);
    if (bounds) {
      this._globalTileRange = this._pxBoundsToTileRange(bounds);
    }
    this._wrapX = crs.wrapLng && !this.options.noWrap && [
      Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
      Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
    ];
    this._wrapY = crs.wrapLat && !this.options.noWrap && [
      Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
      Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
    ];
  },
  _onMoveEnd: function() {
    if (!this._map || this._map._animatingZoom) {
      return;
    }
    this._update();
  },
  _getTiledPixelBounds: function(center) {
    var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  },
  // Private method to load tiles in the grid's active zoom level according to map bounds
  _update: function(center) {
    var map = this._map;
    if (!map) {
      return;
    }
    var zoom2 = this._clampZoom(map.getZoom());
    if (center === void 0) {
      center = map.getCenter();
    }
    if (this._tileZoom === void 0) {
      return;
    }
    var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue2 = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
      tileRange.getBottomLeft().subtract([margin, -margin]),
      tileRange.getTopRight().add([margin, -margin])
    );
    if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
      throw new Error("Attempted to load an infinite number of tiles");
    }
    for (var key in this._tiles) {
      var c = this._tiles[key].coords;
      if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
        this._tiles[key].current = false;
      }
    }
    if (Math.abs(zoom2 - this._tileZoom) > 1) {
      this._setView(center, zoom2);
      return;
    }
    for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
      for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
        var coords = new Point(i, j);
        coords.z = this._tileZoom;
        if (!this._isValidTile(coords)) {
          continue;
        }
        var tile = this._tiles[this._tileCoordsToKey(coords)];
        if (tile) {
          tile.current = true;
        } else {
          queue2.push(coords);
        }
      }
    }
    queue2.sort(function(a, b) {
      return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
    });
    if (queue2.length !== 0) {
      if (!this._loading) {
        this._loading = true;
        this.fire("loading");
      }
      var fragment = document.createDocumentFragment();
      for (i = 0; i < queue2.length; i++) {
        this._addTile(queue2[i], fragment);
      }
      this._level.el.appendChild(fragment);
    }
  },
  _isValidTile: function(coords) {
    var crs = this._map.options.crs;
    if (!crs.infinite) {
      var bounds = this._globalTileRange;
      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
        return false;
      }
    }
    if (!this.options.bounds) {
      return true;
    }
    var tileBounds = this._tileCoordsToBounds(coords);
    return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
  },
  _keyToBounds: function(key) {
    return this._tileCoordsToBounds(this._keyToTileCoords(key));
  },
  _tileCoordsToNwSe: function(coords) {
    var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
    return [nw, se];
  },
  // converts tile coordinates to its geographical bounds
  _tileCoordsToBounds: function(coords) {
    var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
    if (!this.options.noWrap) {
      bounds = this._map.wrapLatLngBounds(bounds);
    }
    return bounds;
  },
  // converts tile coordinates to key for the tile cache
  _tileCoordsToKey: function(coords) {
    return coords.x + ":" + coords.y + ":" + coords.z;
  },
  // converts tile cache key to coordinates
  _keyToTileCoords: function(key) {
    var k = key.split(":"), coords = new Point(+k[0], +k[1]);
    coords.z = +k[2];
    return coords;
  },
  _removeTile: function(key) {
    var tile = this._tiles[key];
    if (!tile) {
      return;
    }
    remove(tile.el);
    delete this._tiles[key];
    this.fire("tileunload", {
      tile: tile.el,
      coords: this._keyToTileCoords(key)
    });
  },
  _initTile: function(tile) {
    addClass(tile, "leaflet-tile");
    var tileSize = this.getTileSize();
    tile.style.width = tileSize.x + "px";
    tile.style.height = tileSize.y + "px";
    tile.onselectstart = falseFn;
    tile.onmousemove = falseFn;
    if (Browser.ielt9 && this.options.opacity < 1) {
      setOpacity(tile, this.options.opacity);
    }
  },
  _addTile: function(coords, container) {
    var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
    var tile = this.createTile(this._wrapCoords(coords), bind3(this._tileReady, this, coords));
    this._initTile(tile);
    if (this.createTile.length < 2) {
      requestAnimFrame(bind3(this._tileReady, this, coords, null, tile));
    }
    setPosition(tile, tilePos);
    this._tiles[key] = {
      el: tile,
      coords,
      current: true
    };
    container.appendChild(tile);
    this.fire("tileloadstart", {
      tile,
      coords
    });
  },
  _tileReady: function(coords, err, tile) {
    if (err) {
      this.fire("tileerror", {
        error: err,
        tile,
        coords
      });
    }
    var key = this._tileCoordsToKey(coords);
    tile = this._tiles[key];
    if (!tile) {
      return;
    }
    tile.loaded = +/* @__PURE__ */ new Date();
    if (this._map._fadeAnimated) {
      setOpacity(tile.el, 0);
      cancelAnimFrame(this._fadeFrame);
      this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
    } else {
      tile.active = true;
      this._pruneTiles();
    }
    if (!err) {
      addClass(tile.el, "leaflet-tile-loaded");
      this.fire("tileload", {
        tile: tile.el,
        coords
      });
    }
    if (this._noTilesToLoad()) {
      this._loading = false;
      this.fire("load");
      if (Browser.ielt9 || !this._map._fadeAnimated) {
        requestAnimFrame(this._pruneTiles, this);
      } else {
        setTimeout(bind3(this._pruneTiles, this), 250);
      }
    }
  },
  _getTilePos: function(coords) {
    return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
  },
  _wrapCoords: function(coords) {
    var newCoords = new Point(
      this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
      this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
    );
    newCoords.z = coords.z;
    return newCoords;
  },
  _pxBoundsToTileRange: function(bounds) {
    var tileSize = this.getTileSize();
    return new Bounds(
      bounds.min.unscaleBy(tileSize).floor(),
      bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
    );
  },
  _noTilesToLoad: function() {
    for (var key in this._tiles) {
      if (!this._tiles[key].loaded) {
        return false;
      }
    }
    return true;
  }
});
var TileLayer = GridLayer.extend({
  // @section
  // @aka TileLayer options
  options: {
    // @option minZoom: Number = 0
    // The minimum zoom level down to which this layer will be displayed (inclusive).
    minZoom: 0,
    // @option maxZoom: Number = 18
    // The maximum zoom level up to which this layer will be displayed (inclusive).
    maxZoom: 18,
    // @option subdomains: String|String[] = 'abc'
    // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
    subdomains: "abc",
    // @option errorTileUrl: String = ''
    // URL to the tile image to show in place of the tile that failed to load.
    errorTileUrl: "",
    // @option zoomOffset: Number = 0
    // The zoom number used in tile URLs will be offset with this value.
    zoomOffset: 0,
    // @option tms: Boolean = false
    // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
    tms: false,
    // @option zoomReverse: Boolean = false
    // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
    zoomReverse: false,
    // @option detectRetina: Boolean = false
    // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
    detectRetina: false,
    // @option crossOrigin: Boolean|String = false
    // Whether the crossOrigin attribute will be added to the tiles.
    // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
    // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
    crossOrigin: false,
    // @option referrerPolicy: Boolean|String = false
    // Whether the referrerPolicy attribute will be added to the tiles.
    // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
    // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
    // (e.g. to validate an API token).
    // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
    referrerPolicy: false
  },
  initialize: function(url, options) {
    this._url = url;
    options = setOptions(this, options);
    if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
      options.tileSize = Math.floor(options.tileSize / 2);
      if (!options.zoomReverse) {
        options.zoomOffset++;
        options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
      } else {
        options.zoomOffset--;
        options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
      }
      options.minZoom = Math.max(0, options.minZoom);
    } else if (!options.zoomReverse) {
      options.maxZoom = Math.max(options.minZoom, options.maxZoom);
    } else {
      options.minZoom = Math.min(options.maxZoom, options.minZoom);
    }
    if (typeof options.subdomains === "string") {
      options.subdomains = options.subdomains.split("");
    }
    this.on("tileunload", this._onTileRemove);
  },
  // @method setUrl(url: String, noRedraw?: Boolean): this
  // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
  // If the URL does not change, the layer will not be redrawn unless
  // the noRedraw parameter is set to false.
  setUrl: function(url, noRedraw) {
    if (this._url === url && noRedraw === void 0) {
      noRedraw = true;
    }
    this._url = url;
    if (!noRedraw) {
      this.redraw();
    }
    return this;
  },
  // @method createTile(coords: Object, done?: Function): HTMLElement
  // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
  // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
  // callback is called when the tile has been loaded.
  createTile: function(coords, done) {
    var tile = document.createElement("img");
    on2(tile, "load", bind3(this._tileOnLoad, this, done, tile));
    on2(tile, "error", bind3(this._tileOnError, this, done, tile));
    if (this.options.crossOrigin || this.options.crossOrigin === "") {
      tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
    }
    if (typeof this.options.referrerPolicy === "string") {
      tile.referrerPolicy = this.options.referrerPolicy;
    }
    tile.alt = "";
    tile.src = this.getTileUrl(coords);
    return tile;
  },
  // @section Extension methods
  // @uninheritable
  // Layers extending `TileLayer` might reimplement the following method.
  // @method getTileUrl(coords: Object): String
  // Called only internally, returns the URL for a tile given its coordinates.
  // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
  getTileUrl: function(coords) {
    var data2 = {
      r: Browser.retina ? "@2x" : "",
      s: this._getSubdomain(coords),
      x: coords.x,
      y: coords.y,
      z: this._getZoomForUrl()
    };
    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;
      if (this.options.tms) {
        data2["y"] = invertedY;
      }
      data2["-y"] = invertedY;
    }
    return template(this._url, extend(data2, this.options));
  },
  _tileOnLoad: function(done, tile) {
    if (Browser.ielt9) {
      setTimeout(bind3(done, this, null, tile), 0);
    } else {
      done(null, tile);
    }
  },
  _tileOnError: function(done, tile, e) {
    var errorUrl = this.options.errorTileUrl;
    if (errorUrl && tile.getAttribute("src") !== errorUrl) {
      tile.src = errorUrl;
    }
    done(e, tile);
  },
  _onTileRemove: function(e) {
    e.tile.onload = null;
  },
  _getZoomForUrl: function() {
    var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
    if (zoomReverse) {
      zoom2 = maxZoom - zoom2;
    }
    return zoom2 + zoomOffset;
  },
  _getSubdomain: function(tilePoint) {
    var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
    return this.options.subdomains[index];
  },
  // stops loading all tiles in the background layer
  _abortLoading: function() {
    var i, tile;
    for (i in this._tiles) {
      if (this._tiles[i].coords.z !== this._tileZoom) {
        tile = this._tiles[i].el;
        tile.onload = falseFn;
        tile.onerror = falseFn;
        if (!tile.complete) {
          tile.src = emptyImageUrl;
          var coords = this._tiles[i].coords;
          remove(tile);
          delete this._tiles[i];
          this.fire("tileabort", {
            tile,
            coords
          });
        }
      }
    }
  },
  _removeTile: function(key) {
    var tile = this._tiles[key];
    if (!tile) {
      return;
    }
    tile.el.setAttribute("src", emptyImageUrl);
    return GridLayer.prototype._removeTile.call(this, key);
  },
  _tileReady: function(coords, err, tile) {
    if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
      return;
    }
    return GridLayer.prototype._tileReady.call(this, coords, err, tile);
  }
});
function tileLayer(url, options) {
  return new TileLayer(url, options);
}
var TileLayerWMS = TileLayer.extend({
  // @section
  // @aka TileLayer.WMS options
  // If any custom options not documented here are used, they will be sent to the
  // WMS server as extra parameters in each request URL. This can be useful for
  // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
  defaultWmsParams: {
    service: "WMS",
    request: "GetMap",
    // @option layers: String = ''
    // **(required)** Comma-separated list of WMS layers to show.
    layers: "",
    // @option styles: String = ''
    // Comma-separated list of WMS styles.
    styles: "",
    // @option format: String = 'image/jpeg'
    // WMS image format (use `'image/png'` for layers with transparency).
    format: "image/jpeg",
    // @option transparent: Boolean = false
    // If `true`, the WMS service will return images with transparency.
    transparent: false,
    // @option version: String = '1.1.1'
    // Version of the WMS service to use
    version: "1.1.1"
  },
  options: {
    // @option crs: CRS = null
    // Coordinate Reference System to use for the WMS requests, defaults to
    // map CRS. Don't change this if you're not sure what it means.
    crs: null,
    // @option uppercase: Boolean = false
    // If `true`, WMS request parameter keys will be uppercase.
    uppercase: false
  },
  initialize: function(url, options) {
    this._url = url;
    var wmsParams = extend({}, this.defaultWmsParams);
    for (var i in options) {
      if (!(i in this.options)) {
        wmsParams[i] = options[i];
      }
    }
    options = setOptions(this, options);
    var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
    var tileSize = this.getTileSize();
    wmsParams.width = tileSize.x * realRetina;
    wmsParams.height = tileSize.y * realRetina;
    this.wmsParams = wmsParams;
  },
  onAdd: function(map) {
    this._crs = this.options.crs || map.options.crs;
    this._wmsVersion = parseFloat(this.wmsParams.version);
    var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
    this.wmsParams[projectionKey] = this._crs.code;
    TileLayer.prototype.onAdd.call(this, map);
  },
  getTileUrl: function(coords) {
    var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
    return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
  },
  // @method setParams(params: Object, noRedraw?: Boolean): this
  // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
  setParams: function(params, noRedraw) {
    extend(this.wmsParams, params);
    if (!noRedraw) {
      this.redraw();
    }
    return this;
  }
});
function tileLayerWMS(url, options) {
  return new TileLayerWMS(url, options);
}
TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;
var Renderer = Layer.extend({
  // @section
  // @aka Renderer options
  options: {
    // @option padding: Number = 0.1
    // How much to extend the clip area around the map view (relative to its size)
    // e.g. 0.1 would be 10% of map view in each direction
    padding: 0.1
  },
  initialize: function(options) {
    setOptions(this, options);
    stamp(this);
    this._layers = this._layers || {};
  },
  onAdd: function() {
    if (!this._container) {
      this._initContainer();
      addClass(this._container, "leaflet-zoom-animated");
    }
    this.getPane().appendChild(this._container);
    this._update();
    this.on("update", this._updatePaths, this);
  },
  onRemove: function() {
    this.off("update", this._updatePaths, this);
    this._destroyContainer();
  },
  getEvents: function() {
    var events = {
      viewreset: this._reset,
      zoom: this._onZoom,
      moveend: this._update,
      zoomend: this._onZoomEnd
    };
    if (this._zoomAnimated) {
      events.zoomanim = this._onAnimZoom;
    }
    return events;
  },
  _onAnimZoom: function(ev) {
    this._updateTransform(ev.center, ev.zoom);
  },
  _onZoom: function() {
    this._updateTransform(this._map.getCenter(), this._map.getZoom());
  },
  _updateTransform: function(center, zoom2) {
    var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
    if (Browser.any3d) {
      setTransform(this._container, topLeftOffset, scale2);
    } else {
      setPosition(this._container, topLeftOffset);
    }
  },
  _reset: function() {
    this._update();
    this._updateTransform(this._center, this._zoom);
    for (var id in this._layers) {
      this._layers[id]._reset();
    }
  },
  _onZoomEnd: function() {
    for (var id in this._layers) {
      this._layers[id]._project();
    }
  },
  _updatePaths: function() {
    for (var id in this._layers) {
      this._layers[id]._update();
    }
  },
  _update: function() {
    var p = this.options.padding, size2 = this._map.getSize(), min = this._map.containerPointToLayerPoint(size2.multiplyBy(-p)).round();
    this._bounds = new Bounds(min, min.add(size2.multiplyBy(1 + p * 2)).round());
    this._center = this._map.getCenter();
    this._zoom = this._map.getZoom();
  }
});
var Canvas = Renderer.extend({
  // @section
  // @aka Canvas options
  options: {
    // @option tolerance: Number = 0
    // How much to extend the click tolerance around a path/object on the map.
    tolerance: 0
  },
  getEvents: function() {
    var events = Renderer.prototype.getEvents.call(this);
    events.viewprereset = this._onViewPreReset;
    return events;
  },
  _onViewPreReset: function() {
    this._postponeUpdatePaths = true;
  },
  onAdd: function() {
    Renderer.prototype.onAdd.call(this);
    this._draw();
  },
  _initContainer: function() {
    var container = this._container = document.createElement("canvas");
    on2(container, "mousemove", this._onMouseMove, this);
    on2(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
    on2(container, "mouseout", this._handleMouseOut, this);
    container["_leaflet_disable_events"] = true;
    this._ctx = container.getContext("2d");
  },
  _destroyContainer: function() {
    cancelAnimFrame(this._redrawRequest);
    delete this._ctx;
    remove(this._container);
    off(this._container);
    delete this._container;
  },
  _updatePaths: function() {
    if (this._postponeUpdatePaths) {
      return;
    }
    var layer;
    this._redrawBounds = null;
    for (var id in this._layers) {
      layer = this._layers[id];
      layer._update();
    }
    this._redraw();
  },
  _update: function() {
    if (this._map._animatingZoom && this._bounds) {
      return;
    }
    Renderer.prototype._update.call(this);
    var b = this._bounds, container = this._container, size2 = b.getSize(), m = Browser.retina ? 2 : 1;
    setPosition(container, b.min);
    container.width = m * size2.x;
    container.height = m * size2.y;
    container.style.width = size2.x + "px";
    container.style.height = size2.y + "px";
    if (Browser.retina) {
      this._ctx.scale(2, 2);
    }
    this._ctx.translate(-b.min.x, -b.min.y);
    this.fire("update");
  },
  _reset: function() {
    Renderer.prototype._reset.call(this);
    if (this._postponeUpdatePaths) {
      this._postponeUpdatePaths = false;
      this._updatePaths();
    }
  },
  _initPath: function(layer) {
    this._updateDashArray(layer);
    this._layers[stamp(layer)] = layer;
    var order = layer._order = {
      layer,
      prev: this._drawLast,
      next: null
    };
    if (this._drawLast) {
      this._drawLast.next = order;
    }
    this._drawLast = order;
    this._drawFirst = this._drawFirst || this._drawLast;
  },
  _addPath: function(layer) {
    this._requestRedraw(layer);
  },
  _removePath: function(layer) {
    var order = layer._order;
    var next = order.next;
    var prev = order.prev;
    if (next) {
      next.prev = prev;
    } else {
      this._drawLast = prev;
    }
    if (prev) {
      prev.next = next;
    } else {
      this._drawFirst = next;
    }
    delete layer._order;
    delete this._layers[stamp(layer)];
    this._requestRedraw(layer);
  },
  _updatePath: function(layer) {
    this._extendRedrawBounds(layer);
    layer._project();
    layer._update();
    this._requestRedraw(layer);
  },
  _updateStyle: function(layer) {
    this._updateDashArray(layer);
    this._requestRedraw(layer);
  },
  _updateDashArray: function(layer) {
    if (typeof layer.options.dashArray === "string") {
      var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
      for (i = 0; i < parts.length; i++) {
        dashValue = Number(parts[i]);
        if (isNaN(dashValue)) {
          return;
        }
        dashArray.push(dashValue);
      }
      layer.options._dashArray = dashArray;
    } else {
      layer.options._dashArray = layer.options.dashArray;
    }
  },
  _requestRedraw: function(layer) {
    if (!this._map) {
      return;
    }
    this._extendRedrawBounds(layer);
    this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
  },
  _extendRedrawBounds: function(layer) {
    if (layer._pxBounds) {
      var padding = (layer.options.weight || 0) + 1;
      this._redrawBounds = this._redrawBounds || new Bounds();
      this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
      this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
    }
  },
  _redraw: function() {
    this._redrawRequest = null;
    if (this._redrawBounds) {
      this._redrawBounds.min._floor();
      this._redrawBounds.max._ceil();
    }
    this._clear();
    this._draw();
    this._redrawBounds = null;
  },
  _clear: function() {
    var bounds = this._redrawBounds;
    if (bounds) {
      var size2 = bounds.getSize();
      this._ctx.clearRect(bounds.min.x, bounds.min.y, size2.x, size2.y);
    } else {
      this._ctx.save();
      this._ctx.setTransform(1, 0, 0, 1, 0, 0);
      this._ctx.clearRect(0, 0, this._container.width, this._container.height);
      this._ctx.restore();
    }
  },
  _draw: function() {
    var layer, bounds = this._redrawBounds;
    this._ctx.save();
    if (bounds) {
      var size2 = bounds.getSize();
      this._ctx.beginPath();
      this._ctx.rect(bounds.min.x, bounds.min.y, size2.x, size2.y);
      this._ctx.clip();
    }
    this._drawing = true;
    for (var order = this._drawFirst; order; order = order.next) {
      layer = order.layer;
      if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
        layer._updatePath();
      }
    }
    this._drawing = false;
    this._ctx.restore();
  },
  _updatePoly: function(layer, closed) {
    if (!this._drawing) {
      return;
    }
    var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
    if (!len) {
      return;
    }
    ctx.beginPath();
    for (i = 0; i < len; i++) {
      for (j = 0, len2 = parts[i].length; j < len2; j++) {
        p = parts[i][j];
        ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
      }
      if (closed) {
        ctx.closePath();
      }
    }
    this._fillStroke(ctx, layer);
  },
  _updateCircle: function(layer) {
    if (!this._drawing || layer._empty()) {
      return;
    }
    var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
    if (s !== 1) {
      ctx.save();
      ctx.scale(1, s);
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
    if (s !== 1) {
      ctx.restore();
    }
    this._fillStroke(ctx, layer);
  },
  _fillStroke: function(ctx, layer) {
    var options = layer.options;
    if (options.fill) {
      ctx.globalAlpha = options.fillOpacity;
      ctx.fillStyle = options.fillColor || options.color;
      ctx.fill(options.fillRule || "evenodd");
    }
    if (options.stroke && options.weight !== 0) {
      if (ctx.setLineDash) {
        ctx.setLineDash(layer.options && layer.options._dashArray || []);
      }
      ctx.globalAlpha = options.opacity;
      ctx.lineWidth = options.weight;
      ctx.strokeStyle = options.color;
      ctx.lineCap = options.lineCap;
      ctx.lineJoin = options.lineJoin;
      ctx.stroke();
    }
  },
  // Canvas obviously doesn't have mouse events for individual drawn objects,
  // so we emulate that by calculating what's under the mouse on mousemove/click manually
  _onClick: function(e) {
    var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
    for (var order = this._drawFirst; order; order = order.next) {
      layer = order.layer;
      if (layer.options.interactive && layer._containsPoint(point)) {
        if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
          clickedLayer = layer;
        }
      }
    }
    this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
  },
  _onMouseMove: function(e) {
    if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
      return;
    }
    var point = this._map.mouseEventToLayerPoint(e);
    this._handleMouseHover(e, point);
  },
  _handleMouseOut: function(e) {
    var layer = this._hoveredLayer;
    if (layer) {
      removeClass(this._container, "leaflet-interactive");
      this._fireEvent([layer], e, "mouseout");
      this._hoveredLayer = null;
      this._mouseHoverThrottled = false;
    }
  },
  _handleMouseHover: function(e, point) {
    if (this._mouseHoverThrottled) {
      return;
    }
    var layer, candidateHoveredLayer;
    for (var order = this._drawFirst; order; order = order.next) {
      layer = order.layer;
      if (layer.options.interactive && layer._containsPoint(point)) {
        candidateHoveredLayer = layer;
      }
    }
    if (candidateHoveredLayer !== this._hoveredLayer) {
      this._handleMouseOut(e);
      if (candidateHoveredLayer) {
        addClass(this._container, "leaflet-interactive");
        this._fireEvent([candidateHoveredLayer], e, "mouseover");
        this._hoveredLayer = candidateHoveredLayer;
      }
    }
    this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
    this._mouseHoverThrottled = true;
    setTimeout(bind3(function() {
      this._mouseHoverThrottled = false;
    }, this), 32);
  },
  _fireEvent: function(layers2, e, type) {
    this._map._fireDOMEvent(e, type || e.type, layers2);
  },
  _bringToFront: function(layer) {
    var order = layer._order;
    if (!order) {
      return;
    }
    var next = order.next;
    var prev = order.prev;
    if (next) {
      next.prev = prev;
    } else {
      return;
    }
    if (prev) {
      prev.next = next;
    } else if (next) {
      this._drawFirst = next;
    }
    order.prev = this._drawLast;
    this._drawLast.next = order;
    order.next = null;
    this._drawLast = order;
    this._requestRedraw(layer);
  },
  _bringToBack: function(layer) {
    var order = layer._order;
    if (!order) {
      return;
    }
    var next = order.next;
    var prev = order.prev;
    if (prev) {
      prev.next = next;
    } else {
      return;
    }
    if (next) {
      next.prev = prev;
    } else if (prev) {
      this._drawLast = prev;
    }
    order.prev = null;
    order.next = this._drawFirst;
    this._drawFirst.prev = order;
    this._drawFirst = order;
    this._requestRedraw(layer);
  }
});
function canvas(options) {
  return Browser.canvas ? new Canvas(options) : null;
}
var vmlCreate = function() {
  try {
    document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
    return function(name) {
      return document.createElement("<lvml:" + name + ' class="lvml">');
    };
  } catch (e) {
  }
  return function(name) {
    return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
  };
}();
var vmlMixin = {
  _initContainer: function() {
    this._container = create$1("div", "leaflet-vml-container");
  },
  _update: function() {
    if (this._map._animatingZoom) {
      return;
    }
    Renderer.prototype._update.call(this);
    this.fire("update");
  },
  _initPath: function(layer) {
    var container = layer._container = vmlCreate("shape");
    addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
    container.coordsize = "1 1";
    layer._path = vmlCreate("path");
    container.appendChild(layer._path);
    this._updateStyle(layer);
    this._layers[stamp(layer)] = layer;
  },
  _addPath: function(layer) {
    var container = layer._container;
    this._container.appendChild(container);
    if (layer.options.interactive) {
      layer.addInteractiveTarget(container);
    }
  },
  _removePath: function(layer) {
    var container = layer._container;
    remove(container);
    layer.removeInteractiveTarget(container);
    delete this._layers[stamp(layer)];
  },
  _updateStyle: function(layer) {
    var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
    container.stroked = !!options.stroke;
    container.filled = !!options.fill;
    if (options.stroke) {
      if (!stroke) {
        stroke = layer._stroke = vmlCreate("stroke");
      }
      container.appendChild(stroke);
      stroke.weight = options.weight + "px";
      stroke.color = options.color;
      stroke.opacity = options.opacity;
      if (options.dashArray) {
        stroke.dashStyle = isArray3(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
      } else {
        stroke.dashStyle = "";
      }
      stroke.endcap = options.lineCap.replace("butt", "flat");
      stroke.joinstyle = options.lineJoin;
    } else if (stroke) {
      container.removeChild(stroke);
      layer._stroke = null;
    }
    if (options.fill) {
      if (!fill) {
        fill = layer._fill = vmlCreate("fill");
      }
      container.appendChild(fill);
      fill.color = options.fillColor || options.color;
      fill.opacity = options.fillOpacity;
    } else if (fill) {
      container.removeChild(fill);
      layer._fill = null;
    }
  },
  _updateCircle: function(layer) {
    var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
    this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
  },
  _setPath: function(layer, path) {
    layer._path.v = path;
  },
  _bringToFront: function(layer) {
    toFront(layer._container);
  },
  _bringToBack: function(layer) {
    toBack(layer._container);
  }
};
var create = Browser.vml ? vmlCreate : svgCreate;
var SVG = Renderer.extend({
  _initContainer: function() {
    this._container = create("svg");
    this._container.setAttribute("pointer-events", "none");
    this._rootGroup = create("g");
    this._container.appendChild(this._rootGroup);
  },
  _destroyContainer: function() {
    remove(this._container);
    off(this._container);
    delete this._container;
    delete this._rootGroup;
    delete this._svgSize;
  },
  _update: function() {
    if (this._map._animatingZoom && this._bounds) {
      return;
    }
    Renderer.prototype._update.call(this);
    var b = this._bounds, size2 = b.getSize(), container = this._container;
    if (!this._svgSize || !this._svgSize.equals(size2)) {
      this._svgSize = size2;
      container.setAttribute("width", size2.x);
      container.setAttribute("height", size2.y);
    }
    setPosition(container, b.min);
    container.setAttribute("viewBox", [b.min.x, b.min.y, size2.x, size2.y].join(" "));
    this.fire("update");
  },
  // methods below are called by vector layers implementations
  _initPath: function(layer) {
    var path = layer._path = create("path");
    if (layer.options.className) {
      addClass(path, layer.options.className);
    }
    if (layer.options.interactive) {
      addClass(path, "leaflet-interactive");
    }
    this._updateStyle(layer);
    this._layers[stamp(layer)] = layer;
  },
  _addPath: function(layer) {
    if (!this._rootGroup) {
      this._initContainer();
    }
    this._rootGroup.appendChild(layer._path);
    layer.addInteractiveTarget(layer._path);
  },
  _removePath: function(layer) {
    remove(layer._path);
    layer.removeInteractiveTarget(layer._path);
    delete this._layers[stamp(layer)];
  },
  _updatePath: function(layer) {
    layer._project();
    layer._update();
  },
  _updateStyle: function(layer) {
    var path = layer._path, options = layer.options;
    if (!path) {
      return;
    }
    if (options.stroke) {
      path.setAttribute("stroke", options.color);
      path.setAttribute("stroke-opacity", options.opacity);
      path.setAttribute("stroke-width", options.weight);
      path.setAttribute("stroke-linecap", options.lineCap);
      path.setAttribute("stroke-linejoin", options.lineJoin);
      if (options.dashArray) {
        path.setAttribute("stroke-dasharray", options.dashArray);
      } else {
        path.removeAttribute("stroke-dasharray");
      }
      if (options.dashOffset) {
        path.setAttribute("stroke-dashoffset", options.dashOffset);
      } else {
        path.removeAttribute("stroke-dashoffset");
      }
    } else {
      path.setAttribute("stroke", "none");
    }
    if (options.fill) {
      path.setAttribute("fill", options.fillColor || options.color);
      path.setAttribute("fill-opacity", options.fillOpacity);
      path.setAttribute("fill-rule", options.fillRule || "evenodd");
    } else {
      path.setAttribute("fill", "none");
    }
  },
  _updatePoly: function(layer, closed) {
    this._setPath(layer, pointsToPath(layer._parts, closed));
  },
  _updateCircle: function(layer) {
    var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
    var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
    this._setPath(layer, d);
  },
  _setPath: function(layer, path) {
    layer._path.setAttribute("d", path);
  },
  // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
  _bringToFront: function(layer) {
    toFront(layer._path);
  },
  _bringToBack: function(layer) {
    toBack(layer._path);
  }
});
if (Browser.vml) {
  SVG.include(vmlMixin);
}
function svg(options) {
  return Browser.svg || Browser.vml ? new SVG(options) : null;
}
Map2.include({
  // @namespace Map; @method getRenderer(layer: Path): Renderer
  // Returns the instance of `Renderer` that should be used to render the given
  // `Path`. It will ensure that the `renderer` options of the map and paths
  // are respected, and that the renderers do exist on the map.
  getRenderer: function(layer) {
    var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
    if (!renderer) {
      renderer = this._renderer = this._createRenderer();
    }
    if (!this.hasLayer(renderer)) {
      this.addLayer(renderer);
    }
    return renderer;
  },
  _getPaneRenderer: function(name) {
    if (name === "overlayPane" || name === void 0) {
      return false;
    }
    var renderer = this._paneRenderers[name];
    if (renderer === void 0) {
      renderer = this._createRenderer({ pane: name });
      this._paneRenderers[name] = renderer;
    }
    return renderer;
  },
  _createRenderer: function(options) {
    return this.options.preferCanvas && canvas(options) || svg(options);
  }
});
var Rectangle = Polygon.extend({
  initialize: function(latLngBounds, options) {
    Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  },
  // @method setBounds(latLngBounds: LatLngBounds): this
  // Redraws the rectangle with the passed bounds.
  setBounds: function(latLngBounds) {
    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  },
  _boundsToLatLngs: function(latLngBounds) {
    latLngBounds = toLatLngBounds(latLngBounds);
    return [
      latLngBounds.getSouthWest(),
      latLngBounds.getNorthWest(),
      latLngBounds.getNorthEast(),
      latLngBounds.getSouthEast()
    ];
  }
});
SVG.create = create;
SVG.pointsToPath = pointsToPath;
GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;
Map2.mergeOptions({
  // @option boxZoom: Boolean = true
  // Whether the map can be zoomed to a rectangular area specified by
  // dragging the mouse while pressing the shift key.
  boxZoom: true
});
var BoxZoom = Handler.extend({
  initialize: function(map) {
    this._map = map;
    this._container = map._container;
    this._pane = map._panes.overlayPane;
    this._resetStateTimeout = 0;
    map.on("unload", this._destroy, this);
  },
  addHooks: function() {
    on2(this._container, "mousedown", this._onMouseDown, this);
  },
  removeHooks: function() {
    off(this._container, "mousedown", this._onMouseDown, this);
  },
  moved: function() {
    return this._moved;
  },
  _destroy: function() {
    remove(this._pane);
    delete this._pane;
  },
  _resetState: function() {
    this._resetStateTimeout = 0;
    this._moved = false;
  },
  _clearDeferredResetState: function() {
    if (this._resetStateTimeout !== 0) {
      clearTimeout(this._resetStateTimeout);
      this._resetStateTimeout = 0;
    }
  },
  _onMouseDown: function(e) {
    if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
      return false;
    }
    this._clearDeferredResetState();
    this._resetState();
    disableTextSelection();
    disableImageDrag();
    this._startPoint = this._map.mouseEventToContainerPoint(e);
    on2(document, {
      contextmenu: stop2,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseMove: function(e) {
    if (!this._moved) {
      this._moved = true;
      this._box = create$1("div", "leaflet-zoom-box", this._container);
      addClass(this._container, "leaflet-crosshair");
      this._map.fire("boxzoomstart");
    }
    this._point = this._map.mouseEventToContainerPoint(e);
    var bounds = new Bounds(this._point, this._startPoint), size2 = bounds.getSize();
    setPosition(this._box, bounds.min);
    this._box.style.width = size2.x + "px";
    this._box.style.height = size2.y + "px";
  },
  _finish: function() {
    if (this._moved) {
      remove(this._box);
      removeClass(this._container, "leaflet-crosshair");
    }
    enableTextSelection();
    enableImageDrag();
    off(document, {
      contextmenu: stop2,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseUp: function(e) {
    if (e.which !== 1 && e.button !== 1) {
      return;
    }
    this._finish();
    if (!this._moved) {
      return;
    }
    this._clearDeferredResetState();
    this._resetStateTimeout = setTimeout(bind3(this._resetState, this), 0);
    var bounds = new LatLngBounds(
      this._map.containerPointToLatLng(this._startPoint),
      this._map.containerPointToLatLng(this._point)
    );
    this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
  },
  _onKeyDown: function(e) {
    if (e.keyCode === 27) {
      this._finish();
      this._clearDeferredResetState();
      this._resetState();
    }
  }
});
Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
Map2.mergeOptions({
  // @option doubleClickZoom: Boolean|String = true
  // Whether the map can be zoomed in by double clicking on it and
  // zoomed out by double clicking while holding shift. If passed
  // `'center'`, double-click zoom will zoom to the center of the
  //  view regardless of where the mouse was.
  doubleClickZoom: true
});
var DoubleClickZoom = Handler.extend({
  addHooks: function() {
    this._map.on("dblclick", this._onDoubleClick, this);
  },
  removeHooks: function() {
    this._map.off("dblclick", this._onDoubleClick, this);
  },
  _onDoubleClick: function(e) {
    var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
    if (map.options.doubleClickZoom === "center") {
      map.setZoom(zoom2);
    } else {
      map.setZoomAround(e.containerPoint, zoom2);
    }
  }
});
Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
Map2.mergeOptions({
  // @option dragging: Boolean = true
  // Whether the map is draggable with mouse/touch or not.
  dragging: true,
  // @section Panning Inertia Options
  // @option inertia: Boolean = *
  // If enabled, panning of the map will have an inertia effect where
  // the map builds momentum while dragging and continues moving in
  // the same direction for some time. Feels especially nice on touch
  // devices. Enabled by default.
  inertia: true,
  // @option inertiaDeceleration: Number = 3000
  // The rate with which the inertial movement slows down, in pixels/second.
  inertiaDeceleration: 3400,
  // px/s^2
  // @option inertiaMaxSpeed: Number = Infinity
  // Max speed of the inertial movement, in pixels/second.
  inertiaMaxSpeed: Infinity,
  // px/s
  // @option easeLinearity: Number = 0.2
  easeLinearity: 0.2,
  // TODO refactor, move to CRS
  // @option worldCopyJump: Boolean = false
  // With this option enabled, the map tracks when you pan to another "copy"
  // of the world and seamlessly jumps to the original one so that all overlays
  // like markers and vector layers are still visible.
  worldCopyJump: false,
  // @option maxBoundsViscosity: Number = 0.0
  // If `maxBounds` is set, this option will control how solid the bounds
  // are when dragging the map around. The default value of `0.0` allows the
  // user to drag outside the bounds at normal speed, higher values will
  // slow down map dragging outside bounds, and `1.0` makes the bounds fully
  // solid, preventing the user from dragging outside the bounds.
  maxBoundsViscosity: 0
});
var Drag = Handler.extend({
  addHooks: function() {
    if (!this._draggable) {
      var map = this._map;
      this._draggable = new Draggable(map._mapPane, map._container);
      this._draggable.on({
        dragstart: this._onDragStart,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this);
      this._draggable.on("predrag", this._onPreDragLimit, this);
      if (map.options.worldCopyJump) {
        this._draggable.on("predrag", this._onPreDragWrap, this);
        map.on("zoomend", this._onZoomEnd, this);
        map.whenReady(this._onZoomEnd, this);
      }
    }
    addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
    this._draggable.enable();
    this._positions = [];
    this._times = [];
  },
  removeHooks: function() {
    removeClass(this._map._container, "leaflet-grab");
    removeClass(this._map._container, "leaflet-touch-drag");
    this._draggable.disable();
  },
  moved: function() {
    return this._draggable && this._draggable._moved;
  },
  moving: function() {
    return this._draggable && this._draggable._moving;
  },
  _onDragStart: function() {
    var map = this._map;
    map._stop();
    if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
      var bounds = toLatLngBounds(this._map.options.maxBounds);
      this._offsetLimit = toBounds(
        this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
        this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
      );
      this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
    } else {
      this._offsetLimit = null;
    }
    map.fire("movestart").fire("dragstart");
    if (map.options.inertia) {
      this._positions = [];
      this._times = [];
    }
  },
  _onDrag: function(e) {
    if (this._map.options.inertia) {
      var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
      this._positions.push(pos);
      this._times.push(time);
      this._prunePositions(time);
    }
    this._map.fire("move", e).fire("drag", e);
  },
  _prunePositions: function(time) {
    while (this._positions.length > 1 && time - this._times[0] > 50) {
      this._positions.shift();
      this._times.shift();
    }
  },
  _onZoomEnd: function() {
    var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
    this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
  },
  _viscousLimit: function(value, threshold) {
    return value - (value - threshold) * this._viscosity;
  },
  _onPreDragLimit: function() {
    if (!this._viscosity || !this._offsetLimit) {
      return;
    }
    var offset = this._draggable._newPos.subtract(this._draggable._startPos);
    var limit = this._offsetLimit;
    if (offset.x < limit.min.x) {
      offset.x = this._viscousLimit(offset.x, limit.min.x);
    }
    if (offset.y < limit.min.y) {
      offset.y = this._viscousLimit(offset.y, limit.min.y);
    }
    if (offset.x > limit.max.x) {
      offset.x = this._viscousLimit(offset.x, limit.max.x);
    }
    if (offset.y > limit.max.y) {
      offset.y = this._viscousLimit(offset.y, limit.max.y);
    }
    this._draggable._newPos = this._draggable._startPos.add(offset);
  },
  _onPreDragWrap: function() {
    var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
    this._draggable._absPos = this._draggable._newPos.clone();
    this._draggable._newPos.x = newX;
  },
  _onDragEnd: function(e) {
    var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
    map.fire("dragend", e);
    if (noInertia) {
      map.fire("moveend");
    } else {
      this._prunePositions(+/* @__PURE__ */ new Date());
      var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
      if (!offset.x && !offset.y) {
        map.fire("moveend");
      } else {
        offset = map._limitOffset(offset, map.options.maxBounds);
        requestAnimFrame(function() {
          map.panBy(offset, {
            duration: decelerationDuration,
            easeLinearity: ease,
            noMoveStart: true,
            animate: true
          });
        });
      }
    }
  }
});
Map2.addInitHook("addHandler", "dragging", Drag);
Map2.mergeOptions({
  // @option keyboard: Boolean = true
  // Makes the map focusable and allows users to navigate the map with keyboard
  // arrows and `+`/`-` keys.
  keyboard: true,
  // @option keyboardPanDelta: Number = 80
  // Amount of pixels to pan when pressing an arrow key.
  keyboardPanDelta: 80
});
var Keyboard = Handler.extend({
  keyCodes: {
    left: [37],
    right: [39],
    down: [40],
    up: [38],
    zoomIn: [187, 107, 61, 171],
    zoomOut: [189, 109, 54, 173]
  },
  initialize: function(map) {
    this._map = map;
    this._setPanDelta(map.options.keyboardPanDelta);
    this._setZoomDelta(map.options.zoomDelta);
  },
  addHooks: function() {
    var container = this._map._container;
    if (container.tabIndex <= 0) {
      container.tabIndex = "0";
    }
    on2(container, {
      focus: this._onFocus,
      blur: this._onBlur,
      mousedown: this._onMouseDown
    }, this);
    this._map.on({
      focus: this._addHooks,
      blur: this._removeHooks
    }, this);
  },
  removeHooks: function() {
    this._removeHooks();
    off(this._map._container, {
      focus: this._onFocus,
      blur: this._onBlur,
      mousedown: this._onMouseDown
    }, this);
    this._map.off({
      focus: this._addHooks,
      blur: this._removeHooks
    }, this);
  },
  _onMouseDown: function() {
    if (this._focused) {
      return;
    }
    var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
    this._map._container.focus();
    window.scrollTo(left, top);
  },
  _onFocus: function() {
    this._focused = true;
    this._map.fire("focus");
  },
  _onBlur: function() {
    this._focused = false;
    this._map.fire("blur");
  },
  _setPanDelta: function(panDelta) {
    var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
    for (i = 0, len = codes.left.length; i < len; i++) {
      keys[codes.left[i]] = [-1 * panDelta, 0];
    }
    for (i = 0, len = codes.right.length; i < len; i++) {
      keys[codes.right[i]] = [panDelta, 0];
    }
    for (i = 0, len = codes.down.length; i < len; i++) {
      keys[codes.down[i]] = [0, panDelta];
    }
    for (i = 0, len = codes.up.length; i < len; i++) {
      keys[codes.up[i]] = [0, -1 * panDelta];
    }
  },
  _setZoomDelta: function(zoomDelta) {
    var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
    for (i = 0, len = codes.zoomIn.length; i < len; i++) {
      keys[codes.zoomIn[i]] = zoomDelta;
    }
    for (i = 0, len = codes.zoomOut.length; i < len; i++) {
      keys[codes.zoomOut[i]] = -zoomDelta;
    }
  },
  _addHooks: function() {
    on2(document, "keydown", this._onKeyDown, this);
  },
  _removeHooks: function() {
    off(document, "keydown", this._onKeyDown, this);
  },
  _onKeyDown: function(e) {
    if (e.altKey || e.ctrlKey || e.metaKey) {
      return;
    }
    var key = e.keyCode, map = this._map, offset;
    if (key in this._panKeys) {
      if (!map._panAnim || !map._panAnim._inProgress) {
        offset = this._panKeys[key];
        if (e.shiftKey) {
          offset = toPoint(offset).multiplyBy(3);
        }
        if (map.options.maxBounds) {
          offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
        }
        if (map.options.worldCopyJump) {
          var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
          map.panTo(newLatLng);
        } else {
          map.panBy(offset);
        }
      }
    } else if (key in this._zoomKeys) {
      map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
    } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
      map.closePopup();
    } else {
      return;
    }
    stop2(e);
  }
});
Map2.addInitHook("addHandler", "keyboard", Keyboard);
Map2.mergeOptions({
  // @section Mouse wheel options
  // @option scrollWheelZoom: Boolean|String = true
  // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
  // it will zoom to the center of the view regardless of where the mouse was.
  scrollWheelZoom: true,
  // @option wheelDebounceTime: Number = 40
  // Limits the rate at which a wheel can fire (in milliseconds). By default
  // user can't zoom via wheel more often than once per 40 ms.
  wheelDebounceTime: 40,
  // @option wheelPxPerZoomLevel: Number = 60
  // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
  // mean a change of one full zoom level. Smaller values will make wheel-zooming
  // faster (and vice versa).
  wheelPxPerZoomLevel: 60
});
var ScrollWheelZoom = Handler.extend({
  addHooks: function() {
    on2(this._map._container, "wheel", this._onWheelScroll, this);
    this._delta = 0;
  },
  removeHooks: function() {
    off(this._map._container, "wheel", this._onWheelScroll, this);
  },
  _onWheelScroll: function(e) {
    var delta = getWheelDelta(e);
    var debounce2 = this._map.options.wheelDebounceTime;
    this._delta += delta;
    this._lastMousePos = this._map.mouseEventToContainerPoint(e);
    if (!this._startTime) {
      this._startTime = +/* @__PURE__ */ new Date();
    }
    var left = Math.max(debounce2 - (+/* @__PURE__ */ new Date() - this._startTime), 0);
    clearTimeout(this._timer);
    this._timer = setTimeout(bind3(this._performZoom, this), left);
    stop2(e);
  },
  _performZoom: function() {
    var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
    map._stop();
    var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
    this._delta = 0;
    this._startTime = null;
    if (!delta) {
      return;
    }
    if (map.options.scrollWheelZoom === "center") {
      map.setZoom(zoom2 + delta);
    } else {
      map.setZoomAround(this._lastMousePos, zoom2 + delta);
    }
  }
});
Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
var tapHoldDelay = 600;
Map2.mergeOptions({
  // @section Touch interaction options
  // @option tapHold: Boolean
  // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
  tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
  // @option tapTolerance: Number = 15
  // The max number of pixels a user can shift his finger during touch
  // for it to be considered a valid tap.
  tapTolerance: 15
});
var TapHold = Handler.extend({
  addHooks: function() {
    on2(this._map._container, "touchstart", this._onDown, this);
  },
  removeHooks: function() {
    off(this._map._container, "touchstart", this._onDown, this);
  },
  _onDown: function(e) {
    clearTimeout(this._holdTimeout);
    if (e.touches.length !== 1) {
      return;
    }
    var first = e.touches[0];
    this._startPos = this._newPos = new Point(first.clientX, first.clientY);
    this._holdTimeout = setTimeout(bind3(function() {
      this._cancel();
      if (!this._isTapValid()) {
        return;
      }
      on2(document, "touchend", preventDefault);
      on2(document, "touchend touchcancel", this._cancelClickPrevent);
      this._simulateEvent("contextmenu", first);
    }, this), tapHoldDelay);
    on2(document, "touchend touchcancel contextmenu", this._cancel, this);
    on2(document, "touchmove", this._onMove, this);
  },
  _cancelClickPrevent: function cancelClickPrevent() {
    off(document, "touchend", preventDefault);
    off(document, "touchend touchcancel", cancelClickPrevent);
  },
  _cancel: function() {
    clearTimeout(this._holdTimeout);
    off(document, "touchend touchcancel contextmenu", this._cancel, this);
    off(document, "touchmove", this._onMove, this);
  },
  _onMove: function(e) {
    var first = e.touches[0];
    this._newPos = new Point(first.clientX, first.clientY);
  },
  _isTapValid: function() {
    return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
  },
  _simulateEvent: function(type, e) {
    var simulatedEvent = new MouseEvent(type, {
      bubbles: true,
      cancelable: true,
      view: window,
      // detail: 1,
      screenX: e.screenX,
      screenY: e.screenY,
      clientX: e.clientX,
      clientY: e.clientY
      // button: 2,
      // buttons: 2
    });
    simulatedEvent._simulated = true;
    e.target.dispatchEvent(simulatedEvent);
  }
});
Map2.addInitHook("addHandler", "tapHold", TapHold);
Map2.mergeOptions({
  // @section Touch interaction options
  // @option touchZoom: Boolean|String = *
  // Whether the map can be zoomed by touch-dragging with two fingers. If
  // passed `'center'`, it will zoom to the center of the view regardless of
  // where the touch events (fingers) were. Enabled for touch-capable web
  // browsers.
  touchZoom: Browser.touch,
  // @option bounceAtZoomLimits: Boolean = true
  // Set it to false if you don't want the map to zoom beyond min/max zoom
  // and then bounce back when pinch-zooming.
  bounceAtZoomLimits: true
});
var TouchZoom = Handler.extend({
  addHooks: function() {
    addClass(this._map._container, "leaflet-touch-zoom");
    on2(this._map._container, "touchstart", this._onTouchStart, this);
  },
  removeHooks: function() {
    removeClass(this._map._container, "leaflet-touch-zoom");
    off(this._map._container, "touchstart", this._onTouchStart, this);
  },
  _onTouchStart: function(e) {
    var map = this._map;
    if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
      return;
    }
    var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
    this._centerPoint = map.getSize()._divideBy(2);
    this._startLatLng = map.containerPointToLatLng(this._centerPoint);
    if (map.options.touchZoom !== "center") {
      this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
    }
    this._startDist = p1.distanceTo(p2);
    this._startZoom = map.getZoom();
    this._moved = false;
    this._zooming = true;
    map._stop();
    on2(document, "touchmove", this._onTouchMove, this);
    on2(document, "touchend touchcancel", this._onTouchEnd, this);
    preventDefault(e);
  },
  _onTouchMove: function(e) {
    if (!e.touches || e.touches.length !== 2 || !this._zooming) {
      return;
    }
    var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
    this._zoom = map.getScaleZoom(scale2, this._startZoom);
    if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
      this._zoom = map._limitZoom(this._zoom);
    }
    if (map.options.touchZoom === "center") {
      this._center = this._startLatLng;
      if (scale2 === 1) {
        return;
      }
    } else {
      var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
      if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
        return;
      }
      this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
    }
    if (!this._moved) {
      map._moveStart(true, false);
      this._moved = true;
    }
    cancelAnimFrame(this._animRequest);
    var moveFn = bind3(map._move, map, this._center, this._zoom, { pinch: true, round: false }, void 0);
    this._animRequest = requestAnimFrame(moveFn, this, true);
    preventDefault(e);
  },
  _onTouchEnd: function() {
    if (!this._moved || !this._zooming) {
      this._zooming = false;
      return;
    }
    this._zooming = false;
    cancelAnimFrame(this._animRequest);
    off(document, "touchmove", this._onTouchMove, this);
    off(document, "touchend touchcancel", this._onTouchEnd, this);
    if (this._map.options.zoomAnimation) {
      this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
    } else {
      this._map._resetView(this._center, this._map._limitZoom(this._zoom));
    }
  }
});
Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
Map2.BoxZoom = BoxZoom;
Map2.DoubleClickZoom = DoubleClickZoom;
Map2.Drag = Drag;
Map2.Keyboard = Keyboard;
Map2.ScrollWheelZoom = ScrollWheelZoom;
Map2.TapHold = TapHold;
Map2.TouchZoom = TouchZoom;

// src/js/leaflet/barrioInfo.ts
var barrioInfo = control();
barrioInfo.onAdd = function(map) {
  this._div = DomUtil.create("div", "info");
  this.update();
  return this._div;
};
barrioInfo.update = function(props) {
  this._div.innerHTML = props ? "<b>Barrio " + props.Nombre_de_Barrio + "</b>" : "";
};
async function barriosLayer(map) {
  var geojson;
  function style2(feature) {
    return {
      fillColor: feature.properties.fillColor,
      weight: 2,
      opacity: 1,
      color: "white",
      dashArray: "3",
      fillOpacity: 0.4
    };
  }
  function resetHighlight(e) {
    geojson.resetStyle(e.target);
    barrioInfo.update();
  }
  function highlightFeature(e) {
    var layer = e.target;
    layer.setStyle({
      weight: 5,
      color: "#666",
      dashArray: "",
      fillOpacity: 0.6
    });
    layer.bringToFront();
    barrioInfo.update(layer.feature.properties);
  }
  function zoomToFeature(e) {
    map.fitBounds(e.target.getBounds());
  }
  function onEachFeature(feature, layer) {
    layer.on({
      mouseover: highlightFeature,
      mouseout: resetHighlight,
      click: zoomToFeature
    });
  }
  barrioInfo.addTo(map);
  return fetch("../json/barrios_old.json").then((res2) => res2.json()).then((data2) => {
    globalThis.barrios = data2;
    geojson = geoJson(data2, { style: style2, onEachFeature });
    geojson.addTo(map);
    return geojson;
  });
}

// src/js/leaflet/metroInfo.ts
var metroInfo = control();
metroInfo.onAdd = function(map) {
  this._div = DomUtil.create("div", "info");
  this.update();
  return this._div;
};
metroInfo.update = function(props) {
  this._div.innerHTML = props ? "<b>Metro " + props.Nombre + "</b><br><b>Linea: </b>" + props.L\u00EDnea : "";
};
var metroIcon = icon({
  iconUrl: "metro.png",
  iconSize: [26, 26],
  // size of the icon
  iconAnchor: [13, 26],
  // point of the icon which will correspond to marker's location
  popupAnchor: [-3, -76]
  // point from which the popup should open relative to the iconAnchor
});
var metrogeojson;
function resetMetroHighlight(e) {
  metrogeojson.resetStyle(e.target);
  metroInfo.update();
}
function highlightMetroFeature(e) {
  var layer = e.target;
  metroInfo.update(layer.feature.properties);
}
async function metroLayer(map) {
  metroInfo.addTo(map);
  return fetch("../json/capa_metro.geojson").then((res2) => res2.json()).then((data2) => {
    metrogeojson = geoJson(data2, {
      onEachFeature: function(feature, layer) {
        if (layer instanceof Marker) {
          layer.setIcon(metroIcon);
        }
        layer.on({
          mouseover: highlightMetroFeature,
          mouseout: resetMetroHighlight
        });
      }
    }).addTo(map);
    return metrogeojson;
  });
}

// src/js/leaflet/colegioInfo.ts
var colegioInfo = control();
colegioInfo.onAdd = function(map) {
  this._div = DomUtil.create("div", "info");
  this.update();
  return this._div;
};
colegioInfo.update = function(props) {
  this._div.innerHTML = props ? "<b>Colegio " + props.Nombre + "</b>" : "";
};
var colegioIcon = icon({
  iconUrl: "colegios.png",
  iconSize: [26, 26],
  // size of the icon
  iconAnchor: [13, 26],
  // point of the icon which will correspond to marker's location
  popupAnchor: [-3, -76]
  // point from which the popup should open relative to the iconAnchor
});
var colegiogeojson;
function resetcolegioHighlight(e) {
  colegiogeojson.resetStyle(e.target);
  colegioInfo.update();
}
function highlightcolegioFeature(e) {
  var layer = e.target;
  colegioInfo.update(layer.feature.properties);
}
async function colegioLayer(map) {
  colegioInfo.addTo(map);
  return fetch("../json/capa_colegios.geojson").then((res2) => res2.json()).then((data2) => {
    colegiogeojson = geoJson(data2, {
      onEachFeature: function(feature, layer) {
        if (layer instanceof Marker) {
          layer.setIcon(colegioIcon);
        }
        layer.on({
          mouseover: highlightcolegioFeature,
          mouseout: resetcolegioHighlight
        });
      }
    }).addTo(map);
    return colegiogeojson;
  });
}

// src/js/leaflet/exampleLayers.ts
var exampleLayers = [
  {
    type: "deals",
    slug_name: "venta_departamentos",
    name: "Departamentos en Venta",
    checked: true,
    criteria: {
      id_tipo_propiedad: 1,
      id_tipo_negocio: 1
    },
    layer_options: {
      icon: {
        url: "data:image/png;base64,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"
      },
      name: "Departamentos en Venta",
      url_low_emphasis: "data:image/png;base64,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",
      text: "f1ad",
      type: "deals",
      scale: 0.7,
      criteria: {
        id_tipo_negocio: 1,
        id_tipo_propiedad: 1
      },
      className: "icon-building-filled",
      slug_name: "venta_departamentos",
      fontFamily: "fontello",
      checked: true,
      fillOpacity: 0.85,
      strokeColor: "#3060ff"
    }
  },
  {
    type: "deals",
    slug_name: "arriendo_departamentos",
    name: "Departamentos en Arriendo",
    checked: true,
    criteria: {
      id_tipo_propiedad: 1,
      id_tipo_negocio: 2
    },
    layer_options: {
      icon: {
        url: "data:image/png;base64,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"
        //url: 'data:image/png;base64,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',
        //url_alt_b:  data:image/png;base64,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
        //url: 'data:image/png;base64,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',
      },
      name: "Departamentos",
      url_low_emphasis: "data:image/png;base64,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",
      text: "f1ad",
      type: "deals",
      scale: 0.7,
      criteria: {
        id_tipo_negocio: 1,
        id_tipo_propiedad: 1
      },
      className: "icon-building-filled",
      slug_name: "departamentos",
      fontFamily: "fontello",
      checked: true,
      fillOpacity: 0.85,
      strokeColor: "#3060cf"
    }
  },
  {
    type: "deals",
    slug_name: "venta_casas",
    name: "Casas en Venta",
    checked: true,
    criteria: {
      id_tipo_propiedad: 2,
      id_tipo_negocio: 1
    },
    layer_options: {
      strokeColor: "#109010",
      scale: 0.7,
      clickable: true,
      fontSize: 32,
      className: "icon-home",
      text: "e800",
      fillOpacity: 0.85,
      checked: true,
      icon: {
        //url: 'data:image/png;base64,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',
        url_alt_c: "data:image/png;base64,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",
        url: "data:image/png;base64,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",
        url_alt_a: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAA2CAYAAACMRWrdAAAAAXNSR0IArs4c6QAACr5JREFUaEPtmXl4U1UWwM99Ly9pli5JmzRJW8oustO0IAiDWnG0DcX5/OBDlBkEWYZFqQjI4FK2YRukiMhiGccBLcqMn7SlOnQQUBChtGWnbNUWmnRvkzbN+t6d7z6kUGmblzblc/x4/2R5955zfufce8657yH4jV7oN8oFD8D+3yL7IGIPIvYr8cCDpfgrCYRgM+5bxAyGGQyxKi9vh1uwdR0Y2ClgOoMxBgN+HNH0KABqAOI4LQYs+dlOGwCYMOAzCMNJhKhDplMZBR1gaHGqX8H0sca5APRsRFNasVzFMnJlqEgiA5qRAlAU3w1wHAfYbQe3o8HitNVWu211SsRxJgzsdhPWbwc/RdQvYLqYxBmIFq0SyQJZqTJCI5aFAMYACIGgT4+9DhprSk2eRqsYc9xSc37Whx2NYIfAdEMSopE44BOaFveRa7qpGGkgYAA+MuQzUh0CvbtqICIsGBQyCf9/faMTTFUWKPypAkyVdc3Gs3YrNFT+WM25Xec41j3FnJdV0l7AdoNp48aOphH1pSREFyxTRTZFRqMMgvHxg9GYYQ9Dj8iwNu26frMKDpy4BP/+5jQuq7Y2Rdhec9PhsJjt2I3/YC7I+LY9cO0C08cmjQGALLmmOyMODG2KUPLzT6Bp40a0xw5I23cMNqUfxhgwL89ZXw22iiKSQY2mUxk5vgr1GYxkPISo7+Th3aViuZKPVP8eelg+ayx6KDrcV/3Nxl8uLoe3tmXii0UmXq6nsRbqy4scgLmR5rysfF+E+wZmmMFE0BUXpEp9T3GQhvfs7wy94YPFz/smx4uFs9em4yN5V3j5DmsFOGrNJVpW3cuXGuiTQfrYce+L5EETFepuKrJkhg/sCTvf+qNPMoR6feqKj/GJs0WAMYbGqpJ6j70uvfTkvllC5ws2Kjxm7CM0jQ4GRfWXUoiG8LBg2LtmJgoNUQjV5dO46roGmPDGDmyuquVrhqXknB1xOL40P/MHIYIEg+njxmUEhGifEitCxaQ+bV78Aoof2leIDmA5Dm6YyqFrpK5pfHllDdgdTpBKJRAepmpRzsGTl2Dumt2Y6HNaq8FuKf/anPtlghClgsC0cWP7URj9EBzVX06W4NOPDoSNCyYKmlteVQPTF66GggtX4Pejh0HqsmRQyKQw4MkXoc5aD2GqECj4+uNWbU3esAf/59hZvt5Zb1ywcQg/UpabecEbnCDjtDHGdwIUymkBqohIApa++s9oSJ9ob7Lh/OUieGnBSiirqIZQZTBU11qgd/cukLZuCRinvA7WBhsogwPhbM7uVmUVFBbDpCXb+DLgrDVVuGy120ynslK8KRcEpjMknZWro/uTvq9/r0jYu36u13n7D34PyctSweF0QfL0ifDcM4/Dhh2fwhdfHYagQDnY7U5wezxewQjAhIVb8NmrJcC5HGCrKr5qyt33UIfB1HEJWgZT1xX6PlIECOZMHAPznh/TJljqzs/g3R3pIBEz8O7br8K5wuuQticDVi2aCTV1Vli3dTdwHFlcIAjs/fQcvHnPASD6raZCpwex3Spzs8vagvPqedJlIBGTJld3jSKC01JeRiNjWnYYic5ryzdBZs5RCFerIPWd+bD9ky/h8PE7tXXK+EQYETsAXlu2CRoa7RCkkMOZnF0goulW7TyafxmmpXyIiX5b5U/VnMc1yVs34hVMF2OcLpIFpgQo9Voy+Ju0pVSERnmPESTLTVu4Cs5cvAYD+vSApfOmwF/WbYOi4tJ7xg6P6Q/zp0+E11ds5rPlyKGDYNtfF0FwUMulw1RRC4+9vIrjC3Zdmd1tsyR7OwF4BzMYl4jlIa+KgzRqknYvZ2ygfmnpxSs/wp9eW8EnicT4EWB8ciQsWvk+1NsaW41ClD4c1i+dCxvT9sCJggvQPToC/pn6NkRHaFuc03vsAo7od1mqWKet5h1zXtbqDi5FYwojV85nFKpAshSuZG28B+yrQ8dh5htr4ZWpEyBAIob12+7sobaUy6QBsGbJbDiedx72Zh2EvdtXQezAh1uc0ss4nyP6nQ3V9R5bbaq3zCgwYspljEJFk8FX9qfeA0YsKSktB4VcCoOemuwtYTW7rwoJgjMHdvHzu0S03kT3SiRgAC5rVaXLbtnU4Yjd2mOKdyWBahmx6PA/UqgITcudAsl4vwSjKARd9LeWF4c5HuDuy1sdI2NLK2rgsSkpHPnutFSUeRy2lA7vMT4r0qJdUqVeTdrtj1bOQSNj+rQY6ZbA7jbc2/3WQn00vxC/tHQLf1CzV5eWYI6d0eGsSOqYCNNF0tAoCaGZ90ICenVy4n0Fe2/Xfrzpk2xMlNqrShxuiuvR4TpGvKiPTSqUBKl7UYwYBvaOhi/eW9ziPvMWEW/3W4vYc6+s5U5fLgbscZGleN6UlznI20b2mjxugRlTaLFsFiNXqkm/8K+NC6mYfj3ukU26dbLHyOfty9tS7Nk1Eg59vqVVO/MvXIfxyev5/eVurC112xt3luVnLfMLGOnuEQc/SFU6GTmyJ442oM1vzmjRKaRjr7M0NOmlKKop25E2qqS0eScUFhrCd/utXXNX7sBffZtHemCwW8w2DDDcb909UaqLTTrCSOSjqAA5v9a3L5+DxowYLCji3rzb2v2c70/jGW9v4fWxzkaXy1GfU3YqM0mIPMGGaWONQxFCOZJAjYJ0AFq1CjI+eJMKUwYJ0ePzmKpaK4ybvZIzVdQAIkcWa6WD5SC+3N8naGKZ1mDcKhJJnhXJgjTk96ND+qLdG14X7Bxf6F5c8Dd8rOAifwRw2+trsMf1melUxlyhMnw2SmcwnmMksn6URMYrfWLYILRz9Xyf5bRl4LQlqfibE2d4+azTjlhn4zUT6Pr58lzfZ4O0hsTxCNGbaUaioRkpySUwuE83WLNwKvVwzy5CHdriuEvXSmDx+r9zZwt/5B8FYNaFPI4GOwCM6tznij+boxsydjJQsIFmJGEUI+UfthBDlsycgGZNMvrsLCJ266dZeO32z3lH8cnC40Kcs9ENCN2fJ8G3Xa2LS3gaWLSVEonltFgW2vS/RgWTkh5Hz4weinp1jWgzgld/KoXsIydxesYhbK6oaRrLehwIe1wWDsGzZbmZR9qzDNrl3SYIg7ELBvgIUeghmpHpKKr5KThKr4a+PaJRpC4MAuV8D82f0W6aq+Di9WJ8w1TZzGbMscC6HbWAuUuYZV80F2QXtweKzOkQ2G2l+ljjOozRZEok1iARw9edu18nCfnNetwIs8564PAic/7+He0Fuj3PL2BEmGZYUjjN4uMUzURTIubWk5o2AO++Dx43Yll3MUuj4RUnMpqfa9pJ6Dcwol8fNy4KMPs9ohg9okX4zivN24S3X3He+Y1JpDi3CRA9wpS770Y7Oe6Z5lcwIj0yJqkni/BRRIvUFIFrY1FyLIsw66mkMRp5Mz/jmr+g/LbHfmmQdsi4vohmv6MoJgQjdGfP3fVOGlgOcdhTh1l6VFnBvov+hOo0MCI4Ii5hMMdRRxAlUiAK/VyfSNeHyTMChDlPA0Vxo0tzs0/7G6pTwYjwcEPCMAqog4BoKaIIEQLMkgCydg64+PK87BOdAdXpYESBLiZxFELov4AoEV9dMOvBGD9pzt//XWdB3RcwflkOMcazFBwg32kOniotyDrYmVD3DYwo0sYa+Rd2Zaeysjsbisj/H9uSlXPXWKYoAAAAAElFTkSuQmCC"
      },
      name: "Casas",
      url_low_emphasis: "data:image/png;base64,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",
      slug_name: "casas",
      fontFamily: "fontello"
    }
  },
  {
    type: "deals",
    slug_name: "arriendo_casas",
    name: "Casas en Arriendo",
    checked: true,
    criteria: {
      id_tipo_propiedad: 2,
      id_tipo_negocio: 2
    },
    layer_options: {
      strokeColor: "#107010",
      scale: 0.7,
      clickable: true,
      fontSize: 32,
      className: "icon-home",
      text: "e800",
      fillOpacity: 0.85,
      checked: true,
      icon: {
        url_alt_0: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAA2CAYAAACMRWrdAAAAAXNSR0IArs4c6QAACdZJREFUaEPtWXt4TVcW/61z7o2IvEQSNJFQg1JvpmSUadSjqBTxHmYqtDpttWqGVjENpYbpqNa0n0c96lUlqo16pqRlfKkKKgzTGS15IETkLTe555w13z43N03kJvdcN/F1+jn/3O+evfZvrd9Ze62919qEX+hDv1BeuE/s/82z9z1232M/ky9wfyn+TBxh2Ix757FkmHWrusNq2Do3BOuEmPlYUGdY0QcyeoH5YYAag9gDTGDmYiK6CvA5aCToHrH2yvrODQ4Op9YqMXNi8HMgfoaZGxOggCjAoVYGGJwnSZTDzP4AZYJpndXnxtra8mitEDMnBMWAtDc0IoUYQQKUAf1YY/iXkEkM4dUF1v5Z69z1oFvE6h8IaGaFtI6IW4OpIaTK5jT3DENHn/YI9wyFn8lXH8xT8pFqyUBKwTlctqTdYT8BpGWTRhdk1qYWD7yVfrcE75qYaV/Qo5C0bdDg+5NnCCGeTTE5dCKim0ShrXebGu26UPg9dmbGY23GJmRYroJAYokKX5cQczGTNF4ZlPXPuyF3V8RM8Y36koQ4EJnADBBB/C58aB5mtXz5buzA0h/exdzvF+o4djwACmsYqURlH3YV1GVi5j1BnVnlBDDXsyljdPPvgtWd30VH34dd1V9JPiX/X3j2u5dwMvfMT++JSkim/tYhrmVO14glw2xOC0wGcQu75kFNBuDznlvdInTn5GHfjMfezIO2zyYcKCHDWprdGaNRalSRS8RMcf7LGNIIAgJEKPRt3AcHeu8yqssluYFHhuNw1hE9rUpAoQqOU0flvGQUxDAx85ZGj7AJXwDsKSaFeoUgqd8hNPYMMqrLJbnrlixEfNkP6bczyrYNshDhSevo7G+NABkmZtocsAMSRQKah9ih4npvxFOhQ4zoQJ4lHyfST+LRFhHwNHnqc5JSjyO/pAD+nn7oEfZrhzifZ+zFyKMTynZEfWEeUsbnDDei1BAxj22N2mpWTiSCFzNjVPgwbO1tbA89e+0chm0cg9ScdHRq2gGf/v5jhDcMQ2BsM+Ra8hDYoBEy512q1tbxRydhR1q8bacHiiVCZOmEW+edkTNEzLSh0RyQNhGMBwTgkUH7ERH8iDNs7D6/FxO3TUZhaRG6hHTC6StnENQgEHETtyBqwyjdk428AnD9L5erxUq68S367HuiLP9yFmnyeiUme6Ez5YaImdcHHGdwW2KgW2AXJA095AwXS79+B3P3z4dJNmPViPfQJrAVEi4eRmzCIpglM1RWoWqqU2JCUcTux5F887QeayrwoxaT09mZAc6JrQlubIL1nL5vETCnyyzEdptdLW6JUoKpn07D5lPbEOwdhE1jP8Sa4xsQd3YX/tznZTwS1h2Ttk9FUeltHcOZx4RM7MnFWHRqqX74ZHCpWurRHi9kZdZEzikx0xq/vtCkD8D8gEDeM2gHBoQ97hDzRmEWojeN1xNDh6btsSLqbby8exbOXE0plx/Yuh9ei/wTnt7+rB53PvW8kfr69/Ct51OtnQfTDmHIvpF6EmFwNsnyZOWZmk8jTonJ//CPIUl6Daw1EZovTjyDcJ+wKkakXDuLYR+NQVpuBoa2G4ypPaZg0vZnkVV0s4ps68BWWB29AnMOzMexy0loF/wQPnt6Ox4MaO6QXGpBGn61qZM9zorBNFt9MbfG7OWUmOm9hjOZtOeISN+wrC/kVFF+6GIiRmwcpy+vmb+djuYB4ZgePwtWtfpiWXho3eiV2HNhP9Ynb9KX5L7Jn6FriOPwMb/f0KZXZQUkLVZeyvmbe0vxnYZzAPV5BvmIr2CdnlsF73jaCQxaOwzLhi5B8pXTWJm0xlls6+MSSVj0RCw8ZA+8+eViHHk+Qfeeo8e03L+sbc0FgPyB8krOIveILfObCYbIFibdYzOqEhPvRdIoKClEkzfLj5GGyNmTh0WxlG/ejiaal/nbliIjiySsVGbkuecxebF/DGR+C2AvUS9dnJqCcN+qMSaU3izKrkLMLJsR2bKPbpRVVZD4w9eV7DaSFVPz09ByVQe9XgNzJpP0V3WWuzG22K8vE68hpiCBu2f0Tgxo4TgrOiJW0XBn49W5+OClQxjySbS915AB4EVldl6NNZrT5IGlDZrIpdI5gDyE4rm9X0Vsn9cd2uDMcGfj1RGLPfIWFh5dYhtmLlElrT3mFF13K8b0IJ/v8x0RPSi+QremXfHNlMR7SixibSROXD1lSx7E55V5BT2dBbBzj4msMc93LhNPAiFIHEaPTk5ARFiPKtgigbRc0h6ZBT99TGdLMSK8B47+MaFaO5PSjqP3uv76IZiIr2osb9IW5NWYEXX+zpiLcY/Z3u1UGYkEqb5otoxuPxxbx3xkZKrbMmM/+QN2nvvM3uS5LUOLLF1YeMEZsCFiAkSe7b0fTL+BOAmDsHPCVjzV7kln+G6Nf37+C0RvHmf7/sylYEpUlxSMMgJqmJj5Nb9umsaigm4g9DTzC8U3075CY+9gI3pclrleeAM9VzyG9NwMeza0SKAnrUvza7eCFpaZZnovZw3CTTqbyFaPIWHqbpeNNjKh/6qhSPzvVzZRoluk4lPlnYIZRuYajrGKYPIrPicI3MZW0BIGtxuA+ClxRvUZkov6cCT2nj9Q3iRn0CWtqKA7Vhu/qTG8FO0WydO8RzD4bQCBRPrtCbqHd8Xqse+jU0gHQ4ZXJ5Ry5Sye+fgFnEw/reOWdYZLZBn9rcuLXLqRcZmYnkim+Y5jjRcTOKDitcOiqAV4dYDh1VKJ35KDf8ec+NgK1xj6nqWQQiOVlYV13wm2W2Oa0qC/ZublxOQlCmH7rUpIwxBM6fU0orsOR7umjk/qdozz1/6Nnad2Ye2xDUjPuXLH7QzlSxKNVT4ouHe9+/JPPaV+qEymVURaKwb0QrT83ghAi8Dm6BjSEeGBofCt76cP59/OQ+qtDKRkpODSzcuV5PUKmTmHiP6jWtUYrC++97ctFdeRFOO1iBhjmdjN7qlUQMTz1LW3jfX2aojou4oxh3jPeQdLFk4kaM30pjQ0ccoEQwNV+G9/f+c4g9M1TykSKwtvuJWByibXHjEB+Lv6oRJJh0G2/ojhh6VMjbW+2FIsSpJaeWqXmDBpfL0HJZi+JGiBtpNQhQOpw/90U4PaD1tLfqwVRnXiMbtlY7zbSlDFDmur5x0+eh7N1UrVgdhV6vRQ6yrp2veY3YLhDTpJsrYPgHelGqL8tp0LNVUehF1FFW75XDW/evm6IyZ0Rnt1lzRtL4g877iCtWiSNBg7byfXHpXKSHVLTByco+r30oh3A6R3uQBWJKahSnzxsboiJXDrnJhu/BDPSIkgqkWxCQzDHovj3kItMr03xITnhtQbKOxW9pSIpFLnz/8ABY3KZDDdo0kAAAAASUVORK5CYII=",
        url: "data:image/png;base64,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"
        //url: 'data:image/png;base64,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',
      },
      name: "Casas",
      url_low_emphasis: "data:image/png;base64,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",
      slug_name: "casas",
      fontFamily: "fontello"
    }
  }
];
var PublicLayersObject = exampleLayers.reduce((acc, layer) => {
  layer.layer_options.checked = true;
  acc[layer.slug_name] = layer;
  return acc;
}, {});

// src/js/leaflet/Wrapper.ts
var Wrapper = class {
  constructor(className) {
    this.wrapper = document.createElement("div");
    this.wrapper.className = className;
  }
  addClass(className) {
    this.wrapper.classList.add(className);
    return this;
  }
  addStyle(property, value) {
    this.wrapper.style[property] = value;
    return this;
  }
  setInnerHTML(html) {
    this.wrapper.innerHTML = html;
    return this;
  }
  appendChild(child) {
    this.wrapper.appendChild(child);
    return this;
  }
  appendTo(parent) {
    parent.appendChild(this.wrapper);
    return this;
  }
  setTextContent(text) {
    this.wrapper.textContent = text;
    return this;
  }
  prependTo(parent) {
    parent.prepend(this.wrapper);
    return this;
  }
  append(child) {
    this.wrapper.appendChild(child);
    return this;
  }
  get div() {
    return this.wrapper;
  }
};

// src/js/leaflet/negocioFeatureToHtml.ts
var negocioFeatureToHtml = class {
  constructor(feature, campos) {
    this.feature = feature;
    campos = {
      "ubicacion": "Ubicaci\xF3n",
      "tipo": "Tipo",
      "dormitorios_total": "Dormitorios",
      "banos_total": "Ba\xF1os",
      "servicios": "Servicios",
      ...campos,
      tipo_negocio: "Modalidad",
      tipo_propiedad: "Tipo Propiedad",
      "titulo-resumen-web": "Resumen",
      nombre: "Nombre",
      comuna: "Ubicaci\xF3n",
      "banos-completos": "Ba\xF1os",
      dormitorios_completos: "Dormitorios",
      "precio": "Precio"
    };
    this.campos = campos;
    this.normalizeProperties();
    this.id = feature.id;
    this.container = new Wrapper("flex flex-col");
    this.container.addClass("flex").addClass("flex-col").addStyle("lineHeight", "1.5em").addStyle("fontSize", "13px").addStyle("fontFamily", "Inter, sans-serif").addStyle("fontWeight", "400").addStyle("maxWidth", "350px");
    this.appendProperties();
  }
  get content() {
    this.container.div.classList.add("flex");
    this.container.div.classList.add("flex-col");
    return this.container.div;
  }
  getProperty(slug_name) {
    return this.feature.properties[slug_name];
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  get linkWeb() {
    const postId = this.getProperty("codigo-wordpress") || this.getProperty("codigo_wordpress");
    return this.getProperty("link-publicacion-web") || postId && `"https://lacasadejuana.cl/?p=${postId}"` || null;
  }
  get ubicacion() {
    let barrio = this.getProperty("barrio").replace("Barrio ", ""), comuna = this.getProperty("comuna");
    return barrio ? `Barrio ${barrio}, ${comuna}` : comuna;
  }
  get precio() {
    return this.getProperty("precio-publicacion") + " (UF)";
  }
  get tipo() {
    return `<span class="font-semibold">${this.getProperty("tipo_propiedad")}</span>
        <span style="margin-left:0.25em;margin-right:0.25em;">en</span>
        <span class="font-semibold">${this.getProperty("tipo_negocio")}</span>`;
  }
  get banos_total() {
    let banos = Number(this.getProperty("banos") || this.getProperty("banos-completos")).toFixed(0), banos_servicios = this.getProperty("banos-servicio"), texto_servicio = Number(banos_servicios) > 0 ? ` + ${Number(banos_servicios).toFixed(0)} servicio` : "";
    return `${Number(banos).toFixed(0)} ba\xF1os ${texto_servicio}`;
  }
  get dormitorios_total() {
    let dormitorios = Number(this.getProperty("dormitorios") || this.getProperty("dormitorios-completos")).toFixed(0), dormitorios_servicio = this.getProperty("dormitorios-servicio"), texto_servicio = Number(dormitorios_servicio) > 0 ? ` + ${Number(dormitorios_servicio).toFixed(0)} servicio` : "";
    return `${dormitorios} dormitorios ${texto_servicio}`;
  }
  get hiddenSlugs() {
    return [
      "lat",
      "lng",
      "searchstring",
      "id_etapa_negocio",
      "precio-publicacion",
      "codigo_interno",
      "codigo-wordpress",
      "codigo_wordpress",
      "link-publicacion",
      "thumbnail",
      "barrio",
      "img-portada-wordpress",
      "id_tipo_negocio",
      "id_tipo_propiedad",
      "dormitorios",
      "banos-completos",
      "banos-servicio",
      "banos",
      "tipo_negocio",
      "tipo_propiedad",
      "comuna",
      "titulo-resumen-web",
      "dormitorios-servicio",
      "servicios",
      "fecha-publicacion"
    ];
  }
  normalizeProperties() {
    this.feature.properties.ubicacion = this.ubicacion;
    this.feature.properties.tipo = this.tipo;
    this.feature.properties.precio = this.precio;
    this.feature.properties.servicios = `${this.dormitorios_total}, ${this.banos_total}`;
    this.feature.properties["fecha-publicacion"] = this.getProperty("fecha-publicacion").split("-").reverse().join("-");
  }
  appendProperties() {
    Object.entries(this.feature.properties).forEach(([slug_name, value]) => {
      if (slug_name === "nombre")
        console.log([value, slug_name]);
      let wrapper = new Wrapper(
        "flex w-full justify-between align-items-center " + slug_name
      );
      if (slug_name.includes("link-img-portada-wordpress")) {
        this.printImagenPortada(wrapper, value);
      } else if (slug_name.includes("seudonimo") || slug_name.includes("nombre") || slug_name.includes("seudonimo-propiedad")) {
        this.printLinkWeb(wrapper, value);
      } else if (this.shouldSkip(slug_name, value)) {
        return;
      } else if (slug_name.includes("titulo-resumen-web")) {
        this.printTituloResumen(wrapper, value);
      } else if (slug_name.includes("tipo")) {
        this.printTipo(wrapper, value);
      } else if (slug_name.includes("servicios")) {
        this.printServicios(wrapper, value);
      } else if (slug_name.includes("ubicacion")) {
        this.printUbicacion(wrapper, value);
      } else {
        this.printOtherCampos(wrapper, slug_name, value);
      }
    });
  }
  printUbicacion(wrapper, value) {
    value = `<span class="nowrap font-bold text-bold">${value}</span>.&nbsp;&nbsp;&nbsp;  ${this.getProperty("titulo-resumen-web")} `;
    wrapper.setInnerHTML(value);
    wrapper.addClass("justify").addStyle("textAlign", "justify").addStyle("fontWeight", "500").addStyle("order", "3").addStyle("fontSize", "1.15em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("display", "block").addStyle("marginTop", "0em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printServicios(wrapper, value) {
    wrapper.setInnerHTML(value);
    wrapper.addStyle("fontWeight", "500").addStyle("order", "4").addStyle("fontSize", "1em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("marginTop", "0em").addStyle("marginBottom", "0.5em").prependTo(this.container.div);
  }
  shouldSkip(slug_name, value) {
    return !value || slug_name.includes("etapa") || this.hiddenSlugs.includes(slug_name) || slug_name.includes("codigo-wordpress") || slug_name.includes("codigo_wordpress") || slug_name.includes("link-publicacion") || !this.campos[slug_name] && slug_name !== "thumbnail";
  }
  printImagenPortada(wrapper, value) {
    const link = `<img src="${value}" style="width:100%;height:200px;object-fit:cover;"/>`;
    wrapper.setInnerHTML(link).addStyle("fontWeight", "600").addStyle("fontSize", "1.1em").addStyle("marginBottom", "0.3em").addStyle("order", "1").appendTo(this.container.div);
  }
  printLinkWeb(wrapper, value) {
    if (this.linkWeb) {
      wrapper.setInnerHTML(
        ` <a href=${this.linkWeb} target="_blank"><i class="fas fa-link"></i> ${value}</a>`
      );
    } else {
      wrapper.setInnerHTML(`  ${value}`);
    }
    wrapper.addStyle("fontWeight", "600").addStyle("order", "2").addStyle("fontSize", "1.5em").addStyle("marginTop", "0.7em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printTipo(wrapper, value) {
    wrapper.div.setAttribute("rel", "tipo");
    new Wrapper("py-1 pl-1 flex border border-1/2 min-w-[150px]").addStyle("fontFamily", "Inter, sans-serif").setTextContent(this.campos.tipo).addStyle("minWidth", "130px").addStyle("maxWidth", "140px").appendTo(wrapper.div);
    new Wrapper(
      "py-1 flex border border-1/2 pl-2 max-w-[350px] min-w-[200px] flex-grow overflow-hidden whitespace-nowrap"
    ).addStyle("maxWidth", "350px").addStyle("minWidth", "200px").addStyle("overflow", "hidden").addStyle("fontFamily", "Inter, sans-serif").setInnerHTML(value).appendTo(wrapper.div);
    wrapper.addStyle("order", "4").addStyle("fontWeight", "500").appendTo(this.container.div);
  }
  printTituloResumen(wrapper, value) {
    let words = value.split("|"), wordsQuantity = words.length, firstRow = words.slice(0, wordsQuantity / 2).join(" "), secondRow = words.slice(wordsQuantity / 2).join(" ");
    wrapper.setInnerHTML(value);
    wrapper.addStyle("fontWeight", "500").addStyle("fontWeight", "500").addStyle("order", "3").addStyle("fontSize", "1.1em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("marginTop", "0.2em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printOtherCampos(wrapper, slug_name, value) {
    wrapper.div.setAttribute("rel", slug_name);
    new Wrapper("py-1 pl-1 flex border border-1/2 min-w-[165px]").addStyle("fontFamily", "Inter, sans-serif").addStyle("fontWeight", "400").addStyle("minWidth", "130px").addStyle("maxWidth", "140px").setTextContent(this.campos[slug_name]).appendTo(wrapper.div);
    new Wrapper(
      "py-1 flex border border-1/2 pl-2 max-w-[350px] min-w-[200px] flex-grow overflow-hidden whitespace-nowrap"
    ).addStyle("maxWidth", "350px").addStyle("minWidth", "200px").addStyle("overflow", "hidden").addStyle("fontFamily", "Inter, sans-serif").setTextContent(value).appendTo(wrapper.div);
    wrapper.addStyle("order", "5").addStyle("fontWeight", "500").appendTo(this.container.div);
  }
};

// src/js/leaflet/PublicLayerDeals.ts
async function PublicLayerDeals({ index, slug_name, name, path, layer_options, criteria }, map) {
  const dealInfo = control();
  dealInfo.onAdd = function(map2) {
    this._div = DomUtil.create("div", "transparent");
    this.update();
    return this._div;
  };
  dealInfo.update = function(props) {
    this._div.innerHTML = props ? '<div class="info"><b>' + props["seudonimo-propiedad"] + "</b></div>" : "";
  };
  const FeatureCollection = {
    type: "FeatureCollection",
    features: []
  };
  var deallayer;
  const icon2 = icon({
    iconUrl: `${slug_name}.png`,
    iconSize: [28, 32],
    // size of the icon
    iconAnchor: [14, 32],
    // point of the icon which will correspond to marker's location
    popupAnchor: [-3, -32]
    // point from which the popup should open relative to the iconAnchor 
  });
  function appendFeatures(dealsWithCoords) {
    let features = dealsWithCoords.filter((negocio) => negocio.match(criteria)).map((n) => n.toFeature());
    for (let feature of features) {
      FeatureCollection.features.push(feature);
    }
  }
  function resetHighlight(e) {
    dealInfo.update();
  }
  function highlightFeature(e) {
    var layer = e.target;
    dealInfo.update(layer.feature.properties);
  }
  dealInfo.addTo(map);
  function addLayerToMap({ slug_name: slug_name2 }) {
    appendFeatures(globalThis.$store.negocios.deals_with_coordinates);
    deallayer = geoJson(FeatureCollection, {
      onEachFeature: (feature, layer) => {
        layer.bindPopup(new negocioFeatureToHtml(feature, {}).content, {
          maxWidth: 400
        });
        layer.on({
          mouseover: highlightFeature,
          mouseout: resetHighlight
        });
        if (layer instanceof Marker) {
          layer.setIcon(icon2);
        }
      }
    });
    deallayer.addTo(map);
    return deallayer;
  }
  globalThis.layers = globalThis.layers || {};
  console.log("addLayerToMap", { slug_name });
  return addLayerToMap({ slug_name });
}

// src/js/leaflet/LeafletMap.ts
var LeafletMap = () => ({
  map: null,
  exampleLayers,
  async init() {
    this.map = createMap("map", {
      zoomControl: false
    }).setView([-33.395, -70.5777], 12);
    control.zoom({
      position: "bottomright"
    }).addTo(this.map);
    globalThis.map = this.map;
    tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: "abcd",
      maxZoom: 20
    }).addTo(this.map);
    globalThis.layerControl = control.layers(null, null).addTo(this.map);
    globalThis.layers = globalThis.layers || {};
    this.barrioslayer = await barriosLayer(this.map);
    this.metrolayer = await metroLayer(this.map);
    this.colegioLayer = await colegioLayer(this.map);
    globalThis.layerControl.addOverlay(this.barrioslayer, "Barrios");
    globalThis.layerControl.addOverlay(this.metrolayer, "Metro");
    globalThis.layerControl.addOverlay(this.colegioLayer, "Colegios");
    this.$store.columnas_actuales.on("ready", () => {
      this.fetchPublicaciones();
    });
  },
  fetchPublicaciones() {
    module_default8.store("negocios").next_page_url = "https://lacasadejuana.cl/api/publicaciones";
    module_default8.store("negocios").complete = false;
    return this.$store.negocios.restart().then(async (result) => {
      setTimeout(() => this.$store.negocios.total = this.$store.negocios.properties.length, 1e3);
      console.info("fetched negocios", this.$store.negocios.properties.length);
      for (let { type, slug_name, name, criteria, layer_options } of exampleLayers) {
        this[slug_name] = await PublicLayerDeals({ slug_name, name, criteria, layer_options }, this.map);
        globalThis.layerControl.addOverlay(this[slug_name], name);
      }
      ;
    });
  }
});

// src/js/leaflet/init_public_map.ts
if (!console.timerInfo) {
  Object.defineProperty(console, "timerInfo", {
    get: function() {
      return Function.prototype.bind.call(
        console.debug,
        console,
        "%c" + Number(performance.now() / 1e3).toFixed(2) + " Timer:",
        "color:#03C;font-weight:bold;"
      );
    }
  });
}
if (!console.marquee) {
  Object.defineProperty(console, "marquee", {
    get: function() {
      return (obj, ...args) => {
        let colors = Object.values(obj), payload = [""].concat(Object.keys(obj));
        console.log(payload.join("%c "), ...colors, ...args);
      };
    }
  });
}
module_default8.plugin(module_default5);
module_default8.plugin(module_default);
module_default8.plugin(module_default3);
module_default8.plugin(module_default2);
module_default8.plugin(module_default7);
module_default8.plugin(module_default4);
module_default8.plugin(module_default6);
globalThis.Alpine = module_default8;
if (!console.timerInfo) {
  Object.defineProperty(console, "timerInfo", {
    get: function() {
      return Function.prototype.bind.call(
        console.debug,
        console,
        "%c" + Number(performance.now() / 1e3).toFixed(2) + " Timer:",
        "color:#03C;font-weight:bold;"
      );
    }
  });
}
if (!console.marquee) {
  Object.defineProperty(console, "marquee", {
    get: function() {
      return (obj, ...args) => {
        let colors = Object.values(obj), payload = [""].concat(Object.keys(obj));
        console.log(payload.join("%c "), ...colors, ...args);
      };
    }
  });
}
globalThis.backendPaginator = { total: 500 };
document.addEventListener("alpine:init", () => {
  module_default8.data("LeafletMap", LeafletMap);
  module_default8.data("PublicLayerDeals", PublicLayerDeals);
});
document.addEventListener("DOMContentLoaded", () => {
  module_default8.start();
});
if (!globalThis.storeCamposBusqueda) {
  const createAlpineStore = (name, factoryFn) => {
    if (module_default8.store(name))
      return module_default8.store(name);
    module_default8.store(name, factoryFn());
    return module_default8.store(name);
  };
  globalThis.$store = {};
  const storeCamposBusqueda = globalThis.$store.campos_busqueda = globalThis.storeCamposBusqueda = createAlpineStore("campos_busqueda", () => new CamposBusquedaStore());
  const storeNegocios = globalThis.$store.negocios = globalThis.storeNegocios = createAlpineStore("negocios", () => createNegociosStore());
  const storeColumnasActuales = globalThis.$store.columnas_actuales = globalThis.storeColumnasActuales = createAlpineStore("columnas_actuales", () => columnas_actuales());
  const storeActiveFilter = globalThis.$store.active_filter = globalThis.storeActiveFilter = createAlpineStore("active_filter", () => new ActiveFilterStore());
  const camposBusquedaPromise = staticFetchWrapper(
    "https://assets.juana.house/api/campos_formulario",
    {}
  ).then((res2) => {
    globalThis.camposBusquedaJson = res2;
    console.timerInfo("received camposBusquedaPromise result from sw");
    return globalThis.camposBusquedaJson;
  });
  globalThis.columnasVisiblesPromise = staticFetchWrapper(
    "https://assets.juana.house/api/columnas_actuales",
    {}
  ).then((res2) => {
    globalThis.camposBusquedaJson = res2;
    console.timerInfo("received camposBusquedaPromise result from sw");
    return globalThis.camposBusquedaJson;
  });
  camposBusquedaPromise.then((campos) => {
    storeCamposBusqueda.reloadCampos(Object.values(campos), false);
  });
  storeCamposBusqueda.on("ready", () => {
    storeColumnasActuales.setDefaultColumns(storeCamposBusqueda.findMany(["id", "nombre"]));
    globalThis.columnasVisiblesPromise.then((columnasVisibles) => {
      storeColumnasActuales.reloadCampos(columnasVisibles, false);
      storeActiveFilter.ready = true;
    });
  });
}
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@alpinejs/focus/dist/module.esm.js:
  (*! Bundled license information:
  
  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)
  
  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  *)

leaflet/dist/leaflet-src.esm.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)
*/
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=init_public_map.js.map

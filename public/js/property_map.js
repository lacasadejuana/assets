var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    "use strict";
    (function() {
      var undefined2;
      var VERSION7 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache4, key) {
        return cache4.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data3, result = [];
        while (!(data3 = iterator.next()).done) {
          result.push(data3.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set4) {
        var index = -1, result = Array(set4.size);
        set4.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set4) {
        var index = -1, result = Array(set4.size);
        set4.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty4 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid4 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid4 ? "Symbol(src)_1." + uid4 : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty4).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer3 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray7(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty4.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject5(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray7(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start3 = view.start, end = view.end, length = end - start3, index = isRight ? end : start3 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data3 = iteratees[iterIndex], iteratee2 = data3.iteratee, type = data3.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data3 = this.__data__;
          if (nativeCreate) {
            var result2 = data3[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty4.call(data3, key) ? data3[key] : undefined2;
        }
        function hashHas(key) {
          var data3 = this.__data__;
          return nativeCreate ? data3[key] !== undefined2 : hasOwnProperty4.call(data3, key);
        }
        function hashSet(key, value) {
          var data3 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data3[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data3 = this.__data__, index = assocIndexOf(data3, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data3.length - 1;
          if (index == lastIndex) {
            data3.pop();
          } else {
            splice.call(data3, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data3 = this.__data__, index = assocIndexOf(data3, key);
          return index < 0 ? undefined2 : data3[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data3 = this.__data__, index = assocIndexOf(data3, key);
          if (index < 0) {
            ++this.size;
            data3.push([key, value]);
          } else {
            data3[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data3 = getMapData(this, key), size4 = data3.size;
          data3.set(key, value);
          this.size += data3.size == size4 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data3 = this.__data__ = new ListCache(entries);
          this.size = data3.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data3 = this.__data__, result2 = data3["delete"](key);
          this.size = data3.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data3 = this.__data__;
          if (data3 instanceof ListCache) {
            var pairs = data3.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data3.size;
              return this;
            }
            data3 = this.__data__ = new MapCache(pairs);
          }
          data3.set(key, value);
          this.size = data3.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray7(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty4.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get4(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject5(value)) {
            return value;
          }
          var isArr = isArray7(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer3(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap3(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol3(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start3, end) {
          var length = array.length;
          start3 = toInteger(start3);
          if (start3 < 0) {
            start3 = -start3 > length ? 0 : length + start3;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start3 > end ? 0 : toLength(end);
          while (start3 < end) {
            array[start3++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray7(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString3(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty4.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start3, end) {
          return number >= nativeMin(start3, end) && number < nativeMax(start3, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache4 = caches[othIndex];
                  if (!(cache4 ? cacheHas(cache4, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray7(object), othIsArr = isArray7(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer3(object)) {
            if (!isBuffer3(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty4.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data3 = matchData[index];
            if (noCustomizer && data3[2] ? data3[1] !== object[data3[0]] : !(data3[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data3 = matchData[index];
            var key = data3[0], objValue = object[key], srcValue = data3[1];
            if (noCustomizer && data3[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject5(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray7(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty4.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject5(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty4.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject5(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray7(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray7(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject5(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray7(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start3, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start3) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start3;
            start3 += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start3) {
          return setToString(overRest(func, start3, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject5(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject5(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data3) {
          metaMap.set(func, data3);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start3, end) {
          var index = -1, length = array.length;
          if (start3 < 0) {
            start3 = -start3 > length ? 0 : length + start3;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start3 > end ? 0 : end - start3 >>> 0;
          start3 >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start3];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol3(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol3(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol3(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol3(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray7(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol3(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set5 = iteratee2 ? null : createSet(array);
            if (set5) {
              return setToArray(set5);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray7(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start3, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start3 && end >= length ? array : baseSlice(array, start3, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer2) {
          var result2 = new arrayBuffer2.constructor(arrayBuffer2.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer2));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol3(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol3(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray7(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject5(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data3 = funcName == "wrapper" ? getData(func) : undefined2;
              if (data3 && isLaziable(data3[0]) && data3[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data3[4].length && data3[9] == 1) {
                wrapper = wrapper[getFuncName(data3[0])].apply(wrapper, data3[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray7(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start3, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start3, end, step)) {
              end = step = undefined2;
            }
            start3 = toFinite(start3);
            if (end === undefined2) {
              end = start3;
              start3 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start3 < end ? 1 : -1 : toFinite(step);
            return baseRange(start3, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop7 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data3 = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data3) {
            mergeData(newData, data3);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data3 ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty4.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject5(objValue) && isObject5(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty4.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop7 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty4.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data3 = array[length], otherFunc = data3.func;
            if (otherFunc == null || otherFunc == func) {
              return data3.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty4.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data3 = map3.__data__;
          return isKeyable(key) ? data3[typeof key == "string" ? "string" : "hash"] : data3.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue2(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start3, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data3 = transforms[index], size4 = data3.size;
            switch (data3.type) {
              case "drop":
                start3 += size4;
                break;
              case "dropRight":
                end -= size4;
                break;
              case "take":
                end = nativeMin(end, start3 + size4);
                break;
              case "takeRight":
                start3 = nativeMax(start3, end - size4);
                break;
            }
          }
          return { "start": start3, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray7(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty4.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray7(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject5(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray7(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol3(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data3 = getData(other);
          return !!data3 && func === data3[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject5(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache4.size === MAX_MEMOIZE_SIZE) {
              cache4.clear();
            }
            return key;
          });
          var cache4 = result2.cache;
          return result2;
        }
        function mergeData(data3, source) {
          var bitmask = data3[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data3[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data3;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data3[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data3[3];
            data3[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data3[4] = partials ? replaceHolders(data3[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data3[5];
            data3[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data3[6] = partials ? replaceHolders(data3[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data3[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data3[8] = data3[8] == null ? source[8] : nativeMin(data3[8], source[8]);
          }
          if (data3[9] == null) {
            data3[9] = source[9];
          }
          data3[0] = source[0];
          data3[1] = newBitmask;
          return data3;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString3(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start3, transform3) {
          start3 = nativeMax(start3 === undefined2 ? func.length - 1 : start3, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start3, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start3 + index];
            }
            index = -1;
            var otherArgs = Array2(start3 + 1);
            while (++index < start3) {
              otherArgs[index] = args[index];
            }
            otherArgs[start3] = transform3(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size4) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size4 = size4 === undefined2 ? length : size4;
          while (++index < size4) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size4;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol3(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size4, guard) {
          if (guard ? isIterateeCall(array, size4, guard) : size4 === undefined2) {
            size4 = 1;
          } else {
            size4 = nativeMax(toInteger(size4), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size4 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size4));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size4);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray7(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start3, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start3 && typeof start3 != "number" && isIterateeCall(array, value, start3)) {
            start3 = 0;
            end = length;
          }
          return baseFill(array, value, start3, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start3, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start3, end)) {
            start3 = 0;
            end = length;
          } else {
            start3 = start3 == null ? 0 : toInteger(start3);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start3, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap2(value, interceptor3) {
          interceptor3(value);
          return value;
        }
        function thru(value, interceptor3) {
          return interceptor3(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start3 = length ? paths[0] : 0, value = this.__wrapped__, interceptor3 = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start3)) {
            return this.thru(interceptor3);
          }
          value = value.slice(start3, +start3 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor3],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone5 = wrapperClone(parent2);
            clone5.__index__ = 0;
            clone5.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone5;
            } else {
              result2 = clone5;
            }
            var previous = clone5;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray7(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray7(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach5(collection, iteratee2) {
          var func = isArray7(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray7(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray7(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray7(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray7(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray7(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray7(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray7(collection) ? arrayFilter : baseFilter;
          return func(collection, negate3(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray7(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray7(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray7(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size3(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString3(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some2(collection, predicate, guard) {
          var func = isArray7(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind4 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind4));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce3(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject5(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache4 = memoized.cache;
            if (cache4.has(key)) {
              return cache4.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache4.set(key, result2) || cache4;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate3(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once3(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray7(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start3) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start3 = start3 === undefined2 ? start3 : toInteger(start3);
          return baseRest(func, start3);
        }
        function spread(func, start3) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start3 = start3 == null ? 0 : nativeMax(toInteger(start3), 0);
          return baseRest(function(args) {
            var array = args[start3], otherArgs = castSlice(args, 0, start3);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle3(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject5(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce3(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray7(value) ? value : [value];
        }
        function clone4(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray7 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer3 = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray7(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty4.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject5(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject5(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap3 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty4.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString3(value) {
          return typeof value == "string" || !isArray7(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol3(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString3(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol3(value)) {
            return NAN;
          }
          if (isObject5(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject5(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty4.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create4(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty4.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has3(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert2 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty4.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate3(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set4(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray7(object), isArrLike = isArr || isBuffer3(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject5(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp3(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start3, end) {
          start3 = toFinite(start3);
          if (end === undefined2) {
            end = start3;
            start3 = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start3, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase4 = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize3(word) : word);
        });
        function capitalize3(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase4 = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty4.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty4.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start3 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start3, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start3 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start3).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject5(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind4(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches3(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject5(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject5(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop7() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray7(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol3(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix3) {
          var id = ++idCounter;
          return toString(prefix3) + id;
        }
        var add5 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply2 = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract2 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind4;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create4;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce3;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert2;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches3;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate3;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once3;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set4;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap2;
        lodash.throttle = throttle3;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add5;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase4;
        lodash.capitalize = capitalize3;
        lodash.ceil = ceil;
        lodash.clamp = clamp3;
        lodash.clone = clone4;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach5;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has3;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray7;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer3;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual2;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap3;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject5;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString3;
        lodash.isSymbol = isSymbol3;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase4;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply2;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop7;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round2;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size3;
        lodash.snakeCase = snakeCase;
        lodash.some = some2;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract2;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach5;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty4.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION7;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate3(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start3, end) {
          start3 = toInteger(start3);
          var result2 = this;
          if (result2.__filtered__ && (start3 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start3 < 0) {
            result2 = result2.takeRight(-start3);
          } else if (start3) {
            result2 = result2.drop(start3);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start3);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray7(value);
            var interceptor3 = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor3], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor3);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray7(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray7(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty4.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    "use strict";
    (function(window3, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log4 = window3.console && (window3.console.warn || window3.console.log);
          if (log4) {
            log4.call(window3.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend2 = deprecate(function extend3(dest, src, merge2) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend2(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler5) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler5, false);
        });
      }
      function removeEventListeners(target, types, handler5) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler5, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix3, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix3 = VENDOR_PREFIXES[i];
          prop = prefix3 ? prefix3 + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window3;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window3;
      var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START2 = 1;
      var INPUT_MOVE2 = 2;
      var INPUT_END2 = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input2.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput2;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput2;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round2(input.pointers[i].clientX),
            clientY: round2(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round2(x / pointersLength),
          y: round2(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start3, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start3[1], start3[0], PROPS_CLIENT_XY);
      }
      function getScale(start3, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start3[0], start3[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP2 = {
        mousedown: INPUT_START2,
        mousemove: INPUT_MOVE2,
        mouseup: INPUT_END2
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput2() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input2.apply(this, arguments);
      }
      inherit(MouseInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP2[ev.type];
          if (eventType & INPUT_START2 && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE2 && ev.which !== 1) {
            eventType = INPUT_END2;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END2) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START2,
        pointermove: INPUT_MOVE2,
        pointerup: INPUT_END2,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window3.MSPointerEvent && !window3.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput2() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input2.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store3 = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store3, ev.pointerId, "pointerId");
          if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store3.push(ev);
              storeIndex = store3.length - 1;
            }
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store3[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store3,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store3.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input2.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input2, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START2) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END2 | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input2.apply(this, arguments);
      }
      inherit(TouchInput, Input2, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START2) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input2.apply(this, arguments);
        var handler5 = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler5);
        this.mouse = new MouseInput2(this.manager, handler5);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input2, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START2) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window3.CSS && window3.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window3.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END2) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance2 = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance2 = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance2 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance2 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START2) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END2) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END2) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START2 && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END2) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager3(element, options);
      }
      Hammer.VERSION = "2.0.7";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager3(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager3.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler5) {
          if (events === undefined2) {
            return;
          }
          if (handler5 === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler5);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler5) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler5) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler5), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data3) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data3);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data3.type = event;
          data3.preventDefault = function() {
            data3.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data3);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add5) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add5) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add5) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data3) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data3;
        data3.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START2,
        INPUT_MOVE: INPUT_MOVE2,
        INPUT_END: INPUT_END2,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager: Manager3,
        Input: Input2,
        TouchAction,
        TouchInput,
        MouseInput: MouseInput2,
        PointerEventInput: PointerEventInput2,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend: extend2,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window3[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data3, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data3.length, outerNode = linkedList(data3, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data3, holeIndices, outerNode, dim);
      if (data3.length > 80 * dim) {
        minX = maxX = data3[0];
        minY = maxY = data3[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data3[i];
          y = data3[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data3, start3, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data3, start3, end, dim) > 0) {
        for (i = start3; i < end; i += dim)
          last = insertNode(i, data3[i], data3[i + 1], last);
      } else {
        for (i = end - dim; i >= start3; i -= dim)
          last = insertNode(i, data3[i], data3[i + 1], last);
      }
      if (last && equals2(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start3, end) {
      if (!start3)
        return start3;
      if (!end)
        end = start3;
      var p = start3, again;
      do {
        again = false;
        if (!p.steiner && (equals2(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop3 = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop3 = next.next;
          continue;
        }
        ear = next;
        if (ear === stop3) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start3, triangles, dim) {
      var p = start3;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals2(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start3 = b;
        }
        p = p.next;
      } while (p !== start3);
      return filterPoints(p);
    }
    function splitEarcut(start3, triangles, dim, minX, minY, invSize) {
      var a = start3;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start3);
    }
    function eliminateHoles(data3, holeIndices, outerNode, dim) {
      var queue3 = [], i, len, start3, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start3 = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data3.length;
        list = linkedList(data3, start3, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue3.push(getLeftmost(list));
      }
      queue3.sort(compareX);
      for (i = 0; i < queue3.length; i++) {
        outerNode = eliminateHole(queue3[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop3 = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan2 = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan2;
          }
        }
        p = p.next;
      } while (p !== stop3);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start3, minX, minY, invSize) {
      var p = start3;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start3);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start3) {
      var p = start3, leftmost = start3;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start3);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals2(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals2(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data3, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data3.length;
      var polygonArea = Math.abs(signedArea(data3, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start3 = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data3.length;
          polygonArea -= Math.abs(signedArea(data3, start3, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data3[a] - data3[c]) * (data3[b + 1] - data3[a + 1]) - (data3[a] - data3[b]) * (data3[c + 1] - data3[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data3, start3, end, dim) {
      var sum = 0;
      for (var i = start3, j = end - dim; i < end; i += dim) {
        sum += (data3[j] - data3[i]) * (data3[i + 1] + data3[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut3.flatten = function(data3) {
      var dim = data3[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data3.length; i++) {
        for (var j = 0; j < data3[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data3[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data3[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/tom-select/dist/js/tom-select.complete.js
var require_tom_select_complete = __commonJS({
  "node_modules/tom-select/dist/js/tom-select.complete.js"(exports, module) {
    "use strict";
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.TomSelect = factory());
    })(exports, function() {
      "use strict";
      function forEvents(events, callback) {
        events.split(/\s+/).forEach((event) => {
          callback(event);
        });
      }
      class MicroEvent {
        constructor() {
          this._events = void 0;
          this._events = {};
        }
        on(events, fct) {
          forEvents(events, (event) => {
            const event_array = this._events[event] || [];
            event_array.push(fct);
            this._events[event] = event_array;
          });
        }
        off(events, fct) {
          var n = arguments.length;
          if (n === 0) {
            this._events = {};
            return;
          }
          forEvents(events, (event) => {
            if (n === 1) {
              delete this._events[event];
              return;
            }
            const event_array = this._events[event];
            if (event_array === void 0)
              return;
            event_array.splice(event_array.indexOf(fct), 1);
            this._events[event] = event_array;
          });
        }
        trigger(events, ...args) {
          var self2 = this;
          forEvents(events, (event) => {
            const event_array = self2._events[event];
            if (event_array === void 0)
              return;
            event_array.forEach((fct) => {
              fct.apply(self2, args);
            });
          });
        }
      }
      function MicroPlugin(Interface) {
        Interface.plugins = {};
        return class extends Interface {
          constructor(...args) {
            super(...args);
            this.plugins = {
              names: [],
              settings: {},
              requested: {},
              loaded: {}
            };
          }
          /**
           * Registers a plugin.
           *
           * @param {function} fn
           */
          static define(name, fn) {
            Interface.plugins[name] = {
              "name": name,
              "fn": fn
            };
          }
          /**
           * Initializes the listed plugins (with options).
           * Acceptable formats:
           *
           * List (without options):
           *   ['a', 'b', 'c']
           *
           * List (with options):
           *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
           *
           * Hash (with options):
           *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
           *
           * @param {array|object} plugins
           */
          initializePlugins(plugins) {
            var key, name;
            const self2 = this;
            const queue3 = [];
            if (Array.isArray(plugins)) {
              plugins.forEach((plugin3) => {
                if (typeof plugin3 === "string") {
                  queue3.push(plugin3);
                } else {
                  self2.plugins.settings[plugin3.name] = plugin3.options;
                  queue3.push(plugin3.name);
                }
              });
            } else if (plugins) {
              for (key in plugins) {
                if (plugins.hasOwnProperty(key)) {
                  self2.plugins.settings[key] = plugins[key];
                  queue3.push(key);
                }
              }
            }
            while (name = queue3.shift()) {
              self2.require(name);
            }
          }
          loadPlugin(name) {
            var self2 = this;
            var plugins = self2.plugins;
            var plugin3 = Interface.plugins[name];
            if (!Interface.plugins.hasOwnProperty(name)) {
              throw new Error('Unable to find "' + name + '" plugin');
            }
            plugins.requested[name] = true;
            plugins.loaded[name] = plugin3.fn.apply(self2, [self2.plugins.settings[name] || {}]);
            plugins.names.push(name);
          }
          /**
           * Initializes a plugin.
           *
           */
          require(name) {
            var self2 = this;
            var plugins = self2.plugins;
            if (!self2.plugins.loaded.hasOwnProperty(name)) {
              if (plugins.requested[name]) {
                throw new Error('Plugin has circular dependency ("' + name + '")');
              }
              self2.loadPlugin(name);
            }
            return plugins.loaded[name];
          }
        };
      }
      const arrayToPattern = (chars) => {
        chars = chars.filter(Boolean);
        if (chars.length < 2) {
          return chars[0] || "";
        }
        return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
      };
      const sequencePattern = (array) => {
        if (!hasDuplicates(array)) {
          return array.join("");
        }
        let pattern = "";
        let prev_char_count = 0;
        const prev_pattern = () => {
          if (prev_char_count > 1) {
            pattern += "{" + prev_char_count + "}";
          }
        };
        array.forEach((char, i) => {
          if (char === array[i - 1]) {
            prev_char_count++;
            return;
          }
          prev_pattern();
          pattern += char;
          prev_char_count = 1;
        });
        prev_pattern();
        return pattern;
      };
      const setToPattern = (chars) => {
        let array = toArray(chars);
        return arrayToPattern(array);
      };
      const hasDuplicates = (array) => {
        return new Set(array).size !== array.length;
      };
      const escape_regex = (str) => {
        return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
      };
      const maxValueLength = (array) => {
        return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
      };
      const unicodeLength = (str) => {
        return toArray(str).length;
      };
      const toArray = (p) => Array.from(p);
      const allSubstrings = (input) => {
        if (input.length === 1)
          return [[input]];
        let result = [];
        const start3 = input.substring(1);
        const suba = allSubstrings(start3);
        suba.forEach(function(subresult) {
          let tmp = subresult.slice(0);
          tmp[0] = input.charAt(0) + tmp[0];
          result.push(tmp);
          tmp = subresult.slice(0);
          tmp.unshift(input.charAt(0));
          result.push(tmp);
        });
        return result;
      };
      const code_points = [[0, 65535]];
      const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
      let unicode_map;
      let multi_char_reg;
      const max_char_length = 3;
      const latin_convert = {};
      const latin_condensed = {
        "/": "\u2044\u2215",
        "0": "\u07C0",
        "a": "\u2C65\u0250\u0251",
        "aa": "\uA733",
        "ae": "\xE6\u01FD\u01E3",
        "ao": "\uA735",
        "au": "\uA737",
        "av": "\uA739\uA73B",
        "ay": "\uA73D",
        "b": "\u0180\u0253\u0183",
        "c": "\uA73F\u0188\u023C\u2184",
        "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
        "e": "\u025B\u01DD\u1D07\u0247",
        "f": "\uA77C\u0192",
        "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
        "h": "\u0127\u2C68\u2C76\u0265",
        "i": "\u0268\u0131",
        "j": "\u0249\u0237",
        "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
        "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
        "m": "\u0271\u026F\u03FB",
        "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
        "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
        "oe": "\u0153",
        "oi": "\u01A3",
        "oo": "\uA74F",
        "ou": "\u0223",
        "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
        "q": "\uA757\uA759\u024B",
        "r": "\u024D\u027D\uA75B\uA7A7\uA783",
        "s": "\xDF\u023F\uA7A9\uA785\u0282",
        "t": "\u0167\u01AD\u0288\u2C66\uA787",
        "th": "\xFE",
        "tz": "\uA729",
        "u": "\u0289",
        "v": "\u028B\uA75F\u028C",
        "vy": "\uA761",
        "w": "\u2C73",
        "y": "\u01B4\u024F\u1EFF",
        "z": "\u01B6\u0225\u0240\u2C6C\uA763",
        "hv": "\u0195"
      };
      for (let latin in latin_condensed) {
        let unicode = latin_condensed[latin] || "";
        for (let i = 0; i < unicode.length; i++) {
          let char = unicode.substring(i, i + 1);
          latin_convert[char] = latin;
        }
      }
      const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
      const initialize = (_code_points) => {
        if (unicode_map !== void 0)
          return;
        unicode_map = generateMap(_code_points || code_points);
      };
      const normalize2 = (str, form = "NFKD") => str.normalize(form);
      const asciifold = (str) => {
        return toArray(str).reduce(
          /**
           * @param {string} result
           * @param {string} char
           */
          (result, char) => {
            return result + _asciifold(char);
          },
          ""
        );
      };
      const _asciifold = (str) => {
        str = normalize2(str).toLowerCase().replace(convert_pat, (char) => {
          return latin_convert[char] || "";
        });
        return normalize2(str, "NFC");
      };
      function* generator(code_points2) {
        for (const [code_point_min, code_point_max] of code_points2) {
          for (let i = code_point_min; i <= code_point_max; i++) {
            let composed = String.fromCharCode(i);
            let folded = asciifold(composed);
            if (folded == composed.toLowerCase()) {
              continue;
            }
            if (folded.length > max_char_length) {
              continue;
            }
            if (folded.length == 0) {
              continue;
            }
            yield {
              folded,
              composed,
              code_point: i
            };
          }
        }
      }
      const generateSets = (code_points2) => {
        const unicode_sets = {};
        const addMatching = (folded, to_add) => {
          const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
          const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
          if (to_add.match(patt)) {
            return;
          }
          folded_set.add(escape_regex(to_add));
          unicode_sets[folded] = folded_set;
        };
        for (let value of generator(code_points2)) {
          addMatching(value.folded, value.folded);
          addMatching(value.folded, value.composed);
        }
        return unicode_sets;
      };
      const generateMap = (code_points2) => {
        const unicode_sets = generateSets(code_points2);
        const unicode_map2 = {};
        let multi_char = [];
        for (let folded in unicode_sets) {
          let set4 = unicode_sets[folded];
          if (set4) {
            unicode_map2[folded] = setToPattern(set4);
          }
          if (folded.length > 1) {
            multi_char.push(escape_regex(folded));
          }
        }
        multi_char.sort((a, b) => b.length - a.length);
        const multi_char_patt = arrayToPattern(multi_char);
        multi_char_reg = new RegExp("^" + multi_char_patt, "u");
        return unicode_map2;
      };
      const mapSequence = (strings, min_replacement = 1) => {
        let chars_replaced = 0;
        strings = strings.map((str) => {
          if (unicode_map[str]) {
            chars_replaced += str.length;
          }
          return unicode_map[str] || str;
        });
        if (chars_replaced >= min_replacement) {
          return sequencePattern(strings);
        }
        return "";
      };
      const substringsToPattern = (str, min_replacement = 1) => {
        min_replacement = Math.max(min_replacement, str.length - 1);
        return arrayToPattern(allSubstrings(str).map((sub_pat) => {
          return mapSequence(sub_pat, min_replacement);
        }));
      };
      const sequencesToPattern = (sequences, all = true) => {
        let min_replacement = sequences.length > 1 ? 1 : 0;
        return arrayToPattern(sequences.map((sequence) => {
          let seq = [];
          const len = all ? sequence.length() : sequence.length() - 1;
          for (let j = 0; j < len; j++) {
            seq.push(substringsToPattern(sequence.substrs[j] || "", min_replacement));
          }
          return sequencePattern(seq);
        }));
      };
      const inSequences = (needle_seq, sequences) => {
        for (const seq of sequences) {
          if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
            continue;
          }
          if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
            continue;
          }
          let needle_parts = needle_seq.parts;
          const filter = (part) => {
            for (const needle_part of needle_parts) {
              if (needle_part.start === part.start && needle_part.substr === part.substr) {
                return false;
              }
              if (part.length == 1 || needle_part.length == 1) {
                continue;
              }
              if (part.start < needle_part.start && part.end > needle_part.start) {
                return true;
              }
              if (needle_part.start < part.start && needle_part.end > part.start) {
                return true;
              }
            }
            return false;
          };
          let filtered = seq.parts.filter(filter);
          if (filtered.length > 0) {
            continue;
          }
          return true;
        }
        return false;
      };
      class Sequence {
        constructor() {
          this.parts = [];
          this.substrs = [];
          this.start = 0;
          this.end = 0;
        }
        /**
         * @param {TSequencePart|undefined} part
         */
        add(part) {
          if (part) {
            this.parts.push(part);
            this.substrs.push(part.substr);
            this.start = Math.min(part.start, this.start);
            this.end = Math.max(part.end, this.end);
          }
        }
        last() {
          return this.parts[this.parts.length - 1];
        }
        length() {
          return this.parts.length;
        }
        /**
         * @param {number} position
         * @param {TSequencePart} last_piece
         */
        clone(position, last_piece) {
          let clone4 = new Sequence();
          let parts = JSON.parse(JSON.stringify(this.parts));
          let last_part = parts.pop();
          for (const part of parts) {
            clone4.add(part);
          }
          let last_substr = last_piece.substr.substring(0, position - last_part.start);
          let clone_last_len = last_substr.length;
          clone4.add({
            start: last_part.start,
            end: last_part.start + clone_last_len,
            length: clone_last_len,
            substr: last_substr
          });
          return clone4;
        }
      }
      const getPattern = (str) => {
        initialize();
        str = asciifold(str);
        let pattern = "";
        let sequences = [new Sequence()];
        for (let i = 0; i < str.length; i++) {
          let substr = str.substring(i);
          let match = substr.match(multi_char_reg);
          const char = str.substring(i, i + 1);
          const match_str = match ? match[0] : null;
          let overlapping = [];
          let added_types = /* @__PURE__ */ new Set();
          for (const sequence of sequences) {
            const last_piece = sequence.last();
            if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
              if (match_str) {
                const len = match_str.length;
                sequence.add({
                  start: i,
                  end: i + len,
                  length: len,
                  substr: match_str
                });
                added_types.add("1");
              } else {
                sequence.add({
                  start: i,
                  end: i + 1,
                  length: 1,
                  substr: char
                });
                added_types.add("2");
              }
            } else if (match_str) {
              let clone4 = sequence.clone(i, last_piece);
              const len = match_str.length;
              clone4.add({
                start: i,
                end: i + len,
                length: len,
                substr: match_str
              });
              overlapping.push(clone4);
            } else {
              added_types.add("3");
            }
          }
          if (overlapping.length > 0) {
            overlapping = overlapping.sort((a, b) => {
              return a.length() - b.length();
            });
            for (let clone4 of overlapping) {
              if (inSequences(clone4, sequences)) {
                continue;
              }
              sequences.push(clone4);
            }
            continue;
          }
          if (i > 0 && added_types.size == 1 && !added_types.has("3")) {
            pattern += sequencesToPattern(sequences, false);
            let new_seq = new Sequence();
            const old_seq = sequences[0];
            if (old_seq) {
              new_seq.add(old_seq.last());
            }
            sequences = [new_seq];
          }
        }
        pattern += sequencesToPattern(sequences, true);
        return pattern;
      };
      const getAttr = (obj, name) => {
        if (!obj)
          return;
        return obj[name];
      };
      const getAttrNesting = (obj, name) => {
        if (!obj)
          return;
        var part, names = name.split(".");
        while ((part = names.shift()) && (obj = obj[part]))
          ;
        return obj;
      };
      const scoreValue = (value, token, weight) => {
        var score, pos;
        if (!value)
          return 0;
        value = value + "";
        if (token.regex == null)
          return 0;
        pos = value.search(token.regex);
        if (pos === -1)
          return 0;
        score = token.string.length / value.length;
        if (pos === 0)
          score += 0.5;
        return score * weight;
      };
      const propToArray = (obj, key) => {
        var value = obj[key];
        if (typeof value == "function")
          return value;
        if (value && !Array.isArray(value)) {
          obj[key] = [value];
        }
      };
      const iterate$1 = (object, callback) => {
        if (Array.isArray(object)) {
          object.forEach(callback);
        } else {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              callback(object[key], key);
            }
          }
        }
      };
      const cmp = (a, b) => {
        if (typeof a === "number" && typeof b === "number") {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        a = asciifold(a + "").toLowerCase();
        b = asciifold(b + "").toLowerCase();
        if (a > b)
          return 1;
        if (b > a)
          return -1;
        return 0;
      };
      class Sifter {
        // []|{};
        /**
         * Textually searches arrays and hashes of objects
         * by property (or multiple properties). Designed
         * specifically for autocomplete.
         *
         */
        constructor(items, settings) {
          this.items = void 0;
          this.settings = void 0;
          this.items = items;
          this.settings = settings || {
            diacritics: true
          };
        }
        /**
         * Splits a search string into an array of individual
         * regexps to be used to match results.
         *
         */
        tokenize(query, respect_word_boundaries, weights) {
          if (!query || !query.length)
            return [];
          const tokens = [];
          const words = query.split(/\s+/);
          var field_regex;
          if (weights) {
            field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
          }
          words.forEach((word) => {
            let field_match;
            let field = null;
            let regex = null;
            if (field_regex && (field_match = word.match(field_regex))) {
              field = field_match[1];
              word = field_match[2];
            }
            if (word.length > 0) {
              if (this.settings.diacritics) {
                regex = getPattern(word) || null;
              } else {
                regex = escape_regex(word);
              }
              if (regex && respect_word_boundaries)
                regex = "\\b" + regex;
            }
            tokens.push({
              string: word,
              regex: regex ? new RegExp(regex, "iu") : null,
              field
            });
          });
          return tokens;
        }
        /**
         * Returns a function to be used to score individual results.
         *
         * Good matches will have a higher score than poor matches.
         * If an item is not a match, 0 will be returned by the function.
         *
         * @returns {T.ScoreFn}
         */
        getScoreFunction(query, options) {
          var search = this.prepareSearch(query, options);
          return this._getScoreFunction(search);
        }
        /**
         * @returns {T.ScoreFn}
         *
         */
        _getScoreFunction(search) {
          const tokens = search.tokens, token_count = tokens.length;
          if (!token_count) {
            return function() {
              return 0;
            };
          }
          const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
          if (!field_count) {
            return function() {
              return 1;
            };
          }
          const scoreObject = function() {
            if (field_count === 1) {
              return function(token, data3) {
                const field = fields[0].field;
                return scoreValue(getAttrFn(data3, field), token, weights[field] || 1);
              };
            }
            return function(token, data3) {
              var sum = 0;
              if (token.field) {
                const value = getAttrFn(data3, token.field);
                if (!token.regex && value) {
                  sum += 1 / field_count;
                } else {
                  sum += scoreValue(value, token, 1);
                }
              } else {
                iterate$1(weights, (weight, field) => {
                  sum += scoreValue(getAttrFn(data3, field), token, weight);
                });
              }
              return sum / field_count;
            };
          }();
          if (token_count === 1) {
            return function(data3) {
              return scoreObject(tokens[0], data3);
            };
          }
          if (search.options.conjunction === "and") {
            return function(data3) {
              var score, sum = 0;
              for (let token of tokens) {
                score = scoreObject(token, data3);
                if (score <= 0)
                  return 0;
                sum += score;
              }
              return sum / token_count;
            };
          } else {
            return function(data3) {
              var sum = 0;
              iterate$1(tokens, (token) => {
                sum += scoreObject(token, data3);
              });
              return sum / token_count;
            };
          }
        }
        /**
         * Returns a function that can be used to compare two
         * results, for sorting purposes. If no sorting should
         * be performed, `null` will be returned.
         *
         * @return function(a,b)
         */
        getSortFunction(query, options) {
          var search = this.prepareSearch(query, options);
          return this._getSortFunction(search);
        }
        _getSortFunction(search) {
          var implicit_score, sort_flds = [];
          const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
          if (typeof sort == "function") {
            return sort.bind(this);
          }
          const get_field = function get_field2(name, result) {
            if (name === "$score")
              return result.score;
            return search.getAttrFn(self2.items[result.id], name);
          };
          if (sort) {
            for (let s of sort) {
              if (search.query || s.field !== "$score") {
                sort_flds.push(s);
              }
            }
          }
          if (search.query) {
            implicit_score = true;
            for (let fld of sort_flds) {
              if (fld.field === "$score") {
                implicit_score = false;
                break;
              }
            }
            if (implicit_score) {
              sort_flds.unshift({
                field: "$score",
                direction: "desc"
              });
            }
          } else {
            sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
          }
          const sort_flds_count = sort_flds.length;
          if (!sort_flds_count) {
            return null;
          }
          return function(a, b) {
            var result, field;
            for (let sort_fld of sort_flds) {
              field = sort_fld.field;
              let multiplier = sort_fld.direction === "desc" ? -1 : 1;
              result = multiplier * cmp(get_field(field, a), get_field(field, b));
              if (result)
                return result;
            }
            return 0;
          };
        }
        /**
         * Parses a search query and returns an object
         * with tokens and fields ready to be populated
         * with results.
         *
         */
        prepareSearch(query, optsUser) {
          const weights = {};
          var options = Object.assign({}, optsUser);
          propToArray(options, "sort");
          propToArray(options, "sort_empty");
          if (options.fields) {
            propToArray(options, "fields");
            const fields = [];
            options.fields.forEach((field) => {
              if (typeof field == "string") {
                field = {
                  field,
                  weight: 1
                };
              }
              fields.push(field);
              weights[field.field] = "weight" in field ? field.weight : 1;
            });
            options.fields = fields;
          }
          return {
            options,
            query: query.toLowerCase().trim(),
            tokens: this.tokenize(query, options.respect_word_boundaries, weights),
            total: 0,
            items: [],
            weights,
            getAttrFn: options.nesting ? getAttrNesting : getAttr
          };
        }
        /**
         * Searches through all items and returns a sorted array of matches.
         *
         */
        search(query, options) {
          var self2 = this, score, search;
          search = this.prepareSearch(query, options);
          options = search.options;
          query = search.query;
          const fn_score = options.score || self2._getScoreFunction(search);
          if (query.length) {
            iterate$1(self2.items, (item, id) => {
              score = fn_score(item);
              if (options.filter === false || score > 0) {
                search.items.push({
                  "score": score,
                  "id": id
                });
              }
            });
          } else {
            iterate$1(self2.items, (_, id) => {
              search.items.push({
                "score": 1,
                "id": id
              });
            });
          }
          const fn_sort = self2._getSortFunction(search);
          if (fn_sort)
            search.items.sort(fn_sort);
          search.total = search.items.length;
          if (typeof options.limit === "number") {
            search.items = search.items.slice(0, options.limit);
          }
          return search;
        }
      }
      const iterate = (object, callback) => {
        if (Array.isArray(object)) {
          object.forEach(callback);
        } else {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              callback(object[key], key);
            }
          }
        }
      };
      const getDom = (query) => {
        if (query.jquery) {
          return query[0];
        }
        if (query instanceof HTMLElement) {
          return query;
        }
        if (isHtmlString(query)) {
          var tpl = document.createElement("template");
          tpl.innerHTML = query.trim();
          return tpl.content.firstChild;
        }
        return document.querySelector(query);
      };
      const isHtmlString = (arg) => {
        if (typeof arg === "string" && arg.indexOf("<") > -1) {
          return true;
        }
        return false;
      };
      const escapeQuery = (query) => {
        return query.replace(/['"\\]/g, "\\$&");
      };
      const triggerEvent = (dom_el, event_name) => {
        var event = document.createEvent("HTMLEvents");
        event.initEvent(event_name, true, false);
        dom_el.dispatchEvent(event);
      };
      const applyCSS = (dom_el, css) => {
        Object.assign(dom_el.style, css);
      };
      const addClasses = (elmts, ...classes) => {
        var norm_classes = classesArray(classes);
        elmts = castAsArray(elmts);
        elmts.map((el) => {
          norm_classes.map((cls) => {
            el.classList.add(cls);
          });
        });
      };
      const removeClasses = (elmts, ...classes) => {
        var norm_classes = classesArray(classes);
        elmts = castAsArray(elmts);
        elmts.map((el) => {
          norm_classes.map((cls) => {
            el.classList.remove(cls);
          });
        });
      };
      const classesArray = (args) => {
        var classes = [];
        iterate(args, (_classes) => {
          if (typeof _classes === "string") {
            _classes = _classes.trim().split(/[\11\12\14\15\40]/);
          }
          if (Array.isArray(_classes)) {
            classes = classes.concat(_classes);
          }
        });
        return classes.filter(Boolean);
      };
      const castAsArray = (arg) => {
        if (!Array.isArray(arg)) {
          arg = [arg];
        }
        return arg;
      };
      const parentMatch = (target, selector, wrapper) => {
        if (wrapper && !wrapper.contains(target)) {
          return;
        }
        while (target && target.matches) {
          if (target.matches(selector)) {
            return target;
          }
          target = target.parentNode;
        }
      };
      const getTail = (list, direction = 0) => {
        if (direction > 0) {
          return list[list.length - 1];
        }
        return list[0];
      };
      const isEmptyObject2 = (obj) => {
        return Object.keys(obj).length === 0;
      };
      const nodeIndex = (el, amongst) => {
        if (!el)
          return -1;
        amongst = amongst || el.nodeName;
        var i = 0;
        while (el = el.previousElementSibling) {
          if (el.matches(amongst)) {
            i++;
          }
        }
        return i;
      };
      const setAttr = (el, attrs) => {
        iterate(attrs, (val, attr) => {
          if (val == null) {
            el.removeAttribute(attr);
          } else {
            el.setAttribute(attr, "" + val);
          }
        });
      };
      const replaceNode = (existing, replacement) => {
        if (existing.parentNode)
          existing.parentNode.replaceChild(replacement, existing);
      };
      const highlight = (element, regex) => {
        if (regex === null)
          return;
        if (typeof regex === "string") {
          if (!regex.length)
            return;
          regex = new RegExp(regex, "i");
        }
        const highlightText = (node) => {
          var match = node.data.match(regex);
          if (match && node.data.length > 0) {
            var spannode = document.createElement("span");
            spannode.className = "highlight";
            var middlebit = node.splitText(match.index);
            middlebit.splitText(match[0].length);
            var middleclone = middlebit.cloneNode(true);
            spannode.appendChild(middleclone);
            replaceNode(middlebit, spannode);
            return 1;
          }
          return 0;
        };
        const highlightChildren = (node) => {
          if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
            Array.from(node.childNodes).forEach((element2) => {
              highlightRecursive(element2);
            });
          }
        };
        const highlightRecursive = (node) => {
          if (node.nodeType === 3) {
            return highlightText(node);
          }
          highlightChildren(node);
          return 0;
        };
        highlightRecursive(element);
      };
      const removeHighlight = (el) => {
        var elements = el.querySelectorAll("span.highlight");
        Array.prototype.forEach.call(elements, function(el2) {
          var parent = el2.parentNode;
          parent.replaceChild(el2.firstChild, el2);
          parent.normalize();
        });
      };
      const KEY_A = 65;
      const KEY_RETURN = 13;
      const KEY_ESC = 27;
      const KEY_LEFT = 37;
      const KEY_UP = 38;
      const KEY_RIGHT = 39;
      const KEY_DOWN = 40;
      const KEY_BACKSPACE = 8;
      const KEY_DELETE = 46;
      const KEY_TAB = 9;
      const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
      const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
      var defaults = {
        options: [],
        optgroups: [],
        plugins: [],
        delimiter: ",",
        splitOn: null,
        // regexp or string for splitting up values from a paste command
        persist: true,
        diacritics: true,
        create: null,
        createOnBlur: false,
        createFilter: null,
        highlight: true,
        openOnFocus: true,
        shouldOpen: null,
        maxOptions: 50,
        maxItems: null,
        hideSelected: null,
        duplicates: false,
        addPrecedence: false,
        selectOnTab: false,
        preload: null,
        allowEmptyOption: false,
        //closeAfterSelect: false,
        loadThrottle: 300,
        loadingClass: "loading",
        dataAttr: null,
        //'data-data',
        optgroupField: "optgroup",
        valueField: "value",
        labelField: "text",
        disabledField: "disabled",
        optgroupLabelField: "label",
        optgroupValueField: "value",
        lockOptgroupOrder: false,
        sortField: "$order",
        searchField: ["text"],
        searchConjunction: "and",
        mode: null,
        wrapperClass: "ts-wrapper",
        controlClass: "ts-control",
        dropdownClass: "ts-dropdown",
        dropdownContentClass: "ts-dropdown-content",
        itemClass: "item",
        optionClass: "option",
        dropdownParent: null,
        controlInput: '<input type="text" autocomplete="off" size="1" />',
        copyClassesToDropdown: false,
        placeholder: null,
        hidePlaceholder: null,
        shouldLoad: function(query) {
          return query.length > 0;
        },
        /*
        load                 : null, // function(query, callback) { ... }
        score                : null, // function(search) { ... }
        onInitialize         : null, // function() { ... }
        onChange             : null, // function(value) { ... }
        onItemAdd            : null, // function(value, $item) { ... }
        onItemRemove         : null, // function(value) { ... }
        onClear              : null, // function() { ... }
        onOptionAdd          : null, // function(value, data) { ... }
        onOptionRemove       : null, // function(value) { ... }
        onOptionClear        : null, // function() { ... }
        onOptionGroupAdd     : null, // function(id, data) { ... }
        onOptionGroupRemove  : null, // function(id) { ... }
        onOptionGroupClear   : null, // function() { ... }
        onDropdownOpen       : null, // function(dropdown) { ... }
        onDropdownClose      : null, // function(dropdown) { ... }
        onType               : null, // function(str) { ... }
        onDelete             : null, // function(values) { ... }
        */
        render: {
          /*
          item: null,
          optgroup: null,
          optgroup_header: null,
          option: null,
          option_create: null
          */
        }
      };
      const hash_key = (value) => {
        if (typeof value === "undefined" || value === null)
          return null;
        return get_hash(value);
      };
      const get_hash = (value) => {
        if (typeof value === "boolean")
          return value ? "1" : "0";
        return value + "";
      };
      const escape_html = (str) => {
        return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
      };
      const loadDebounce = (fn, delay) => {
        var timeout;
        return function(value, callback) {
          var self2 = this;
          if (timeout) {
            self2.loading = Math.max(self2.loading - 1, 0);
            clearTimeout(timeout);
          }
          timeout = setTimeout(function() {
            timeout = null;
            self2.loadedSearches[value] = true;
            fn.call(self2, value, callback);
          }, delay);
        };
      };
      const debounce_events = (self2, types, fn) => {
        var type;
        var trigger3 = self2.trigger;
        var event_args = {};
        self2.trigger = function() {
          var type2 = arguments[0];
          if (types.indexOf(type2) !== -1) {
            event_args[type2] = arguments;
          } else {
            return trigger3.apply(self2, arguments);
          }
        };
        fn.apply(self2, []);
        self2.trigger = trigger3;
        for (type of types) {
          if (type in event_args) {
            trigger3.apply(self2, event_args[type]);
          }
        }
      };
      const getSelection = (input) => {
        return {
          start: input.selectionStart || 0,
          length: (input.selectionEnd || 0) - (input.selectionStart || 0)
        };
      };
      const preventDefault = (evt, stop3 = false) => {
        if (evt) {
          evt.preventDefault();
          if (stop3) {
            evt.stopPropagation();
          }
        }
      };
      const addEvent = (target, type, callback, options) => {
        target.addEventListener(type, callback, options);
      };
      const isKeyDown = (key_name, evt) => {
        if (!evt) {
          return false;
        }
        if (!evt[key_name]) {
          return false;
        }
        var count2 = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
        if (count2 === 1) {
          return true;
        }
        return false;
      };
      const getId = (el, id) => {
        const existing_id = el.getAttribute("id");
        if (existing_id) {
          return existing_id;
        }
        el.setAttribute("id", id);
        return id;
      };
      const addSlashes = (str) => {
        return str.replace(/[\\"']/g, "\\$&");
      };
      const append = (parent, node) => {
        if (node)
          parent.append(node);
      };
      function getSettings(input, settings_user) {
        var settings = Object.assign({}, defaults, settings_user);
        var attr_data = settings.dataAttr;
        var field_label = settings.labelField;
        var field_value = settings.valueField;
        var field_disabled = settings.disabledField;
        var field_optgroup = settings.optgroupField;
        var field_optgroup_label = settings.optgroupLabelField;
        var field_optgroup_value = settings.optgroupValueField;
        var tag_name = input.tagName.toLowerCase();
        var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
        if (!placeholder && !settings.allowEmptyOption) {
          let option = input.querySelector('option[value=""]');
          if (option) {
            placeholder = option.textContent;
          }
        }
        var settings_element = {
          placeholder,
          options: [],
          optgroups: [],
          items: [],
          maxItems: null
        };
        var init_select = () => {
          var tagName;
          var options = settings_element.options;
          var optionsMap = {};
          var group_count = 1;
          var readData = (el) => {
            var data3 = Object.assign({}, el.dataset);
            var json = attr_data && data3[attr_data];
            if (typeof json === "string" && json.length) {
              data3 = Object.assign(data3, JSON.parse(json));
            }
            return data3;
          };
          var addOption = (option, group) => {
            var value = hash_key(option.value);
            if (value == null)
              return;
            if (!value && !settings.allowEmptyOption)
              return;
            if (optionsMap.hasOwnProperty(value)) {
              if (group) {
                var arr = optionsMap[value][field_optgroup];
                if (!arr) {
                  optionsMap[value][field_optgroup] = group;
                } else if (!Array.isArray(arr)) {
                  optionsMap[value][field_optgroup] = [arr, group];
                } else {
                  arr.push(group);
                }
              }
            } else {
              var option_data = readData(option);
              option_data[field_label] = option_data[field_label] || option.textContent;
              option_data[field_value] = option_data[field_value] || value;
              option_data[field_disabled] = option_data[field_disabled] || option.disabled;
              option_data[field_optgroup] = option_data[field_optgroup] || group;
              option_data.$option = option;
              optionsMap[value] = option_data;
              options.push(option_data);
            }
            if (option.selected) {
              settings_element.items.push(value);
            }
          };
          var addGroup = (optgroup) => {
            var id, optgroup_data;
            optgroup_data = readData(optgroup);
            optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
            optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
            optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
            settings_element.optgroups.push(optgroup_data);
            id = optgroup_data[field_optgroup_value];
            iterate(optgroup.children, (option) => {
              addOption(option, id);
            });
          };
          settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
          iterate(input.children, (child) => {
            tagName = child.tagName.toLowerCase();
            if (tagName === "optgroup") {
              addGroup(child);
            } else if (tagName === "option") {
              addOption(child);
            }
          });
        };
        var init_textbox = () => {
          const data_raw = input.getAttribute(attr_data);
          if (!data_raw) {
            var value = input.value.trim() || "";
            if (!settings.allowEmptyOption && !value.length)
              return;
            const values = value.split(settings.delimiter);
            iterate(values, (value2) => {
              const option = {};
              option[field_label] = value2;
              option[field_value] = value2;
              settings_element.options.push(option);
            });
            settings_element.items = values;
          } else {
            settings_element.options = JSON.parse(data_raw);
            iterate(settings_element.options, (opt) => {
              settings_element.items.push(opt[field_value]);
            });
          }
        };
        if (tag_name === "select") {
          init_select();
        } else {
          init_textbox();
        }
        return Object.assign({}, defaults, settings_element, settings_user);
      }
      var instance_i = 0;
      class TomSelect3 extends MicroPlugin(MicroEvent) {
        // @deprecated 1.8
        constructor(input_arg, user_settings) {
          super();
          this.control_input = void 0;
          this.wrapper = void 0;
          this.dropdown = void 0;
          this.control = void 0;
          this.dropdown_content = void 0;
          this.focus_node = void 0;
          this.order = 0;
          this.settings = void 0;
          this.input = void 0;
          this.tabIndex = void 0;
          this.is_select_tag = void 0;
          this.rtl = void 0;
          this.inputId = void 0;
          this._destroy = void 0;
          this.sifter = void 0;
          this.isOpen = false;
          this.isDisabled = false;
          this.isRequired = void 0;
          this.isInvalid = false;
          this.isValid = true;
          this.isLocked = false;
          this.isFocused = false;
          this.isInputHidden = false;
          this.isSetup = false;
          this.ignoreFocus = false;
          this.ignoreHover = false;
          this.hasOptions = false;
          this.currentResults = void 0;
          this.lastValue = "";
          this.caretPos = 0;
          this.loading = 0;
          this.loadedSearches = {};
          this.activeOption = null;
          this.activeItems = [];
          this.optgroups = {};
          this.options = {};
          this.userOptions = {};
          this.items = [];
          instance_i++;
          var dir;
          var input = getDom(input_arg);
          if (input.tomselect) {
            throw new Error("Tom Select already initialized on this element");
          }
          input.tomselect = this;
          var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
          dir = computedStyle.getPropertyValue("direction");
          const settings = getSettings(input, user_settings);
          this.settings = settings;
          this.input = input;
          this.tabIndex = input.tabIndex || 0;
          this.is_select_tag = input.tagName.toLowerCase() === "select";
          this.rtl = /rtl/i.test(dir);
          this.inputId = getId(input, "tomselect-" + instance_i);
          this.isRequired = input.required;
          this.sifter = new Sifter(this.options, {
            diacritics: settings.diacritics
          });
          settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
          if (typeof settings.hideSelected !== "boolean") {
            settings.hideSelected = settings.mode === "multi";
          }
          if (typeof settings.hidePlaceholder !== "boolean") {
            settings.hidePlaceholder = settings.mode !== "multi";
          }
          var filter = settings.createFilter;
          if (typeof filter !== "function") {
            if (typeof filter === "string") {
              filter = new RegExp(filter);
            }
            if (filter instanceof RegExp) {
              settings.createFilter = (input2) => filter.test(input2);
            } else {
              settings.createFilter = (value) => {
                return this.settings.duplicates || !this.options[value];
              };
            }
          }
          this.initializePlugins(settings.plugins);
          this.setupCallbacks();
          this.setupTemplates();
          const wrapper = getDom("<div>");
          const control = getDom("<div>");
          const dropdown = this._render("dropdown");
          const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
          const classes = this.input.getAttribute("class") || "";
          const inputMode = settings.mode;
          var control_input;
          addClasses(wrapper, settings.wrapperClass, classes, inputMode);
          addClasses(control, settings.controlClass);
          append(wrapper, control);
          addClasses(dropdown, settings.dropdownClass, inputMode);
          if (settings.copyClassesToDropdown) {
            addClasses(dropdown, classes);
          }
          addClasses(dropdown_content, settings.dropdownContentClass);
          append(dropdown, dropdown_content);
          getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
          if (isHtmlString(settings.controlInput)) {
            control_input = getDom(settings.controlInput);
            var attrs = ["autocorrect", "autocapitalize", "autocomplete"];
            iterate$1(attrs, (attr) => {
              if (input.getAttribute(attr)) {
                setAttr(control_input, {
                  [attr]: input.getAttribute(attr)
                });
              }
            });
            control_input.tabIndex = -1;
            control.appendChild(control_input);
            this.focus_node = control_input;
          } else if (settings.controlInput) {
            control_input = getDom(settings.controlInput);
            this.focus_node = control_input;
          } else {
            control_input = getDom("<input/>");
            this.focus_node = control;
          }
          this.wrapper = wrapper;
          this.dropdown = dropdown;
          this.dropdown_content = dropdown_content;
          this.control = control;
          this.control_input = control_input;
          this.setup();
        }
        /**
         * set up event bindings.
         *
         */
        setup() {
          const self2 = this;
          const settings = self2.settings;
          const control_input = self2.control_input;
          const dropdown = self2.dropdown;
          const dropdown_content = self2.dropdown_content;
          const wrapper = self2.wrapper;
          const control = self2.control;
          const input = self2.input;
          const focus_node = self2.focus_node;
          const passive_event = {
            passive: true
          };
          const listboxId = self2.inputId + "-ts-dropdown";
          setAttr(dropdown_content, {
            id: listboxId
          });
          setAttr(focus_node, {
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-expanded": "false",
            "aria-controls": listboxId
          });
          const control_id = getId(focus_node, self2.inputId + "-ts-control");
          const query = "label[for='" + escapeQuery(self2.inputId) + "']";
          const label = document.querySelector(query);
          const label_click = self2.focus.bind(self2);
          if (label) {
            addEvent(label, "click", label_click);
            setAttr(label, {
              for: control_id
            });
            const label_id = getId(label, self2.inputId + "-ts-label");
            setAttr(focus_node, {
              "aria-labelledby": label_id
            });
            setAttr(dropdown_content, {
              "aria-labelledby": label_id
            });
          }
          wrapper.style.width = input.style.width;
          if (self2.plugins.names.length) {
            const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
            addClasses([wrapper, dropdown], classes_plugins);
          }
          if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
            setAttr(input, {
              multiple: "multiple"
            });
          }
          if (settings.placeholder) {
            setAttr(control_input, {
              placeholder: settings.placeholder
            });
          }
          if (!settings.splitOn && settings.delimiter) {
            settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
          }
          if (settings.load && settings.loadThrottle) {
            settings.load = loadDebounce(settings.load, settings.loadThrottle);
          }
          self2.control_input.type = input.type;
          addEvent(dropdown, "mousemove", () => {
            self2.ignoreHover = false;
          });
          addEvent(dropdown, "mouseenter", (e) => {
            var target_match = parentMatch(e.target, "[data-selectable]", dropdown);
            if (target_match)
              self2.onOptionHover(e, target_match);
          }, {
            capture: true
          });
          addEvent(dropdown, "click", (evt) => {
            const option = parentMatch(evt.target, "[data-selectable]");
            if (option) {
              self2.onOptionSelect(evt, option);
              preventDefault(evt, true);
            }
          });
          addEvent(control, "click", (evt) => {
            var target_match = parentMatch(evt.target, "[data-ts-item]", control);
            if (target_match && self2.onItemSelect(evt, target_match)) {
              preventDefault(evt, true);
              return;
            }
            if (control_input.value != "") {
              return;
            }
            self2.onClick();
            preventDefault(evt, true);
          });
          addEvent(focus_node, "keydown", (e) => self2.onKeyDown(e));
          addEvent(control_input, "keypress", (e) => self2.onKeyPress(e));
          addEvent(control_input, "input", (e) => self2.onInput(e));
          addEvent(focus_node, "blur", (e) => self2.onBlur(e));
          addEvent(focus_node, "focus", (e) => self2.onFocus(e));
          addEvent(control_input, "paste", (e) => self2.onPaste(e));
          const doc_mousedown = (evt) => {
            const target = evt.composedPath()[0];
            if (!wrapper.contains(target) && !dropdown.contains(target)) {
              if (self2.isFocused) {
                self2.blur();
              }
              self2.inputState();
              return;
            }
            if (target == control_input && self2.isOpen) {
              evt.stopPropagation();
            } else {
              preventDefault(evt, true);
            }
          };
          const win_scroll = () => {
            if (self2.isOpen) {
              self2.positionDropdown();
            }
          };
          addEvent(document, "mousedown", doc_mousedown);
          addEvent(window, "scroll", win_scroll, passive_event);
          addEvent(window, "resize", win_scroll, passive_event);
          this._destroy = () => {
            document.removeEventListener("mousedown", doc_mousedown);
            window.removeEventListener("scroll", win_scroll);
            window.removeEventListener("resize", win_scroll);
            if (label)
              label.removeEventListener("click", label_click);
          };
          this.revertSettings = {
            innerHTML: input.innerHTML,
            tabIndex: input.tabIndex
          };
          input.tabIndex = -1;
          input.insertAdjacentElement("afterend", self2.wrapper);
          self2.sync(false);
          settings.items = [];
          delete settings.optgroups;
          delete settings.options;
          addEvent(input, "invalid", () => {
            if (self2.isValid) {
              self2.isValid = false;
              self2.isInvalid = true;
              self2.refreshState();
            }
          });
          self2.updateOriginalInput();
          self2.refreshItems();
          self2.close(false);
          self2.inputState();
          self2.isSetup = true;
          if (input.disabled) {
            self2.disable();
          } else {
            self2.enable();
          }
          self2.on("change", this.onChange);
          addClasses(input, "tomselected", "ts-hidden-accessible");
          self2.trigger("initialize");
          if (settings.preload === true) {
            self2.preload();
          }
        }
        /**
         * Register options and optgroups
         *
         */
        setupOptions(options = [], optgroups2 = []) {
          this.addOptions(options);
          iterate$1(optgroups2, (optgroup) => {
            this.registerOptionGroup(optgroup);
          });
        }
        /**
         * Sets up default rendering functions.
         */
        setupTemplates() {
          var self2 = this;
          var field_label = self2.settings.labelField;
          var field_optgroup = self2.settings.optgroupLabelField;
          var templates = {
            "optgroup": (data3) => {
              let optgroup = document.createElement("div");
              optgroup.className = "optgroup";
              optgroup.appendChild(data3.options);
              return optgroup;
            },
            "optgroup_header": (data3, escape) => {
              return '<div class="optgroup-header">' + escape(data3[field_optgroup]) + "</div>";
            },
            "option": (data3, escape) => {
              return "<div>" + escape(data3[field_label]) + "</div>";
            },
            "item": (data3, escape) => {
              return "<div>" + escape(data3[field_label]) + "</div>";
            },
            "option_create": (data3, escape) => {
              return '<div class="create">Add <strong>' + escape(data3.input) + "</strong>&hellip;</div>";
            },
            "no_results": () => {
              return '<div class="no-results">No results found</div>';
            },
            "loading": () => {
              return '<div class="spinner"></div>';
            },
            "not_loading": () => {
            },
            "dropdown": () => {
              return "<div></div>";
            }
          };
          self2.settings.render = Object.assign({}, templates, self2.settings.render);
        }
        /**
         * Maps fired events to callbacks provided
         * in the settings used when creating the control.
         */
        setupCallbacks() {
          var key, fn;
          var callbacks = {
            "initialize": "onInitialize",
            "change": "onChange",
            "item_add": "onItemAdd",
            "item_remove": "onItemRemove",
            "item_select": "onItemSelect",
            "clear": "onClear",
            "option_add": "onOptionAdd",
            "option_remove": "onOptionRemove",
            "option_clear": "onOptionClear",
            "optgroup_add": "onOptionGroupAdd",
            "optgroup_remove": "onOptionGroupRemove",
            "optgroup_clear": "onOptionGroupClear",
            "dropdown_open": "onDropdownOpen",
            "dropdown_close": "onDropdownClose",
            "type": "onType",
            "load": "onLoad",
            "focus": "onFocus",
            "blur": "onBlur"
          };
          for (key in callbacks) {
            fn = this.settings[callbacks[key]];
            if (fn)
              this.on(key, fn);
          }
        }
        /**
         * Sync the Tom Select instance with the original input or select
         *
         */
        sync(get_settings = true) {
          const self2 = this;
          const settings = get_settings ? getSettings(self2.input, {
            delimiter: self2.settings.delimiter
          }) : self2.settings;
          self2.setupOptions(settings.options, settings.optgroups);
          self2.setValue(settings.items || [], true);
          self2.lastQuery = null;
        }
        /**
         * Triggered when the main control element
         * has a click event.
         *
         */
        onClick() {
          var self2 = this;
          if (self2.activeItems.length > 0) {
            self2.clearActiveItems();
            self2.focus();
            return;
          }
          if (self2.isFocused && self2.isOpen) {
            self2.blur();
          } else {
            self2.focus();
          }
        }
        /**
         * @deprecated v1.7
         *
         */
        onMouseDown() {
        }
        /**
         * Triggered when the value of the control has been changed.
         * This should propagate the event to the original DOM
         * input / select element.
         */
        onChange() {
          triggerEvent(this.input, "input");
          triggerEvent(this.input, "change");
        }
        /**
         * Triggered on <input> paste.
         *
         */
        onPaste(e) {
          var self2 = this;
          if (self2.isInputHidden || self2.isLocked) {
            preventDefault(e);
            return;
          }
          if (!self2.settings.splitOn) {
            return;
          }
          setTimeout(() => {
            var pastedText = self2.inputValue();
            if (!pastedText.match(self2.settings.splitOn)) {
              return;
            }
            var splitInput = pastedText.trim().split(self2.settings.splitOn);
            iterate$1(splitInput, (piece) => {
              const hash = hash_key(piece);
              if (hash) {
                if (this.options[piece]) {
                  self2.addItem(piece);
                } else {
                  self2.createItem(piece);
                }
              }
            });
          }, 0);
        }
        /**
         * Triggered on <input> keypress.
         *
         */
        onKeyPress(e) {
          var self2 = this;
          if (self2.isLocked) {
            preventDefault(e);
            return;
          }
          var character = String.fromCharCode(e.keyCode || e.which);
          if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
            self2.createItem();
            preventDefault(e);
            return;
          }
        }
        /**
         * Triggered on <input> keydown.
         *
         */
        onKeyDown(e) {
          var self2 = this;
          self2.ignoreHover = true;
          if (self2.isLocked) {
            if (e.keyCode !== KEY_TAB) {
              preventDefault(e);
            }
            return;
          }
          switch (e.keyCode) {
            case KEY_A:
              if (isKeyDown(KEY_SHORTCUT, e)) {
                if (self2.control_input.value == "") {
                  preventDefault(e);
                  self2.selectAll();
                  return;
                }
              }
              break;
            case KEY_ESC:
              if (self2.isOpen) {
                preventDefault(e, true);
                self2.close();
              }
              self2.clearActiveItems();
              return;
            case KEY_DOWN:
              if (!self2.isOpen && self2.hasOptions) {
                self2.open();
              } else if (self2.activeOption) {
                let next = self2.getAdjacent(self2.activeOption, 1);
                if (next)
                  self2.setActiveOption(next);
              }
              preventDefault(e);
              return;
            case KEY_UP:
              if (self2.activeOption) {
                let prev = self2.getAdjacent(self2.activeOption, -1);
                if (prev)
                  self2.setActiveOption(prev);
              }
              preventDefault(e);
              return;
            case KEY_RETURN:
              if (self2.canSelect(self2.activeOption)) {
                self2.onOptionSelect(e, self2.activeOption);
                preventDefault(e);
              } else if (self2.settings.create && self2.createItem()) {
                preventDefault(e);
              } else if (document.activeElement == self2.control_input && self2.isOpen) {
                preventDefault(e);
              }
              return;
            case KEY_LEFT:
              self2.advanceSelection(-1, e);
              return;
            case KEY_RIGHT:
              self2.advanceSelection(1, e);
              return;
            case KEY_TAB:
              if (self2.settings.selectOnTab) {
                if (self2.canSelect(self2.activeOption)) {
                  self2.onOptionSelect(e, self2.activeOption);
                  preventDefault(e);
                }
                if (self2.settings.create && self2.createItem()) {
                  preventDefault(e);
                }
              }
              return;
            case KEY_BACKSPACE:
            case KEY_DELETE:
              self2.deleteSelection(e);
              return;
          }
          if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
            preventDefault(e);
          }
        }
        /**
         * Triggered on <input> keyup.
         *
         */
        onInput(e) {
          var self2 = this;
          if (self2.isLocked) {
            return;
          }
          var value = self2.inputValue();
          if (self2.lastValue !== value) {
            self2.lastValue = value;
            if (self2.settings.shouldLoad.call(self2, value)) {
              self2.load(value);
            }
            self2.refreshOptions();
            self2.trigger("type", value);
          }
        }
        /**
         * Triggered when the user rolls over
         * an option in the autocomplete dropdown menu.
         *
         */
        onOptionHover(evt, option) {
          if (this.ignoreHover)
            return;
          this.setActiveOption(option, false);
        }
        /**
         * Triggered on <input> focus.
         *
         */
        onFocus(e) {
          var self2 = this;
          var wasFocused = self2.isFocused;
          if (self2.isDisabled) {
            self2.blur();
            preventDefault(e);
            return;
          }
          if (self2.ignoreFocus)
            return;
          self2.isFocused = true;
          if (self2.settings.preload === "focus")
            self2.preload();
          if (!wasFocused)
            self2.trigger("focus");
          if (!self2.activeItems.length) {
            self2.showInput();
            self2.refreshOptions(!!self2.settings.openOnFocus);
          }
          self2.refreshState();
        }
        /**
         * Triggered on <input> blur.
         *
         */
        onBlur(e) {
          if (document.hasFocus() === false)
            return;
          var self2 = this;
          if (!self2.isFocused)
            return;
          self2.isFocused = false;
          self2.ignoreFocus = false;
          var deactivate = () => {
            self2.close();
            self2.setActiveItem();
            self2.setCaret(self2.items.length);
            self2.trigger("blur");
          };
          if (self2.settings.create && self2.settings.createOnBlur) {
            self2.createItem(null, deactivate);
          } else {
            deactivate();
          }
        }
        /**
         * Triggered when the user clicks on an option
         * in the autocomplete dropdown menu.
         *
         */
        onOptionSelect(evt, option) {
          var value, self2 = this;
          if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
            return;
          }
          if (option.classList.contains("create")) {
            self2.createItem(null, () => {
              if (self2.settings.closeAfterSelect) {
                self2.close();
              }
            });
          } else {
            value = option.dataset.value;
            if (typeof value !== "undefined") {
              self2.lastQuery = null;
              self2.addItem(value);
              if (self2.settings.closeAfterSelect) {
                self2.close();
              }
              if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                self2.setActiveOption(option);
              }
            }
          }
        }
        /**
         * Return true if the given option can be selected
         *
         */
        canSelect(option) {
          if (this.isOpen && option && this.dropdown_content.contains(option)) {
            return true;
          }
          return false;
        }
        /**
         * Triggered when the user clicks on an item
         * that has been selected.
         *
         */
        onItemSelect(evt, item) {
          var self2 = this;
          if (!self2.isLocked && self2.settings.mode === "multi") {
            preventDefault(evt);
            self2.setActiveItem(item, evt);
            return true;
          }
          return false;
        }
        /**
         * Determines whether or not to invoke
         * the user-provided option provider / loader
         *
         * Note, there is a subtle difference between
         * this.canLoad() and this.settings.shouldLoad();
         *
         *	- settings.shouldLoad() is a user-input validator.
         *	When false is returned, the not_loading template
         *	will be added to the dropdown
         *
         *	- canLoad() is lower level validator that checks
         * 	the Tom Select instance. There is no inherent user
         *	feedback when canLoad returns false
         *
         */
        canLoad(value) {
          if (!this.settings.load)
            return false;
          if (this.loadedSearches.hasOwnProperty(value))
            return false;
          return true;
        }
        /**
         * Invokes the user-provided option provider / loader.
         *
         */
        load(value) {
          const self2 = this;
          if (!self2.canLoad(value))
            return;
          addClasses(self2.wrapper, self2.settings.loadingClass);
          self2.loading++;
          const callback = self2.loadCallback.bind(self2);
          self2.settings.load.call(self2, value, callback);
        }
        /**
         * Invoked by the user-provided option provider
         *
         */
        loadCallback(options, optgroups2) {
          const self2 = this;
          self2.loading = Math.max(self2.loading - 1, 0);
          self2.lastQuery = null;
          self2.clearActiveOption();
          self2.setupOptions(options, optgroups2);
          self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
          if (!self2.loading) {
            removeClasses(self2.wrapper, self2.settings.loadingClass);
          }
          self2.trigger("load", options, optgroups2);
        }
        preload() {
          var classList = this.wrapper.classList;
          if (classList.contains("preloaded"))
            return;
          classList.add("preloaded");
          this.load("");
        }
        /**
         * Sets the input field of the control to the specified value.
         *
         */
        setTextboxValue(value = "") {
          var input = this.control_input;
          var changed = input.value !== value;
          if (changed) {
            input.value = value;
            triggerEvent(input, "update");
            this.lastValue = value;
          }
        }
        /**
         * Returns the value of the control. If multiple items
         * can be selected (e.g. <select multiple>), this returns
         * an array. If only one item can be selected, this
         * returns a string.
         *
         */
        getValue() {
          if (this.is_select_tag && this.input.hasAttribute("multiple")) {
            return this.items;
          }
          return this.items.join(this.settings.delimiter);
        }
        /**
         * Resets the selected items to the given value.
         *
         */
        setValue(value, silent) {
          var events = silent ? [] : ["change"];
          debounce_events(this, events, () => {
            this.clear(silent);
            this.addItems(value, silent);
          });
        }
        /**
         * Resets the number of max items to the given value
         *
         */
        setMaxItems(value) {
          if (value === 0)
            value = null;
          this.settings.maxItems = value;
          this.refreshState();
        }
        /**
         * Sets the selected item.
         *
         */
        setActiveItem(item, e) {
          var self2 = this;
          var eventName;
          var i, begin, end, swap;
          var last;
          if (self2.settings.mode === "single")
            return;
          if (!item) {
            self2.clearActiveItems();
            if (self2.isFocused) {
              self2.showInput();
            }
            return;
          }
          eventName = e && e.type.toLowerCase();
          if (eventName === "click" && isKeyDown("shiftKey", e) && self2.activeItems.length) {
            last = self2.getLastActive();
            begin = Array.prototype.indexOf.call(self2.control.children, last);
            end = Array.prototype.indexOf.call(self2.control.children, item);
            if (begin > end) {
              swap = begin;
              begin = end;
              end = swap;
            }
            for (i = begin; i <= end; i++) {
              item = self2.control.children[i];
              if (self2.activeItems.indexOf(item) === -1) {
                self2.setActiveItemClass(item);
              }
            }
            preventDefault(e);
          } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e) || eventName === "keydown" && isKeyDown("shiftKey", e)) {
            if (item.classList.contains("active")) {
              self2.removeActiveItem(item);
            } else {
              self2.setActiveItemClass(item);
            }
          } else {
            self2.clearActiveItems();
            self2.setActiveItemClass(item);
          }
          self2.hideInput();
          if (!self2.isFocused) {
            self2.focus();
          }
        }
        /**
         * Set the active and last-active classes
         *
         */
        setActiveItemClass(item) {
          const self2 = this;
          const last_active = self2.control.querySelector(".last-active");
          if (last_active)
            removeClasses(last_active, "last-active");
          addClasses(item, "active last-active");
          self2.trigger("item_select", item);
          if (self2.activeItems.indexOf(item) == -1) {
            self2.activeItems.push(item);
          }
        }
        /**
         * Remove active item
         *
         */
        removeActiveItem(item) {
          var idx = this.activeItems.indexOf(item);
          this.activeItems.splice(idx, 1);
          removeClasses(item, "active");
        }
        /**
         * Clears all the active items
         *
         */
        clearActiveItems() {
          removeClasses(this.activeItems, "active");
          this.activeItems = [];
        }
        /**
         * Sets the selected item in the dropdown menu
         * of available options.
         *
         */
        setActiveOption(option, scroll = true) {
          if (option === this.activeOption) {
            return;
          }
          this.clearActiveOption();
          if (!option)
            return;
          this.activeOption = option;
          setAttr(this.focus_node, {
            "aria-activedescendant": option.getAttribute("id")
          });
          setAttr(option, {
            "aria-selected": "true"
          });
          addClasses(option, "active");
          if (scroll)
            this.scrollToOption(option);
        }
        /**
         * Sets the dropdown_content scrollTop to display the option
         *
         */
        scrollToOption(option, behavior) {
          if (!option)
            return;
          const content = this.dropdown_content;
          const height_menu = content.clientHeight;
          const scrollTop = content.scrollTop || 0;
          const height_item = option.offsetHeight;
          const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
          if (y + height_item > height_menu + scrollTop) {
            this.scroll(y - height_menu + height_item, behavior);
          } else if (y < scrollTop) {
            this.scroll(y, behavior);
          }
        }
        /**
         * Scroll the dropdown to the given position
         *
         */
        scroll(scrollTop, behavior) {
          const content = this.dropdown_content;
          if (behavior) {
            content.style.scrollBehavior = behavior;
          }
          content.scrollTop = scrollTop;
          content.style.scrollBehavior = "";
        }
        /**
         * Clears the active option
         *
         */
        clearActiveOption() {
          if (this.activeOption) {
            removeClasses(this.activeOption, "active");
            setAttr(this.activeOption, {
              "aria-selected": null
            });
          }
          this.activeOption = null;
          setAttr(this.focus_node, {
            "aria-activedescendant": null
          });
        }
        /**
         * Selects all items (CTRL + A).
         */
        selectAll() {
          const self2 = this;
          if (self2.settings.mode === "single")
            return;
          const activeItems = self2.controlChildren();
          if (!activeItems.length)
            return;
          self2.hideInput();
          self2.close();
          self2.activeItems = activeItems;
          iterate$1(activeItems, (item) => {
            self2.setActiveItemClass(item);
          });
        }
        /**
         * Determines if the control_input should be in a hidden or visible state
         *
         */
        inputState() {
          var self2 = this;
          if (!self2.control.contains(self2.control_input))
            return;
          setAttr(self2.control_input, {
            placeholder: self2.settings.placeholder
          });
          if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
            self2.setTextboxValue();
            self2.isInputHidden = true;
          } else {
            if (self2.settings.hidePlaceholder && self2.items.length > 0) {
              setAttr(self2.control_input, {
                placeholder: ""
              });
            }
            self2.isInputHidden = false;
          }
          self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
        }
        /**
         * Hides the input element out of view, while
         * retaining its focus.
         * @deprecated 1.3
         */
        hideInput() {
          this.inputState();
        }
        /**
         * Restores input visibility.
         * @deprecated 1.3
         */
        showInput() {
          this.inputState();
        }
        /**
         * Get the input value
         */
        inputValue() {
          return this.control_input.value.trim();
        }
        /**
         * Gives the control focus.
         */
        focus() {
          var self2 = this;
          if (self2.isDisabled)
            return;
          self2.ignoreFocus = true;
          if (self2.control_input.offsetWidth) {
            self2.control_input.focus();
          } else {
            self2.focus_node.focus();
          }
          setTimeout(() => {
            self2.ignoreFocus = false;
            self2.onFocus();
          }, 0);
        }
        /**
         * Forces the control out of focus.
         *
         */
        blur() {
          this.focus_node.blur();
          this.onBlur();
        }
        /**
         * Returns a function that scores an object
         * to show how good of a match it is to the
         * provided query.
         *
         * @return {function}
         */
        getScoreFunction(query) {
          return this.sifter.getScoreFunction(query, this.getSearchOptions());
        }
        /**
         * Returns search options for sifter (the system
         * for scoring and sorting results).
         *
         * @see https://github.com/orchidjs/sifter.js
         * @return {object}
         */
        getSearchOptions() {
          var settings = this.settings;
          var sort = settings.sortField;
          if (typeof settings.sortField === "string") {
            sort = [{
              field: settings.sortField
            }];
          }
          return {
            fields: settings.searchField,
            conjunction: settings.searchConjunction,
            sort,
            nesting: settings.nesting
          };
        }
        /**
         * Searches through available options and returns
         * a sorted array of matches.
         *
         */
        search(query) {
          var result, calculateScore;
          var self2 = this;
          var options = this.getSearchOptions();
          if (self2.settings.score) {
            calculateScore = self2.settings.score.call(self2, query);
            if (typeof calculateScore !== "function") {
              throw new Error('Tom Select "score" setting must be a function that returns a function');
            }
          }
          if (query !== self2.lastQuery) {
            self2.lastQuery = query;
            result = self2.sifter.search(query, Object.assign(options, {
              score: calculateScore
            }));
            self2.currentResults = result;
          } else {
            result = Object.assign({}, self2.currentResults);
          }
          if (self2.settings.hideSelected) {
            result.items = result.items.filter((item) => {
              let hashed = hash_key(item.id);
              return !(hashed && self2.items.indexOf(hashed) !== -1);
            });
          }
          return result;
        }
        /**
         * Refreshes the list of available options shown
         * in the autocomplete dropdown menu.
         *
         */
        refreshOptions(triggerDropdown = true) {
          var i, j, k, n, optgroup, optgroups2, html, has_create_option, active_group;
          var create4;
          const groups = {};
          const groups_order = [];
          var self2 = this;
          var query = self2.inputValue();
          const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
          var results = self2.search(query);
          var active_option = null;
          var show_dropdown = self2.settings.shouldOpen || false;
          var dropdown_content = self2.dropdown_content;
          if (same_query) {
            active_option = self2.activeOption;
            if (active_option) {
              active_group = active_option.closest("[data-group]");
            }
          }
          n = results.items.length;
          if (typeof self2.settings.maxOptions === "number") {
            n = Math.min(n, self2.settings.maxOptions);
          }
          if (n > 0) {
            show_dropdown = true;
          }
          for (i = 0; i < n; i++) {
            let item = results.items[i];
            if (!item)
              continue;
            let opt_value = item.id;
            let option = self2.options[opt_value];
            if (option === void 0)
              continue;
            let opt_hash = get_hash(opt_value);
            let option_el = self2.getOption(opt_hash, true);
            if (!self2.settings.hideSelected) {
              option_el.classList.toggle("selected", self2.items.includes(opt_hash));
            }
            optgroup = option[self2.settings.optgroupField] || "";
            optgroups2 = Array.isArray(optgroup) ? optgroup : [optgroup];
            for (j = 0, k = optgroups2 && optgroups2.length; j < k; j++) {
              optgroup = optgroups2[j];
              if (!self2.optgroups.hasOwnProperty(optgroup)) {
                optgroup = "";
              }
              let group_fragment = groups[optgroup];
              if (group_fragment === void 0) {
                group_fragment = document.createDocumentFragment();
                groups_order.push(optgroup);
              }
              if (j > 0) {
                option_el = option_el.cloneNode(true);
                setAttr(option_el, {
                  id: option.$id + "-clone-" + j,
                  "aria-selected": null
                });
                option_el.classList.add("ts-cloned");
                removeClasses(option_el, "active");
                if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
                  if (active_group && active_group.dataset.group === optgroup.toString()) {
                    active_option = option_el;
                  }
                }
              }
              group_fragment.appendChild(option_el);
              groups[optgroup] = group_fragment;
            }
          }
          if (self2.settings.lockOptgroupOrder) {
            groups_order.sort((a, b) => {
              const grp_a = self2.optgroups[a];
              const grp_b = self2.optgroups[b];
              const a_order = grp_a && grp_a.$order || 0;
              const b_order = grp_b && grp_b.$order || 0;
              return a_order - b_order;
            });
          }
          html = document.createDocumentFragment();
          iterate$1(groups_order, (optgroup2) => {
            let group_fragment = groups[optgroup2];
            if (!group_fragment || !group_fragment.children.length)
              return;
            let group_heading = self2.optgroups[optgroup2];
            if (group_heading !== void 0) {
              let group_options = document.createDocumentFragment();
              let header = self2.render("optgroup_header", group_heading);
              append(group_options, header);
              append(group_options, group_fragment);
              let group_html = self2.render("optgroup", {
                group: group_heading,
                options: group_options
              });
              append(html, group_html);
            } else {
              append(html, group_fragment);
            }
          });
          dropdown_content.innerHTML = "";
          append(dropdown_content, html);
          if (self2.settings.highlight) {
            removeHighlight(dropdown_content);
            if (results.query.length && results.tokens.length) {
              iterate$1(results.tokens, (tok) => {
                highlight(dropdown_content, tok.regex);
              });
            }
          }
          var add_template = (template) => {
            let content = self2.render(template, {
              input: query
            });
            if (content) {
              show_dropdown = true;
              dropdown_content.insertBefore(content, dropdown_content.firstChild);
            }
            return content;
          };
          if (self2.loading) {
            add_template("loading");
          } else if (!self2.settings.shouldLoad.call(self2, query)) {
            add_template("not_loading");
          } else if (results.items.length === 0) {
            add_template("no_results");
          }
          has_create_option = self2.canCreate(query);
          if (has_create_option) {
            create4 = add_template("option_create");
          }
          self2.hasOptions = results.items.length > 0 || has_create_option;
          if (show_dropdown) {
            if (results.items.length > 0) {
              if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
                active_option = self2.getOption(self2.items[0]);
              }
              if (!dropdown_content.contains(active_option)) {
                let active_index = 0;
                if (create4 && !self2.settings.addPrecedence) {
                  active_index = 1;
                }
                active_option = self2.selectable()[active_index];
              }
            } else if (create4) {
              active_option = create4;
            }
            if (triggerDropdown && !self2.isOpen) {
              self2.open();
              self2.scrollToOption(active_option, "auto");
            }
            self2.setActiveOption(active_option);
          } else {
            self2.clearActiveOption();
            if (triggerDropdown && self2.isOpen) {
              self2.close(false);
            }
          }
        }
        /**
         * Return list of selectable options
         *
         */
        selectable() {
          return this.dropdown_content.querySelectorAll("[data-selectable]");
        }
        /**
         * Adds an available option. If it already exists,
         * nothing will happen. Note: this does not refresh
         * the options list dropdown (use `refreshOptions`
         * for that).
         *
         * Usage:
         *
         *   this.addOption(data)
         *
         */
        addOption(data3, user_created = false) {
          const self2 = this;
          if (Array.isArray(data3)) {
            self2.addOptions(data3, user_created);
            return false;
          }
          const key = hash_key(data3[self2.settings.valueField]);
          if (key === null || self2.options.hasOwnProperty(key)) {
            return false;
          }
          data3.$order = data3.$order || ++self2.order;
          data3.$id = self2.inputId + "-opt-" + data3.$order;
          self2.options[key] = data3;
          self2.lastQuery = null;
          if (user_created) {
            self2.userOptions[key] = user_created;
            self2.trigger("option_add", key, data3);
          }
          return key;
        }
        /**
         * Add multiple options
         *
         */
        addOptions(data3, user_created = false) {
          iterate$1(data3, (dat) => {
            this.addOption(dat, user_created);
          });
        }
        /**
         * @deprecated 1.7.7
         */
        registerOption(data3) {
          return this.addOption(data3);
        }
        /**
         * Registers an option group to the pool of option groups.
         *
         * @return {boolean|string}
         */
        registerOptionGroup(data3) {
          var key = hash_key(data3[this.settings.optgroupValueField]);
          if (key === null)
            return false;
          data3.$order = data3.$order || ++this.order;
          this.optgroups[key] = data3;
          return key;
        }
        /**
         * Registers a new optgroup for options
         * to be bucketed into.
         *
         */
        addOptionGroup(id, data3) {
          var hashed_id;
          data3[this.settings.optgroupValueField] = id;
          if (hashed_id = this.registerOptionGroup(data3)) {
            this.trigger("optgroup_add", hashed_id, data3);
          }
        }
        /**
         * Removes an existing option group.
         *
         */
        removeOptionGroup(id) {
          if (this.optgroups.hasOwnProperty(id)) {
            delete this.optgroups[id];
            this.clearCache();
            this.trigger("optgroup_remove", id);
          }
        }
        /**
         * Clears all existing option groups.
         */
        clearOptionGroups() {
          this.optgroups = {};
          this.clearCache();
          this.trigger("optgroup_clear");
        }
        /**
         * Updates an option available for selection. If
         * it is visible in the selected items or options
         * dropdown, it will be re-rendered automatically.
         *
         */
        updateOption(value, data3) {
          const self2 = this;
          var item_new;
          var index_item;
          const value_old = hash_key(value);
          const value_new = hash_key(data3[self2.settings.valueField]);
          if (value_old === null)
            return;
          const data_old = self2.options[value_old];
          if (data_old == void 0)
            return;
          if (typeof value_new !== "string")
            throw new Error("Value must be set in option data");
          const option = self2.getOption(value_old);
          const item = self2.getItem(value_old);
          data3.$order = data3.$order || data_old.$order;
          delete self2.options[value_old];
          self2.uncacheValue(value_new);
          self2.options[value_new] = data3;
          if (option) {
            if (self2.dropdown_content.contains(option)) {
              const option_new = self2._render("option", data3);
              replaceNode(option, option_new);
              if (self2.activeOption === option) {
                self2.setActiveOption(option_new);
              }
            }
            option.remove();
          }
          if (item) {
            index_item = self2.items.indexOf(value_old);
            if (index_item !== -1) {
              self2.items.splice(index_item, 1, value_new);
            }
            item_new = self2._render("item", data3);
            if (item.classList.contains("active"))
              addClasses(item_new, "active");
            replaceNode(item, item_new);
          }
          self2.lastQuery = null;
        }
        /**
         * Removes a single option.
         *
         */
        removeOption(value, silent) {
          const self2 = this;
          value = get_hash(value);
          self2.uncacheValue(value);
          delete self2.userOptions[value];
          delete self2.options[value];
          self2.lastQuery = null;
          self2.trigger("option_remove", value);
          self2.removeItem(value, silent);
        }
        /**
         * Clears all options.
         */
        clearOptions(filter) {
          const boundFilter = (filter || this.clearFilter).bind(this);
          this.loadedSearches = {};
          this.userOptions = {};
          this.clearCache();
          const selected = {};
          iterate$1(this.options, (option, key) => {
            if (boundFilter(option, key)) {
              selected[key] = option;
            }
          });
          this.options = this.sifter.items = selected;
          this.lastQuery = null;
          this.trigger("option_clear");
        }
        /**
         * Used by clearOptions() to decide whether or not an option should be removed
         * Return true to keep an option, false to remove
         *
         */
        clearFilter(option, value) {
          if (this.items.indexOf(value) >= 0) {
            return true;
          }
          return false;
        }
        /**
         * Returns the dom element of the option
         * matching the given value.
         *
         */
        getOption(value, create4 = false) {
          const hashed = hash_key(value);
          if (hashed === null)
            return null;
          const option = this.options[hashed];
          if (option != void 0) {
            if (option.$div) {
              return option.$div;
            }
            if (create4) {
              return this._render("option", option);
            }
          }
          return null;
        }
        /**
         * Returns the dom element of the next or previous dom element of the same type
         * Note: adjacent options may not be adjacent DOM elements (optgroups)
         *
         */
        getAdjacent(option, direction, type = "option") {
          var self2 = this, all;
          if (!option) {
            return null;
          }
          if (type == "item") {
            all = self2.controlChildren();
          } else {
            all = self2.dropdown_content.querySelectorAll("[data-selectable]");
          }
          for (let i = 0; i < all.length; i++) {
            if (all[i] != option) {
              continue;
            }
            if (direction > 0) {
              return all[i + 1];
            }
            return all[i - 1];
          }
          return null;
        }
        /**
         * Returns the dom element of the item
         * matching the given value.
         *
         */
        getItem(item) {
          if (typeof item == "object") {
            return item;
          }
          var value = hash_key(item);
          return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
        }
        /**
         * "Selects" multiple items at once. Adds them to the list
         * at the current caret position.
         *
         */
        addItems(values, silent) {
          var self2 = this;
          var items = Array.isArray(values) ? values : [values];
          items = items.filter((x) => self2.items.indexOf(x) === -1);
          const last_item = items[items.length - 1];
          items.forEach((item) => {
            self2.isPending = item !== last_item;
            self2.addItem(item, silent);
          });
        }
        /**
         * "Selects" an item. Adds it to the list
         * at the current caret position.
         *
         */
        addItem(value, silent) {
          var events = silent ? [] : ["change", "dropdown_close"];
          debounce_events(this, events, () => {
            var item, wasFull;
            const self2 = this;
            const inputMode = self2.settings.mode;
            const hashed = hash_key(value);
            if (hashed && self2.items.indexOf(hashed) !== -1) {
              if (inputMode === "single") {
                self2.close();
              }
              if (inputMode === "single" || !self2.settings.duplicates) {
                return;
              }
            }
            if (hashed === null || !self2.options.hasOwnProperty(hashed))
              return;
            if (inputMode === "single")
              self2.clear(silent);
            if (inputMode === "multi" && self2.isFull())
              return;
            item = self2._render("item", self2.options[hashed]);
            if (self2.control.contains(item)) {
              item = item.cloneNode(true);
            }
            wasFull = self2.isFull();
            self2.items.splice(self2.caretPos, 0, hashed);
            self2.insertAtCaret(item);
            if (self2.isSetup) {
              if (!self2.isPending && self2.settings.hideSelected) {
                let option = self2.getOption(hashed);
                let next = self2.getAdjacent(option, 1);
                if (next) {
                  self2.setActiveOption(next);
                }
              }
              if (!self2.isPending && !self2.settings.closeAfterSelect) {
                self2.refreshOptions(self2.isFocused && inputMode !== "single");
              }
              if (self2.settings.closeAfterSelect != false && self2.isFull()) {
                self2.close();
              } else if (!self2.isPending) {
                self2.positionDropdown();
              }
              self2.trigger("item_add", hashed, item);
              if (!self2.isPending) {
                self2.updateOriginalInput({
                  silent
                });
              }
            }
            if (!self2.isPending || !wasFull && self2.isFull()) {
              self2.inputState();
              self2.refreshState();
            }
          });
        }
        /**
         * Removes the selected item matching
         * the provided value.
         *
         */
        removeItem(item = null, silent) {
          const self2 = this;
          item = self2.getItem(item);
          if (!item)
            return;
          var i, idx;
          const value = item.dataset.value;
          i = nodeIndex(item);
          item.remove();
          if (item.classList.contains("active")) {
            idx = self2.activeItems.indexOf(item);
            self2.activeItems.splice(idx, 1);
            removeClasses(item, "active");
          }
          self2.items.splice(i, 1);
          self2.lastQuery = null;
          if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
            self2.removeOption(value, silent);
          }
          if (i < self2.caretPos) {
            self2.setCaret(self2.caretPos - 1);
          }
          self2.updateOriginalInput({
            silent
          });
          self2.refreshState();
          self2.positionDropdown();
          self2.trigger("item_remove", value, item);
        }
        /**
         * Invokes the `create` method provided in the
         * TomSelect options that should provide the data
         * for the new item, given the user input.
         *
         * Once this completes, it will be added
         * to the item list.
         *
         */
        createItem(input = null, callback = () => {
        }) {
          if (arguments.length === 3) {
            callback = arguments[2];
          }
          if (typeof callback != "function") {
            callback = () => {
            };
          }
          var self2 = this;
          var caret = self2.caretPos;
          var output;
          input = input || self2.inputValue();
          if (!self2.canCreate(input)) {
            callback();
            return false;
          }
          self2.lock();
          var created = false;
          var create4 = (data3) => {
            self2.unlock();
            if (!data3 || typeof data3 !== "object")
              return callback();
            var value = hash_key(data3[self2.settings.valueField]);
            if (typeof value !== "string") {
              return callback();
            }
            self2.setTextboxValue();
            self2.addOption(data3, true);
            self2.setCaret(caret);
            self2.addItem(value);
            callback(data3);
            created = true;
          };
          if (typeof self2.settings.create === "function") {
            output = self2.settings.create.call(this, input, create4);
          } else {
            output = {
              [self2.settings.labelField]: input,
              [self2.settings.valueField]: input
            };
          }
          if (!created) {
            create4(output);
          }
          return true;
        }
        /**
         * Re-renders the selected item lists.
         */
        refreshItems() {
          var self2 = this;
          self2.lastQuery = null;
          if (self2.isSetup) {
            self2.addItems(self2.items);
          }
          self2.updateOriginalInput();
          self2.refreshState();
        }
        /**
         * Updates all state-dependent attributes
         * and CSS classes.
         */
        refreshState() {
          const self2 = this;
          self2.refreshValidityState();
          const isFull = self2.isFull();
          const isLocked = self2.isLocked;
          self2.wrapper.classList.toggle("rtl", self2.rtl);
          const wrap_classList = self2.wrapper.classList;
          wrap_classList.toggle("focus", self2.isFocused);
          wrap_classList.toggle("disabled", self2.isDisabled);
          wrap_classList.toggle("required", self2.isRequired);
          wrap_classList.toggle("invalid", !self2.isValid);
          wrap_classList.toggle("locked", isLocked);
          wrap_classList.toggle("full", isFull);
          wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
          wrap_classList.toggle("dropdown-active", self2.isOpen);
          wrap_classList.toggle("has-options", isEmptyObject2(self2.options));
          wrap_classList.toggle("has-items", self2.items.length > 0);
        }
        /**
         * Update the `required` attribute of both input and control input.
         *
         * The `required` property needs to be activated on the control input
         * for the error to be displayed at the right place. `required` also
         * needs to be temporarily deactivated on the input since the input is
         * hidden and can't show errors.
         */
        refreshValidityState() {
          var self2 = this;
          if (!self2.input.validity) {
            return;
          }
          self2.isValid = self2.input.validity.valid;
          self2.isInvalid = !self2.isValid;
        }
        /**
         * Determines whether or not more items can be added
         * to the control without exceeding the user-defined maximum.
         *
         * @returns {boolean}
         */
        isFull() {
          return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
        }
        /**
         * Refreshes the original <select> or <input>
         * element to reflect the current state.
         *
         */
        updateOriginalInput(opts = {}) {
          const self2 = this;
          var option, label;
          const empty_option = self2.input.querySelector('option[value=""]');
          if (self2.is_select_tag) {
            let AddSelected = function(option_el, value, label2) {
              if (!option_el) {
                option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
              }
              if (option_el != empty_option) {
                self2.input.append(option_el);
              }
              selected.push(option_el);
              if (option_el != empty_option || has_selected > 0) {
                option_el.selected = true;
              }
              return option_el;
            };
            const selected = [];
            const has_selected = self2.input.querySelectorAll("option:checked").length;
            self2.input.querySelectorAll("option:checked").forEach((option_el) => {
              option_el.selected = false;
            });
            if (self2.items.length == 0 && self2.settings.mode == "single") {
              AddSelected(empty_option, "", "");
            } else {
              self2.items.forEach((value) => {
                option = self2.options[value];
                label = option[self2.settings.labelField] || "";
                if (selected.includes(option.$option)) {
                  const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
                  AddSelected(reuse_opt, value, label);
                } else {
                  option.$option = AddSelected(option.$option, value, label);
                }
              });
            }
          } else {
            self2.input.value = self2.getValue();
          }
          if (self2.isSetup) {
            if (!opts.silent) {
              self2.trigger("change", self2.getValue());
            }
          }
        }
        /**
         * Shows the autocomplete dropdown containing
         * the available options.
         */
        open() {
          var self2 = this;
          if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
            return;
          self2.isOpen = true;
          setAttr(self2.focus_node, {
            "aria-expanded": "true"
          });
          self2.refreshState();
          applyCSS(self2.dropdown, {
            visibility: "hidden",
            display: "block"
          });
          self2.positionDropdown();
          applyCSS(self2.dropdown, {
            visibility: "visible",
            display: "block"
          });
          self2.focus();
          self2.trigger("dropdown_open", self2.dropdown);
        }
        /**
         * Closes the autocomplete dropdown menu.
         */
        close(setTextboxValue = true) {
          var self2 = this;
          var trigger3 = self2.isOpen;
          if (setTextboxValue) {
            self2.setTextboxValue();
            if (self2.settings.mode === "single" && self2.items.length) {
              self2.hideInput();
            }
          }
          self2.isOpen = false;
          setAttr(self2.focus_node, {
            "aria-expanded": "false"
          });
          applyCSS(self2.dropdown, {
            display: "none"
          });
          if (self2.settings.hideSelected) {
            self2.clearActiveOption();
          }
          self2.refreshState();
          if (trigger3)
            self2.trigger("dropdown_close", self2.dropdown);
        }
        /**
         * Calculates and applies the appropriate
         * position of the dropdown if dropdownParent = 'body'.
         * Otherwise, position is determined by css
         */
        positionDropdown() {
          if (this.settings.dropdownParent !== "body") {
            return;
          }
          var context = this.control;
          var rect = context.getBoundingClientRect();
          var top = context.offsetHeight + rect.top + window.scrollY;
          var left = rect.left + window.scrollX;
          applyCSS(this.dropdown, {
            width: rect.width + "px",
            top: top + "px",
            left: left + "px"
          });
        }
        /**
         * Resets / clears all selected items
         * from the control.
         *
         */
        clear(silent) {
          var self2 = this;
          if (!self2.items.length)
            return;
          var items = self2.controlChildren();
          iterate$1(items, (item) => {
            self2.removeItem(item, true);
          });
          self2.showInput();
          if (!silent)
            self2.updateOriginalInput();
          self2.trigger("clear");
        }
        /**
         * A helper method for inserting an element
         * at the current caret position.
         *
         */
        insertAtCaret(el) {
          const self2 = this;
          const caret = self2.caretPos;
          const target = self2.control;
          target.insertBefore(el, target.children[caret] || null);
          self2.setCaret(caret + 1);
        }
        /**
         * Removes the current selected item(s).
         *
         */
        deleteSelection(e) {
          var direction, selection, caret, tail;
          var self2 = this;
          direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
          selection = getSelection(self2.control_input);
          const rm_items = [];
          if (self2.activeItems.length) {
            tail = getTail(self2.activeItems, direction);
            caret = nodeIndex(tail);
            if (direction > 0) {
              caret++;
            }
            iterate$1(self2.activeItems, (item) => rm_items.push(item));
          } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
            const items = self2.controlChildren();
            let rm_item;
            if (direction < 0 && selection.start === 0 && selection.length === 0) {
              rm_item = items[self2.caretPos - 1];
            } else if (direction > 0 && selection.start === self2.inputValue().length) {
              rm_item = items[self2.caretPos];
            }
            if (rm_item !== void 0) {
              rm_items.push(rm_item);
            }
          }
          if (!self2.shouldDelete(rm_items, e)) {
            return false;
          }
          preventDefault(e, true);
          if (typeof caret !== "undefined") {
            self2.setCaret(caret);
          }
          while (rm_items.length) {
            self2.removeItem(rm_items.pop());
          }
          self2.showInput();
          self2.positionDropdown();
          self2.refreshOptions(false);
          return true;
        }
        /**
         * Return true if the items should be deleted
         */
        shouldDelete(items, evt) {
          const values = items.map((item) => item.dataset.value);
          if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
            return false;
          }
          return true;
        }
        /**
         * Selects the previous / next item (depending on the `direction` argument).
         *
         * > 0 - right
         * < 0 - left
         *
         */
        advanceSelection(direction, e) {
          var last_active, adjacent, self2 = this;
          if (self2.rtl)
            direction *= -1;
          if (self2.inputValue().length)
            return;
          if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown("shiftKey", e)) {
            last_active = self2.getLastActive(direction);
            if (last_active) {
              if (!last_active.classList.contains("active")) {
                adjacent = last_active;
              } else {
                adjacent = self2.getAdjacent(last_active, direction, "item");
              }
            } else if (direction > 0) {
              adjacent = self2.control_input.nextElementSibling;
            } else {
              adjacent = self2.control_input.previousElementSibling;
            }
            if (adjacent) {
              if (adjacent.classList.contains("active")) {
                self2.removeActiveItem(last_active);
              }
              self2.setActiveItemClass(adjacent);
            }
          } else {
            self2.moveCaret(direction);
          }
        }
        moveCaret(direction) {
        }
        /**
         * Get the last active item
         *
         */
        getLastActive(direction) {
          let last_active = this.control.querySelector(".last-active");
          if (last_active) {
            return last_active;
          }
          var result = this.control.querySelectorAll(".active");
          if (result) {
            return getTail(result, direction);
          }
        }
        /**
         * Moves the caret to the specified index.
         *
         * The input must be moved by leaving it in place and moving the
         * siblings, due to the fact that focus cannot be restored once lost
         * on mobile webkit devices
         *
         */
        setCaret(new_pos) {
          this.caretPos = this.items.length;
        }
        /**
         * Return list of item dom elements
         *
         */
        controlChildren() {
          return Array.from(this.control.querySelectorAll("[data-ts-item]"));
        }
        /**
         * Disables user input on the control. Used while
         * items are being asynchronously created.
         */
        lock() {
          this.isLocked = true;
          this.refreshState();
        }
        /**
         * Re-enables user input on the control.
         */
        unlock() {
          this.isLocked = false;
          this.refreshState();
        }
        /**
         * Disables user input on the control completely.
         * While disabled, it cannot receive focus.
         */
        disable() {
          var self2 = this;
          self2.input.disabled = true;
          self2.control_input.disabled = true;
          self2.focus_node.tabIndex = -1;
          self2.isDisabled = true;
          this.close();
          self2.lock();
        }
        /**
         * Enables the control so that it can respond
         * to focus and user input.
         */
        enable() {
          var self2 = this;
          self2.input.disabled = false;
          self2.control_input.disabled = false;
          self2.focus_node.tabIndex = self2.tabIndex;
          self2.isDisabled = false;
          self2.unlock();
        }
        /**
         * Completely destroys the control and
         * unbinds all event listeners so that it can
         * be garbage collected.
         */
        destroy() {
          var self2 = this;
          var revertSettings = self2.revertSettings;
          self2.trigger("destroy");
          self2.off();
          self2.wrapper.remove();
          self2.dropdown.remove();
          self2.input.innerHTML = revertSettings.innerHTML;
          self2.input.tabIndex = revertSettings.tabIndex;
          removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
          self2._destroy();
          delete self2.input.tomselect;
        }
        /**
         * A helper method for rendering "item" and
         * "option" templates, given the data.
         *
         */
        render(templateName, data3) {
          var id, html;
          const self2 = this;
          if (typeof this.settings.render[templateName] !== "function") {
            return null;
          }
          html = self2.settings.render[templateName].call(this, data3, escape_html);
          if (!html) {
            return null;
          }
          html = getDom(html);
          if (templateName === "option" || templateName === "option_create") {
            if (data3[self2.settings.disabledField]) {
              setAttr(html, {
                "aria-disabled": "true"
              });
            } else {
              setAttr(html, {
                "data-selectable": ""
              });
            }
          } else if (templateName === "optgroup") {
            id = data3.group[self2.settings.optgroupValueField];
            setAttr(html, {
              "data-group": id
            });
            if (data3.group[self2.settings.disabledField]) {
              setAttr(html, {
                "data-disabled": ""
              });
            }
          }
          if (templateName === "option" || templateName === "item") {
            const value = get_hash(data3[self2.settings.valueField]);
            setAttr(html, {
              "data-value": value
            });
            if (templateName === "item") {
              addClasses(html, self2.settings.itemClass);
              setAttr(html, {
                "data-ts-item": ""
              });
            } else {
              addClasses(html, self2.settings.optionClass);
              setAttr(html, {
                role: "option",
                id: data3.$id
              });
              data3.$div = html;
              self2.options[value] = data3;
            }
          }
          return html;
        }
        /**
         * Type guarded rendering
         *
         */
        _render(templateName, data3) {
          const html = this.render(templateName, data3);
          if (html == null) {
            throw "HTMLElement expected";
          }
          return html;
        }
        /**
         * Clears the render cache for a template. If
         * no template is given, clears all render
         * caches.
         *
         */
        clearCache() {
          iterate$1(this.options, (option) => {
            if (option.$div) {
              option.$div.remove();
              delete option.$div;
            }
          });
        }
        /**
         * Removes a value from item and option caches
         *
         */
        uncacheValue(value) {
          const option_el = this.getOption(value);
          if (option_el)
            option_el.remove();
        }
        /**
         * Determines whether or not to display the
         * create item prompt, given a user input.
         *
         */
        canCreate(input) {
          return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
        }
        /**
         * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
         *
         * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
         *
         * });
         */
        hook(when, method, new_fn) {
          var self2 = this;
          var orig_method = self2[method];
          self2[method] = function() {
            var result, result_new;
            if (when === "after") {
              result = orig_method.apply(self2, arguments);
            }
            result_new = new_fn.apply(self2, arguments);
            if (when === "instead") {
              return result_new;
            }
            if (when === "before") {
              result = orig_method.apply(self2, arguments);
            }
            return result;
          };
        }
      }
      function change_listener() {
        addEvent(this.input, "change", () => {
          this.sync();
        });
      }
      function checkbox_options() {
        var self2 = this;
        var orig_onOptionSelect = self2.onOptionSelect;
        self2.settings.hideSelected = false;
        var UpdateCheckbox = function UpdateCheckbox2(option) {
          setTimeout(() => {
            var checkbox = option.querySelector("input");
            if (checkbox instanceof HTMLInputElement) {
              if (option.classList.contains("selected")) {
                checkbox.checked = true;
              } else {
                checkbox.checked = false;
              }
            }
          }, 1);
        };
        self2.hook("after", "setupTemplates", () => {
          var orig_render_option = self2.settings.render.option;
          self2.settings.render.option = (data3, escape_html2) => {
            var rendered = getDom(orig_render_option.call(self2, data3, escape_html2));
            var checkbox = document.createElement("input");
            checkbox.addEventListener("click", function(evt) {
              preventDefault(evt);
            });
            checkbox.type = "checkbox";
            const hashed = hash_key(data3[self2.settings.valueField]);
            if (hashed && self2.items.indexOf(hashed) > -1) {
              checkbox.checked = true;
            }
            rendered.prepend(checkbox);
            return rendered;
          };
        });
        self2.on("item_remove", (value) => {
          var option = self2.getOption(value);
          if (option) {
            option.classList.remove("selected");
            UpdateCheckbox(option);
          }
        });
        self2.on("item_add", (value) => {
          var option = self2.getOption(value);
          if (option) {
            UpdateCheckbox(option);
          }
        });
        self2.hook("instead", "onOptionSelect", (evt, option) => {
          if (option.classList.contains("selected")) {
            option.classList.remove("selected");
            self2.removeItem(option.dataset.value);
            self2.refreshOptions();
            preventDefault(evt, true);
            return;
          }
          orig_onOptionSelect.call(self2, evt, option);
          UpdateCheckbox(option);
        });
      }
      function clear_button(userOptions) {
        const self2 = this;
        const options = Object.assign({
          className: "clear-button",
          title: "Clear All",
          html: (data3) => {
            return `<div class="${data3.className}" title="${data3.title}">&#10799;</div>`;
          }
        }, userOptions);
        self2.on("initialize", () => {
          var button = getDom(options.html(options));
          button.addEventListener("click", (evt) => {
            if (self2.isDisabled) {
              return;
            }
            self2.clear();
            if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
              self2.addItem("");
            }
            evt.preventDefault();
            evt.stopPropagation();
          });
          self2.control.appendChild(button);
        });
      }
      function drag_drop() {
        var self2 = this;
        if (!$.fn.sortable)
          throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
        if (self2.settings.mode !== "multi")
          return;
        var orig_lock = self2.lock;
        var orig_unlock = self2.unlock;
        self2.hook("instead", "lock", () => {
          var sortable = $(self2.control).data("sortable");
          if (sortable)
            sortable.disable();
          return orig_lock.call(self2);
        });
        self2.hook("instead", "unlock", () => {
          var sortable = $(self2.control).data("sortable");
          if (sortable)
            sortable.enable();
          return orig_unlock.call(self2);
        });
        self2.on("initialize", () => {
          var $control = $(self2.control).sortable({
            items: "[data-value]",
            forcePlaceholderSize: true,
            disabled: self2.isLocked,
            start: (e, ui) => {
              ui.placeholder.css("width", ui.helper.css("width"));
              $control.css({
                overflow: "visible"
              });
            },
            stop: () => {
              $control.css({
                overflow: "hidden"
              });
              var values = [];
              $control.children("[data-value]").each(function() {
                if (this.dataset.value)
                  values.push(this.dataset.value);
              });
              self2.setValue(values);
            }
          });
        });
      }
      function dropdown_header(userOptions) {
        const self2 = this;
        const options = Object.assign({
          title: "Untitled",
          headerClass: "dropdown-header",
          titleRowClass: "dropdown-header-title",
          labelClass: "dropdown-header-label",
          closeClass: "dropdown-header-close",
          html: (data3) => {
            return '<div class="' + data3.headerClass + '"><div class="' + data3.titleRowClass + '"><span class="' + data3.labelClass + '">' + data3.title + '</span><a class="' + data3.closeClass + '">&times;</a></div></div>';
          }
        }, userOptions);
        self2.on("initialize", () => {
          var header = getDom(options.html(options));
          var close_link = header.querySelector("." + options.closeClass);
          if (close_link) {
            close_link.addEventListener("click", (evt) => {
              preventDefault(evt, true);
              self2.close();
            });
          }
          self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
        });
      }
      function caret_position() {
        var self2 = this;
        self2.hook("instead", "setCaret", (new_pos) => {
          if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
            new_pos = self2.items.length;
          } else {
            new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
            if (new_pos != self2.caretPos && !self2.isPending) {
              self2.controlChildren().forEach((child, j) => {
                if (j < new_pos) {
                  self2.control_input.insertAdjacentElement("beforebegin", child);
                } else {
                  self2.control.appendChild(child);
                }
              });
            }
          }
          self2.caretPos = new_pos;
        });
        self2.hook("instead", "moveCaret", (direction) => {
          if (!self2.isFocused)
            return;
          const last_active = self2.getLastActive(direction);
          if (last_active) {
            const idx = nodeIndex(last_active);
            self2.setCaret(direction > 0 ? idx + 1 : idx);
            self2.setActiveItem();
            removeClasses(last_active, "last-active");
          } else {
            self2.setCaret(self2.caretPos + direction);
          }
        });
      }
      function dropdown_input() {
        const self2 = this;
        self2.settings.shouldOpen = true;
        self2.hook("before", "setup", () => {
          self2.focus_node = self2.control;
          addClasses(self2.control_input, "dropdown-input");
          const div = getDom('<div class="dropdown-input-wrap">');
          div.append(self2.control_input);
          self2.dropdown.insertBefore(div, self2.dropdown.firstChild);
          const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
          placeholder.placeholder = self2.settings.placeholder || "";
          self2.control.append(placeholder);
        });
        self2.on("initialize", () => {
          self2.control_input.addEventListener("keydown", (evt) => {
            switch (evt.keyCode) {
              case KEY_ESC:
                if (self2.isOpen) {
                  preventDefault(evt, true);
                  self2.close();
                }
                self2.clearActiveItems();
                return;
              case KEY_TAB:
                self2.focus_node.tabIndex = -1;
                break;
            }
            return self2.onKeyDown.call(self2, evt);
          });
          self2.on("blur", () => {
            self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
          });
          self2.on("dropdown_open", () => {
            self2.control_input.focus();
          });
          const orig_onBlur = self2.onBlur;
          self2.hook("instead", "onBlur", (evt) => {
            if (evt && evt.relatedTarget == self2.control_input)
              return;
            return orig_onBlur.call(self2);
          });
          addEvent(self2.control_input, "blur", () => self2.onBlur());
          self2.hook("before", "close", () => {
            if (!self2.isOpen)
              return;
            self2.focus_node.focus({
              preventScroll: true
            });
          });
        });
      }
      function input_autogrow() {
        var self2 = this;
        self2.on("initialize", () => {
          var test_input = document.createElement("span");
          var control = self2.control_input;
          test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
          self2.wrapper.appendChild(test_input);
          var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
          for (const style_name of transfer_styles) {
            test_input.style[style_name] = control.style[style_name];
          }
          var resize = () => {
            test_input.textContent = control.value;
            control.style.width = test_input.clientWidth + "px";
          };
          resize();
          self2.on("update item_add item_remove", resize);
          addEvent(control, "input", resize);
          addEvent(control, "keyup", resize);
          addEvent(control, "blur", resize);
          addEvent(control, "update", resize);
        });
      }
      function no_backspace_delete() {
        var self2 = this;
        var orig_deleteSelection = self2.deleteSelection;
        this.hook("instead", "deleteSelection", (evt) => {
          if (self2.activeItems.length) {
            return orig_deleteSelection.call(self2, evt);
          }
          return false;
        });
      }
      function no_active_items() {
        this.hook("instead", "setActiveItem", () => {
        });
        this.hook("instead", "selectAll", () => {
        });
      }
      function optgroup_columns() {
        var self2 = this;
        var orig_keydown = self2.onKeyDown;
        self2.hook("instead", "onKeyDown", (evt) => {
          var index, option, options, optgroup;
          if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
            return orig_keydown.call(self2, evt);
          }
          self2.ignoreHover = true;
          optgroup = parentMatch(self2.activeOption, "[data-group]");
          index = nodeIndex(self2.activeOption, "[data-selectable]");
          if (!optgroup) {
            return;
          }
          if (evt.keyCode === KEY_LEFT) {
            optgroup = optgroup.previousSibling;
          } else {
            optgroup = optgroup.nextSibling;
          }
          if (!optgroup) {
            return;
          }
          options = optgroup.querySelectorAll("[data-selectable]");
          option = options[Math.min(options.length - 1, index)];
          if (option) {
            self2.setActiveOption(option);
          }
        });
      }
      function remove_button(userOptions) {
        const options = Object.assign({
          label: "&times;",
          title: "Remove",
          className: "remove",
          append: true
        }, userOptions);
        var self2 = this;
        if (!options.append) {
          return;
        }
        var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
        self2.hook("after", "setupTemplates", () => {
          var orig_render_item = self2.settings.render.item;
          self2.settings.render.item = (data3, escape) => {
            var item = getDom(orig_render_item.call(self2, data3, escape));
            var close_button = getDom(html);
            item.appendChild(close_button);
            addEvent(close_button, "mousedown", (evt) => {
              preventDefault(evt, true);
            });
            addEvent(close_button, "click", (evt) => {
              preventDefault(evt, true);
              if (self2.isLocked)
                return;
              if (!self2.shouldDelete([item], evt))
                return;
              self2.removeItem(item);
              self2.refreshOptions(false);
              self2.inputState();
            });
            return item;
          };
        });
      }
      function restore_on_backspace(userOptions) {
        const self2 = this;
        const options = Object.assign({
          text: (option) => {
            return option[self2.settings.labelField];
          }
        }, userOptions);
        self2.on("item_remove", function(value) {
          if (!self2.isFocused) {
            return;
          }
          if (self2.control_input.value.trim() === "") {
            var option = self2.options[value];
            if (option) {
              self2.setTextboxValue(options.text.call(self2, option));
            }
          }
        });
      }
      function virtual_scroll() {
        const self2 = this;
        const orig_canLoad = self2.canLoad;
        const orig_clearActiveOption = self2.clearActiveOption;
        const orig_loadCallback = self2.loadCallback;
        var pagination = {};
        var dropdown_content;
        var loading_more = false;
        var load_more_opt;
        var default_values = [];
        if (!self2.settings.shouldLoadMore) {
          self2.settings.shouldLoadMore = () => {
            const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
            if (scroll_percent > 0.9) {
              return true;
            }
            if (self2.activeOption) {
              var selectable = self2.selectable();
              var index = Array.from(selectable).indexOf(self2.activeOption);
              if (index >= selectable.length - 2) {
                return true;
              }
            }
            return false;
          };
        }
        if (!self2.settings.firstUrl) {
          throw "virtual_scroll plugin requires a firstUrl() method";
        }
        self2.settings.sortField = [{
          field: "$order"
        }, {
          field: "$score"
        }];
        const canLoadMore = (query) => {
          if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
            return false;
          }
          if (query in pagination && pagination[query]) {
            return true;
          }
          return false;
        };
        const clearFilter = (option, value) => {
          if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
            return true;
          }
          return false;
        };
        self2.setNextUrl = (value, next_url) => {
          pagination[value] = next_url;
        };
        self2.getUrl = (query) => {
          if (query in pagination) {
            const next_url = pagination[query];
            pagination[query] = false;
            return next_url;
          }
          pagination = {};
          return self2.settings.firstUrl.call(self2, query);
        };
        self2.hook("instead", "clearActiveOption", () => {
          if (loading_more) {
            return;
          }
          return orig_clearActiveOption.call(self2);
        });
        self2.hook("instead", "canLoad", (query) => {
          if (!(query in pagination)) {
            return orig_canLoad.call(self2, query);
          }
          return canLoadMore(query);
        });
        self2.hook("instead", "loadCallback", (options, optgroups2) => {
          if (!loading_more) {
            self2.clearOptions(clearFilter);
          } else if (load_more_opt) {
            const first_option = options[0];
            if (first_option !== void 0) {
              load_more_opt.dataset.value = first_option[self2.settings.valueField];
            }
          }
          orig_loadCallback.call(self2, options, optgroups2);
          loading_more = false;
        });
        self2.hook("after", "refreshOptions", () => {
          const query = self2.lastValue;
          var option;
          if (canLoadMore(query)) {
            option = self2.render("loading_more", {
              query
            });
            if (option) {
              option.setAttribute("data-selectable", "");
              load_more_opt = option;
            }
          } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
            option = self2.render("no_more_results", {
              query
            });
          }
          if (option) {
            addClasses(option, self2.settings.optionClass);
            dropdown_content.append(option);
          }
        });
        self2.on("initialize", () => {
          default_values = Object.keys(self2.options);
          dropdown_content = self2.dropdown_content;
          self2.settings.render = Object.assign({}, {
            loading_more: () => {
              return `<div class="loading-more-results">Loading more results ... </div>`;
            },
            no_more_results: () => {
              return `<div class="no-more-results">No more results</div>`;
            }
          }, self2.settings.render);
          dropdown_content.addEventListener("scroll", () => {
            if (!self2.settings.shouldLoadMore.call(self2)) {
              return;
            }
            if (!canLoadMore(self2.lastValue)) {
              return;
            }
            if (loading_more)
              return;
            loading_more = true;
            self2.load.call(self2, self2.lastValue);
          });
        });
      }
      TomSelect3.define("change_listener", change_listener);
      TomSelect3.define("checkbox_options", checkbox_options);
      TomSelect3.define("clear_button", clear_button);
      TomSelect3.define("drag_drop", drag_drop);
      TomSelect3.define("dropdown_header", dropdown_header);
      TomSelect3.define("caret_position", caret_position);
      TomSelect3.define("dropdown_input", dropdown_input);
      TomSelect3.define("input_autogrow", input_autogrow);
      TomSelect3.define("no_backspace_delete", no_backspace_delete);
      TomSelect3.define("no_active_items", no_active_items);
      TomSelect3.define("optgroup_columns", optgroup_columns);
      TomSelect3.define("remove_button", remove_button);
      TomSelect3.define("restore_on_backspace", restore_on_backspace);
      TomSelect3.define("virtual_scroll", virtual_scroll);
      return TomSelect3;
    });
  }
});

// node_modules/alpinejs/dist/module.esm.js
var flushPending = false;
var flushing = false;
var queue = [];
var lastFlushedIndex = -1;
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  let index = queue.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex)
    queue.splice(index, 1);
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i = 0; i < queue.length; i++) {
    queue[i]();
    lastFlushedIndex = i;
  }
  queue.length = 0;
  lastFlushedIndex = -1;
  flushing = false;
}
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  } });
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup22 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i) => i());
      };
    }
    el._x_effects.add(effectReference);
    cleanup22 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup22();
  }];
}
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      // Allows events to pass the shadow DOM barrier.
      composed: true,
      cancelable: true
    })
  );
}
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback, false);
    node = node.nextElementSibling;
  }
}
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started = false;
function start() {
  if (started)
    warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started = true;
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
var initInterceptors = [];
function interceptInit(callback) {
  initInterceptors.push(callback);
}
function initTree(el, walker = walk, intercept = () => {
}) {
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      intercept(el2, skip);
      initInterceptors.forEach((i) => i(el2, skip));
      directives(el2, el2.attributes).forEach((handle) => handle());
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root) {
  walk(root, (el) => {
    cleanupAttributes(el);
    cleanupElement(el);
  });
}
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds.push(callback);
  }
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i) => i());
      delete el._x_attributeCleanups[name];
    }
  });
}
function cleanupElement(el) {
  if (el._x_cleanups) {
    while (el._x_cleanups.length)
      el._x_cleanups.pop()();
  }
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var recordQueue = [];
var willProcessRecordQueue = false;
function flushObserver() {
  recordQueue = recordQueue.concat(observer.takeRecords());
  if (recordQueue.length && !willProcessRecordQueue) {
    willProcessRecordQueue = true;
    queueMicrotask(() => {
      processRecordQueue();
      willProcessRecordQueue = false;
    });
  }
}
function processRecordQueue() {
  onMutate(recordQueue);
  recordQueue.length = 0;
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = [];
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i = 0; i < mutations.length; i++) {
    if (mutations[i].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i].type === "childList") {
      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
    }
    if (mutations[i].type === "attributes") {
      let el = mutations[i].target;
      let name = mutations[i].attributeName;
      let oldValue = mutations[i].oldValue;
      let add22 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add22();
      } else if (el.hasAttribute(name)) {
        remove();
        add22();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i) => i(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.includes(node))
      continue;
    onElRemoveds.forEach((i) => i(node));
    destroyTree(node);
  }
  addedNodes.forEach((node) => {
    node._x_ignoreSelf = true;
    node._x_ignore = true;
  });
  for (let node of addedNodes) {
    if (removedNodes.includes(node))
      continue;
    if (!node.isConnected)
      continue;
    delete node._x_ignoreSelf;
    delete node._x_ignore;
    onElAddeds.forEach((i) => i(node));
    node._x_ignore = true;
    node._x_ignoreSelf = true;
  }
  addedNodes.forEach((node) => {
    delete node._x_ignoreSelf;
    delete node._x_ignore;
  });
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data22, referenceNode) {
  node._x_dataStack = [data22, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i) => i !== data22);
  };
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  let thisProxy = new Proxy({}, {
    ownKeys: () => {
      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
    },
    has: (target, name) => {
      return objects.some((obj) => obj.hasOwnProperty(name));
    },
    get: (target, name) => {
      return (objects.find((obj) => {
        if (obj.hasOwnProperty(name)) {
          let descriptor = Object.getOwnPropertyDescriptor(obj, name);
          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
            return true;
          }
          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
            let getter = descriptor.get;
            let setter = descriptor.set;
            let property = descriptor;
            getter = getter && getter.bind(thisProxy);
            setter = setter && setter.bind(thisProxy);
            if (getter)
              getter._x_alreadyBound = true;
            if (setter)
              setter._x_alreadyBound = true;
            Object.defineProperty(obj, name, {
              ...property,
              get: getter,
              set: setter
            });
          }
          return true;
        }
        return false;
      }) || {})[name];
    },
    set: (target, name, value) => {
      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
      if (closestObjectWithKey) {
        closestObjectWithKey[name] = value;
      } else {
        objects[objects.length - 1][name] = value;
      }
      return true;
    }
  });
  return thisProxy;
}
function initInterceptors2(data22) {
  let isObject22 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data22, path, key);
      } else {
        if (isObject22(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data22);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data22, path, key) {
      return callback(this.initialValue, () => get(data22, path), (value) => set(data22, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data22, path, key) => {
        let innerValue = initialValue.initialize(data22, path, key);
        obj.initialValue = innerValue;
        return initialize(data22, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  Object.entries(magics).forEach(([name, callback]) => {
    let memoizedUtilities = null;
    function getUtilities() {
      if (memoizedUtilities) {
        return memoizedUtilities;
      } else {
        let [utilities, cleanup22] = getElementBoundUtilities(el);
        memoizedUtilities = { interceptor, ...utilities };
        onElRemoved(el, cleanup22);
        return memoizedUtilities;
      }
    }
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, getUtilities());
      },
      enumerable: false
    });
  });
  return obj;
}
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e) {
    handleError(e, el, expression);
  }
}
function handleError(error22, el, expression = void 0) {
  Object.assign(error22, { el, expression });
  console.warn(`Alpine Expression Error: ${error22.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error22;
  }, 0);
}
var shouldAutoEvaluateFunctions = true;
function dontAutoEvaluateFunctions(callback) {
  let cache4 = shouldAutoEvaluateFunctions;
  shouldAutoEvaluateFunctions = false;
  let result = callback();
  shouldAutoEvaluateFunctions = cache4;
  return result;
}
function evaluate(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope22 = {}, params = [] } = {}) => {
    let result = func.apply(mergeProxies([scope22, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
    } catch (error22) {
      handleError(error22, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, { scope: scope22 = {}, params = [] } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope22, ...dataStack]);
    if (typeof func === "function") {
      let promise = func(func, completeScope).catch((error22) => handleError(error22, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error22) => handleError(error22, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope22, params, el) {
  if (shouldAutoEvaluateFunctions && typeof value === "function") {
    let result = value.apply(scope22, params);
    if (result instanceof Promise) {
      result.then((i) => runIfTypeOfFunction(receiver, i, scope22, params)).catch((error22) => handleError(error22, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i) => receiver(i));
  } else {
    receiver(value);
  }
}
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
  return {
    before(directive22) {
      if (!directiveHandlers[directive22]) {
        console.warn(
          "Cannot find directive `${directive}`. `${name}` will use the default order of execution"
        );
        return;
      }
      const pos = directiveOrder.indexOf(directive22);
      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directives(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives22 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives22.map((directive22) => {
    return getDirectiveHandler(el, directive22);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = /* @__PURE__ */ new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities(el) {
  let cleanups = [];
  let cleanup22 = (callback) => cleanups.push(callback);
  let [effect32, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect32,
    cleanup: cleanup22,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate.bind(evaluate, el)
  };
  let doCleanup = () => cleanups.forEach((i) => i());
  return [utilities, doCleanup];
}
function getDirectiveHandler(el, directive22) {
  let noop7 = () => {
  };
  let handler42 = directiveHandlers[directive22.type] || noop7;
  let [utilities, cleanup22] = getElementBoundUtilities(el);
  onAttributeRemoved(el, directive22.original, cleanup22);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler42.inline && handler42.inline(el, directive22, utilities);
    handler42 = handler42.bind(handler42, el, directive22, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler42) : handler42();
  };
  fullHandler.runCleanups = cleanup22;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into = (i) => i;
function toTransformedAttributes(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform2) => {
      return transform2(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({ name }) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i) => i.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport"
];
function byPriority(a, b) {
  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}
var tickStack = [];
var isHolding = false;
function nextTick(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
  return new Promise((res2) => {
    tickStack.push(() => {
      callback();
      res2();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let split = (classString2) => classString2.split(" ").filter(Boolean);
  let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i) => {
    if (el.classList.contains(i)) {
      el.classList.remove(i);
      removed.push(i);
    }
  });
  forAdd.forEach((i) => {
    if (!el.classList.contains(i)) {
      el.classList.add(i);
      added.push(i);
    }
  });
  return () => {
    removed.forEach((i) => el.classList.add(i));
    added.forEach((i) => el.classList.remove(i));
  };
}
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache4 = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache4 || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate22 }) => {
  if (typeof expression === "function")
    expression = evaluate22(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    "enter": (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    "leave": (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
  let delay = modifierValue(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick22 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick22(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve2, reject) => {
    el._x_transition.out(() => {
    }, () => resolve2(hide));
    el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick22(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i]) => i());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e) => {
          if (!e.isFromCancelledTransition)
            throw e;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, { during, start: start22, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start22).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start22);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      ;
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay);
      reachedEnd = true;
    });
  });
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function onlyDuringClone(callback) {
  return (...args) => isCloning && callback(...args);
}
function cloneNode(from, to) {
  if (from._x_dataStack) {
    to._x_dataStack = from._x_dataStack;
    to.setAttribute("data-has-alpine-state", true);
  }
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    initTree(to, (el, callback) => {
      callback(el, () => {
      });
    });
  });
  isCloning = false;
}
var isCloningLegacy = false;
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  isCloningLegacy = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
  isCloningLegacy = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache4 = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache4(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache4);
}
function shouldSkipRegisteringDataDuringClone(el) {
  if (!isCloning)
    return false;
  if (isCloningLegacy)
    return true;
  return el.hasAttribute("data-has-alpine-state");
}
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty(el, name, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (el.type === "radio") {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      el.checked = checkedAttrLooseCompare(el.value, value);
    }
  } else if (el.type === "checkbox") {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value === void 0 ? "" : value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttributeAndProperty(el, name, value) {
  bindAttribute(el, name, value);
  setPropertyIfChanged(el, name, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function isBooleanAttr(attrName) {
  const booleanAttributes = [
    "disabled",
    "checked",
    "required",
    "readonly",
    "hidden",
    "open",
    "selected",
    "autofocus",
    "itemscope",
    "multiple",
    "novalidate",
    "allowfullscreen",
    "allowpaymentrequest",
    "formnovalidate",
    "autoplay",
    "controls",
    "loop",
    "muted",
    "playsinline",
    "default",
    "ismap",
    "reversed",
    "async",
    "defer",
    "nomodule"
  ];
  return booleanAttributes.includes(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding(el, name, fallback);
}
function extractProp(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions(() => {
      return evaluate(el, binding.expression);
    });
  }
  return getAttributeBinding(el, name, fallback);
}
function getAttributeBinding(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash, innerHash, outerHashLatest, innerHashLatest;
  let reference = effect(() => {
    let outer, inner;
    if (firstRun) {
      outer = outerGet();
      innerSet(JSON.parse(JSON.stringify(outer)));
      inner = innerGet();
      firstRun = false;
    } else {
      outer = outerGet();
      inner = innerGet();
      outerHashLatest = JSON.stringify(outer);
      innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        inner = innerGet();
        innerSet(outer);
        inner = outer;
      } else {
        outerSet(JSON.parse(innerHashLatest ?? null));
        outer = inner;
      }
    }
    outerHash = JSON.stringify(outer);
    innerHash = JSON.stringify(inner);
  });
  return () => {
    release(reference);
  };
}
function plugin(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i) => i(alpine_default));
}
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
  initInterceptors2(stores[name]);
}
function getStores() {
  return stores;
}
var binds = {};
function bind2(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    return applyBindingsObject(name, getBindings());
  } else {
    binds[name] = getBindings;
  }
  return () => {
  };
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives(el, attributes, original).map((handle) => {
    cleanupRunners.push(handle.runCleanups);
    handle();
  });
  return () => {
    while (cleanupRunners.length)
      cleanupRunners.pop()();
  };
}
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine2 = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.13.0",
  flushAndStopDeferringMutations,
  dontAutoEvaluateFunctions,
  disableEffectScheduling,
  startObservingMutations,
  stopObservingMutations,
  setReactivityEngine,
  onAttributeRemoved,
  onAttributesAdded,
  closestDataStack,
  skipDuringClone,
  onlyDuringClone,
  addRootSelector,
  addInitSelector,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  interceptInit,
  setEvaluator,
  mergeProxies,
  extractProp,
  findClosest,
  onElRemoved,
  closestRoot,
  destroyTree,
  interceptor,
  // INTERNAL: not public API and is subject to change without major release.
  transition,
  // INTERNAL
  setStyles,
  // INTERNAL
  mutateDom,
  directive,
  entangle,
  throttle,
  debounce,
  evaluate,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  // INTERNAL
  cloneNode,
  // INTERNAL
  bound: getBinding,
  $data: scope,
  walk,
  data,
  bind: bind2
};
var alpine_default = Alpine2;
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction = (fn) => {
  const cache4 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache4[str];
    return hit || (cache4[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap = /* @__PURE__ */ new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol(true ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
function isEffect(fn) {
  return fn && fn._isEffect === true;
}
function effect2(fn, options = EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }
  const effect32 = createReactiveEffect(fn, options);
  if (!options.lazy) {
    effect32();
  }
  return effect32;
}
function stop(effect32) {
  if (effect32.active) {
    cleanup(effect32);
    if (effect32.options.onStop) {
      effect32.options.onStop();
    }
    effect32.active = false;
  }
}
var uid = 0;
function createReactiveEffect(fn, options) {
  const effect32 = function reactiveEffect() {
    if (!effect32.active) {
      return fn();
    }
    if (!effectStack.includes(effect32)) {
      cleanup(effect32);
      try {
        enableTracking();
        effectStack.push(effect32);
        activeEffect = effect32;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };
  effect32.id = uid++;
  effect32.allowRecurse = !!options.allowRecurse;
  effect32._isEffect = true;
  effect32.active = true;
  effect32.raw = fn;
  effect32.deps = [];
  effect32.options = options;
  return effect32;
}
function cleanup(effect32) {
  const { deps } = effect32;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect32);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!shouldTrack || activeEffect === void 0) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add22 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect32) => {
        if (effect32 !== activeEffect || effect32.allowRecurse) {
          effects.add(effect32);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add22);
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add22(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add22(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          add22(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add22(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          add22(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          add22(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add22(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          add22(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const run = (effect32) => {
    if (effect32.options.onTrigger) {
      effect32.options.onTrigger({
        effect: effect32,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect32.options.scheduler) {
      effect32.options.scheduler(effect32);
    } else {
      effect32();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
var get2 = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res2 = arr[key](...args);
      if (res2 === -1 || res2 === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res2;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res2 = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res2;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get32(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res2 = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res2;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res2;
    }
    if (isRef(res2)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res2.value : res2;
    }
    if (isObject(res2)) {
      return isReadonly ? readonly(res2) : reactive2(res2);
    }
    return res2;
  };
}
var set2 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set32(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get2,
  set: set2,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (true) {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (true) {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => isObject(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const { has: has22 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has22.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has22.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has22, get: get32 } = getProto(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has22.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has22, key);
  }
  const oldValue = get32.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has22, get: get32 } = getProto(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has22.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has22, key);
  }
  const oldValue = get32 ? get32.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach5(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations22 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations22 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations22 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations22 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods2 = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods2.forEach((method) => {
    mutableInstrumentations22[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations22[method] = createIterableMethod(method, true, false);
    shallowInstrumentations22[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations22[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations22,
    readonlyInstrumentations22,
    shallowInstrumentations22,
    shallowReadonlyInstrumentations22
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has22, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has22.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (target && target[
    "__v_isReadonly"
    /* IS_READONLY */
  ]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* RAW */
  ] && !(isReadonly && target[
    "__v_isReactive"
    /* IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  return observed && toRaw(observed[
    "__v_raw"
    /* RAW */
  ]) || observed;
}
function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}
magic("nextTick", () => nextTick);
magic("dispatch", (el) => dispatch.bind(dispatch, el));
magic("watch", (el, { evaluateLater: evaluateLater22, effect: effect32 }) => (key, callback) => {
  let evaluate22 = evaluateLater22(key);
  let firstTime = true;
  let oldValue;
  let effectReference = effect32(() => evaluate22((value) => {
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  }));
  el._x_effects.delete(effectReference);
});
magic("store", getStores);
magic("data", (el) => scope(el));
magic("root", (el) => closestRoot(el));
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  let currentEl = el;
  while (currentEl) {
    if (currentEl._x_refs)
      refObjects.push(currentEl._x_refs);
    currentEl = currentEl.parentNode;
  }
  return refObjects;
}
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}
magic("id", (el) => (name, key = null) => {
  let root = closestIdRoot(el, name);
  let id = root ? root._x_ids[name] : findAndIncrementId(name);
  return key ? `${name}-${id}-${key}` : `${name}-${id}`;
});
magic("el", (el) => el);
warnMissingPluginMagic("Focus", "focus", "focus");
warnMissingPluginMagic("Persist", "persist", "persist");
function warnMissingPluginMagic(name, magicName, slug) {
  magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
directive("modelable", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22, cleanup: cleanup22 }) => {
  let func = evaluateLater22(expression);
  let innerGet = () => {
    let result;
    func((i) => result = i);
    return result;
  };
  let evaluateInnerSet = evaluateLater22(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { "__placeholder": val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle(
      {
        get() {
          return outerGet();
        },
        set(value) {
          outerSet(value);
        }
      },
      {
        get() {
          return innerGet();
        },
        set(value) {
          innerSet(value);
        }
      }
    );
    cleanup22(releaseEntanglement);
  });
});
var teleportContainerDuringClone = document.createElement("div");
directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup22 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = skipDuringClone(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone;
  })();
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  let clone22 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone22;
  clone22._x_teleportBack = el;
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone22.addEventListener(eventName, (e) => {
        e.stopPropagation();
        el.dispatchEvent(new e.constructor(e.type, e));
      });
    });
  }
  addScopeToNode(clone22, {}, el);
  mutateDom(() => {
    if (modifiers.includes("prepend")) {
      target.parentNode.insertBefore(clone22, target);
    } else if (modifiers.includes("append")) {
      target.parentNode.insertBefore(clone22, target.nextSibling);
    } else {
      target.appendChild(clone22);
    }
    initTree(clone22);
    clone22._x_ignore = true;
  });
  cleanup22(() => clone22.remove());
});
var handler = () => {
};
handler.inline = (el, { modifiers }, { cleanup: cleanup22 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup22(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);
directive("effect", (el, { expression }, { effect: effect32 }) => effect32(evaluateLater(el, expression)));
function on(el, event, modifiers, callback) {
  let listenerTarget = el;
  let handler42 = (e) => callback(e);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
  if (modifiers.includes("dot"))
    event = dotSyntax(event);
  if (modifiers.includes("camel"))
    event = camelCase2(event);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler42 = debounce(handler42, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler42 = throttle(handler42, wait);
  }
  if (modifiers.includes("prevent"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.preventDefault();
      next(e);
    });
  if (modifiers.includes("stop"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.stopPropagation();
      next(e);
    });
  if (modifiers.includes("self"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.target === el && next(e);
    });
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler42 = wrapHandler(handler42, (next, e) => {
      if (el.contains(e.target))
        return;
      if (e.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e);
    });
  }
  if (modifiers.includes("once")) {
    handler42 = wrapHandler(handler42, (next, e) => {
      next(e);
      listenerTarget.removeEventListener(event, handler42, options);
    });
  }
  handler42 = wrapHandler(handler42, (next, e) => {
    if (isKeyEvent(event)) {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
        return;
      }
    }
    next(e);
  });
  listenerTarget.addEventListener(event, handler42, options);
  return () => {
    listenerTarget.removeEventListener(event, handler42, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  if ([" ", "_"].includes(
    subject
  ))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event) {
  return ["keydown", "keyup"].includes(event);
}
function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
  let keyModifiers = modifiers.filter((i) => {
    return !["window", "document", "prevent", "stop", "once", "capture"].includes(i);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (keyToModifiers(e.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    "ctrl": "control",
    "slash": "/",
    "space": " ",
    "spacebar": " ",
    "cmd": "meta",
    "esc": "escape",
    "up": "arrow-up",
    "down": "arrow-down",
    "left": "arrow-left",
    "right": "arrow-right",
    "period": ".",
    "equal": "=",
    "minus": "-",
    "underscore": "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive("model", (el, { modifiers, expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue2 = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { "__placeholder": value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning ? () => {
  } : on(el, event, modifiers, (e) => {
    setValue(getInputValue(el, modifiers, e, getValue2()));
  });
  if (modifiers.includes("fill")) {
    if ([null, ""].includes(getValue2()) || el.type === "checkbox" && Array.isArray(getValue2())) {
      el.dispatchEvent(new Event(event, {}));
    }
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup22(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on(el.form, "reset", [], (e) => {
      nextTick(() => el._x_model && el._x_model.set(el.value));
    });
    cleanup22(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue2();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom(() => bind(el, "value", value));
    delete window.fromModel;
  };
  effect32(() => {
    let value = getValue2();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue(el, modifiers, event, currentValue) {
  return mutateDom(() => {
    if (event instanceof CustomEvent && event.detail !== void 0)
      return event.detail ?? event.target.value;
    else if (el.type === "checkbox") {
      if (Array.isArray(currentValue)) {
        let newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;
        return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
      } else {
        return event.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
        let rawValue = option.value || option.text;
        return safeParseNumber(rawValue);
      }) : Array.from(event.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let rawValue = event.target.value;
      return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
    }
  });
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate22 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate22(expression, {}, false);
  }
  return evaluate22(expression, {}, false);
}));
directive("text", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22 }) => {
  let evaluate22 = evaluateLater22(expression);
  effect32(() => {
    evaluate22((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});
directive("html", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22 }) => {
  let evaluate22 = evaluateLater22(expression);
  effect32(() => {
    evaluate22((value) => {
      mutateDom(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes(startingWith(":", into(prefix("bind:"))));
var handler2 = (el, { value, modifiers, expression, original }, { effect: effect32 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    getBindings((bindings) => {
      applyBindingsObject(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate22 = evaluateLater(el, expression);
  effect32(() => evaluate22((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom(() => bind(el, value, result, modifiers));
  }));
};
handler2.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive("bind", handler2);
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector(() => `[${prefix("data")}]`);
directive("data", (el, { expression }, { cleanup: cleanup22 }) => {
  if (shouldSkipRegisteringDataDuringClone(el))
    return;
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data22 = evaluate(el, expression, { scope: dataProviderContext });
  if (data22 === void 0 || data22 === true)
    data22 = {};
  injectMagics(data22, el);
  let reactiveData = reactive(data22);
  initInterceptors2(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate(el, reactiveData["init"]);
  cleanup22(() => {
    reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
    undo();
  });
});
directive("show", (el, { modifiers, expression }, { effect: effect32 }) => {
  let evaluate22 = evaluateLater(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once(
    (value) => value ? show() : hide(),
    (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    }
  );
  let oldValue;
  let firstTime = true;
  effect32(() => evaluate22((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive("for", (el, { expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(
    el,
    // the x-bind:key expression is stored for our use instead of evaluated.
    el._x_keyExpression || "index"
  );
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect32(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup22(() => {
    Object.values(el._x_lookup).forEach((el2) => el2.remove());
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject22 = (i) => typeof i === "object" && !Array.isArray(i);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i) => i + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject22(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope22 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope22 } });
        scopes.push(scope22);
      });
    } else {
      for (let i = 0; i < items.length; i++) {
        let scope22 = getIterationScopeVariables(iteratorNames, items[i], i, items);
        evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope22 } });
        scopes.push(scope22);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i = 0; i < prevKeys.length; i++) {
      let key = prevKeys[i];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i, 0, key);
        adds.push([lastKey, i]);
      } else if (prevIndex !== i) {
        let keyInSpot = prevKeys.splice(i, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i = 0; i < removes.length; i++) {
      let key = removes[i];
      if (!!lookup[key]._x_effects) {
        lookup[key]._x_effects.forEach(dequeueJob);
      }
      lookup[key].remove();
      lookup[key] = null;
      delete lookup[key];
    }
    for (let i = 0; i < moves.length; i++) {
      let [keyInSpot, keyForSpot] = moves[i];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        if (!elForSpot)
          warn(`x-for ":key" is undefined or invalid`, templateEl);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i = 0; i < adds.length; i++) {
      let [lastKey2, index] = adds[i];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope22 = scopes[index];
      let key = keys[index];
      let clone22 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive(scope22);
      addScopeToNode(clone22, reactiveScope, templateEl);
      clone22._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom(() => {
        lastEl.after(clone22);
        initTree(clone22);
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone22;
    }
    for (let i = 0; i < sames.length; i++) {
      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res2 = {};
  res2.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res2.item = item.replace(forIteratorRE, "").trim();
    res2.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res2.collection = iteratorMatch[2].trim();
    }
  } else {
    res2.item = item;
  }
  return res2;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
    names.forEach((name, i) => {
      scopeVariables[name] = item[i];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler3() {
}
handler3.inline = (el, { expression }, { cleanup: cleanup22 }) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup22(() => delete root._x_refs[expression]);
};
directive("ref", handler3);
directive("if", (el, { expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let evaluate22 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone22 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone22, {}, el);
    mutateDom(() => {
      el.after(clone22);
      initTree(clone22);
    });
    el._x_currentIfEl = clone22;
    el._x_undoIf = () => {
      walk(clone22, (node) => {
        if (!!node._x_effects) {
          node._x_effects.forEach(dequeueJob);
        }
      });
      clone22.remove();
      delete el._x_currentIfEl;
    };
    return clone22;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect32(() => evaluate22((value) => {
    value ? show() : hide();
  }));
  cleanup22(() => el._x_undoIf && el._x_undoIf());
});
directive("id", (el, { expression }, { evaluate: evaluate22 }) => {
  let names = evaluate22(expression);
  names.forEach((name) => setIdRoot(el, name));
});
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup22 }) => {
  let evaluate22 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e) => {
    evaluate22(() => {
    }, { scope: { "$event": e }, params: [e] });
  });
  cleanup22(() => removeListener());
}));
warnMissingPluginDirective("Collapse", "collapse", "collapse");
warnMissingPluginDirective("Intersect", "intersect", "intersect");
warnMissingPluginDirective("Focus", "trap", "focus");
warnMissingPluginDirective("Mask", "mask", "mask");
function warnMissingPluginDirective(name, directiveName2, slug) {
  directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default.setEvaluator(normalEvaluator);
alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
var src_default = alpine_default;
var module_default = src_default;

// src/js/components/openToast.ts
function openToastRaw(options = {}) {
  if (typeof options === "string") {
    let textmsg = options;
    options = {
      type: "info",
      text: textmsg,
      delay: 2e3,
      from: null,
      description: "",
      callback: () => {
      }
    };
  }
  let {
    type = "info",
    text = "Solicitud guardada exitosamente",
    delay = 2e3,
    from = null,
    description = "",
    callback = () => {
    }
  } = options;
  if (from)
    console.info("openToast called from " + from);
  globalThis.dispatchEvent(
    new CustomEvent("notice", {
      detail: {
        type,
        title: text,
        description,
        delay
      }
    })
  );
  if (callback) {
    setTimeout(callback, delay);
  }
}
var openToast = module_default.debounce(openToastRaw, 400);
globalThis.openToast = openToast;

// src/js/components/decorators/ErrorResponse.ts
var ErrorResponse = class extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
};

// src/js/components/decorators/staticFetchWrapper.ts
globalThis.readCookie = (name) => {
  return ((document.cookie || "").split("; ").find((row) => row.startsWith(`${name}=`)) || "").split("=")[1];
};
globalThis.setCookie = (name, value, days = 365) => {
  var expires;
  if (days) {
    var date = /* @__PURE__ */ new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
    expires = "; expires=" + date.toGMTString();
  } else {
    expires = "";
  }
  document.cookie = name + "=" + value + expires + "; path=/ ; SameSite=Lax; Secure";
};
function getTokenValue() {
  let tokenMetaValue = document.querySelector('meta[name="csrf"]') && document.querySelector('meta[name="csrf"]').content;
  let jwtMetaValue = document.querySelector('meta[name="jwt"]') && document.querySelector('meta[name="jwt"]').content;
  let tokenElementValue = document.querySelector('[name="_token"]') && document.querySelector('[name="_token"]').value;
  return tokenMetaValue || tokenElementValue;
}
function getJwtValue() {
  return document.querySelector('meta[name="jwt"]') && document.querySelector('meta[name="jwt"]').content;
}
async function staticFetchWrapper(endpoint, options) {
  let tokenValue = getTokenValue();
  const sanctumToken = document.querySelector('meta[name="test_user_token"]');
  if (!tokenValue && !sanctumToken)
    console.warn(endpoint + ": no token found (attempting anyway)");
  if (globalThis.readCookie("debug_lcdj")) {
    globalThis.setCookie("x-csrf-token", document.querySelector('meta[name="csrf"]') && document.querySelector('meta[name="csrf"]').content, 1);
  }
  let headers = {
    "Content-Type": "application/json; charset=UTF-8",
    "charset": "utf-8",
    "expect": "application/json",
    "accept": "application/json",
    ...options.headers
  };
  let jwtValue = getJwtValue();
  if (options.useJwt && jwtValue) {
    headers["Authorization"] = `Bearer ${jwtValue}`;
  } else if (sanctumToken) {
    headers["Authorization"] = `Bearer ${sanctumToken.content}`;
  } else {
    headers["X-CSRF-TOKEN"] = tokenValue;
  }
  let mergedReqInit = {
    method: options.method ?? "GET",
    headers,
    body: options.body
  };
  if (typeof options.body !== "string") {
    mergedReqInit.body = JSON.stringify(options.body);
  }
  return fetch(endpoint, mergedReqInit).then(async (res2) => {
    if (!location.href.includes("public") && !res2.ok) {
      if (res2.status == 401) {
        return location.href = "/logout";
      }
      throw new ErrorResponse(res2.statusText, res2.status);
    }
    return res2.json();
  }).catch((err) => {
    console.error(err);
    throw err;
  });
}

// src/js/components/plugins/addEditableBehavior.ts
var requestAnimationPromise = globalThis.requestAnimationPromise;

// src/js/components/DttColumn.ts
function inferDireccionAndPropietario(value = "") {
  value = value || "";
  if (!(value || "").includes(" - ") && (value || "").includes("-"))
    value = value.replace(
      /([^\s]+)\s*-\s*([^\s]+)/,
      "$1 - $2"
    );
  let valueArray = (value || "").split(" - ");
  let [
    direccion = "",
    propietario = ""
  ] = !valueArray[1] || /\d+/.test(valueArray[0]) || !/\d+/.test(valueArray[1]) ? [
    valueArray[0],
    valueArray[1]
  ] : [valueArray[1], valueArray[0]];
  return { direccion, propietario };
}
var DttColumn = class {
  constructor(options) {
    this._visible = true;
    this.input_type = "text" /* Text */;
    this.editable = true;
    const {
      name,
      data: data3,
      title,
      visible = true,
      className,
      sortable,
      render,
      width,
      targets,
      slug_name,
      input_type,
      checkbox,
      attr_type = "negocio",
      editable = true,
      is_default = false,
      ...attrs
    } = options;
    Object.entries(attrs).forEach(([attr_name, attr_value]) => {
      this[attr_name] = attr_value;
    });
    this.editable = editable;
    this.is_default = is_default;
    this.slug_name = slug_name;
    this.width = width;
    this.title = this.name = name;
    if (data3) {
      this.data = data3;
      this.field = data3;
    } else if (checkbox) {
      this.checkbox = checkbox;
    }
    this.attr_type = attr_type;
    this.title = title;
    this.visible = visible;
    this.class = this.className = className;
    this.sortable = sortable;
    this.targets = targets;
    this.input_type = input_type || "text";
    this.render = render || this.defaultRendered;
    this.formatter = (value, row) => {
      return this.render(value, null, row, null);
    };
    const key = [slug_name, attr_type].filter(Boolean).join(",");
  }
  /*set visible(visible: boolean) {
      //console.trace(this.slug_name + ' setting visible', visible)
      this._visible = visible;
  }
  get visible() {
      return this._visible;
  }*/
  defaultRendered(data3, type, row, meta) {
    return data3;
  }
  get $store() {
    return {
      columnas_actuales: Alpine.store("columnas_actuales"),
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      active_filter: Alpine.store("active_filter"),
      maps: Alpine.store("maps"),
      user: Alpine.store("user")
    };
  }
};

// src/js/components/alpine.store.ts
console.zdebug = console.info.bind(
  console,
  "%cDEBUG:",
  "color:#A39;font-weight:bold;"
);
console.zsuccess = console.info.bind(
  console,
  "%cSUCCESS:",
  "color:#16a34a;font-weight:bold;"
);
console.zlog = console.log.bind(
  console,
  "%cLOG:",
  "color:#090;font-weight:bold;"
);
console.zinfo = console.info.bind(
  console,
  "%cINFO:",
  "color:#33C;font-weight:bold;"
);
console.zwarn = console.warn.bind(
  console,
  "%cWARN:",
  "color:orange;font-weight:bold;"
);
console.ztable = console.table.bind(
  console,
  "%cTABLE:",
  "color:orange;font-weight:bold;"
);
console.timeEnd = console.timeEnd.bind(
  console,
  "%ctimeEnd:",
  "color:cyan;font-weight:bold;"
);

// src/js/components/alpine_definitions/bindConsole.ts
function bindConsole(className, classNameColor) {
  if (!console.timerInfo) {
    Object.defineProperty(console, "timerInfo", {
      get: function() {
        return Function.prototype.bind.call(
          console.log,
          console,
          "%c" + Number(performance.now() / 1e3).toFixed(1) + " Timer:",
          "color:#03C;font-weight:bold;"
        );
      }
    });
  }
  return {
    ...console,
    debug: console.debug.bind(console, `%c${className}:`, "color:#A39;font-weight:bold;"),
    log: console.log.bind(console, `%c${className}:`, "color:#090;font-weight:bold;"),
    info: console.info.bind(console, `%c${className}:`, classNameColor ?? "color:#33C;font-weight:bold;"),
    warn: console.warn.bind(console, `%c${className}:`, "color:orange;font-weight:bold;"),
    error: console.error.bind(console, `%c${className}:`, "color:red;font-weight:bold;"),
    timerInfo: console.timerInfo.bind(console, `%c${className}:`, classNameColor ?? "color:#33C;font-weight:bold;")
  };
}

// src/js/components/alpine_definitions/definitions.search_types.ts
var VSearchType = /* @__PURE__ */ ((VSearchType3) => {
  VSearchType3["BETWEEN"] = "15";
  VSearchType3["GREATER_THAN"] = "5";
  VSearchType3["GREATER_THAN_OR_EQUAL"] = "7";
  VSearchType3["HAS_ATTACHMENTS"] = "23";
  VSearchType3["IN_RANGE"] = "25";
  VSearchType3["IS_AFTER"] = "18";
  VSearchType3["IS_BEFORE"] = "17";
  VSearchType3["IS_EQUAL"] = "21";
  VSearchType3["IS_NOT_EQUAL"] = "22";
  VSearchType3["IS_NOT_NULL"] = "14";
  VSearchType3["IS_NULL"] = "13";
  VSearchType3["JSON_CONTAINS"] = "19";
  VSearchType3["JSON_NOT_CONTAINS"] = "20";
  VSearchType3["LESS_THAN"] = "6";
  VSearchType3["LESS_THAN_OR_EQUAL"] = "8";
  VSearchType3["LIKE"] = "3";
  VSearchType3["NOT_BETWEEN"] = "16";
  VSearchType3["NOT_IN"] = "2";
  VSearchType3["NOT_LIKE"] = "4";
  VSearchType3["IN"] = "1";
  return VSearchType3;
})(VSearchType || {});
var VTypeSearch = Object.entries(VSearchType).reduce((a, [k, v]) => ({ ...a, [v]: k }), {});

// src/js/components/alpine_definitions/logLevel.ts
var fakeConsole = {
  ...console,
  log: (args) => {
    null;
  },
  info: (args) => {
    null;
  },
  debug: (args) => {
    null;
  },
  warn: (args) => {
    null;
  },
  error: (args) => {
    null;
  }
};

// src/js/components/hardCodedDateFields.ts
var hardCodedDateFields = [
  //{ slug_name: "created_at", attr_type: "negocio", name: "Fecha Creación" },
  {
    slug_name: "updated_at",
    attr_type: "negocio",
    name: "\xDAltima actualizaci\xF3n",
    id_input_type: "6" /* INPUT_DATE_TIME */,
    visible: false,
    readonly: true
  }
  //{ slug_name: "fecha_esperada_venta", attr_type: "negocio_attr", name: "F. Esperada venta" }
].map((item) => {
  let { slug_name, attr_type } = item;
  return {
    data: slug_name,
    field: slug_name,
    id: 0,
    related_model: null,
    readonly: 0,
    input_type: "date",
    ...item,
    key: `${slug_name},${attr_type}`,
    id_input_type: 5,
    inputType: "date",
    form_component: "dateInputComponent",
    visible: item.visible
  };
}).sort((a, b) => {
  return a.slug_name.localeCompare(b.slug_name);
});

// ../../../negocios-panel/node_modules/alpinejs/dist/module.esm.js
var flushPending2 = false;
var flushing2 = false;
var queue2 = [];
var lastFlushedIndex2 = -1;
function scheduler2(callback) {
  queueJob2(callback);
}
function queueJob2(job) {
  if (!queue2.includes(job))
    queue2.push(job);
  queueFlush2();
}
function dequeueJob2(job) {
  let index = queue2.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex2)
    queue2.splice(index, 1);
}
function queueFlush2() {
  if (!flushing2 && !flushPending2) {
    flushPending2 = true;
    queueMicrotask(flushJobs2);
  }
}
function flushJobs2() {
  flushPending2 = false;
  flushing2 = true;
  for (let i = 0; i < queue2.length; i++) {
    queue2[i]();
    lastFlushedIndex2 = i;
  }
  queue2.length = 0;
  lastFlushedIndex2 = -1;
  flushing2 = false;
}
var reactive3;
var effect3;
var release2;
var raw2;
var shouldSchedule2 = true;
function disableEffectScheduling2(callback) {
  shouldSchedule2 = false;
  callback();
  shouldSchedule2 = true;
}
function setReactivityEngine2(engine) {
  reactive3 = engine.reactive;
  release2 = engine.release;
  effect3 = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule2) {
      scheduler2(task);
    } else {
      task();
    }
  } });
  raw2 = engine.raw;
}
function overrideEffect2(override) {
  effect3 = override;
}
function elementBoundEffect2(el) {
  let cleanup22 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect3(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i) => i());
      };
    }
    el._x_effects.add(effectReference);
    cleanup22 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release2(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup22();
  }];
}
var onAttributeAddeds2 = [];
var onElRemoveds2 = [];
var onElAddeds2 = [];
function onElAdded2(callback) {
  onElAddeds2.push(callback);
}
function onElRemoved2(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds2.push(callback);
  }
}
function onAttributesAdded2(callback) {
  onAttributeAddeds2.push(callback);
}
function onAttributeRemoved2(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes2(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i) => i());
      delete el._x_attributeCleanups[name];
    }
  });
}
var observer2 = new MutationObserver(onMutate2);
var currentlyObserving2 = false;
function startObservingMutations2() {
  observer2.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving2 = true;
}
function stopObservingMutations2() {
  flushObserver2();
  observer2.disconnect();
  currentlyObserving2 = false;
}
var recordQueue2 = [];
var willProcessRecordQueue2 = false;
function flushObserver2() {
  recordQueue2 = recordQueue2.concat(observer2.takeRecords());
  if (recordQueue2.length && !willProcessRecordQueue2) {
    willProcessRecordQueue2 = true;
    queueMicrotask(() => {
      processRecordQueue2();
      willProcessRecordQueue2 = false;
    });
  }
}
function processRecordQueue2() {
  onMutate2(recordQueue2);
  recordQueue2.length = 0;
}
function mutateDom2(callback) {
  if (!currentlyObserving2)
    return callback();
  stopObservingMutations2();
  let result = callback();
  startObservingMutations2();
  return result;
}
var isCollecting2 = false;
var deferredMutations2 = [];
function deferMutations2() {
  isCollecting2 = true;
}
function flushAndStopDeferringMutations2() {
  isCollecting2 = false;
  onMutate2(deferredMutations2);
  deferredMutations2 = [];
}
function onMutate2(mutations) {
  if (isCollecting2) {
    deferredMutations2 = deferredMutations2.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = [];
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i = 0; i < mutations.length; i++) {
    if (mutations[i].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i].type === "childList") {
      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
    }
    if (mutations[i].type === "attributes") {
      let el = mutations[i].target;
      let name = mutations[i].attributeName;
      let oldValue = mutations[i].oldValue;
      let add22 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add22();
      } else if (el.hasAttribute(name)) {
        remove();
        add22();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes2(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds2.forEach((i) => i(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.includes(node))
      continue;
    onElRemoveds2.forEach((i) => i(node));
    if (node._x_cleanups) {
      while (node._x_cleanups.length)
        node._x_cleanups.pop()();
    }
  }
  addedNodes.forEach((node) => {
    node._x_ignoreSelf = true;
    node._x_ignore = true;
  });
  for (let node of addedNodes) {
    if (removedNodes.includes(node))
      continue;
    if (!node.isConnected)
      continue;
    delete node._x_ignoreSelf;
    delete node._x_ignore;
    onElAddeds2.forEach((i) => i(node));
    node._x_ignore = true;
    node._x_ignoreSelf = true;
  }
  addedNodes.forEach((node) => {
    delete node._x_ignoreSelf;
    delete node._x_ignore;
  });
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope2(node) {
  return mergeProxies2(closestDataStack2(node));
}
function addScopeToNode2(node, data22, referenceNode) {
  node._x_dataStack = [data22, ...closestDataStack2(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i) => i !== data22);
  };
}
function closestDataStack2(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack2(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack2(node.parentNode);
}
function mergeProxies2(objects) {
  let thisProxy = new Proxy({}, {
    ownKeys: () => {
      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
    },
    has: (target, name) => {
      return objects.some((obj) => obj.hasOwnProperty(name));
    },
    get: (target, name) => {
      return (objects.find((obj) => {
        if (obj.hasOwnProperty(name)) {
          let descriptor = Object.getOwnPropertyDescriptor(obj, name);
          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
            return true;
          }
          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
            let getter = descriptor.get;
            let setter = descriptor.set;
            let property = descriptor;
            getter = getter && getter.bind(thisProxy);
            setter = setter && setter.bind(thisProxy);
            if (getter)
              getter._x_alreadyBound = true;
            if (setter)
              setter._x_alreadyBound = true;
            Object.defineProperty(obj, name, {
              ...property,
              get: getter,
              set: setter
            });
          }
          return true;
        }
        return false;
      }) || {})[name];
    },
    set: (target, name, value) => {
      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
      if (closestObjectWithKey) {
        closestObjectWithKey[name] = value;
      } else {
        objects[objects.length - 1][name] = value;
      }
      return true;
    }
  });
  return thisProxy;
}
function initInterceptors3(data22) {
  let isObject22 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data22, path, key);
      } else {
        if (isObject22(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data22);
}
function interceptor2(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data22, path, key) {
      return callback(this.initialValue, () => get3(data22, path), (value) => set3(data22, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data22, path, key) => {
        let innerValue = initialValue.initialize(data22, path, key);
        obj.initialValue = innerValue;
        return initialize(data22, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get3(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set3(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set3(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set3(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics2 = {};
function magic2(name, callback) {
  magics2[name] = callback;
}
function injectMagics2(obj, el) {
  Object.entries(magics2).forEach(([name, callback]) => {
    let memoizedUtilities = null;
    function getUtilities() {
      if (memoizedUtilities) {
        return memoizedUtilities;
      } else {
        let [utilities, cleanup22] = getElementBoundUtilities2(el);
        memoizedUtilities = { interceptor: interceptor2, ...utilities };
        onElRemoved2(el, cleanup22);
        return memoizedUtilities;
      }
    }
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, getUtilities());
      },
      enumerable: false
    });
  });
  return obj;
}
function tryCatch2(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e) {
    handleError2(e, el, expression);
  }
}
function handleError2(error22, el, expression = void 0) {
  Object.assign(error22, { el, expression });
  console.warn(`Alpine Expression Error: ${error22.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error22;
  }, 0);
}
var shouldAutoEvaluateFunctions2 = true;
function dontAutoEvaluateFunctions2(callback) {
  let cache4 = shouldAutoEvaluateFunctions2;
  shouldAutoEvaluateFunctions2 = false;
  let result = callback();
  shouldAutoEvaluateFunctions2 = cache4;
  return result;
}
function evaluate2(el, expression, extras = {}) {
  let result;
  evaluateLater2(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater2(...args) {
  return theEvaluatorFunction2(...args);
}
var theEvaluatorFunction2 = normalEvaluator2;
function setEvaluator2(newEvaluator) {
  theEvaluatorFunction2 = newEvaluator;
}
function normalEvaluator2(el, expression) {
  let overriddenMagics = {};
  injectMagics2(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack2(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction2(dataStack, expression) : generateEvaluatorFromString2(dataStack, expression, el);
  return tryCatch2.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction2(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope22 = {}, params = [] } = {}) => {
    let result = func.apply(mergeProxies2([scope22, ...dataStack]), params);
    runIfTypeOfFunction2(receiver, result);
  };
}
var evaluatorMemo2 = {};
function generateFunctionFromString2(expression, el) {
  if (evaluatorMemo2[expression]) {
    return evaluatorMemo2[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)\s/.test(expression) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
    } catch (error22) {
      handleError2(error22, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo2[expression] = func;
  return func;
}
function generateEvaluatorFromString2(dataStack, expression, el) {
  let func = generateFunctionFromString2(expression, el);
  return (receiver = () => {
  }, { scope: scope22 = {}, params = [] } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies2([scope22, ...dataStack]);
    if (typeof func === "function") {
      let promise = func(func, completeScope).catch((error22) => handleError2(error22, el, expression));
      if (func.finished) {
        runIfTypeOfFunction2(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction2(receiver, result, completeScope, params, el);
        }).catch((error22) => handleError2(error22, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction2(receiver, value, scope22, params, el) {
  if (shouldAutoEvaluateFunctions2 && typeof value === "function") {
    let result = value.apply(scope22, params);
    if (result instanceof Promise) {
      result.then((i) => runIfTypeOfFunction2(receiver, i, scope22, params)).catch((error22) => handleError2(error22, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i) => receiver(i));
  } else {
    receiver(value);
  }
}
var prefixAsString2 = "x-";
function prefix2(subject = "") {
  return prefixAsString2 + subject;
}
function setPrefix2(newPrefix) {
  prefixAsString2 = newPrefix;
}
var directiveHandlers2 = {};
function directive2(name, callback) {
  directiveHandlers2[name] = callback;
  return {
    before(directive22) {
      if (!directiveHandlers2[directive22]) {
        console.warn("Cannot find directive `${directive}`. `${name}` will use the default order of execution");
        return;
      }
      const pos = directiveOrder2.indexOf(directive22);
      directiveOrder2.splice(pos >= 0 ? pos : directiveOrder2.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directives2(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly2(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives22 = attributes.map(toTransformedAttributes2((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes2).map(toParsedDirectives2(transformedAttributeMap, originalAttributeOverride)).sort(byPriority2);
  return directives22.map((directive22) => {
    return getDirectiveHandler2(el, directive22);
  });
}
function attributesOnly2(attributes) {
  return Array.from(attributes).map(toTransformedAttributes2()).filter((attr) => !outNonAlpineAttributes2(attr));
}
var isDeferringHandlers2 = false;
var directiveHandlerStacks2 = /* @__PURE__ */ new Map();
var currentHandlerStackKey2 = Symbol();
function deferHandlingDirectives2(callback) {
  isDeferringHandlers2 = true;
  let key = Symbol();
  currentHandlerStackKey2 = key;
  directiveHandlerStacks2.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks2.get(key).length)
      directiveHandlerStacks2.get(key).shift()();
    directiveHandlerStacks2.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers2 = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities2(el) {
  let cleanups = [];
  let cleanup22 = (callback) => cleanups.push(callback);
  let [effect32, cleanupEffect] = elementBoundEffect2(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default2,
    effect: effect32,
    cleanup: cleanup22,
    evaluateLater: evaluateLater2.bind(evaluateLater2, el),
    evaluate: evaluate2.bind(evaluate2, el)
  };
  let doCleanup = () => cleanups.forEach((i) => i());
  return [utilities, doCleanup];
}
function getDirectiveHandler2(el, directive22) {
  let noop7 = () => {
  };
  let handler42 = directiveHandlers2[directive22.type] || noop7;
  let [utilities, cleanup22] = getElementBoundUtilities2(el);
  onAttributeRemoved2(el, directive22.original, cleanup22);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler42.inline && handler42.inline(el, directive22, utilities);
    handler42 = handler42.bind(handler42, el, directive22, utilities);
    isDeferringHandlers2 ? directiveHandlerStacks2.get(currentHandlerStackKey2).push(handler42) : handler42();
  };
  fullHandler.runCleanups = cleanup22;
  return fullHandler;
}
var startingWith2 = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into2 = (i) => i;
function toTransformedAttributes2(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers2.reduce((carry, transform2) => {
      return transform2(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers2 = [];
function mapAttributes2(callback) {
  attributeTransformers2.push(callback);
}
function outNonAlpineAttributes2({ name }) {
  return alpineAttributeRegex2().test(name);
}
var alpineAttributeRegex2 = () => new RegExp(`^${prefixAsString2}([^:^.]+)\\b`);
function toParsedDirectives2(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex2());
    let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i) => i.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT2 = "DEFAULT";
var directiveOrder2 = [
  "ignore",
  "ref",
  "data",
  "id",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT2,
  "teleport"
];
function byPriority2(a, b) {
  let typeA = directiveOrder2.indexOf(a.type) === -1 ? DEFAULT2 : a.type;
  let typeB = directiveOrder2.indexOf(b.type) === -1 ? DEFAULT2 : b.type;
  return directiveOrder2.indexOf(typeA) - directiveOrder2.indexOf(typeB);
}
function dispatch2(el, name, detail = {}) {
  el.dispatchEvent(new CustomEvent(name, {
    detail,
    bubbles: true,
    composed: true,
    cancelable: true
  }));
}
function walk2(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk2(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk2(node, callback, false);
    node = node.nextElementSibling;
  }
}
function warn2(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started2 = false;
function start2() {
  if (started2)
    warn2("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started2 = true;
  if (!document.body)
    warn2("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch2(document, "alpine:init");
  dispatch2(document, "alpine:initializing");
  startObservingMutations2();
  onElAdded2((el) => initTree2(el, walk2));
  onElRemoved2((el) => destroyTree2(el));
  onAttributesAdded2((el, attrs) => {
    directives2(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot2(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors2())).filter(outNestedComponents).forEach((el) => {
    initTree2(el);
  });
  dispatch2(document, "alpine:initialized");
}
var rootSelectorCallbacks2 = [];
var initSelectorCallbacks2 = [];
function rootSelectors2() {
  return rootSelectorCallbacks2.map((fn) => fn());
}
function allSelectors2() {
  return rootSelectorCallbacks2.concat(initSelectorCallbacks2).map((fn) => fn());
}
function addRootSelector2(selectorCallback) {
  rootSelectorCallbacks2.push(selectorCallback);
}
function addInitSelector2(selectorCallback) {
  initSelectorCallbacks2.push(selectorCallback);
}
function closestRoot2(el, includeInitSelectors = false) {
  return findClosest2(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors2() : rootSelectors2();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest2(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest2(el.parentElement, callback);
}
function isRoot2(el) {
  return rootSelectors2().some((selector) => el.matches(selector));
}
var initInterceptors22 = [];
function interceptInit2(callback) {
  initInterceptors22.push(callback);
}
function initTree2(el, walker = walk2, intercept = () => {
}) {
  deferHandlingDirectives2(() => {
    walker(el, (el2, skip) => {
      intercept(el2, skip);
      initInterceptors22.forEach((i) => i(el2, skip));
      directives2(el2, el2.attributes).forEach((handle) => handle());
      el2._x_ignore && skip();
    });
  });
}
function destroyTree2(root) {
  walk2(root, (el) => cleanupAttributes2(el));
}
var tickStack2 = [];
var isHolding2 = false;
function nextTick2(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding2 || setTimeout(() => {
      releaseNextTicks2();
    });
  });
  return new Promise((res2) => {
    tickStack2.push(() => {
      callback();
      res2();
    });
  });
}
function releaseNextTicks2() {
  isHolding2 = false;
  while (tickStack2.length)
    tickStack2.shift()();
}
function holdNextTicks2() {
  isHolding2 = true;
}
function setClasses2(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString2(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject2(el, value);
  } else if (typeof value === "function") {
    return setClasses2(el, value());
  }
  return setClassesFromString2(el, value);
}
function setClassesFromString2(el, classString) {
  let split = (classString2) => classString2.split(" ").filter(Boolean);
  let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject2(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i) => {
    if (el.classList.contains(i)) {
      el.classList.remove(i);
      removed.push(i);
    }
  });
  forAdd.forEach((i) => {
    if (!el.classList.contains(i)) {
      el.classList.add(i);
      added.push(i);
    }
  });
  return () => {
    removed.forEach((i) => el.classList.add(i));
    added.forEach((i) => el.classList.remove(i));
  };
}
function setStyles2(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject2(el, value);
  }
  return setStylesFromString2(el, value);
}
function setStylesFromObject2(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase3(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles2(el, previousStyles);
  };
}
function setStylesFromString2(el, value) {
  let cache4 = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache4 || "");
  };
}
function kebabCase3(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once2(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive2("transition", (el, { value, modifiers, expression }, { evaluate: evaluate22 }) => {
  if (typeof expression === "function")
    expression = evaluate22(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper2(el, modifiers, value);
  } else {
    registerTransitionsFromClassString2(el, expression, value);
  }
});
function registerTransitionsFromClassString2(el, classString, stage) {
  registerTransitionObject2(el, setClasses2, "");
  let directiveStorageMap = {
    enter: (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    leave: (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper2(el, modifiers, stage) {
  registerTransitionObject2(el, setStyles2);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue2(modifiers, "scale", 95) / 100 : 1;
  let delay = modifierValue2(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue2(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue2(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue2(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject2(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition2(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition2(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick22 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick22(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve2, reject) => {
    el._x_transition.out(() => {
    }, () => resolve2(hide));
    el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide2(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick22(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i]) => i());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e) => {
          if (!e.isFromCancelledTransition)
            throw e;
        });
      });
    }
  });
};
function closestHide2(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide2(parent);
}
function transition2(el, setFunction, { during, start: start22, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start22).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition2(el, {
    start() {
      undoStart = setFunction(el, start22);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition2(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once2(() => {
    mutateDom2(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks2();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once2(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      ;
      finish();
    }),
    finish
  };
  mutateDom2(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks2();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom2(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom2(() => {
        stages.end();
      });
      releaseNextTicks2();
      setTimeout(el._x_transitioning.finish, duration + delay);
      reachedEnd = true;
    });
  });
}
function modifierValue2(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning2 = false;
function skipDuringClone2(callback, fallback = () => {
}) {
  return (...args) => isCloning2 ? fallback(...args) : callback(...args);
}
function onlyDuringClone2(callback) {
  return (...args) => isCloning2 && callback(...args);
}
function clone2(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning2 = true;
  dontRegisterReactiveSideEffects2(() => {
    cloneTree2(newEl);
  });
  isCloning2 = false;
}
function cloneTree2(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk2(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot2(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree2(el, shallowWalker);
}
function dontRegisterReactiveSideEffects2(callback) {
  let cache4 = effect3;
  overrideEffect2((callback2, el) => {
    let storedEffect = cache4(callback2);
    release2(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect2(cache4);
}
function bind3(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive3({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase3(name) : name;
  switch (name) {
    case "value":
      bindInputValue2(el, value);
      break;
    case "style":
      bindStyles2(el, value);
      break;
    case "class":
      bindClasses2(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty2(el, name, value);
      break;
    default:
      bindAttribute2(el, name, value);
      break;
  }
}
function bindInputValue2(el, value) {
  if (el.type === "radio") {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      el.checked = checkedAttrLooseCompare3(el.value, value);
    }
  } else if (el.type === "checkbox") {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare3(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect2(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value;
  }
}
function bindClasses2(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses2(el, value);
}
function bindStyles2(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles2(el, value);
}
function bindAttributeAndProperty2(el, name, value) {
  bindAttribute2(el, name, value);
  setPropertyIfChanged2(el, name, value);
}
function bindAttribute2(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy2(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr3(name))
      value = name;
    setIfChanged2(el, name, value);
  }
}
function setIfChanged2(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged2(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect2(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase3(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare3(valueA, valueB) {
  return valueA == valueB;
}
function isBooleanAttr3(attrName) {
  const booleanAttributes = [
    "disabled",
    "checked",
    "required",
    "readonly",
    "hidden",
    "open",
    "selected",
    "autofocus",
    "itemscope",
    "multiple",
    "novalidate",
    "allowfullscreen",
    "allowpaymentrequest",
    "formnovalidate",
    "autoplay",
    "controls",
    "loop",
    "muted",
    "playsinline",
    "default",
    "ismap",
    "reversed",
    "async",
    "defer",
    "nomodule"
  ];
  return booleanAttributes.includes(attrName);
}
function attributeShouldntBePreservedIfFalsy2(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding2(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding2(el, name, fallback);
}
function extractProp2(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions2(() => {
      return evaluate2(el, binding.expression);
    });
  }
  return getAttributeBinding2(el, name, fallback);
}
function getAttributeBinding2(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr3(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function debounce2(func, wait) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle2(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function plugin2(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i) => i(alpine_default2));
}
var stores2 = {};
var isReactive2 = false;
function store2(name, value) {
  if (!isReactive2) {
    stores2 = reactive3(stores2);
    isReactive2 = true;
  }
  if (value === void 0) {
    return stores2[name];
  }
  stores2[name] = value;
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores2[name].init();
  }
  initInterceptors3(stores2[name]);
}
function getStores2() {
  return stores2;
}
var binds2 = {};
function bind22(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    applyBindingsObject2(name, getBindings());
  } else {
    binds2[name] = getBindings;
  }
}
function injectBindingProviders2(obj) {
  Object.entries(binds2).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject2(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly2(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives2(el, attributes, original).map((handle) => {
    cleanupRunners.push(handle.runCleanups);
    handle();
  });
}
var datas2 = {};
function data2(name, callback) {
  datas2[name] = callback;
}
function injectDataProviders2(obj, context) {
  Object.entries(datas2).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine3 = {
  get reactive() {
    return reactive3;
  },
  get release() {
    return release2;
  },
  get effect() {
    return effect3;
  },
  get raw() {
    return raw2;
  },
  version: "3.12.3",
  flushAndStopDeferringMutations: flushAndStopDeferringMutations2,
  dontAutoEvaluateFunctions: dontAutoEvaluateFunctions2,
  disableEffectScheduling: disableEffectScheduling2,
  startObservingMutations: startObservingMutations2,
  stopObservingMutations: stopObservingMutations2,
  setReactivityEngine: setReactivityEngine2,
  closestDataStack: closestDataStack2,
  skipDuringClone: skipDuringClone2,
  onlyDuringClone: onlyDuringClone2,
  addRootSelector: addRootSelector2,
  addInitSelector: addInitSelector2,
  addScopeToNode: addScopeToNode2,
  deferMutations: deferMutations2,
  mapAttributes: mapAttributes2,
  evaluateLater: evaluateLater2,
  interceptInit: interceptInit2,
  setEvaluator: setEvaluator2,
  mergeProxies: mergeProxies2,
  extractProp: extractProp2,
  findClosest: findClosest2,
  closestRoot: closestRoot2,
  destroyTree: destroyTree2,
  interceptor: interceptor2,
  transition: transition2,
  setStyles: setStyles2,
  mutateDom: mutateDom2,
  directive: directive2,
  throttle: throttle2,
  debounce: debounce2,
  evaluate: evaluate2,
  initTree: initTree2,
  nextTick: nextTick2,
  prefixed: prefix2,
  prefix: setPrefix2,
  plugin: plugin2,
  magic: magic2,
  store: store2,
  start: start2,
  clone: clone2,
  bound: getBinding2,
  $data: scope2,
  walk: walk2,
  data: data2,
  bind: bind22
};
var alpine_default2 = Alpine3;
function makeMap2(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
var specialBooleanAttrs2 = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isBooleanAttr22 = /* @__PURE__ */ makeMap2(specialBooleanAttrs2 + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
var EMPTY_OBJ2 = true ? Object.freeze({}) : {};
var EMPTY_ARR2 = true ? Object.freeze([]) : [];
var extend = Object.assign;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var hasOwn2 = (val, key) => hasOwnProperty2.call(val, key);
var isArray2 = Array.isArray;
var isMap2 = (val) => toTypeString2(val) === "[object Map]";
var isString2 = (val) => typeof val === "string";
var isSymbol2 = (val) => typeof val === "symbol";
var isObject2 = (val) => val !== null && typeof val === "object";
var objectToString2 = Object.prototype.toString;
var toTypeString2 = (value) => objectToString2.call(value);
var toRawType2 = (value) => {
  return toTypeString2(value).slice(8, -1);
};
var isIntegerKey2 = (key) => isString2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction2 = (fn) => {
  const cache4 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache4[str];
    return hit || (cache4[str] = fn(str));
  };
};
var camelizeRE2 = /-(\w)/g;
var camelize2 = cacheStringFunction2((str) => {
  return str.replace(camelizeRE2, (_, c) => c ? c.toUpperCase() : "");
});
var hyphenateRE2 = /\B([A-Z])/g;
var hyphenate2 = cacheStringFunction2((str) => str.replace(hyphenateRE2, "-$1").toLowerCase());
var capitalize2 = cacheStringFunction2((str) => str.charAt(0).toUpperCase() + str.slice(1));
var toHandlerKey2 = cacheStringFunction2((str) => str ? `on${capitalize2(str)}` : ``);
var hasChanged2 = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap2 = /* @__PURE__ */ new WeakMap();
var effectStack2 = [];
var activeEffect2;
var ITERATE_KEY2 = Symbol(true ? "iterate" : "");
var MAP_KEY_ITERATE_KEY2 = Symbol(true ? "Map key iterate" : "");
function isEffect2(fn) {
  return fn && fn._isEffect === true;
}
function effect22(fn, options = EMPTY_OBJ2) {
  if (isEffect2(fn)) {
    fn = fn.raw;
  }
  const effect32 = createReactiveEffect2(fn, options);
  if (!options.lazy) {
    effect32();
  }
  return effect32;
}
function stop2(effect32) {
  if (effect32.active) {
    cleanup2(effect32);
    if (effect32.options.onStop) {
      effect32.options.onStop();
    }
    effect32.active = false;
  }
}
var uid2 = 0;
function createReactiveEffect2(fn, options) {
  const effect32 = function reactiveEffect() {
    if (!effect32.active) {
      return fn();
    }
    if (!effectStack2.includes(effect32)) {
      cleanup2(effect32);
      try {
        enableTracking2();
        effectStack2.push(effect32);
        activeEffect2 = effect32;
        return fn();
      } finally {
        effectStack2.pop();
        resetTracking2();
        activeEffect2 = effectStack2[effectStack2.length - 1];
      }
    }
  };
  effect32.id = uid2++;
  effect32.allowRecurse = !!options.allowRecurse;
  effect32._isEffect = true;
  effect32.active = true;
  effect32.raw = fn;
  effect32.deps = [];
  effect32.options = options;
  return effect32;
}
function cleanup2(effect32) {
  const { deps } = effect32;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect32);
    }
    deps.length = 0;
  }
}
var shouldTrack2 = true;
var trackStack2 = [];
function pauseTracking2() {
  trackStack2.push(shouldTrack2);
  shouldTrack2 = false;
}
function enableTracking2() {
  trackStack2.push(shouldTrack2);
  shouldTrack2 = true;
}
function resetTracking2() {
  const last = trackStack2.pop();
  shouldTrack2 = last === void 0 ? true : last;
}
function track2(target, type, key) {
  if (!shouldTrack2 || activeEffect2 === void 0) {
    return;
  }
  let depsMap = targetMap2.get(target);
  if (!depsMap) {
    targetMap2.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect2)) {
    dep.add(activeEffect2);
    activeEffect2.deps.push(dep);
    if (activeEffect2.options.onTrack) {
      activeEffect2.options.onTrack({
        effect: activeEffect2,
        target,
        type,
        key
      });
    }
  }
}
function trigger2(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap2.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add22 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect32) => {
        if (effect32 !== activeEffect2 || effect32.allowRecurse) {
          effects.add(effect32);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add22);
  } else if (key === "length" && isArray2(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add22(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add22(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray2(target)) {
          add22(depsMap.get(ITERATE_KEY2));
          if (isMap2(target)) {
            add22(depsMap.get(MAP_KEY_ITERATE_KEY2));
          }
        } else if (isIntegerKey2(key)) {
          add22(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray2(target)) {
          add22(depsMap.get(ITERATE_KEY2));
          if (isMap2(target)) {
            add22(depsMap.get(MAP_KEY_ITERATE_KEY2));
          }
        }
        break;
      case "set":
        if (isMap2(target)) {
          add22(depsMap.get(ITERATE_KEY2));
        }
        break;
    }
  }
  const run = (effect32) => {
    if (effect32.options.onTrigger) {
      effect32.options.onTrigger({
        effect: effect32,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect32.options.scheduler) {
      effect32.options.scheduler(effect32);
    } else {
      effect32();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys2 = /* @__PURE__ */ makeMap2(`__proto__,__v_isRef,__isVue`);
var builtInSymbols2 = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol2));
var get22 = /* @__PURE__ */ createGetter2();
var shallowGet = /* @__PURE__ */ createGetter2(false, true);
var readonlyGet2 = /* @__PURE__ */ createGetter2(true);
var shallowReadonlyGet = /* @__PURE__ */ createGetter2(true, true);
var arrayInstrumentations2 = {};
["includes", "indexOf", "lastIndexOf"].forEach((key) => {
  const method = Array.prototype[key];
  arrayInstrumentations2[key] = function(...args) {
    const arr = toRaw2(this);
    for (let i = 0, l = this.length; i < l; i++) {
      track2(arr, "get", i + "");
    }
    const res2 = method.apply(arr, args);
    if (res2 === -1 || res2 === false) {
      return method.apply(arr, args.map(toRaw2));
    } else {
      return res2;
    }
  };
});
["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
  const method = Array.prototype[key];
  arrayInstrumentations2[key] = function(...args) {
    pauseTracking2();
    const res2 = method.apply(this, args);
    resetTracking2();
    return res2;
  };
});
function createGetter2(isReadonly = false, shallow = false) {
  return function get32(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap2 : readonlyMap2 : shallow ? shallowReactiveMap2 : reactiveMap2).get(target)) {
      return target;
    }
    const targetIsArray = isArray2(target);
    if (!isReadonly && targetIsArray && hasOwn2(arrayInstrumentations2, key)) {
      return Reflect.get(arrayInstrumentations2, key, receiver);
    }
    const res2 = Reflect.get(target, key, receiver);
    if (isSymbol2(key) ? builtInSymbols2.has(key) : isNonTrackableKeys2(key)) {
      return res2;
    }
    if (!isReadonly) {
      track2(target, "get", key);
    }
    if (shallow) {
      return res2;
    }
    if (isRef2(res2)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey2(key);
      return shouldUnwrap ? res2.value : res2;
    }
    if (isObject2(res2)) {
      return isReadonly ? readonly2(res2) : reactive22(res2);
    }
    return res2;
  };
}
var set22 = /* @__PURE__ */ createSetter2();
var shallowSet = /* @__PURE__ */ createSetter2(true);
function createSetter2(shallow = false) {
  return function set32(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw2(value);
      oldValue = toRaw2(oldValue);
      if (!isArray2(target) && isRef2(oldValue) && !isRef2(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray2(target) && isIntegerKey2(key) ? Number(key) < target.length : hasOwn2(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw2(receiver)) {
      if (!hadKey) {
        trigger2(target, "add", key, value);
      } else if (hasChanged2(value, oldValue)) {
        trigger2(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty2(target, key) {
  const hadKey = hasOwn2(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger2(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has2(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol2(key) || !builtInSymbols2.has(key)) {
    track2(target, "has", key);
  }
  return result;
}
function ownKeys2(target) {
  track2(target, "iterate", isArray2(target) ? "length" : ITERATE_KEY2);
  return Reflect.ownKeys(target);
}
var mutableHandlers2 = {
  get: get22,
  set: set22,
  deleteProperty: deleteProperty2,
  has: has2,
  ownKeys: ownKeys2
};
var readonlyHandlers2 = {
  get: readonlyGet2,
  set(target, key) {
    if (true) {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (true) {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var shallowReactiveHandlers = extend({}, mutableHandlers2, {
  get: shallowGet,
  set: shallowSet
});
var shallowReadonlyHandlers = extend({}, readonlyHandlers2, {
  get: shallowReadonlyGet
});
var toReactive2 = (value) => isObject2(value) ? reactive22(value) : value;
var toReadonly2 = (value) => isObject2(value) ? readonly2(value) : value;
var toShallow2 = (value) => value;
var getProto2 = (v) => Reflect.getPrototypeOf(v);
function get$12(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw2(target);
  const rawKey = toRaw2(key);
  if (key !== rawKey) {
    !isReadonly && track2(rawTarget, "get", key);
  }
  !isReadonly && track2(rawTarget, "get", rawKey);
  const { has: has22 } = getProto2(rawTarget);
  const wrap = isShallow ? toShallow2 : isReadonly ? toReadonly2 : toReactive2;
  if (has22.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has22.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$12(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw2(target);
  const rawKey = toRaw2(key);
  if (key !== rawKey) {
    !isReadonly && track2(rawTarget, "has", key);
  }
  !isReadonly && track2(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size2(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track2(toRaw2(target), "iterate", ITERATE_KEY2);
  return Reflect.get(target, "size", target);
}
function add2(value) {
  value = toRaw2(value);
  const target = toRaw2(this);
  const proto = getProto2(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger2(target, "add", value, value);
  }
  return this;
}
function set$12(key, value) {
  value = toRaw2(value);
  const target = toRaw2(this);
  const { has: has22, get: get32 } = getProto2(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw2(key);
    hadKey = has22.call(target, key);
  } else if (true) {
    checkIdentityKeys2(target, has22, key);
  }
  const oldValue = get32.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger2(target, "add", key, value);
  } else if (hasChanged2(value, oldValue)) {
    trigger2(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry2(key) {
  const target = toRaw2(this);
  const { has: has22, get: get32 } = getProto2(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw2(key);
    hadKey = has22.call(target, key);
  } else if (true) {
    checkIdentityKeys2(target, has22, key);
  }
  const oldValue = get32 ? get32.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger2(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear2() {
  const target = toRaw2(this);
  const hadItems = target.size !== 0;
  const oldTarget = true ? isMap2(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger2(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach2(isReadonly, isShallow) {
  return function forEach5(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw2(target);
    const wrap = isShallow ? toShallow2 : isReadonly ? toReadonly2 : toReactive2;
    !isReadonly && track2(rawTarget, "iterate", ITERATE_KEY2);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod2(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw2(target);
    const targetIsMap = isMap2(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow2 : isReadonly ? toReadonly2 : toReactive2;
    !isReadonly && track2(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY2 : ITERATE_KEY2);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod2(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize2(type)} operation ${key}failed: target is readonly.`, toRaw2(this));
    }
    return type === "delete" ? false : this;
  };
}
var mutableInstrumentations2 = {
  get(key) {
    return get$12(this, key);
  },
  get size() {
    return size2(this);
  },
  has: has$12,
  add: add2,
  set: set$12,
  delete: deleteEntry2,
  clear: clear2,
  forEach: createForEach2(false, false)
};
var shallowInstrumentations2 = {
  get(key) {
    return get$12(this, key, false, true);
  },
  get size() {
    return size2(this);
  },
  has: has$12,
  add: add2,
  set: set$12,
  delete: deleteEntry2,
  clear: clear2,
  forEach: createForEach2(false, true)
};
var readonlyInstrumentations2 = {
  get(key) {
    return get$12(this, key, true);
  },
  get size() {
    return size2(this, true);
  },
  has(key) {
    return has$12.call(this, key, true);
  },
  add: createReadonlyMethod2("add"),
  set: createReadonlyMethod2("set"),
  delete: createReadonlyMethod2("delete"),
  clear: createReadonlyMethod2("clear"),
  forEach: createForEach2(true, false)
};
var shallowReadonlyInstrumentations2 = {
  get(key) {
    return get$12(this, key, true, true);
  },
  get size() {
    return size2(this, true);
  },
  has(key) {
    return has$12.call(this, key, true);
  },
  add: createReadonlyMethod2("add"),
  set: createReadonlyMethod2("set"),
  delete: createReadonlyMethod2("delete"),
  clear: createReadonlyMethod2("clear"),
  forEach: createForEach2(true, true)
};
var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
iteratorMethods.forEach((method) => {
  mutableInstrumentations2[method] = createIterableMethod2(method, false, false);
  readonlyInstrumentations2[method] = createIterableMethod2(method, true, false);
  shallowInstrumentations2[method] = createIterableMethod2(method, false, true);
  shallowReadonlyInstrumentations2[method] = createIterableMethod2(method, true, true);
});
function createInstrumentationGetter2(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations2 : shallowInstrumentations2 : isReadonly ? readonlyInstrumentations2 : mutableInstrumentations2;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn2(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers2 = {
  get: createInstrumentationGetter2(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter2(false, true)
};
var readonlyCollectionHandlers2 = {
  get: createInstrumentationGetter2(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter2(true, true)
};
function checkIdentityKeys2(target, has22, key) {
  const rawKey = toRaw2(key);
  if (rawKey !== key && has22.call(target, rawKey)) {
    const type = toRawType2(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap2 = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap2 = /* @__PURE__ */ new WeakMap();
var readonlyMap2 = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap2 = /* @__PURE__ */ new WeakMap();
function targetTypeMap2(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType2(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap2(toRawType2(value));
}
function reactive22(target) {
  if (target && target["__v_isReadonly"]) {
    return target;
  }
  return createReactiveObject2(target, false, mutableHandlers2, mutableCollectionHandlers2, reactiveMap2);
}
function readonly2(target) {
  return createReactiveObject2(target, true, readonlyHandlers2, readonlyCollectionHandlers2, readonlyMap2);
}
function createReactiveObject2(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject2(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType2(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw2(observed) {
  return observed && toRaw2(observed["__v_raw"]) || observed;
}
function isRef2(r) {
  return Boolean(r && r.__v_isRef === true);
}
magic2("nextTick", () => nextTick2);
magic2("dispatch", (el) => dispatch2.bind(dispatch2, el));
magic2("watch", (el, { evaluateLater: evaluateLater22, effect: effect32 }) => (key, callback) => {
  let evaluate22 = evaluateLater22(key);
  let firstTime = true;
  let oldValue;
  let effectReference = effect32(() => evaluate22((value) => {
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  }));
  el._x_effects.delete(effectReference);
});
magic2("store", getStores2);
magic2("data", (el) => scope2(el));
magic2("root", (el) => closestRoot2(el));
magic2("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies2(getArrayOfRefObject2(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject2(el) {
  let refObjects = [];
  let currentEl = el;
  while (currentEl) {
    if (currentEl._x_refs)
      refObjects.push(currentEl._x_refs);
    currentEl = currentEl.parentNode;
  }
  return refObjects;
}
var globalIdMemo2 = {};
function findAndIncrementId2(name) {
  if (!globalIdMemo2[name])
    globalIdMemo2[name] = 0;
  return ++globalIdMemo2[name];
}
function closestIdRoot2(el, name) {
  return findClosest2(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot2(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId2(name);
}
magic2("id", (el) => (name, key = null) => {
  let root = closestIdRoot2(el, name);
  let id = root ? root._x_ids[name] : findAndIncrementId2(name);
  return key ? `${name}-${id}-${key}` : `${name}-${id}`;
});
magic2("el", (el) => el);
warnMissingPluginMagic2("Focus", "focus", "focus");
warnMissingPluginMagic2("Persist", "persist", "persist");
function warnMissingPluginMagic2(name, magicName, slug) {
  magic2(magicName, (el) => warn2(`You can't use [$${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
function entangle2({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash, innerHash, outerHashLatest, innerHashLatest;
  let reference = effect3(() => {
    let outer, inner;
    if (firstRun) {
      outer = outerGet();
      innerSet(outer);
      inner = innerGet();
      firstRun = false;
    } else {
      outer = outerGet();
      inner = innerGet();
      outerHashLatest = JSON.stringify(outer);
      innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        inner = innerGet();
        innerSet(outer);
        inner = outer;
      } else {
        outerSet(inner);
        outer = inner;
      }
    }
    outerHash = JSON.stringify(outer);
    innerHash = JSON.stringify(inner);
  });
  return () => {
    release2(reference);
  };
}
directive2("modelable", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22, cleanup: cleanup22 }) => {
  let func = evaluateLater22(expression);
  let innerGet = () => {
    let result;
    func((i) => result = i);
    return result;
  };
  let evaluateInnerSet = evaluateLater22(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { __placeholder: val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle2({
      get() {
        return outerGet();
      },
      set(value) {
        outerSet(value);
      }
    }, {
      get() {
        return innerGet();
      },
      set(value) {
        innerSet(value);
      }
    });
    cleanup22(releaseEntanglement);
  });
});
var teleportContainerDuringClone2 = document.createElement("div");
directive2("teleport", (el, { modifiers, expression }, { cleanup: cleanup22 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn2("x-teleport can only be used on a <template> tag", el);
  let target = skipDuringClone2(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone2;
  })();
  if (!target)
    warn2(`Cannot find x-teleport element for selector: "${expression}"`);
  let clone22 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone22;
  clone22._x_teleportBack = el;
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone22.addEventListener(eventName, (e) => {
        e.stopPropagation();
        el.dispatchEvent(new e.constructor(e.type, e));
      });
    });
  }
  addScopeToNode2(clone22, {}, el);
  mutateDom2(() => {
    if (modifiers.includes("prepend")) {
      target.parentNode.insertBefore(clone22, target);
    } else if (modifiers.includes("append")) {
      target.parentNode.insertBefore(clone22, target.nextSibling);
    } else {
      target.appendChild(clone22);
    }
    initTree2(clone22);
    clone22._x_ignore = true;
  });
  cleanup22(() => clone22.remove());
});
var handler4 = () => {
};
handler4.inline = (el, { modifiers }, { cleanup: cleanup22 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup22(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive2("ignore", handler4);
directive2("effect", (el, { expression }, { effect: effect32 }) => effect32(evaluateLater2(el, expression)));
function on2(el, event, modifiers, callback) {
  let listenerTarget = el;
  let handler42 = (e) => callback(e);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
  if (modifiers.includes("dot"))
    event = dotSyntax2(event);
  if (modifiers.includes("camel"))
    event = camelCase22(event);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric4(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler42 = debounce2(handler42, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric4(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler42 = throttle2(handler42, wait);
  }
  if (modifiers.includes("prevent"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.preventDefault();
      next(e);
    });
  if (modifiers.includes("stop"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.stopPropagation();
      next(e);
    });
  if (modifiers.includes("self"))
    handler42 = wrapHandler(handler42, (next, e) => {
      e.target === el && next(e);
    });
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler42 = wrapHandler(handler42, (next, e) => {
      if (el.contains(e.target))
        return;
      if (e.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e);
    });
  }
  if (modifiers.includes("once")) {
    handler42 = wrapHandler(handler42, (next, e) => {
      next(e);
      listenerTarget.removeEventListener(event, handler42, options);
    });
  }
  handler42 = wrapHandler(handler42, (next, e) => {
    if (isKeyEvent2(event)) {
      if (isListeningForASpecificKeyThatHasntBeenPressed2(e, modifiers)) {
        return;
      }
    }
    next(e);
  });
  listenerTarget.addEventListener(event, handler42, options);
  return () => {
    listenerTarget.removeEventListener(event, handler42, options);
  };
}
function dotSyntax2(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase22(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric4(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase22(subject) {
  if ([" ", "_"].includes(subject))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent2(event) {
  return ["keydown", "keyup"].includes(event);
}
function isListeningForASpecificKeyThatHasntBeenPressed2(e, modifiers) {
  let keyModifiers = modifiers.filter((i) => {
    return !["window", "document", "prevent", "stop", "once", "capture"].includes(i);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric4((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric4((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers2(e.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (keyToModifiers2(e.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers2(key) {
  if (!key)
    return [];
  key = kebabCase22(key);
  let modifierToKeyMap = {
    ctrl: "control",
    slash: "/",
    space: " ",
    spacebar: " ",
    cmd: "meta",
    esc: "escape",
    up: "arrow-up",
    down: "arrow-down",
    left: "arrow-left",
    right: "arrow-right",
    period: ".",
    equal: "=",
    minus: "-",
    underscore: "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive2("model", (el, { modifiers, expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater2(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater2(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater2(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue2 = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter2(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter2(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { __placeholder: value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom2(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning2 ? () => {
  } : on2(el, event, modifiers, (e) => {
    setValue(getInputValue2(el, modifiers, e, getValue2()));
  });
  if (modifiers.includes("fill") && [null, ""].includes(getValue2())) {
    el.dispatchEvent(new Event(event, {}));
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup22(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on2(el.form, "reset", [], (e) => {
      nextTick2(() => el._x_model && el._x_model.set(el.value));
    });
    cleanup22(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue2();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    value = value === void 0 ? getValue2() : value;
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom2(() => bind3(el, "value", value));
    delete window.fromModel;
  };
  effect32(() => {
    let value = getValue2();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue2(el, modifiers, event, currentValue) {
  return mutateDom2(() => {
    if (event instanceof CustomEvent && event.detail !== void 0)
      return event.detail ?? event.target.value;
    else if (el.type === "checkbox") {
      if (Array.isArray(currentValue)) {
        let newValue = modifiers.includes("number") ? safeParseNumber2(event.target.value) : event.target.value;
        return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare22(el2, newValue));
      } else {
        return event.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
        let rawValue = option.value || option.text;
        return safeParseNumber2(rawValue);
      }) : Array.from(event.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let rawValue = event.target.value;
      return modifiers.includes("number") ? safeParseNumber2(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
    }
  });
}
function safeParseNumber2(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric22(number) ? number : rawValue;
}
function checkedAttrLooseCompare22(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric22(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter2(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive2("cloak", (el) => queueMicrotask(() => mutateDom2(() => el.removeAttribute(prefix2("cloak")))));
addInitSelector2(() => `[${prefix2("init")}]`);
directive2("init", skipDuringClone2((el, { expression }, { evaluate: evaluate22 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate22(expression, {}, false);
  }
  return evaluate22(expression, {}, false);
}));
directive2("text", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22 }) => {
  let evaluate22 = evaluateLater22(expression);
  effect32(() => {
    evaluate22((value) => {
      mutateDom2(() => {
        el.textContent = value;
      });
    });
  });
});
directive2("html", (el, { expression }, { effect: effect32, evaluateLater: evaluateLater22 }) => {
  let evaluate22 = evaluateLater22(expression);
  effect32(() => {
    evaluate22((value) => {
      mutateDom2(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree2(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes2(startingWith2(":", into2(prefix2("bind:"))));
var handler22 = (el, { value, modifiers, expression, original }, { effect: effect32 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders2(bindingProviders);
    let getBindings = evaluateLater2(el, expression);
    getBindings((bindings) => {
      applyBindingsObject2(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor2(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate22 = evaluateLater2(el, expression);
  effect32(() => evaluate22((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom2(() => bind3(el, value, result, modifiers));
  }));
};
handler22.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive2("bind", handler22);
function storeKeyForXFor2(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector2(() => `[${prefix2("data")}]`);
directive2("data", skipDuringClone2((el, { expression }, { cleanup: cleanup22 }) => {
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics2(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders2(dataProviderContext, magicContext);
  let data22 = evaluate2(el, expression, { scope: dataProviderContext });
  if (data22 === void 0 || data22 === true)
    data22 = {};
  injectMagics2(data22, el);
  let reactiveData = reactive3(data22);
  initInterceptors3(reactiveData);
  let undo = addScopeToNode2(el, reactiveData);
  reactiveData["init"] && evaluate2(el, reactiveData["init"]);
  cleanup22(() => {
    reactiveData["destroy"] && evaluate2(el, reactiveData["destroy"]);
    undo();
  });
}));
directive2("show", (el, { modifiers, expression }, { effect: effect32 }) => {
  let evaluate22 = evaluateLater2(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom2(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom2(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once2((value) => value ? show() : hide(), (value) => {
    if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
    } else {
      value ? clickAwayCompatibleShow() : hide();
    }
  });
  let oldValue;
  let firstTime = true;
  effect32(() => evaluate22((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive2("for", (el, { expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let iteratorNames = parseForExpression2(expression);
  let evaluateItems = evaluateLater2(el, iteratorNames.items);
  let evaluateKey = evaluateLater2(el, el._x_keyExpression || "index");
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect32(() => loop2(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup22(() => {
    Object.values(el._x_lookup).forEach((el2) => el2.remove());
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop2(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject22 = (i) => typeof i === "object" && !Array.isArray(i);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric32(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i) => i + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject22(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope22 = getIterationScopeVariables2(iteratorNames, value, key, items);
        evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope22 } });
        scopes.push(scope22);
      });
    } else {
      for (let i = 0; i < items.length; i++) {
        let scope22 = getIterationScopeVariables2(iteratorNames, items[i], i, items);
        evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope22 } });
        scopes.push(scope22);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i = 0; i < prevKeys.length; i++) {
      let key = prevKeys[i];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i, 0, key);
        adds.push([lastKey, i]);
      } else if (prevIndex !== i) {
        let keyInSpot = prevKeys.splice(i, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i = 0; i < removes.length; i++) {
      let key = removes[i];
      if (!!lookup[key]._x_effects) {
        lookup[key]._x_effects.forEach(dequeueJob2);
      }
      lookup[key].remove();
      lookup[key] = null;
      delete lookup[key];
    }
    for (let i = 0; i < moves.length; i++) {
      let [keyInSpot, keyForSpot] = moves[i];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom2(() => {
        if (!elForSpot)
          warn2(`x-for ":key" is undefined or invalid`, templateEl);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i = 0; i < adds.length; i++) {
      let [lastKey2, index] = adds[i];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope22 = scopes[index];
      let key = keys[index];
      let clone22 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive3(scope22);
      addScopeToNode2(clone22, reactiveScope, templateEl);
      clone22._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom2(() => {
        lastEl.after(clone22);
        initTree2(clone22);
      });
      if (typeof key === "object") {
        warn2("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone22;
    }
    for (let i = 0; i < sames.length; i++) {
      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression2(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res2 = {};
  res2.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res2.item = item.replace(forIteratorRE, "").trim();
    res2.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res2.collection = iteratorMatch[2].trim();
    }
  } else {
    res2.item = item;
  }
  return res2;
}
function getIterationScopeVariables2(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
    names.forEach((name, i) => {
      scopeVariables[name] = item[i];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric32(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler32() {
}
handler32.inline = (el, { expression }, { cleanup: cleanup22 }) => {
  let root = closestRoot2(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup22(() => delete root._x_refs[expression]);
};
directive2("ref", handler32);
directive2("if", (el, { expression }, { effect: effect32, cleanup: cleanup22 }) => {
  let evaluate22 = evaluateLater2(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone22 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode2(clone22, {}, el);
    mutateDom2(() => {
      el.after(clone22);
      initTree2(clone22);
    });
    el._x_currentIfEl = clone22;
    el._x_undoIf = () => {
      walk2(clone22, (node) => {
        if (!!node._x_effects) {
          node._x_effects.forEach(dequeueJob2);
        }
      });
      clone22.remove();
      delete el._x_currentIfEl;
    };
    return clone22;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect32(() => evaluate22((value) => {
    value ? show() : hide();
  }));
  cleanup22(() => el._x_undoIf && el._x_undoIf());
});
directive2("id", (el, { expression }, { evaluate: evaluate22 }) => {
  let names = evaluate22(expression);
  names.forEach((name) => setIdRoot2(el, name));
});
mapAttributes2(startingWith2("@", into2(prefix2("on:"))));
directive2("on", skipDuringClone2((el, { value, modifiers, expression }, { cleanup: cleanup22 }) => {
  let evaluate22 = expression ? evaluateLater2(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on2(el, value, modifiers, (e) => {
    evaluate22(() => {
    }, { scope: { $event: e }, params: [e] });
  });
  cleanup22(() => removeListener());
}));
warnMissingPluginDirective2("Collapse", "collapse", "collapse");
warnMissingPluginDirective2("Intersect", "intersect", "intersect");
warnMissingPluginDirective2("Focus", "trap", "focus");
warnMissingPluginDirective2("Mask", "mask", "mask");
function warnMissingPluginDirective2(name, directiveName2, slug) {
  directive2(directiveName2, (el) => warn2(`You can't use [x-${directiveName2}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default2.setEvaluator(normalEvaluator2);
alpine_default2.setReactivityEngine({ reactive: reactive22, effect: effect22, release: stop2, raw: toRaw2 });

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/definitions.render_type.ts
var VRenderType = /* @__PURE__ */ ((VRenderType2) => {
  VRenderType2["renderNull"] = "renderNull";
  VRenderType2["renderSelect"] = "renderSelect";
  VRenderType2["renderSingleDate"] = "renderSingleDate";
  VRenderType2["renderDateRange"] = "renderDateRange";
  VRenderType2["renderNumber"] = "renderNumber";
  VRenderType2["renderContacto"] = "renderContacto";
  VRenderType2["renderButtonGroup"] = "renderButtonGroup";
  VRenderType2["renderText"] = "renderText";
  VRenderType2["renderNumericInterval"] = "renderNumericInterval";
  return VRenderType2;
})(VRenderType || {});

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/definitions.search_types.ts
var IN = "1";
var NOT_IN = "2";
var LIKE = "3";
var NOT_LIKE = "4";
var GREATER_THAN = "5";
var LESS_THAN = "6";
var GREATER_THAN_OR_EQUAL = "7";
var LESS_THAN_OR_EQUAL = "8";
var IS_NULL = "13";
var IS_NOT_NULL = "14";
var BETWEEN = "15";
var NOT_BETWEEN = "16";
var IS_BEFORE = "17";
var IS_AFTER = "18";
var JSON_CONTAINS = "19";
var JSON_NOT_CONTAINS = "20";
var IS_EQUAL = "21";
var IS_NOT_EQUAL = "22";
var HAS_ATTACHMENTS = "23";
var IN_RANGE = "25";
var search_types = {
  BETWEEN,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  HAS_ATTACHMENTS,
  IS_AFTER,
  IS_BEFORE,
  IS_EQUAL,
  IS_NOT_EQUAL,
  IS_NOT_NULL,
  IS_NULL,
  JSON_CONTAINS,
  JSON_NOT_CONTAINS,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LIKE,
  NOT_BETWEEN,
  NOT_IN,
  NOT_LIKE,
  IN,
  IN_RANGE
};
var VSearchType2 = /* @__PURE__ */ ((VSearchType3) => {
  VSearchType3["BETWEEN"] = "15";
  VSearchType3["GREATER_THAN"] = "5";
  VSearchType3["GREATER_THAN_OR_EQUAL"] = "7";
  VSearchType3["HAS_ATTACHMENTS"] = "23";
  VSearchType3["IN_RANGE"] = "25";
  VSearchType3["IS_AFTER"] = "18";
  VSearchType3["IS_BEFORE"] = "17";
  VSearchType3["IS_EQUAL"] = "21";
  VSearchType3["IS_NOT_EQUAL"] = "22";
  VSearchType3["IS_NOT_NULL"] = "14";
  VSearchType3["IS_NULL"] = "13";
  VSearchType3["JSON_CONTAINS"] = "19";
  VSearchType3["JSON_NOT_CONTAINS"] = "20";
  VSearchType3["LESS_THAN"] = "6";
  VSearchType3["LESS_THAN_OR_EQUAL"] = "8";
  VSearchType3["LIKE"] = "3";
  VSearchType3["NOT_BETWEEN"] = "16";
  VSearchType3["NOT_IN"] = "2";
  VSearchType3["NOT_LIKE"] = "4";
  VSearchType3["IN"] = "1";
  return VSearchType3;
})(VSearchType2 || {});
var VTypeSearch2 = Object.entries(VSearchType2).reduce((a, [k, v]) => ({ ...a, [v]: k }), {});

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/src/logLevel.ts
var LogLevels = {
  ERROR: 5,
  WARN: 4,
  INFO: 3,
  DEBUG: 2,
  TRACE: 1
};
var fakeConsole2 = {
  ...console,
  log: (args) => {
    null;
  },
  info: (args) => {
    null;
  },
  debug: (args) => {
    null;
  },
  warn: (args) => {
    null;
  },
  error: (args) => {
    null;
  }
};

// ../../../negocios-panel/resources/packages/@lacasadejuana/types/alpine.store.ts
console.zdebug = console.info.bind(
  console,
  "%cDEBUG:",
  "color:#A39;font-weight:bold;"
);
console.zsuccess = console.info.bind(
  console,
  "%cSUCCESS:",
  "color:#16a34a;font-weight:bold;"
);
console.zlog = console.log.bind(
  console,
  "%cLOG:",
  "color:#090;font-weight:bold;"
);
console.zinfo = console.info.bind(
  console,
  "%cINFO:",
  "color:#33C;font-weight:bold;"
);
console.zwarn = console.warn.bind(
  console,
  "%cWARN:",
  "color:orange;font-weight:bold;"
);

// src/js/components/decorators/ContactOption.ts
function processOption(option) {
  let entry = typeof option === "string" ? { name: option, value: option, id: option } : {
    //@ts-ignore
    name: option.name || option.label || option.value || option,
    //@ts-ignore
    label: option.label || option.name || option.value || option,
    //@ts-ignore
    value: option.value || option.id || option.name || option,
    //@ts-ignore
    id: option.value || option.id || option.name || option
  };
  if (typeof option === "object" && option && option.opt_group)
    entry.opt_group = option.opt_group;
  if (/^\d+$/.test(entry.id))
    entry.id = Number(entry.id);
  if (/^\d+$/.test(entry.value))
    entry.value = Number(entry.value);
  return entry;
}
function processContactOption(option) {
  const optionObject = typeof option === "string" ? { nombre_completo: option, id: option, name: option } : {
    nombre_completo: option.nombre_completo,
    id: option.id,
    email: option.email,
    name: option.nombre_completo
  };
  return optionObject;
}

// src/js/components/alpine_definitions/OptionGroups.ts
var optgroups = [
  //{ group: 'otros', id: 'otros', name: 'Otros' },
  {
    group: "fechas_negocio",
    id: "fechas_negocio",
    name: "Fechas Negocio"
  },
  {
    group: "general",
    id: "general",
    name: "General"
  },
  {
    group: "propiedad",
    id: "propiedad",
    name: "Datos Propiedad"
  },
  {
    group: "comercial",
    id: "comercial",
    name: "Info Comercial"
  },
  {
    group: "contacto",
    id: "contacto",
    name: "Contactos Asociados"
  }
];
var defaultSlugs = [
  "id",
  "nombre",
  "tipo_negocio",
  //'id_tipo_negocio',
  "tipo_propiedad",
  //'id_tipo_propiedad',
  "etapa_negocio",
  //'id_etapa_negocio',
  "fecha_creacion",
  "fecha_actualizacion",
  "fecha_creacion_visual",
  "fechaCreacion"
];

// src/js/components/decorators/decorateCampo.ts
function decorateCampo(campo) {
  campo.id_input_type = String(campo.id_input_type);
  const {
    slug_name = "",
    attr_type,
    id_input_type,
    input_type,
    name
  } = campo;
  let { visible, width } = campo;
  if (!slug_name) {
    console.warn({ campo });
    return campo;
  }
  let group = "general";
  if (slug_name === "nombre") {
    group = "general";
  } else if (attr_type === "propiedad_attr" || slug_name.includes("direccion") || attr_type === "propiedad" || slug_name.includes("m2")) {
    group = "propiedad";
  } else if (slug_name.includes("esperada") && slug_name.includes("venta") || slug_name.includes("precio") || slug_name.includes("monto") || slug_name.includes("gasto") || slug_name.includes("contribuciones") || slug_name.includes("credito") || slug_name.includes("pago") || slug_name.includes("abono") || slug_name.includes("uf") || slug_name.includes("costo") || slug_name.includes("valor")) {
    group = "comercial";
  } else if (String(input_type).toLowerCase().includes("date") || ["5" /* INPUT_DATE */, "6" /* INPUT_DATE_TIME */].includes(id_input_type)) {
    group = "fechas_negocio";
  } else if ((attr_type || "").includes("contacto") || (input_type || "").includes("contacto")) {
    group = "contacto";
  }
  let optgroup = optgroups.find((g) => g.id === group);
  if (!optgroup)
    group = "general";
  let editable = true;
  if (campo.readonly) {
    editable = false;
  }
  let black_list = defaultSlugs;
  if (black_list.includes(slug_name)) {
    editable = false;
  }
  const key = [slug_name, attr_type].filter(Boolean).join(",");
  let data3 = campo.slug_name;
  if (campo.id_input_type === "8" /* INPUT_CHECKBOX */) {
    campo.properties = [
      { id: "NOT NULL", name: "Checked" },
      { id: "NULL", name: "Unchecked" }
    ];
  }
  let template_id;
  switch (campo.id_input_type) {
    case "1" /* INPUT_SELECT */:
    case "14" /* INPUT_RADIO_BUTTONGROUP */:
    case "12" /* INPUT_STATIC_PARAMS */:
      if ([
        "id_tipo_negocio",
        "id_tipo_propiedad",
        "id_etapa_negocio"
      ].includes(String(campo.slug_name))) {
        template_id = "#input_main_fields";
      } else {
        template_id = "#input_select";
      }
      break;
    case "10" /* INPUT_CONTACTO_ASOCIADO */:
      template_id = "#input_contacto";
      break;
    case "2" /* INPUT_TEXT */:
    case "4" /* INPUT_TEXT_AREA */:
      template_id = "#input_textarea";
      break;
    case "9" /* INPUT_SELECT_MULTIPLE */:
      template_id = "#input_multiselect";
      break;
    case "8" /* INPUT_CHECKBOX */:
      template_id = "#input_checkbox";
      break;
    case "7" /* INPUT_NUMBER */:
      if (campo.slug_name !== "id") {
        template_id = "#input_number";
      }
      break;
    case "5" /* INPUT_DATE */:
    case "6" /* INPUT_DATE_TIME */:
      if (campo.readonly) {
        template_id = "#input_readonly";
      } else {
        template_id = "#input_dates";
      }
      break;
    default:
      break;
  }
  return {
    ...campo,
    editable,
    data: data3,
    field: data3,
    key,
    group,
    template_id,
    className: [name].join(" "),
    width,
    title: campo.name
  };
}
globalThis.decorateCampo = decorateCampo;

// src/js/components/stores/BaseClass.ts
var BaseClass = class _BaseClass {
  constructor() {
    this.className = "BaseClass";
    this.silent = false;
    this.loglevel = 3 /* INFO */;
    this.timerColor = "color:blue;font-weight:bold";
    this.classNameColor = "color:blue;font-weight:bold;";
    this.onReadyHandlers = [];
    this.eventListeners = {};
  }
  async onReady(handler5) {
    return this.once("ready", handler5);
  }
  /**
   * Handlers declared on an event that is fulfilled should be invoked inmediately
   */
  get verifiers() {
    return {
      "ready": this.ready
    };
  }
  on(event, handler5) {
    this.eventListeners[event] = this.eventListeners[event] || [];
    if (handler5) {
      return this.tap(() => {
        if (typeof handler5 !== "function") {
          this.console.warn("handler is not a function", handler5);
        }
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return handler5(this);
        this.eventListeners[event].push(handler5);
      });
    } else {
      return new Promise((res2) => {
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return res2(this);
        this.eventListeners[event].push(res2);
      });
    }
  }
  once(event, handler5) {
    this.eventListeners[event] = this.eventListeners[event] || [];
    if (handler5) {
      return this.tap(() => {
        if (typeof handler5 !== "function") {
          this.console.warn("handler is not a function", handler5);
        }
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return handler5(this);
        handler5.once = true;
        this.eventListeners[event].push(handler5);
      });
    } else {
      return new Promise((res2) => {
        if (event === "ready" && this.ready || this.verifiers[event] === true)
          return res2(this);
        res2.once = true;
        this.eventListeners[event].push(res2);
      });
    }
  }
  processEventListeners(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event] || !this.eventListeners[event].length)
      return;
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    this.eventListeners[event] = otherHandlers;
    if (onceHandlers.length) {
      this.marquee(" firing " + onceHandlers.length + " onceHandlers for " + event + " event ");
      while (onceHandlers.length) {
        let onceHandler = onceHandlers.shift();
        if (typeof onceHandler !== "function")
          continue;
        try {
          requestAnimationFrame(() => onceHandler(callbackArgument));
        } catch (e) {
          console.error("error in onceHandler", e);
        }
      }
    }
    if (otherHandlers.length) {
      this.marquee(" firing " + otherHandlers.length + " regular handlers for " + event + " event ");
      otherHandlers.forEach((cb) => requestAnimationFrame(() => cb(callbackArgument)));
    }
    this.marquee(" done firing " + event + " event ");
  }
  processEventListenersAlt(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event] || !this.eventListeners[event].length)
      return;
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    this.marquee(" firing " + onceHandlers.length + " onceHandlers for " + event + " event ");
    while (onceHandlers.length) {
      let onceHandler = onceHandlers.shift();
      requestAnimationFrame(() => onceHandler(callbackArgument));
    }
    this.marquee(" firing " + otherHandlers.length + " regular handlers for " + event + " event ");
    otherHandlers.forEach((cb) => requestAnimationFrame(() => cb(callbackArgument)));
    this.eventListeners[event] = otherHandlers;
  }
  processHandler(handler5) {
    if (typeof handler5 === "function") {
      handler5(this);
    }
    requestAnimationFrame(() => this.processEventListeners("ready", this));
  }
  marquee(message, ...args) {
    console.marquee({
      [Number(performance.now() / 1e3).toFixed(1)]: this.timerColor,
      [String(this.constructor.name)]: this.classNameColor,
      [message]: ""
      //@ts-ignore
    }, ...args);
  }
  get console() {
    return this.silent ? fakeConsole2 : this._console;
  }
  debug(...arg) {
    this.loglevel >= LogLevels.DEBUG && this.console.debug(...arg);
  }
  log(...arg) {
    this.loglevel >= LogLevels.INFO && this.console.log(...arg);
  }
  error(...arg) {
    this.loglevel >= LogLevels.ERROR && this.console.error(...arg);
  }
  warn(...arg) {
    this.loglevel >= LogLevels.WARN && this.console.warn(...arg);
  }
  info(...arg) {
    this.loglevel >= LogLevels.INFO && this.console.info(...arg);
  }
  init() {
    this.console.log("init");
  }
  get $store() {
    return {
      tipos_busqueda: Alpine.store("tipos_busqueda"),
      columnas_actuales: Alpine.store("columnas_actuales"),
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      roles_negocio: Alpine.store("roles_negocio"),
      active_filter: Alpine.store("active_filter"),
      maps: Alpine.store("maps"),
      user: Alpine.store("user")
    };
  }
  tap(handler5) {
    if (typeof handler5 !== "function") {
      console.warn("handler is not a function", { handler: handler5 });
      return this;
    }
    return tap(this, handler5);
  }
  /**
   * Boilerplate for generic json fetch. Won't work with other content types.
   * @param endpoint 
   * @param options 
   * @returns 
   */
  fetchWrapper(endpoint, options) {
    return _BaseClass.staticFetchWrapper(endpoint, options);
  }
  static staticFetchWrapper(endpoint, options) {
    return staticFetchWrapper(endpoint, options);
  }
};
Object.defineProperty(BaseClass.prototype, "init", { enumerable: true });

// src/js/components/entities/NegocioColumn.ts
var NegocioColumn = class extends DttColumn {
  constructor(options) {
    super(options);
    this.id_input_type = options.id_input_type;
    this.attr_type = options.attr_type;
    this.properties = options.properties;
    if (this.id_input_type === "8" /* INPUT_CHECKBOX */) {
      this.properties = [
        { id: "NOT NULL", name: "Checked" },
        { id: "NULL", name: "Unchecked" }
      ];
    }
    if (this.slug_name === "dias-publicado")
      this.name = "D\xEDas Publicado";
    this.populateOptions();
    this.inferTemplateId();
    this.group = assignGroup(this);
    this.editable = !this.readonly && !defaultSlugs.includes(this.slug_name);
    this.key = [this.slug_name, this.attr_type].filter(Boolean).join(",");
    this.data = this.slug_name;
    this.field = this.slug_name;
    this.folder_slug = options.folder_slug;
  }
  populateOptions() {
    if (this.properties && Array.isArray(this.properties)) {
      this.optionMap = new Map(this.options.map((o) => [o.id, o.name]));
    }
  }
  get options() {
    if (!this.properties || !Array.isArray(this.properties))
      return [];
    return this.id_input_type == "10" /* INPUT_CONTACTO_ASOCIADO */ ? Object.values(this.properties).map(processContactOption) : Object.values(this.properties).map(processOption);
  }
  get componentName() {
    return `inputs.${this.form_component}`;
  }
  get inputName() {
    return null !== this.attr_type ? `${this.attr_type}-${this.slug_name}` : this.slug_name;
  }
  get filesInputName() {
    return this.attachesFiles ? this.inputName + "-files" : null;
  }
  inferTemplateId() {
    switch (this.id_input_type) {
      case "1" /* INPUT_SELECT */:
      case "14" /* INPUT_RADIO_BUTTONGROUP */:
      case "12" /* INPUT_STATIC_PARAMS */:
        if (String(this.slug_name) === "id_etapa_negocio") {
          this.template_id = "#input_etapa_negocio";
        } else if ([
          "id_tipo_negocio",
          "id_tipo_propiedad"
        ].includes(String(this.slug_name))) {
          this.template_id = "#input_main_fields";
        } else {
          this.template_id = "#input_select";
        }
        break;
      case "10" /* INPUT_CONTACTO_ASOCIADO */:
        this.template_id = "#input_contacto";
        break;
      case "2" /* INPUT_TEXT */:
      case "4" /* INPUT_TEXT_AREA */:
        this.template_id = "#input_textarea";
        break;
      case "9" /* INPUT_SELECT_MULTIPLE */:
        this.template_id = "#input_multiselect";
        break;
      case "8" /* INPUT_CHECKBOX */:
        this.template_id = "#input_checkbox";
        break;
      case "7" /* INPUT_NUMBER */:
        if (this.slug_name !== "id") {
          this.template_id = "#input_number";
        }
        break;
      case "5" /* INPUT_DATE */:
      case "6" /* INPUT_DATE_TIME */:
        if (this.readonly) {
          this.template_id = "#input_readonly";
        } else {
          this.template_id = "#input_dates";
        }
        break;
      default:
        break;
    }
  }
  getShownValue(negocio) {
    if (typeof negocio === "number")
      negocio = this.$store.negocios.get(negocio);
    negocio = negocio || { _extra_props: {} };
    let baseline = negocio[this.slug_name] || (negocio._extra_props || {})[this.slug_name] || "";
    if (this.isSelectOrRadioButtonGroup || this.isContact) {
      if (!this.optionMap) {
        console.warn("Campo select sin opciones", this);
        return baseline;
      }
      return this.optionMap.get(negocio[this.slug_name] || "") || this.optionMap.get(String(negocio[this.slug_name]) || "") || this.optionMap.get(Number(negocio[this.slug_name]) || "") || "";
    }
    if (this.isMultiSelectField) {
      let value = negocio[this.slug_name] || [];
      return Array.isArray(value) ? value.map((id) => this.optionMap.get(id) || "").join(", ") : value;
    }
    if (typeof negocio[this.slug_name] === "string") {
      return baseline.replace("[null]", "").replace("null", "");
    }
    return baseline;
  }
  get attachesFiles() {
    return !!this.attach_files;
  }
  get isMultiSelectField() {
    return "9" /* INPUT_SELECT_MULTIPLE */ === String(this.id_input_type);
  }
  get isDateOrDatetimeField() {
    return "5" /* INPUT_DATE */ === String(this.id_input_type) || "6" /* INPUT_DATE_TIME */ === String(this.id_input_type);
  }
  get isTextOrTextArea() {
    return "2" /* INPUT_TEXT */ === String(this.id_input_type) || "4" /* INPUT_TEXT_AREA */ === String(this.id_input_type);
  }
  get isSelectOrRadioButtonGroup() {
    return "12" /* INPUT_STATIC_PARAMS */ === String(this.id_input_type) || "14" /* INPUT_RADIO_BUTTONGROUP */ === String(this.id_input_type) || "1" /* INPUT_SELECT */ === String(this.id_input_type);
  }
  get isCheckbox() {
    return "8" /* INPUT_CHECKBOX */ === String(this.id_input_type);
  }
  get isNumber() {
    return "7" /* INPUT_NUMBER */ === String(this.id_input_type);
  }
  get isContact() {
    return "10" /* INPUT_CONTACTO_ASOCIADO */ === String(this.id_input_type);
  }
};
function assignGroup(column) {
  let { slug_name, attr_type, input_type, id_input_type } = column;
  let group = "general";
  if (slug_name === "nombre") {
    group = "general";
  } else if (attr_type === "propiedad_attr" || slug_name.includes("direccion") || attr_type === "propiedad" || slug_name.includes("m2")) {
    group = "propiedad";
  } else if (slug_name.includes("esperada") && slug_name.includes("venta") || slug_name.includes("precio") || slug_name.includes("monto") || slug_name.includes("gasto") || slug_name.includes("contribuciones") || slug_name.includes("credito") || slug_name.includes("pago") || slug_name.includes("abono") || slug_name.includes("uf") || slug_name.includes("costo") || slug_name.includes("valor")) {
    group = "comercial";
  } else if (String(input_type).toLowerCase().includes("date") || ["5" /* INPUT_DATE */, "6" /* INPUT_DATE_TIME */].includes(id_input_type)) {
    group = "fechas_negocio";
  } else if ((attr_type || "").includes("contacto") || (input_type || "").includes("contacto")) {
    group = "contacto";
  }
  let optgroup = optgroups.find((g) => g.id === group);
  if (!optgroup)
    group = "general";
  return group;
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/js/components/stores/CamposBusquedaStore.ts
var CamposBusquedaStore = class extends BaseClass {
  constructor() {
    super();
    this.className = "CamposBusquedaStore";
    this.silent = false;
    this.loglevel = 4 /* WARN */;
    this.id = v4_default();
    this.properties = [];
    this.fieldMap = /* @__PURE__ */ new Map();
    this.timerColor = "color:blue;font-weight:bold";
    this.classNameColor = "color:purple;font-weight:bold;";
    this.fetching_light_list = false;
    this.ready = false;
    this.classNameColor = "color:purple;font-weight:bold;";
    this._console = bindConsole(this.className, this.classNameColor);
    this.init();
  }
  init() {
    this.marquee(" init ");
    this.lightList = new Promise((res2) => {
    });
  }
  get columnDefs() {
    return this.properties;
  }
  set columnDefs(campos_busqueda) {
    this.properties = campos_busqueda;
  }
  reloadCampos(campos_busqueda, reset = false) {
    if (!campos_busqueda || campos_busqueda.length === 0)
      return;
    if (this.ready)
      return;
    this.properties = Object.values(campos_busqueda).filter((c) => c.slug_name).map((c) => new NegocioColumn(decorateCampo(c))).map((c) => {
      if (defaultSlugs.includes(c.slug_name)) {
        c.readonly = true;
        c.is_default = true;
      }
      this.fieldMap.set(c.slug_name, c);
      return c;
    });
    if (!this.ready) {
      this.ready = true;
      this.marquee(" finished proccesing columnDefs ");
      requestAnimationFrame(() => this.processEventListeners("ready", this));
    }
    return this.properties;
  }
  async fetchLightNegocios() {
    if (this.fetching_light_list)
      return this.lightList;
    this.fetching_light_list = true;
    return staticFetchWrapper("/api/negocios/light_list", {}).then(async (res2) => {
      const jsonRes = tap(await res2, (lightList) => {
        this.find("codigo_interno").properties = Object.values(lightList).filter((option) => option.codigo_interno && String(option.codigo_interno).length === 6).map((option) => {
          return {
            id: option.codigo_interno,
            value: option.codigo_interno,
            label: `${option.codigo_interno}|${option.nombre}`,
            name: `${option.codigo_interno}|${option.nombre}`
          };
        });
        this.find("id").properties = Object.values(lightList).filter((option) => option.id).map((option) => {
          return {
            value: option.id,
            name: `#${option.id}|${option.nombre}`
          };
        });
      });
      return jsonRes.map((row) => {
        let { direccion, propietario } = inferDireccionAndPropietario(row.nombre);
        return { id: row.id, direccion, propietario };
      });
    });
  }
  findMany(cols) {
    return cols.filter((c) => c).map((c) => {
      let col = this.find(c.slug_name || c) || { slug_name: c.slug_name || c, visible: true };
      col.visible = typeof c === "object" ? c.visible ?? true : col.visible;
      return col;
    }).filter((c) => c);
  }
  getMany(ids) {
    return ids.filter((c) => c).map((c) => {
      let col = this.get(c.id || c) || { id: typeof c === "object" ? c.id : c, visible: true };
      col.visible = typeof c === "object" ? c.visible ?? true : col.visible;
      return col;
    }).filter((c) => c);
  }
  computeOptions(campo_busqueda) {
    const campo = this.find(campo_busqueda.split(",")[0]) || { id_input_type: "2" /* INPUT_TEXT */ };
    if (!campo || campo.id_input_type === "1" /* INPUT_SELECT */ && campo.properties === null) {
      console.warn("Campo select sin opciones", campo);
      return [];
    }
    return campo.options;
  }
  getShownValue(negocio, slug_name) {
    const item = this.find(slug_name);
    if (typeof negocio === "number")
      negocio = this.$store.negocios.get(negocio);
    if (item)
      return item.getShownValue(negocio);
    negocio = negocio || {};
    let baseline = negocio[slug_name] || "";
    if (negocio._extra_props) {
      baseline = (negocio[slug_name] ?? negocio._extra_props[slug_name]) || "";
    }
    if (!item) {
      return baseline;
    }
    if (this.isSelectOrRadioButtonGroup(item.id_input_type) || this.isContact(item.id_input_type)) {
      if (!item.optionMap) {
        console.warn("Campo select sin opciones", item);
        return baseline;
      }
      return item.optionMap.get(baseline || "") || item.optionMap.get(baseline || "") || "";
    }
    if (this.isMultiSelectField(item.id_input_type)) {
      let value = negocio[slug_name] || [];
      return Array.isArray(value) ? value.map((id) => item.optionMap.get(id) || "").join(", ") : value;
    }
    if (typeof baseline === "string") {
      return baseline.replace("[null]", "");
    }
    return baseline;
  }
  /**
   * Slug name should be only the clean nombre of the field,
   * but this method cleans the postfix in case it was passed a
   * filter campo de busqueda
   * 
   * @param {string} slug_name 
   * @returns 
   */
  find(slug_name) {
    let exact_match = this.fieldMap.get(slug_name.replace(/^([^,]+),?.*$/, "$1"));
    if (exact_match)
      return exact_match;
    if (slug_name.endsWith("*"))
      return this.properties.find((prop) => prop.slug_name.startsWith(slug_name.replace("*", "")));
    if (slug_name.startsWith("*"))
      return this.properties.find((prop) => prop.slug_name.endsWith(slug_name.replace("*", "")));
    return this.properties.find((prop) => prop.slug_name.includes(slug_name.replaceAll("*", "")));
  }
  has(slug_name) {
    return this.fieldMap.has(slug_name);
  }
  get(id) {
    return this.properties.find((c) => c.id == id);
  }
  get contactos_asociados_fields() {
    return Object.values(this.properties).filter(
      (c) => [
        "10" /* INPUT_CONTACTO_ASOCIADO */
      ].includes(c.id_input_type)
    ).filter(
      (field) => field.group === "contacto"
    );
  }
  get slugs_no_seleccionables() {
    return this.no_seleccionables.map((c) => c.slug_name);
  }
  get columnas_seleccionables() {
    return Object.values(this.properties).filter(
      (campo) => !this.slugs_no_seleccionables.includes(campo.slug_name)
    );
  }
  get all_selectable_fields() {
    return Object.values(this.properties).filter((c) => [
      "1" /* INPUT_SELECT */,
      "2" /* INPUT_TEXT */,
      "4" /* INPUT_TEXT_AREA */,
      "7" /* INPUT_NUMBER */,
      "14" /* INPUT_RADIO_BUTTONGROUP */,
      "12" /* INPUT_STATIC_PARAMS */,
      "8" /* INPUT_CHECKBOX */,
      "12" /* INPUT_STATIC_PARAMS */,
      "5" /* INPUT_DATE */,
      "6" /* INPUT_DATE_TIME */,
      "9" /* INPUT_SELECT_MULTIPLE */
    ].includes(c.id_input_type)).concat(this.contactos_asociados_fields);
  }
  isMultiSelectField(id_input_type) {
    return "9" /* INPUT_SELECT_MULTIPLE */ === String(id_input_type);
  }
  isDateOrDatetimeField(id_input_type) {
    return "5" /* INPUT_DATE */ === String(id_input_type) || "6" /* INPUT_DATE_TIME */ === String(id_input_type);
  }
  isTextOrTextArea(id_input_type) {
    return "2" /* INPUT_TEXT */ === String(id_input_type) || "4" /* INPUT_TEXT_AREA */ === String(id_input_type);
  }
  isSelectOrRadioButtonGroup(id_input_type) {
    return "12" /* INPUT_STATIC_PARAMS */ === String(id_input_type) || "14" /* INPUT_RADIO_BUTTONGROUP */ === String(id_input_type) || "1" /* INPUT_SELECT */ === String(id_input_type);
  }
  isCheckbox(id_input_type) {
    return "8" /* INPUT_CHECKBOX */ === String(id_input_type);
  }
  isNumber(id_input_type) {
    return "7" /* INPUT_NUMBER */ === String(id_input_type);
  }
  isContact(id_input_type) {
    return "10" /* INPUT_CONTACTO_ASOCIADO */ === String(id_input_type);
  }
  get optgroups() {
    return optgroups;
  }
  get no_seleccionables() {
    return this.properties.filter((c) => [
      "nombre",
      "id_tipo_negocio",
      "id_tipo_propiedad",
      "id_etapa_negocio",
      "fecha_creacion",
      "fechaCreacion",
      "fecha_creacion_visual"
    ].concat(this.defaultSlugs).includes(c.slug_name));
  }
  get defaultSlugs() {
    return defaultSlugs;
  }
  printTable(ids) {
    ids = ids.map((id) => id.id || id);
    console.log("buscando", ids.toString());
    let campos = ids.map((id) => this.get(id));
    console.table(campos, ["id", "slug_name", "visible"]);
  }
  /**
   * @todo why stringify and parse?
   */
  get readOnly() {
    return JSON.parse(JSON.stringify(Object.values(this.properties))).filter((c) => c.readonly).map((c) => c.slug_name).concat(this.defaultSlugs);
  }
};
Object.defineProperty(CamposBusquedaStore.prototype, "init", { enumerable: true });

// src/js/components/stores/PersonaStore.ts
var PersonaStore = class extends BaseClass {
  constructor() {
    super();
    this.className = "PersonaStore";
    this.silent = false;
    this.loglevel = 4 /* WARN */;
    this.persona = {};
    this._console = bindConsole(this.className);
    console.marquee({
      [Number(performance.now() / 1e3).toFixed(1)]: "color:blue;font-weight:bold",
      " created store ": "",
      [String(this.constructor.name)]: "color:purple;font-weight:bold;"
    });
  }
  init() {
  }
  get extra_attributes() {
    return this.persona.extra_attributes || {};
  }
  mergeAttributes(attrs) {
    this.persona.extra_attributes = {
      ...this.persona.extra_attributes,
      ...attrs
    };
  }
  mergeAttributesIfMissing(attrs) {
    Object.entries(attrs).forEach(([key, value]) => {
      this.persona.extra_attributes[key] = this.persona.extra_attributes[key] ?? value;
    });
  }
  get nombre_completo() {
    return this.persona.nombre + " " + this.persona.apellidos;
  }
  setProperties(persona) {
    this.persona = persona;
    this.id = persona.id || null;
    this.persona.extra_attributes = this.persona.extra_attributes || {};
    this.syncAttributes();
    this.persona.extra_attributes.id_rol_negocio = Object.values((this.persona.extra_attributes || {}).id_rol_negocio || []);
  }
  /**
   * Syncs extra attributes in both notations 
   * e.g. persona[extra-attributes->comuna] and persona.extra_attributes.comuna
   */
  syncAttributes() {
    Object.entries(this.persona || {}).forEach(([key, value]) => {
      if (key.startsWith("extra_attributes->")) {
        this.persona.extra_attributes[key.replace("extra_attributes->", "")] = this.persona.extra_attributes[key.replace("extra_attributes->", "")] ?? value;
      }
    });
    Object.entries(this.persona.extra_attributes || {}).forEach(([key, value]) => {
      this.persona[`extra_attributes->${key}`] = this.persona[`extra_attributes->${key}`] ?? value;
    });
  }
  get(key, defaultValue = null) {
    return this.persona[key] || defaultValue;
  }
  get mapLink() {
    let { lat, lng, map_link } = this.persona.extra_attributes;
    if (map_link)
      return map_link;
    if (lat && lng)
      return encodeURI(`https://www.google.com/maps/search/?api=1&query='${this.persona.direccion}'`);
  }
  get payload() {
    return this.persona;
  }
  save_property(frm, remove_label = false) {
    let tokenElement = frm.querySelector('[name="_token"]');
    if (!(tokenElement instanceof HTMLInputElement) || !tokenElement.value)
      throw new Error("No se encontr\xF3 el token de seguridad");
    const sanctumToken = document.querySelector('meta[name="test_user_token"]');
    const headers = {
      // 'Content-Type': 'application/json; charset=UTF-8',
    };
    if (sanctumToken) {
      headers["Authorization"] = `Bearer ${sanctumToken.content}`;
    } else {
      headers["X-CSRF-TOKEN"] = `${tokenElement.value}`;
    }
    const propfields = new FormData(frm);
    propfields.delete("negocio-id_etapa_negocio");
    propfields.delete("modal_etapas");
    return fetch(frm.action, {
      method: String(propfields.get("_method") || "POST"),
      headers,
      body: propfields
    }).then((res2) => res2.json()).then(async (jsonRes) => {
      return jsonRes;
    });
  }
  get changed() {
    let changed = /* @__PURE__ */ new Map();
    for (let [key, value] of Object.entries(this.persona)) {
      let cleanKey = key;
      let initialValue = this.persona[key];
      if (initialValue === null && !value)
        continue;
      if (initialValue != value) {
        changed.set(cleanKey, value);
      }
    }
    return Object.fromEntries(changed);
  }
};
Object.defineProperty(PersonaStore.prototype, "init", { enumerable: true });

// src/js/components/entities/EnrichedFilter.ts
var import_lodash = __toESM(require_lodash());
var EnrichedFilter = class {
  constructor(filtro) {
    this.filter_id = String(filtro.id);
    filtro.valor_busquedaFn = (negocio) => true;
    this._filtro = filtro;
    this._campo_busqueda = filtro.campo_busqueda;
    this._tipo_busqueda = filtro.tipo_busqueda;
    this._conector = filtro.conector;
    this._valor_busqueda = filtro.valor_busqueda;
    this.disabled = filtro.disabled;
    this.index = filtro.index;
    this.$store.active_filter = Alpine.store("active_filter");
    this.$store.tipos_busqueda = Alpine.store("tipos_busqueda");
  }
  get id() {
    return this.filter_id;
  }
  get parent_id() {
    return Number(this.$store.active_filter.id);
  }
  get conector() {
    return this._conector || this._filtro.conector;
  }
  set conector(conector) {
    this._conector = conector;
    this._filtro.conector = conector;
  }
  get valor_busqueda() {
    return this._valor_busqueda || this._filtro.valor_busqueda;
  }
  set valor_busqueda(valor_busqueda) {
    this._valor_busqueda = valor_busqueda;
    this._filtro.valor_busqueda = valor_busqueda;
  }
  get "$store"() {
    return {
      campos_busqueda: Alpine.store("campos_busqueda"),
      negocios: Alpine.store("negocios"),
      columnas_actuales: Alpine.store("columnas_actuales"),
      active_filter: Alpine.store("active_filter"),
      tipos_busqueda: Alpine.store("tipos_busqueda")
    };
  }
  get campo_busqueda() {
    return this._campo_busqueda;
  }
  set campo_busqueda(newCampo) {
    if (this._campo_busqueda !== newCampo) {
      this._campo_busqueda = newCampo;
      console.colorInfo("#00C", "EnrichedFilter", { "setting new campo ": newCampo, shouldRender: this.shouldRender });
      this.valor_busqueda = "";
      this.tipo_busqueda = "13" /* IS_NULL */;
    }
  }
  get tipo_busqueda() {
    return this._tipo_busqueda;
  }
  set tipo_busqueda(newType) {
    if (this._tipo_busqueda === newType)
      return;
    this._tipo_busqueda = newType;
    console.colorInfo("#00C", "EnrichedFilter", { "setting new tipo_busqueda ": newType, shouldRender: this.shouldRender, valor_busqueda: this.valor_busqueda });
    if (!(0, import_lodash.isArray)(this.valor_busqueda))
      this.valor_busqueda = [];
  }
  get filtro() {
    return this;
  }
  get slug_name() {
    return (this.campo_busqueda || "").replace(/^([^,]+).*$/, "$1") || this.campo_busqueda.split(",")[0];
  }
  get id_input_type() {
    return (this.campo || { id_input_type: "2" /* INPUT_TEXT */ }).id_input_type;
  }
  get id_rol_negocio() {
    return (this.campo || { id_rol_negocio: null }).id_rol_negocio;
  }
  get slug() {
    return this.slug_name;
  }
  get attr_type() {
    return this.campo ? this.campo.attr_type : this.campo_busqueda.split(",")[1] ?? "negocio";
  }
  get campo() {
    return this.filtro && this.campo_busqueda ? this.$store.campos_busqueda.find(this.campo_busqueda) : { id_input_type: "2" /* INPUT_TEXT */ };
  }
  get tipo() {
    return this.$store.tipos_busqueda.get(this.tipo_busqueda).name;
  }
  get operation() {
    return this.$store.tipos_busqueda.getOperation(this.tipo_busqueda);
  }
  get properties() {
    return this.campo && Array.isArray(this.campo.properties) ? this.campo.properties : [];
  }
  get items() {
    return (Array.isArray(this.valor_busqueda) ? this.valor_busqueda : [this.valor_busqueda]).map(String);
  }
  get options() {
    return this.campo ? this.campo.options : [];
  }
  get operadores_busqueda() {
    return this.$store.tipos_busqueda.operadores_para(
      this.campo || { id_input_type: 0 }
    ) || {
      ["13" /* IS_NULL */]: "Vac\xEDo/Nulo",
      ["14" /* IS_NOT_NULL */]: "No es vac\xEDo/Nulo"
    };
  }
  /*get index() {
      return (this.filtro || {}).index;
  }
  set index(value) {
      this.filtro.index = value;
  }
  get disabled() {
      return !!(this.filtro || {}).disabled
  }
  set disabled(value) {
      this.filtro.disabled = !!value
  }*/
  get operadores() {
    return this.operadores_busqueda;
  }
  get isValid() {
    return this.campo_busqueda && this.campo_busqueda !== ",negocio" && this.slug_name && (this.valor_busqueda !== null && this.valor_busqueda !== void 0 || String(this.tipo_busqueda) === "13" /* IS_NULL */ || String(this.tipo_busqueda) === "14" /* IS_NOT_NULL */);
  }
  get input_type() {
    return this.campo ? this.campo.input_type : "text";
  }
  get payload() {
    let {
      id,
      conector,
      campo_busqueda,
      tipo_busqueda,
      valor_busqueda,
      slug_name,
      attr_type,
      id_input_type,
      id_rol_negocio,
      disabled,
      input_type,
      operation,
      index
    } = this;
    return {
      id,
      index,
      conector,
      campo_busqueda,
      tipo_busqueda,
      input_type,
      valor_busqueda: valor_busqueda === null ? null : typeof valor_busqueda === "object" ? Object.values(valor_busqueda) : valor_busqueda,
      slug_name,
      id_input_type,
      attr_type,
      id_rol_negocio,
      operation,
      disabled
    };
  }
  get templateId() {
    if (this.renderButtonGroup)
      return "#render_button_group";
    if (this.renderSelect)
      return "#render_select";
    if (this.renderContacto)
      return "#render_contacto";
    if (this.renderDateRange)
      return "#render_date_range";
    if (this.renderSingleDate)
      return "#render_date";
    if (this.renderNull)
      return "#render_null";
    if (this.renderNumber)
      return "#render_number";
    if (this.renderText)
      return "#render_text";
    return "#render_text";
  }
  getTemplateContent() {
    return document.querySelector(this.templateId).innerHTML;
  }
  get templateContent() {
    return document.querySelector(this.templateId).innerHTML;
  }
  get VRenderType() {
    return VRenderType;
  }
  get shouldRender() {
    if (!this.campo)
      return "renderNull";
    let {
      renderNumericInterval,
      renderSelect,
      renderSingleDate,
      renderDateRange,
      renderNumber,
      renderContacto,
      renderNull,
      renderText,
      renderButtonGroup
    } = this;
    let shouldRender = Object.entries({
      renderNull,
      renderSelect,
      renderSingleDate,
      renderDateRange,
      renderNumericInterval,
      renderNumber,
      renderContacto,
      renderButtonGroup,
      renderText
      //@ts-ignore
    }).find(([key, value]) => value === true);
    return shouldRender ? shouldRender[0] : "renderText";
  }
  get renderSelect() {
    if (!this.campo)
      return false;
    return (this.campo.isSelectOrRadioButtonGroup || this.campo.isMultiSelectField || this.campo.isCheckbox || !this.renderContacto && [search_types.IN, search_types.NOT_IN].includes(String(this.tipo_busqueda)) && (this.campo.options || []).length) && !this.renderNull && !this.renderButtonGroup;
  }
  get renderButtonGroup() {
    if (!this.campo)
      return false;
    return [
      search_types.HAS_ATTACHMENTS
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderSingleDate() {
    if (!this.campo)
      return false;
    return this.campo && this.campo.isDateOrDatetimeField && ![
      search_types.BETWEEN,
      search_types.NOT_BETWEEN
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderDateRange() {
    if (!this.campo)
      return false;
    return this.campo && this.campo.isDateOrDatetimeField && [
      search_types.BETWEEN,
      search_types.NOT_BETWEEN
    ].includes(String(this.tipo_busqueda)) && !this.renderNull;
  }
  get renderNumber() {
    if (!this.campo)
      return false;
    return this.campo.isNumber && !this.renderNull && search_types.IN_RANGE !== String(this.tipo_busqueda);
  }
  get renderNumericInterval() {
    if (!this.campo)
      return false;
    return this.campo.isNumber && !this.renderNull && search_types.IN_RANGE === String(this.tipo_busqueda);
  }
  get renderNull() {
    if (!this.campo)
      return true;
    return [
      search_types.IS_NULL,
      search_types.IS_NOT_NULL
    ].includes(String(this.tipo_busqueda));
  }
  get renderContacto() {
    if (!this.campo)
      return false;
    return this.campo.isContact && !this.renderNull;
  }
  get renderText() {
    return !this.renderSelect && !this.renderNull && !this.renderNumber && !this.renderDateRange && !this.renderSingleDate && !this.renderContacto && !this.renderNull;
  }
};
Object.defineProperty(EnrichedFilter.prototype, "tipo", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "input_type", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "shouldRender", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "payload", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "operadores_busqueda", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "operation", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "tipo_busqueda", { enumerable: true });
Object.defineProperty(EnrichedFilter.prototype, "campo_busqueda", { enumerable: true });

// src/js/components/stores/activeFilterStore.ts
var ActiveFilterStore = class extends BaseClass {
  constructor() {
    super();
    this.opened_once = false;
    this.filters_open = false;
    this.className = "ActiveFilterStore";
    this.ready = false;
    this.estimate = 0;
    //updated_at: Date;
    this.properties = {
      columnas_actuales: []
    };
    this.filtrosDisponibles = [];
    this.default_changed = false;
    this.filterMap = null;
    this.filterIndex = -1;
    this.filterIds = [];
    this.estimatePromise = null;
    this.controls = /* @__PURE__ */ new Map();
    this.redrawing = false;
    this.searchUrl = "/api/negocios/apply_filter";
    this.display_filters_accordion = false;
    this.loadingProgress = 0;
    this.loadingText = "";
    this._console = bindConsole(this.className);
    this.marquee(" created store ");
    globalThis.$store = globalThis.$store || {};
    globalThis.$store.active_filter = this;
    this.filterMap = /* @__PURE__ */ new Map();
    this.redrawingTimeout = null;
    this.debouncedDisableRedrawing = () => {
      if (this.redrawingTimeout)
        clearTimeout(this.redrawingTimeout);
      this.redrawingTimeout = setTimeout(() => this.disableRedrawing(), 500);
    };
  }
  get user_id() {
    return this.properties.user_id;
  }
  get nextIndex() {
    return tap(
      ++this.filterIndex,
      (index) => console.log("nextIndex", index)
    );
  }
  resetControl() {
    this.controls = /* @__PURE__ */ new Map();
    this.on("ready", () => {
    });
  }
  disableRedrawing() {
    this.marquee("disableRedrawing");
    this.redrawing = false;
  }
  get verifiers() {
    return {
      ready: !!this.ready,
      filters_loaded: this.filtrosDisponibles.length > 0
    };
  }
  replaceDisponible(filtro) {
    let position = this.filtrosDisponibles.map((f) => Number(f.id)).indexOf(Number(filtro.id));
    if (position !== -1) {
      let extracted = this.filtrosDisponibles.splice(position, 1);
      filtro.highlighted = true;
      this.filtrosDisponibles.splice(position, 0, filtro);
      this.processEventListeners("filters_loaded", this);
    } else {
      this.filtrosDisponibles.unshift(filtro);
      this.processEventListeners("filters_loaded", this);
    }
  }
  loadFiltrosDisponibles(filtrosDisponibles) {
    let filtrosNormalized = filtrosDisponibles.map((filtro) => {
      let {
        query_string,
        id,
        updated_at,
        user_id,
        name,
        created_at,
        opt_group = "Otros",
        areas_subareas,
        user,
        ...rest
      } = filtro, author = user?.name, {
        user_id: fake_user_id,
        id: fake_id,
        rol,
        personas,
        //@ts-ignore
        _method,
        filter,
        ...properties
      } = query_string;
      return {
        id,
        name,
        public: !!rest.public,
        user_id,
        ...properties,
        opt_group,
        areas_subareas,
        author,
        created_at,
        updated_at
      };
    });
    this.filtrosDisponibles = filtrosNormalized;
    this.processEventListeners("filters_loaded", this);
    return this;
  }
  once(event, handler5) {
    if (event === "filters_loaded" && this.filtrosDisponibles.length > 0 || event === "ready" && this.ready) {
      return Promise.resolve(typeof handler5 === "function" ? handler5(this) : this);
    }
    return super.once(event, handler5);
  }
  xprocessEventListeners(event, callbackArgument) {
    callbackArgument = callbackArgument || this;
    if (!this.eventListeners[event])
      return;
    this.log(`processing ${event} handlers, ${this.eventListeners[event].length} remaining`);
    let onceHandlers = this.eventListeners[event].filter((h) => h.once), otherHandlers = this.eventListeners[event].filter((h) => !h.once);
    while (onceHandlers.length) {
      onceHandlers.shift()(callbackArgument);
    }
    otherHandlers.forEach((cb) => cb(callbackArgument));
    this.eventListeners[event] = otherHandlers;
  }
  get emptyFilter() {
    return {
      id: null,
      name: "Nuevo filtro " + (/* @__PURE__ */ new Date()).toLocaleString("es-CL").replace(",", "").substr(0, 16),
      opt_group: "Otros",
      public: null,
      author: null,
      filtros: [{
        conector: "AND",
        valor_busqueda: null,
        tipo_busqueda: "14" /* IS_NOT_NULL */,
        campo_busqueda: "id_tipo_negocio,negocio",
        slug_name: "id_tipo_negocio",
        attr_type: "negocio",
        id_input_type: "1" /* INPUT_SELECT */
      }],
      columnas_visibles: [70],
      columnas_actuales: [{
        slug_name: "id_tipo_negocio",
        id: 70,
        visible: true
      }],
      areas_subareas: null,
      //@ts-ignore
      estimate: this.$store.negocios.properties.length,
      grouped_filters: [],
      filtros_and_or: [],
      user_id: null,
      created_at: null,
      updated_at: null
    };
  }
  getEstimate(options) {
    this.estimatePromise = this.estimatePromise ?? this.getEstimateOriginal(options);
    return this.estimatePromise;
  }
  get estimate_icon() {
    return this.estimatePromise ? "fa fa-spinner fa-spin" : "fa fa-calculator";
  }
  get payloadForNewFilter() {
    let { id, ...payload } = this.estimatePayload;
    return payload;
  }
  /**
  * @returns {Array<string>} the list of slugs for the current set of columns
  */
  get currentSlugs() {
    return [...(this.columnas_actuales || []).map((c) => c.slug_name)];
  }
  get estimatePayload() {
    let {
      filtros,
      user_id,
      columnas_actuales,
      columnas_visibles,
      id,
      name
    } = this.properties;
    filtros = this.filtros.filter((f) => !f.disabled && f.campo_busqueda).map((filtro) => {
      let f = filtro._filtro || filtro;
      f.conector = f.conector || f._conector || "and";
      f.campo_busqueda = (filtro.campo_busqueda || f.campo_busqueda || f._campo_busqueda).replace("fechaCreacion", "created_at");
      f.tipo_busqueda = filtro.tipo_busqueda || f.tipo_busqueda || f._tipo_busqueda;
      f.valor_busqueda = filtro.valor_busqueda || f.valor_busqueda || f._valor_busqueda;
      let [slug_name, attr_type] = f.campo_busqueda.split(",");
      f.slug_name = slug_name;
      f.attr_type = attr_type;
      return f;
    }).filter((f) => f.campo_busqueda && f.campo_busqueda !== ",negocio").map((f) => module_default.raw(f));
    return module_default.raw({
      id: this.id,
      name: this.name,
      opt_group: this.opt_group,
      areas_subareas: this.areas_subareas,
      filtros,
      public: this.public,
      columnas_actuales: module_default.raw(this.columnas_actuales),
      columnas_visibles: module_default.raw(this.columnas_visibles)
    });
  }
  normalizeSearchPayload(state) {
    state.columnas_actuales = module_default.raw(state.columnas_actuales.length ? state.columnas_actuales : this.columnas_visibles).map((c) => {
      return { id: Number(c.id), visible: c.visible, slug_name: c.slug_name };
    });
    state.columnas_visibles = module_default.raw(state.columnas_visibles.length ? state.columnas_visibles : this.columnas_visibles).map((c) => Number(c));
    let missingVisible = state.columnas_visibles.filter((c) => !state.columnas_actuales.find((c2) => c2.id == c));
    if (missingVisible.length)
      this.console.warn("missingVisible", missingVisible);
    let missing_actuales = state.columnas_actuales.filter((c) => state.columnas_visibles.indexOf(c.id) === -1).map((c) => c.id);
    if (missing_actuales.length)
      this.console.warn("missing_actuales", missing_actuales);
    state.filter = 1;
    state.from = state.from || Number(Date.now() / 1e3).toFixed(0);
    state.limit = Math.max(this.estimate ?? 100, state.limit || 1e3);
    this.console.log({ state });
    return state;
  }
  setLoading(progress, text) {
    if (progress < 1) {
      progress = Math.min(100, (100 - this.loadingProgress) * progress);
    }
    this.loadingProgress = progress;
    this.loadingText = text ?? "cargando";
    if (this.$store.user)
      this.$store.user.displayLoadingMessage = false;
  }
  clearLoading(delay = 100) {
    this.loadingProgress = this.loadingProgress + (100 - this.loadingProgress) / 2;
    setTimeout(() => {
      this.loadingProgress = 0;
      this.loadingText = "";
      if (this.$store.user)
        this.$store.user.displayLoadingMessage = false;
    }, delay ?? 100);
  }
  computeEndpoint() {
    let endpoint = location.origin + "/api/negocios/apply_filter";
    if (this.searchUrl)
      endpoint = location.origin + this.searchUrl.replace(location.origin, "");
    return endpoint;
  }
  submitSearch(state = {}) {
    const payload = this.estimatePayload;
    state = this.normalizeSearchPayload({ ...payload, ...state });
    if (!state.columnas_visibles.length) {
      this.setLoading(1 / 4, "Buscando negocios");
      this.console.warn("submitSearch: retry with  " + this.columnas_visibles.length + " current columnas_visibles");
      return waitFor(100).then(() => this.submitSearch(this.estimatePayload));
    }
    console.table(state.columnas_actuales);
    this.info("submitSearch", state);
    this.$store.negocios.complete = false;
    this.setLoading(1 / 2, "Buscando negocios");
    return this.$store.negocios.fetchFilteredRecords(this.computeEndpoint(), {
      method: "post",
      headers: {},
      state,
      page: 1
    }).then(async (result) => {
      setTimeout(() => this.$store.negocios.total = this.$store.negocios.properties.length, 1e3);
      return result;
    }).catch((e) => {
      this.clearLoading();
    });
  }
  async getEstimateOriginal(options) {
    const estimate_url = new URL(
      location.origin + "/api/filtros/estimate_filter"
    );
    estimate_url.pathname += `/${this.properties.id}`;
    if (options.include_columns) {
      estimate_url.searchParams.append("include_columns", "1");
    }
    setTimeout(() => {
      this.estimatePromise = null;
    }, 2e3);
    return BaseClass.staticFetchWrapper(estimate_url.toString(), {
      method: "POST",
      body: JSON.stringify(this.estimatePayload)
    }).then((results) => {
      results = results;
      let { total, new_total, default_filter_id, columnas_visibles } = results || {};
      this.marquee("estimate", {
        total,
        new_total,
        default_filter_id,
        columnas_visibles
      });
      this.estimatePromise = null;
      this.estimate = total;
      let freshResult = { estimate: this.estimate, columnas_visibles };
      this.processEventListeners("probe", freshResult);
      this.redrawing = false;
      return freshResult;
    }).catch((err) => {
      this.redrawing = false;
      this.estimatePromise = null;
      let fallbackResult = {
        estimate: this.estimate,
        columnas_visibles: options.include_columns ? this.$store.columnas_actuales.columnDefs : this.columnas_visibles
      };
      return fallbackResult;
    });
  }
  async updateColumnDefs() {
    return new Promise((res2) => {
      this.$store.columnas_actuales.once("columns_updated", () => res2(this.get_or_infer_columnas_actuales()));
      if (!this.$store.columnas_actuales.ready) {
        setTimeout(() => {
          this.$store.columnas_actuales.processEventListeners("columns_updated", this.$store.columnas_actuales.columnDefs);
        }, 200);
      }
      this.$store.columnas_actuales.reloadCampos(this.get_or_infer_columnas_actuales(), true);
      setTimeout(() => res2(this.columnas_actuales), 200);
    });
  }
  async submitTwice() {
    this.$store.columnas_actuales.once("columns_updated", async () => {
      this.$store.negocios.ready = false;
      await this.submitSearch({ limit: 5500, from: Number(Date.now() / 1e3).toFixed(0) });
      setTimeout(() => this.submitSearch({ limit: 5500, from: Number(Date.now() / 1e3).toFixed(0) }).then(() => globalThis.filterProgress.width = 100));
    });
    this.updateColumnDefs();
  }
  get filtros() {
    return this.filterIds.map((id) => this.filterMap.get(id));
  }
  set filtros(filtros) {
    console.log("set filtros", filtros);
    this.filterIds = [];
    let newFiltros = filtros.map((f, index) => {
      this.filterIds.push(String(f.id));
      return f;
    });
    this.properties.filtros = newFiltros;
    this.filterMap = new Map(newFiltros.map((f) => [f.id, f]));
  }
  get updated_at() {
    return this.properties.updated_at;
  }
  set updated_at(updated_at) {
    this.properties.updated_at = updated_at;
  }
  updateProperties(newProperties) {
    let {
      columnas_visibles,
      id,
      name,
      user_id,
      filtros,
      updated_at,
      created_at,
      opt_group,
      areas_subareas,
      public: isPublic,
      author,
      columnas_actuales,
      ...otherProps
    } = newProperties || this.properties;
    this.author = author;
    console.marquee({
      'Filter name is "': "",
      [name]: "color:blue;font-weight:bold",
      '"': ""
    });
    if (!id)
      isPublic = true;
    this.properties = {
      columnas_actuales: module_default.raw(columnas_actuales),
      columnas_visibles: module_default.raw(columnas_visibles),
      updated_at,
      created_at,
      id,
      name,
      user_id,
      author,
      filtros: module_default.raw(filtros),
      //@ts-ignore
      filtros2: filtros,
      opt_group,
      areas_subareas,
      public: isPublic,
      ...otherProps
    };
    this.properties.columnas_visibles = Array.isArray(columnas_visibles) && columnas_visibles.length ? module_default.raw(columnas_visibles) : [
      61,
      139,
      70,
      71,
      65,
      62
    ];
    this.properties.columnas_visibles = Array.from(
      new Set(
        [...this.properties.columnas_visibles].map((c) => String(c))
      )
    );
    this.columnas_actuales = this.infer_columnas_actuales(columnas_actuales);
    this.properties.columnas_actuales = columnas_actuales;
    this.properties.opt_group = this.properties.opt_group || "Otros";
    this.properties.areas_subareas = this.properties.areas_subareas || [];
    this.author = this.properties.author;
    this.id = id;
    this.name = name;
    this.created_at = created_at;
    this.updated_at = updated_at;
    this.public = !!isPublic;
    try {
      this.properties.filtros = this.properties.filtros || [];
      this.normalizeFiltros(filtros ?? []);
    } catch (e) {
      console.error(e);
    }
    this.columnas_actuales.forEach((c) => {
      c.id = Number(c.id);
      c.visible = c.visible ?? true;
      if (this.$store.campos_busqueda.get(c.id)) {
        let { slug_name } = this.$store.campos_busqueda.get(c.id);
        c.slug_name = slug_name;
      }
    });
    this.reloadCampos();
    if (!this.ready) {
      this.ready = true;
      this.processEventListeners("ready", this);
    }
  }
  onReady(handler5) {
    return this.once("ready", handler5);
  }
  normalizeFiltros(filtros) {
    this.filterMap = /* @__PURE__ */ new Map();
    this.filterIds = [];
    filtros = filtros || this.properties.filtros;
    if (!filtros.length)
      filtros.push(this.createDummyFilter());
    this.properties.filtros = filtros.map(
      (f, index) => {
        f.conector = f.conector || "AND";
        f.index = index;
        this.filterIds.push(String(f.id));
        return f;
      }
    );
    this.properties.filtros.forEach(
      (filtro) => this.filterMap.set(filtro.id, filtro)
    );
  }
  syncFiltrosWithAvailableInfo() {
    let availableFiltro = this.get(this.id);
    if (availableFiltro) {
      this.normalizeFiltros(availableFiltro.filtros);
      this.columnas_visibles = availableFiltro.columnas_visibles;
      this.columnas_actuales = availableFiltro.columnas_actuales;
    }
  }
  appendFiltro() {
    if (!Array.isArray(this.filterIds)) {
      this.filterIds = [];
      this.normalizeFiltros();
    }
    let lengthBefore = this.filterMap.size;
    let newFiltro = this.createDummyFilter();
    newFiltro.index = lengthBefore;
    newFiltro.id = v4_default();
    newFiltro.parent_id = Number(this.id);
    const filtro = new EnrichedFilter(newFiltro);
    this.properties.filtros.push(filtro);
    this.filterMap.set(filtro.id, filtro);
    this.filterIds.push(filtro.id);
    return filtro;
  }
  reloadCampos() {
    this.$store.columnas_actuales.syncWithActiveFilter();
  }
  rollBack() {
    this.setActive(this.id);
  }
  toggleRedrawing() {
    this.redrawing = true;
    this.debouncedDisableRedrawing();
  }
  getActive() {
    return this.get(this.id);
  }
  getSafeProperies(id) {
    id = Number(id ?? this.id);
    let { filtros, ...newProperties } = this.get(id) || {};
    filtros = (filtros || []).map((filtro) => {
      return { ...module_default.raw(filtro) };
    });
    return { id, filtros, ...newProperties };
  }
  async setActive(id) {
    id = Number(id ?? this.id);
    let { filtros, ...newProperties } = this.get(id) || {};
    this.ready = false;
    this.once("ready", () => this.updateColumnDefs());
    this.$store.tipos_busqueda.once("ready").then(() => {
      this.updateProperties(this.getSafeProperies(Number(id)));
      this.id = id;
      this.name = this.properties.name;
      this.resetSelectedColumns();
      this.default_changed = true;
    });
    return this.redrawing = true;
  }
  resetSelectedColumns() {
    if (this.controls.has("columnas_disponibles_control")) {
      this.controls.get("columnas_disponibles_control").resetSelectedOptions(
        [...this.columnas_visibles].join(",")
      );
    }
  }
  get(id) {
    if (id == 0)
      return this.emptyFilter;
    return this.filtrosDisponibles.find(
      (f) => Number(f.id) === Number(id || this.id)
    );
  }
  /**
   * Reads a cookie in the user's browser to decide if
   * the page should be reloaded after a filter is saved, or when
   * the default filter is changed
   */
  get prevent_reload() {
    return true;
  }
  reloadAvailableFilters(setActive = null) {
    this.filtrosDisponibles = [];
    setActive = setActive || this.id;
    return BaseClass.staticFetchWrapper(
      "/api/filtros/get_available_filters",
      {
        headers: {
          "cache-control": "no-cache"
        }
      }
    ).then(async (filtros) => {
      if (setActive) {
        this.once("filters_loaded", () => this.setActive(setActive));
      }
      await this.loadFiltrosDisponibles(filtros);
      return filtros;
    });
  }
  getCurrentFilter() {
    globalThis.activeFilterPromise = staticFetchWrapper(
      "/api/filtros/current_filter",
      {}
    ).then((res2) => {
      console.timerInfo("received activeFilterPromise result from sw", res2.id);
      return res2;
    });
  }
  async init() {
    this.marquee(" init ");
    this.updateProperties(this.properties);
    this.properties.filtros = (this.properties || {}).filtros || [];
  }
  removeAt(id, retry = 0) {
    this.filterIds = this.filterIds.filter((fid) => fid !== id);
    this.properties.filtros = this.properties.filtros.filter(
      (f) => f.id !== id
    );
    return this.filterMap.delete(id);
  }
  moveFilter(from, to) {
    let filterIds = [...this.filterIds].slice(0);
    let moved = filterIds.splice(from, 1)[0];
    filterIds.splice(to, 0, moved);
    this.filterIds = filterIds;
    this.properties.filtros = this.filterIds.map((id) => {
      return this.properties.filtros.find((f) => f.id == id);
    });
    console.table(this.filtros.map((f) => f.campo_busqueda));
  }
  get columnas_visibles() {
    return Array.from(new Set(this.properties.columnas_visibles));
  }
  set columnas_visibles(columnas_visibles) {
    this.properties.columnas_visibles = Array.from(
      new Set(columnas_visibles)
    );
  }
  get columnas_actuales() {
    return this.infer_columnas_actuales(this.properties.columnas_actuales);
  }
  set columnas_actuales(columnas_actuales) {
    this.properties.columnas_actuales = this.infer_columnas_actuales(columnas_actuales);
    this.columnas_visibles = this.columnas_actuales.map((c) => c.id);
  }
  get_or_infer_columnas_actuales() {
    if (!this.columnas_actuales)
      this.columnas_actuales = this.infer_columnas_actuales();
    return this.columnas_actuales;
  }
  sync_columnas_actuales() {
    this.columnas_actuales = this.infer_columnas_actuales();
    return this.columnas_actuales;
  }
  infer_columnas_actuales(columnas_actuales) {
    columnas_actuales = Array.isArray(columnas_actuales) ? columnas_actuales : Array.isArray(this.properties.columnas_actuales) ? this.properties.columnas_actuales : this.$store.columnas_actuales.columnDefs;
    let actuales = Array.from(new Set(this.columnas_visibles)).map((c) => Number(c)).map((c) => {
      let actual = columnas_actuales.find((ca) => ca.id == c) || {
        id: c,
        visible: true
      };
      let campo = this.$store.campos_busqueda.get(c);
      return {
        id: c,
        slug_name: campo?.slug_name.replace(
          "fechaCracion",
          "created_at"
        ),
        visible: actual.visible ?? true
      };
    });
    return Array.from(new Set(actuales));
  }
  get name() {
    return this.properties.name;
  }
  set name(name) {
    if (name && name !== this.properties.name) {
      this.properties.name = name;
    }
  }
  get public() {
    return !!this.properties.public;
  }
  set public(flag) {
    this.properties.public = !!flag;
  }
  get opt_group() {
    return this.properties.opt_group;
  }
  set opt_group(opt_group) {
    this.properties.opt_group = opt_group;
  }
  get areas_subareas() {
    return this.properties.areas_subareas;
  }
  set areas_subareas(areas_subareas) {
    this.properties.areas_subareas = areas_subareas;
  }
  createDummyFilter() {
    return dummyFilter();
  }
  enrichFilter(filtro) {
    return;
  }
  printColumns() {
    let combinedColumns = this.columnas_visibles.map((c) => {
      let actual = this.columnas_actuales.find((ca) => ca.id == c);
      return {
        id_visible: c,
        id_actual: actual?.id,
        slug_name: actual?.slug_name,
        visible: actual?.visible
      };
    });
    console.table(combinedColumns);
  }
  printTable(filters = null) {
    printFilters(
      (filters ?? this.enrichedFilters).map((f) => {
        let filtro = f._filtro || f;
        filtro.tipo = f.operation || f.tipo;
        return filtro;
      }),
      ["attr_type", "slug_name", "tipo", "valor_busqueda", "conector"]
    );
  }
  at(index) {
    return this.filtros[index] || {};
  }
  get enrichedFilters() {
    return this.properties.filtros;
  }
  suggestNewName() {
    return [
      (this.name || "nuevo filtro ").split(" v202")[0],
      (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").replace("T", " ").substr(0, 14)
    ].join(" v");
  }
  async setDefaultFilter(id) {
    return Promise.resolve().then(() => {
      return Promise.resolve();
    }).then(() => {
      return staticFetchWrapper("/api/filtros/change_default_filter", {
        method: "POST",
        body: JSON.stringify({ default_filter: id })
      });
    }).then((jsonRes) => {
      openToast({
        //@ts-ignore
        type: jsonRes.type,
        //@ts-ignore
        text: "Cambio de filtro guardado",
        description: jsonRes.message,
        delay: 4e3,
        from: "selectorFiltroDefault"
      });
      return;
    });
  }
  populateEmptyFilter() {
    let emptyFilter = this.emptyFilter;
    if (globalThis.defaultFieldsPromise) {
      globalThis.defaultFieldsPromise.then((fields) => {
        emptyFilter.columnas_actuales = fields.map((field) => {
          let { slug_name, id, visible } = field;
          return { slug_name, id, visible };
        });
        emptyFilter.columnas_visibles = fields.map((f) => f.id);
        this.updateProperties(emptyFilter);
      });
    } else {
      this.updateProperties(emptyFilter);
    }
    this.redrawing = true;
    this.searchUrl = null;
  }
};
Object.defineProperty(ActiveFilterStore.prototype, "id", { enumerable: true, writable: true });
Object.defineProperty(ActiveFilterStore.prototype, "name", { enumerable: true, writable: true });

// src/js/components/index.ts
var ifDefined = (element, callback, fallback) => {
  if (element) {
    return callback(element);
  }
  return typeof fallback === "function" ? fallback() : fallback;
};
globalThis.ifDefined = ifDefined;
async function waitFor2(delay = 500, cb = () => {
}) {
  return new Promise((res2) => {
    setTimeout(() => res2(cb), delay);
  });
}

// src/js/components/plugins/phoneToPrettyPhone.ts
function phoneToPrettyPhone(phone) {
  if (phone && /(\+*5*6*){0,1}([1-9])(\d{4})(\d{4})/.exec(phone.replace(
    /\s/g,
    ""
  ))) {
    let [_, code, prefix3, group1, group2] = /(\+*5*6*){0,1}([1-9])(\d{4})(\d{4})/.exec(phone.replace(
      /\s/g,
      ""
    ));
    phone = ["+56", prefix3, group1, group2].join(" ");
  }
  return phone;
}
globalThis.phoneToPrettyPhone = phoneToPrettyPhone;

// src/js/components/plugins/requestAnimationPromise.ts
async function requestAnimationPromise3() {
  return new Promise((res2) => {
    requestAnimationFrame(() => res2());
  });
}

// src/js/components/plugins/tap.ts
var tap = (element, callback) => {
  if (callback)
    callback(element);
  return element;
};

// src/js/components/plugins/waitFor.ts
async function waitFor(delay = 500, cb = () => {
}) {
  return new Promise((res2) => {
    setTimeout(() => res2(cb), delay);
  });
}

// src/js/property_map/public_map_modules/exampleLayers.ts
var exampleLayers = [
  {
    type: "deals",
    slug_name: "venta_departamentos",
    name: "Departamentos en Venta",
    checked: true,
    criteria: {
      id_tipo_propiedad: 1,
      id_tipo_negocio: 1
    },
    layer_options: {
      icon: {
        url: "data:image/png;base64,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"
      },
      name: "Departamentos en Venta",
      url_low_emphasis: "data:image/png;base64,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",
      text: "f1ad",
      type: "deals",
      scale: 0.7,
      criteria: {
        id_tipo_negocio: 1,
        id_tipo_propiedad: 1
      },
      className: "icon-building-filled",
      slug_name: "venta_departamentos",
      fontFamily: "fontello",
      checked: true,
      fillOpacity: 0.85,
      strokeColor: "#3060ff"
    }
  },
  {
    type: "deals",
    slug_name: "arriendo_departamentos",
    name: "Departamentos en Arriendo",
    checked: true,
    criteria: {
      id_tipo_propiedad: 1,
      id_tipo_negocio: 2
    },
    layer_options: {
      icon: {
        url: "data:image/png;base64,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"
        //url: 'data:image/png;base64,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',
        //url_alt_b:  data:image/png;base64,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
        //url: 'data:image/png;base64,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',
      },
      name: "Departamentos",
      url_low_emphasis: "data:image/png;base64,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",
      text: "f1ad",
      type: "deals",
      scale: 0.7,
      criteria: {
        id_tipo_negocio: 1,
        id_tipo_propiedad: 1
      },
      className: "icon-building-filled",
      slug_name: "departamentos",
      fontFamily: "fontello",
      checked: true,
      fillOpacity: 0.85,
      strokeColor: "#3060cf"
    }
  },
  {
    type: "deals",
    slug_name: "venta_casas",
    name: "Casas en Venta",
    checked: true,
    criteria: {
      id_tipo_propiedad: 2,
      id_tipo_negocio: 1
    },
    layer_options: {
      strokeColor: "#109010",
      scale: 0.7,
      clickable: true,
      fontSize: 32,
      className: "icon-home",
      text: "e800",
      fillOpacity: 0.85,
      checked: true,
      icon: {
        //url: 'data:image/png;base64,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',
        url_alt_c: "data:image/png;base64,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",
        url: "data:image/png;base64,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",
        url_alt_a: "data:image/png;base64,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"
      },
      name: "Casas",
      url_low_emphasis: "data:image/png;base64,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",
      slug_name: "casas",
      fontFamily: "fontello"
    }
  },
  {
    type: "deals",
    slug_name: "arriendo_casas",
    name: "Casas en Arriendo",
    checked: true,
    criteria: {
      id_tipo_propiedad: 2,
      id_tipo_negocio: 2
    },
    layer_options: {
      strokeColor: "#107010",
      scale: 0.7,
      clickable: true,
      fontSize: 32,
      className: "icon-home",
      text: "e800",
      fillOpacity: 0.85,
      checked: true,
      icon: {
        url_alt_0: "data:image/png;base64,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",
        url: "data:image/png;base64,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"
        //url: 'data:image/png;base64,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',
      },
      name: "Casas",
      url_low_emphasis: "data:image/png;base64,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",
      slug_name: "casas",
      fontFamily: "fontello"
    }
  },
  {
    type: "barrios",
    slug_name: "barrios",
    name: "Barrios",
    layer_options: {
      strokeColor: "#666666",
      strokeWeight: 1,
      text: "e803",
      className: "icon-leaf",
      fontFamily: "fontello",
      scale: 0.84,
      clickable: true,
      labelProperty: "Nombre_de_Barrio",
      fillOpacity: 0.8,
      strokeOpacity: 0.8,
      url: "/json/barrios_old.json",
      infoWindow: false,
      checked: true,
      campos: {
        Nombre_de_Barrio: "Nombre de Barrio"
      }
    }
  },
  /*  {
          type: 'geojson',
          slug_name: 'publicaciones',
          name: 'Publicaciones',
          layer_options: {
              strokeColor: '#339933',
              scale: 0.8,
              clickable: true,
              fillOpacity: 0.85,
              url: '/json/deals_for_map.geojson',
              labelProperty: 'Nombre',
  
              infoWindow: true,
  
              checked: false,
              text: 'e803',
              type: 'geojson',
  
  
              className: 'icon-home-2',
              icon: {
                  url_depto: 'data:image/png;base64,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',
                  url: 'data:image/png;base64,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'
              },
              campos: {
  
                  barrio: "Barrio",
                  seudonimo: "Nombre",
                  status: "Status",
                  precio_uf: "precio_uf",
                  //thumbnail: "thumbnail",
                  dormitorios: "Dormitorios",
                  id_propiedad: "id_propiedad",
                  tipo_negocio: "Modalidad",
                  //comuna_barrio: "comuna_barrio",
                  banos_servicio: "Baños servicio",
                  //codigo_interno: "codigo_interno",
                  tipo_propiedad: "Tipo propiedad",
                  banos_completos: "Baños completos",
                  comuna_propiedad: "Comuna",
                  fecha_publicacion: "Fecha Publicacion",
                  //precio_publicacion: "precio_publicacion",
                  dormitorios_servicio: "Dormitorios servicio",
              },
          },
      },*/
  {
    type: "geojson",
    slug_name: "colegios",
    name: "Colegios",
    layer_options: {
      strokeColor: "#2e2338",
      scale: 0.3,
      clickable: true,
      fillOpacity: 0.85,
      url: "/json/capa_colegios.geojson",
      className: "icon-school",
      labelProperty: "Nombre",
      infoWindow: true,
      text: "e834",
      checked: true,
      fontFamily: "fontello",
      icon: {
        url: "data:image/png;base64,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",
        old_url: "data:image/png;base64,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"
      },
      campos: {
        Nombre: "Nombre",
        Direcci\u00F3n_: "Direcci\xF3n",
        Comuna: "Comuna",
        Formaci\u00F3n: "Formaci\xF3n",
        G\u00E9nero: "G\xE9nero",
        Biling\u00FCe: "Biling\xFCe",
        Playgroup: "Playgroup",
        Cursos_por_nivel: "Cursos por nivel",
        Alumnos_por_nivel: "Alumnos por nivel",
        Superficie_terreno: "Superficieterreno"
      }
    }
  },
  {
    type: "geojson",
    slug_name: "metro",
    name: "Estaciones de Metro",
    layer_options: {
      strokeColor: "#993333",
      scale: 0.3,
      infoWindow: true,
      clickable: true,
      fillOpacity: 0.85,
      className: "icon-subway",
      strokeWeight: 1,
      icon: {
        strokeWeight: 0.14,
        rotation: 0,
        url: "data:image/png;base64,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"
        //path: 'm -0.06452214,-1300.3857 c -144.29784786,0 -258.43104786,33.1537 -344.50584786,94.9296 42.9233,-20.0324 91.3754,-30.1484 145.4707,-30.1484 h 383.41995 c 64.6672,0 120.9378,14.0824 168.8652,42.1621 -87.7094,-72.0803 -206.0617,-106.9433 -353.25000214,-106.9433 z M 353.18548,-1193.4424 c 37.2095,30.5791 68.9017,67.8605 94.8789,112.0938 -9.6712,-37.4905 -34.1898,-70.3022 -73.6465,-98.4082 -6.8766,-4.8985 -13.9716,-9.4316 -21.2324,-13.6856 z m 94.8789,112.0938 c 3.1403,12.1731 4.7559,24.8277 4.7559,37.9902 v 537.00004 c 0,50.8361 -25.0596,94.87145 -75.1797,132.10352 -50.1201,37.23207 -111.3382,56.92036 -183.6543,59.06836 l 127.8066,120.28906 c 1.0601,0.95406 1.7594,1.95596 2.584,2.94141 118.0796,-146.74362 210.8828,-311.40576 210.8828,-491.81055 0,-167.97517 -29.7021,-299.68413 -87.1953,-397.58204 z m -123.6875,889.39259 c -8.1862,10.17344 -16.325,20.35496 -24.7344,30.35351 h 9.2618 c 8.592,0 14.6777,-3.93844 18.2578,-11.81445 3.0499,-6.70994 1.9601,-12.86848 -2.7852,-18.53906 z m -24.7344,30.35351 H -305.83217 C -203.49037,-44.171958 -87.765672,59.410753 1.8065779,149.22955 91.460077,58.315253 202.24108,-45.794548 299.64248,-161.6025 Z m -605.47465,0 c -10.0972,-11.58587 -19.8542,-23.47198 -29.6523,-35.32812 l -2.1602,2.0332 c -5.728,6.44402 -7.1608,13.60446 -4.2968,21.48047 2.864,7.87601 8.9497,11.81445 18.2578,11.81445 z m -29.6523,-35.32812 125.6465,-118.25586 c -71.6002,-2.86401 -132.4619,-22.55229 -182.5821,-59.06836 -50.12,-36.51607 -75.1796,-80.55142 -75.1796,-132.10352 v -537.00004 c -0.1341,-10.0542 0.9879,-19.7242 2.7363,-29.2012 -58.5056,99.66164 -86.08977,229.31225 -85.16797,383.56257 1.1008,184.20416 95.50167,348.01696 214.54687,492.06641 z m -129.3789,-875.62898 c 31.1756,-53.1063 71.1793,-97.6475 120.293,-132.8965 -15.5941,7.2778 -30.5075,15.7774 -44.627,25.6993 -43.0639,30.2611 -68.0762,66.0574 -75.666,107.1972 z m 73.5176,-9.4629 v 307.16414 h 345.829998 v -307.16414 z m 422.083948,0 v 307.16414 H 357.23428 v -307.16414 z m -325.423848,441.41414 c -27.9241,0 -50.8363,9.3078 -68.7363,27.92383 -17.9001,18.61604 -27.2078,41.17007 -27.9238,67.66211 -0.716,26.49205 8.5917,49.04608 27.9238,67.66211 19.332,18.61603 42.2442,27.92383 68.7363,27.92383 25.0601,0 47.6141,-9.3078 67.6621,-27.92383 20.0481,-18.61603 29.3559,-41.17006 27.9239,-67.66211 -1.432,-26.49204 -10.7398,-49.04607 -27.9239,-67.66211 -17.184,-18.61603 -39.738,-27.92383 -67.6621,-27.92383 z m 574.59185,0 c -26.4921,0 -49.0461,9.3078 -67.6621,27.92383 -18.6161,18.61604 -27.9238,41.17007 -27.9238,67.66211 0,26.49205 9.3077,49.04608 27.9238,67.66211 18.616,18.61603 41.17,27.92383 67.6621,27.92383 25.06,0 47.6141,-9.3078 67.6621,-27.92383 20.048,-18.61603 29.7141,-41.17006 28.9981,-67.66211 -0.716,-26.49204 -10.3821,-49.04607 -28.9981,-67.66211 -18.616,-18.61603 -41.1701,-27.92383 -67.6621,-27.92383 z',
      },
      rotation: 0,
      //fontFamily: 'FontAwesome5Free',
      text: "f239",
      labelProperty: "Nombre",
      url: "/json/capa_metro.geojson",
      checked: true,
      campos: {
        Nombre: "Nombre",
        Estaci\u00F3n: "Estaci\xF3n",
        L\u00EDnea: "L\xEDnea"
      }
    }
  }
];
var PublicLayersObject = exampleLayers.reduce((acc, layer) => {
  layer.layer_options.checked = true;
  acc[layer.slug_name] = layer;
  return acc;
}, {});

// src/js/property_map/public_map_modules/Wrapper.ts
var Wrapper = class {
  constructor(className) {
    this.wrapper = document.createElement("div");
    this.wrapper.className = className;
  }
  addClass(className) {
    this.wrapper.classList.add(className);
    return this;
  }
  addStyle(property, value) {
    this.wrapper.style[property] = value;
    return this;
  }
  setInnerHTML(html) {
    this.wrapper.innerHTML = html;
    return this;
  }
  appendChild(child) {
    this.wrapper.appendChild(child);
    return this;
  }
  appendTo(parent) {
    parent.appendChild(this.wrapper);
    return this;
  }
  setTextContent(text) {
    this.wrapper.textContent = text;
    return this;
  }
  prependTo(parent) {
    parent.prepend(this.wrapper);
    return this;
  }
  append(child) {
    this.wrapper.appendChild(child);
    return this;
  }
  get div() {
    return this.wrapper;
  }
};

// src/js/property_map/public_map_modules/genericFeatureToHtml.ts
var genericFeatureToHtml = class {
  constructor(feature, campos) {
    this.feature = feature;
    this.campos = campos;
    console.log({ feature, campos });
    this.container = new Wrapper("flex flex-col");
    this.container.addClass("flex").addClass("flex-col").addStyle("lineHeight", "1.5em").addStyle("fontSize", "13px").addStyle("fontFamily", "Inter, sans-serif").addStyle("fontWeight", "400");
    this.appendProperties();
  }
  get content() {
    this.container.div.classList.add("flex");
    this.container.div.classList.add("flex-col");
    return this.container.div;
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  get linkWeb() {
    const postId = this.feature.getProperty("codigo-wordpress") || this.feature.getProperty("codigo_wordpress");
    return this.feature.getProperty("link-publicacion-web") || postId && `"https://lacasadejuana.cl/?p=${postId}"` || null;
  }
  appendProperties() {
    this.feature.forEachProperty((value, slug_name) => {
      if (!value || slug_name.includes("etapa") || slug_name === "lat" || slug_name === "searchstring" || slug_name === "Color" || slug_name === "lng" || slug_name === "codigo_interno" || slug_name.includes("codigo-wordpress") || slug_name.includes("codigo_wordpress") || slug_name.includes("link-publicacion") || !this.campos[slug_name] && slug_name !== "thumbnail")
        return;
      let wrapper = new Wrapper("flex w-full justify-between " + slug_name);
      if (slug_name.includes("thumbnail") || slug_name.includes("img-portada-wordpress")) {
        const link = `<img src="${value}" style="width:100%;height:200px;object-fit:cover;"/>`;
        wrapper.setInnerHTML(link).addStyle("fontWeight", "600").addStyle("fontSize", "1.1em").addStyle("marginBottom", "0.3em").addStyle("order", "1").appendTo(this.container.div);
      } else if (slug_name.includes("seudonimo")) {
        if (this.linkWeb) {
          wrapper.setInnerHTML(`<a href=${this.linkWeb} target="_blank"><i class="fas fa-link"></i> ${value}</a>`);
        }
        wrapper.addStyle("fontWeight", "600").addStyle("order", "2").addStyle("fontSize", "1.5em").addStyle("marginTop", "0.7em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
      } else if (slug_name.includes("post_title")) {
        if (this.linkWeb) {
          wrapper.setInnerHTML(`<a href=${this.linkWeb} target="_blank"><i class="fas fa-link"></i> ${value}</a>`);
        }
        wrapper.addStyle("fontWeight", "600").addStyle("order", "2").addStyle("fontSize", "1.35em").addStyle("maxWidth", "400px").addStyle("marginTop", "0.7em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
      } else if (slug_name.includes("titulo-resumen-web")) {
        wrapper.setTextContent(value);
        wrapper.addStyle("fontWeight", "500").addStyle("order", "3").addStyle("fontSize", "1.05em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("marginTop", "0.2em").addStyle("marginBottom", "0.7em").prependTo(this.container.div);
      } else {
        new Wrapper("py-1 flex border min-w-[135px]").addStyle("fontFamily", "Inter, sans-serif").addStyle("minWidth", "135px").setTextContent(this.campos[slug_name]).appendTo(wrapper.div);
        new Wrapper("py-1 flex border pl-2 max-w-[350px] min-w-[170px] flex-grow overflow-hidden whitespace-nowrap").addStyle("fontFamily", "Inter, sans-serif").addStyle("minWidth", "170px").setTextContent(value).appendTo(wrapper.div);
        wrapper.addStyle("order", "3").addStyle("fontWeight", "500").appendTo(this.container.div);
      }
    });
  }
};

// src/js/property_map/public_map_modules/saveLayer.ts
var saveLayer = ({ slug_name, layer_options }) => ({
  layer_options,
  _checked: false,
  slug_name,
  _length: 0,
  debouncedSaveLayer() {
  },
  get length() {
    return this._length;
  },
  set length(value) {
    this._length = value;
  },
  get icon() {
    return this.getIconOptions();
  },
  get label() {
    return this.getMarkerLabel();
  },
  iconPreview: null,
  isSaving: false,
  watch() {
    this.debouncedSetStyle = Alpine.debounce(this.setStyle.bind(this), 200);
    this.debouncedSaveLayer = Alpine.debounce(this.saveLayer);
    this.$watch("layer_options", (layer_options2, previous_options) => {
      console.log("layer_options changed", { [this.slug_name]: layer_options2 });
      layer_options2 = {
        ...layer_options2,
        icon: this.updateIcon ? this.updateIcon() : this.icon
      };
      this.getLayer()?.setMap(this.layer_options.checked ? globalThis.gmap : null);
      if (this.isSaving)
        return;
      this.isSaving = true;
      this.layer_options = layer_options2;
      this.length = this.getLayer()?.getLength();
      this.debouncedSaveLayer({ layer_options: layer_options2 });
    });
    google.maps.event.addListener(this.getLayer(), "map_changed", () => {
      console.log("map_changed");
      this.checked = globalThis.layers[slug_name].getMap() ? true : false;
    });
  },
  getNameLabel(text = "", className = "markerLabel bg-white border radius-4 p-1  ") {
    return {
      text,
      color: "#444",
      fontSize: "14px",
      className
    };
  },
  get dealsWithCoords() {
    return Alpine.store("public_maps").dealsWithCoords;
  },
  save() {
    this.saveLayer({ layer_options: this.layer_options });
  },
  init() {
    console.log("init SaveLayer   ");
  },
  get featuresMatchingSearch() {
    return [];
  },
  saveLayer({ layer_options: layer_options2 }) {
    if (this.iconPreview && this.iconPreview.url) {
      this.iconPreview = this.updateIcon();
      layer_options2.icon.url = this.iconPreview.url;
    }
    let {
      layer_options: nested_options,
      ...newOptions
    } = layer_options2, mergedOptions = {
      layer_options: {
        ...newOptions
      }
    };
    return requestAnimationPromise3().then(() => {
      this.debouncedSetStyle();
      this.isSaving = false;
    });
  },
  get checked() {
    return this.layer_options.checked;
  },
  getBounds() {
    return this.getLayer().getBounds();
  },
  set checked(value) {
    this.getLayer()?.setMap(value ? globalThis.gmap : null);
    this.layer_options.checked = value;
  },
  getLayer() {
    return globalThis.layers[this.slug_name];
  },
  toggleMap() {
    const map2 = this.getLayer().getMap() ? null : globalThis.gmap;
    this.getLayer().setMap(map2);
    this._map = map2;
  },
  addMouseOverBehavior(layer) {
    if (this.mouseover_added) {
      return;
    }
    this.mouseover_added = true;
    google.maps.event.addListener(layer, "mouseover", this.mouseOverListener);
    google.maps.event.addListener(layer, "mouseout", this.mouseOutListener);
  },
  removeMouseOverBehavior(layer) {
    if (!this.mouseover_added) {
      return;
    }
    console.log(this.slug_name + " removing mouseover behavior");
    this.mouseover_added = false;
    google.maps.event.clearListeners(layer, "mouseover");
    google.maps.event.clearListeners(layer, "mouseout");
  },
  removeInfoWindowBehavior(layer) {
    if (!this.infowindow_added)
      return;
    this.infowindow_added = false;
    google.maps.event.clearListeners(layer, "click");
  },
  addInfoWindowBehavior(layer) {
    if (this.infowindow_added)
      return;
    this.infowindow_added = true;
    google.maps.event.addListener(layer, "click", this.clickListener);
  },
  getIconOptions(defaultScale = 1) {
    let iconUrl = this.iconUrl;
    if (iconUrl) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: iconUrl,
        size: { width: 54, height: 54 },
        anchor: { x: width / 2, y: height },
        scaledSize: { width, height }
      };
    }
  },
  getMarkerLabel(text) {
    return {
      text: text || "HOLA ",
      //className: 'marker_label border border-green-600 p-1 -mt-2 h-12 w-12 -ml-4',//+*/ ' border  radius-full bg-white',
      className: "  border     bg-gray-300 border-2 translate-y-full  mb-3 mt-6 mr-1   -ml-2 h-4 w-8 z-0   border-top-0",
      // fontFamily: 'fontello',// "Font Awesome 5 Free",//"fontello",
      fontSize: 12,
      //Number(25 * this.layer_options.scale / 0.05).toFixed(1) + 'px',
      strokeColor: this.layer_options.fillColor,
      //@ts-ignore
      // color: 'transparent',
      //strokeColor: '#ccc',
      fillColor: "#ffffff",
      strokeOpacity: Number(this.layer_options.fillOpacity),
      fillOpacity: 2 * Number(this.layer_options.fillOpacity)
    };
  }
});

// src/js/property_map/PublicLayerBarriosDataLayer.ts
var PublicLayerBarriosDataLayer = ({ index, slug_name, name, layer_options }, comunas2) => ({
  mapTypes: [],
  lastType: null,
  layer_options,
  filters_open: false,
  _map: null,
  index,
  controls: [
    //  { property: 'className', name: 'Icon', inputType: 'icon' },
    { property: "fillOpacity", name: "Opacidad", min: 0, max: 1, step: 0.01, inputType: "range" },
    { property: "strokeWeight", name: "Grosor", min: 0, max: 5, step: 0.05, inputType: "range" },
    { property: "scale", name: "Tama\xF1o", min: 0, max: 1, step: 0.05, inputType: "range" },
    { property: "strokeColor", name: "Color", inputType: "color" }
  ],
  boundingBox: {
    "south": -33.49850221364226,
    "west": -70.70542845963612,
    "north": -33.33716710494213,
    "east": -70.4681924366869
  },
  bounds: null,
  ...saveLayer({ slug_name, layer_options }),
  codigo_interno: null,
  async init() {
    this.bounds = new google.maps.LatLngBounds(this.boundingBox);
    let qs = new URL(location.href);
    if (qs.searchParams.get("codigo_interno")) {
      this.codigo_interno = qs.searchParams.get("codigo_interno");
    }
    let { layer_options: layer_options2, ...featureCollection } = await staticFetchWrapper(this.layer_options.url, {});
    this.layer_options = { ...this.layer_options, ...layer_options2 };
    globalThis.layerComponents = globalThis.layerComponents || {};
    globalThis.layerComponents[this.slug_name] = this;
    this.featureCollection = featureCollection;
    this.original_icon = JSON.parse(JSON.stringify(this.layer_options.icon ?? {}));
    this.iconPreview = this.updateIcon();
    globalThis.exampleLayerObject = PublicLayersObject;
    let example_layer = PublicLayersObject[slug_name] || { layer_options: layer_options2 }, icon = (example_layer.layer_options || layer_options2).icon;
    this.name = name;
    this.slug_name = slug_name;
    globalThis.layers = globalThis.layers || {};
    this.addLayerToMap();
    this.declareEventHandlers();
    this.$watch("index", this.setStyle.bind(this));
    this.watch();
    const checked = this.layer_options.checked;
    this.layer_options.checked = false;
    this.layer_options = { ...layer_options2, name, slug_name };
    setTimeout(() => {
      this.layer_options.checked = checked;
    }, 1e3);
  },
  updateIcon(defaultScale = 1) {
    let {
      text,
      fontFamily,
      strokeColor,
      fillOpacity,
      fillColor,
      strokeOpacity,
      fontSize,
      scale: scale3,
      icon,
      strokeWeight,
      rotation
    } = this.layer_options;
    if (!icon)
      return null;
    if (icon.path) {
      return {
        path: icon.path,
        scale: (scale3 ?? icon.scale) / 10,
        fillColor: strokeColor || icon.strokeColor || strokeColor,
        strokeColor,
        strokeOpacity,
        strokeWeight: icon.strokeWeight ?? (strokeWeight || 0.1),
        fillOpacity,
        rotation: icon.rotation ?? (rotation ?? 90),
        anchor: new google.maps.Point(96, 48)
      };
    }
    if (icon.url) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: icon.url,
        size: new google.maps.Size(54, 54),
        anchor: { x: width / 2, y: height },
        scaledSize: new google.maps.Size(width, height)
      };
    }
  },
  get base64Icon() {
    return (this.iconPreview ?? this.layer_options.icon ?? {}).url;
  },
  get iconUrl() {
    return this.blobUrl || this.base64Icon;
  },
  getIconOptions(defaultScale = 1) {
    let iconUrl = this.iconUrl;
    if (iconUrl) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: iconUrl,
        size: { width: 54, height: 54 },
        anchor: { x: width / 2, y: height },
        scaledSize: { width, height },
        labelOrigin: { x: 0.8 * width, y: height }
      };
    }
  },
  setStyle() {
    const layer = this.getLayer();
    const highlightLabelClassname = "uppercase max-w-[125px] text-gray-500 markerLabel_break_words markerLabel bg-gray-200   p-1 bg-opacity-50";
    requestAnimationPromise3().then(() => {
      let icon = this.iconPreview;
      let { labelVisibility } = this.layer_options;
      let laberIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 5,
        strokeWeight: 2,
        labelOrigin: new google.maps.Point(0, 2),
        strokeColor: "rgba(200,200,200,0)"
      };
      this.getLayer().setStyle((feature) => {
        let featureName = feature.getProperty(this.layer_options.labelProperty), comuna = feature.getProperty("Comuna"), comunaOffset = Object.keys(comunas2).indexOf(comuna);
        if (!comuna || comunaOffset === -1) {
          comunaOffset = 0;
        }
        comunaOffset -= 1;
        let highlighted = feature.getProperty("highlighted"), matches3 = feature.getProperty("matches"), transparencia = feature.getProperty("Transparencia") ?? 0, fillOpacity = this.layer_options.fillOpacity * //(1 - transparencia / 10) *
        ((matches3 ? 2.5 : 0.9) * highlighted ? 1.3 : 0.7), fillColor = `hsl(${(matches3 ? 20 : transparencia * 7) + comunaOffset * 50},${matches3 ? 65 : 55}%,${matches3 ? 60 : 70}%)`;
        let styleObj = {
          // label,
          fillColor: feature.getProperty("fillColor") || fillColor,
          strokeColor: feature.getProperty("strokeColor") || `hsl(${comunaOffset * 60},45%,40%)`,
          strokeWeight: this.layer_options.strokeWeight || 1,
          strokeOpacity: matches3 ? 1 : 0.7,
          // visible: feature.getProperty('comuna') && comunas[feature.getProperty('comuna')] === true,
          fillOpacity
        };
        return styleObj;
      });
    });
    return this;
  },
  fontSize: 33,
  setFontSize(fontSize) {
    this.fontSize = fontSize;
    this.setStyle();
  },
  mouseover_added: false,
  infowindow_added: false,
  addLayerToMap() {
    const layer = globalThis.layers[this.slug_name] || new google.maps.Data();
    globalThis.layers[this.slug_name] = layer;
    return this.appendFeatures().then(() => {
      google.maps.event.addListener(layer, "map_changed", () => {
        this.checked = layer.getMap() ? true : false;
        if (this.checked) {
          this.addMouseOverBehavior(layer);
          this.addInfoWindowBehavior(layer);
        } else {
          this.removeMouseOverBehavior(layer);
          this.removeInfoWindowBehavior(layer);
        }
      });
      this.length = layer.getLength();
      return this.setStyle();
    });
  },
  mouseOverListener: null,
  mouseOutListener: null,
  clickListener: null,
  async declareEventHandlers() {
    const labelProperty = this.layer_options.labelProperty || "Nombre_de_Barrio";
    this.marker = globalThis.gmap.labelMarker;
    if (!this.mouseOverListener) {
      this.marker = this.marker || new google.maps.Marker({
        position: this.getLayer().getBounds().getCenter(),
        visible: true,
        map: globalThis.gmap,
        zIndex: 210,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 5,
          strokeWeight: 2,
          labelOrigin: new google.maps.Point(0, 2),
          strokeColor: "rgba(200,200,200,0)"
        }
      });
      const layer = this.getLayer();
      let visibilityZoom = this.layer_options.labelVisibility.zoom;
      if (visibilityZoom && document.querySelector(".gm-style")) {
        let previousZoom = globalThis.gmap.getZoom();
        const zoomChangedHandler = (e) => {
          let currentZoom = globalThis.gmap.getZoom();
          if (currentZoom >= visibilityZoom && previousZoom <= visibilityZoom) {
            console.zinfo("went above visibility zoom", currentZoom);
            document.querySelector(".gm-style").classList.remove("hide-labels");
            document.querySelector(".gm-style").classList.add("show-labels");
          }
          if (currentZoom < visibilityZoom && previousZoom >= visibilityZoom) {
            console.zinfo("went below visibility zoom", currentZoom);
            document.querySelector(".gm-style").classList.remove("show-labels");
            document.querySelector(".gm-style").classList.add("hide-labels");
          }
          console.timerInfo(`zoom changed from ${previousZoom} to ${currentZoom}`);
          previousZoom = currentZoom;
        };
        this.gmap.addListener("idle", () => zoomChangedHandler(null));
      }
      if (this.layer_options.labelVisibility.highlighted) {
        this.mouseOverListener = (event) => {
          const { feature } = event;
          feature.setProperty("highlighted", true);
          let featureLabel = feature.getProperty(labelProperty);
          if (featureLabel) {
            this.marker.setLabel(this.getNameLabel(featureLabel, "uppercase max-w-[125px] text-gray-500 markerLabel_break_words markerLabel bg-gray-50   p-1 bg-opacity-10"));
            this.marker.setPosition(feature.getCenter());
            this.marker.setVisible(true);
          }
        };
      }
      if (!this.mouseOutListener && this.layer_options.labelVisibility.highlighted) {
        this.mouseOutListener = (event) => {
          event.feature.setProperty("highlighted", false);
          this.marker.setLabel("");
          this.marker.setVisible(false);
        };
      }
    }
    if (!this.clickListener && this.layer_options.infoWindow) {
      this.clickListener = (event) => {
        globalThis.gmap.infowindow.close();
        let negocio = event.feature;
        console.log({ latLng: event.latLng });
        this.getMap().panTo(event.latLng);
        let html = new genericFeatureToHtml(negocio, this.layer_options.campos).content;
        this.getInfoWindow().setContent(html);
        this.getInfoWindow().setPosition(event.latLng);
        this.getInfoWindow().open({ map: globalThis.gmap });
      };
    }
  },
  get infowindow() {
    return globalThis.gmap.infowindow;
  },
  getInfoWindow() {
    return globalThis.gmap.infowindow;
  },
  getLayer() {
    return globalThis.layers[this.slug_name];
  },
  getLength() {
    return this.getLayer().getLength();
  },
  length: 0,
  setMap(map2) {
    return this.getLayer().setMap(map2);
  },
  getMap() {
    return this.getLayer().getMap();
  },
  get gmap() {
    return globalThis.gmap;
  },
  get layer() {
    return this.getLayer();
  },
  removeFeatures() {
    return;
  },
  async appendFeatures() {
    if (this.getLayer() && this.getLayer().getLength() > 0)
      return this.getLayer();
    if (this.featureCollection) {
      this.getLayer().addGeoJson(this.featureCollection);
    } else if (this.layer_options.url) {
      this.getLayer().loadGeoJson(this.layer_options.url);
    }
    setTimeout(() => this.length = this.getLength(), 1500);
    return this.getLayer();
  },
  mapDialogOpen: false
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint2) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res2 = prim.call(input, hint2 || "default");
    if (_typeof(res2) !== "object")
      return res2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint2 === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
  const userAgent2 = mockUserAgent || realUserAgent;
  if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}

// node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
function isBrowser() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
  return !isNode || isElectron();
}

// node_modules/@probe.gl/env/dist/esm/lib/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document,
  process: typeof process === "object" && process
};
var self_ = globals.self || globals.window || globals.global;
var window_ = globals.window || globals.self || globals.global;
var document_ = globals.document || {};
var process_ = globals.process || {};

// node_modules/@probe.gl/env/dist/esm/utils/globals.js
var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
var isBrowser2 = isBrowser();

// node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
var window2 = globalThis;
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const navigator_2 = typeof navigator !== "undefined" ? navigator : {};
  const userAgent2 = mockUserAgent || navigator_2.userAgent || "";
  if (userAgent2.indexOf("Edge") > -1) {
    return "Edge";
  }
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  if (isMSIE || isTrident) {
    return "IE";
  }
  if (window2.chrome) {
    return "Chrome";
  }
  if (window2.safari) {
    return "Safari";
  }
  if (window2.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}

// node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
var LocalStorage = class {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "config", void 0);
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// node_modules/@probe.gl/log/dist/esm/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1e3) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1e3).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(" ".repeat(padLength)).concat(string);
}
function formatImage(image, message, scale3) {
  let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  if (image.width > maxWidth) {
    scale3 = Math.min(scale3, maxWidth / image.width);
  }
  const width = image.width * scale3;
  const height = image.height * scale3;
  const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
  return ["".concat(message, " %c+"), style];
}

// node_modules/@probe.gl/log/dist/esm/utils/color.js
var COLOR;
(function(COLOR3) {
  COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
  COLOR3[COLOR3["RED"] = 31] = "RED";
  COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
  COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
  COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
  COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
  COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
  COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
  COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
function getColor(color) {
  return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!isBrowser && typeof string === "string") {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}

// node_modules/@probe.gl/log/dist/esm/utils/autobind.js
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === "function") {
      if (!predefined.find((name) => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}

// node_modules/@probe.gl/log/dist/esm/utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

// node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (isBrowser && "performance" in window_) {
    var _window$performance, _window$performance$n;
    timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ("hrtime" in process_) {
    var _process$hrtime;
    const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/log/dist/esm/log.js
var originalConsole = {
  debug: isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};
function noop() {
}
var cache = {};
var ONCE = {
  once: true
};
var Log = class {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "VERSION", VERSION);
    _defineProperty(this, "_startTs", getHiResTimestamp());
    _defineProperty(this, "_deltaTs", getHiResTimestamp());
    _defineProperty(this, "_storage", void 0);
    _defineProperty(this, "userData", {});
    _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.timeStamp("".concat(this.id, " started"));
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    assert(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = "",
      scale: scale3 = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return isBrowser ? logImageInBrowser({
      image,
      message,
      scale: scale3
    }) : logImageInNode({
      image,
      message,
      scale: scale3
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      assert(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp();
      const tag = opts.tag || opts.message;
      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
};
_defineProperty(Log, "VERSION", VERSION);
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert(messageType === "string" || messageType === "object");
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = "",
    scale: scale3 = 1
  } = _ref2;
  console.warn("removed");
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = "",
    scale: scale3 = 1
  } = _ref3;
  if (typeof image === "string") {
    const img = new Image();
    img.onload = () => {
      const args = formatImage(img, message, scale3);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || "";
  if (element.toLowerCase() === "img") {
    console.log(...formatImage(image, message, scale3));
    return noop;
  }
  if (element.toLowerCase() === "canvas") {
    const img = new Image();
    img.onload = () => console.log(...formatImage(img, message, scale3));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// node_modules/@probe.gl/log/dist/esm/index.js
var esm_default = new Log({
  id: "@probe.gl/log"
});

// node_modules/@luma.gl/gltools/dist/esm/utils/log.js
var log = new Log({
  id: "luma.gl"
});

// node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}

// node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
var ERR_CONTEXT = "Invalid WebGLRenderingContext";
var ERR_WEBGL2 = "Requires WebGL2";
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  assert2(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  assert2(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
var glErrorShadow = {};
function error2(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log2(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== void 0) {
    error2(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return 0;
  };
}
var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);
  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }
  this.maxAttrib = 0;
};
WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = 5126;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = "";
  this.recache();
};
WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
  const self2 = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };
  gl.getParameter = function getParameter(pname) {
    if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
      if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
        return null;
      }
      return self2.currentVertexArrayObject;
    }
    return original.getParameter.apply(this, arguments);
  };
  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self2.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };
  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self2.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };
  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case 34962:
        self2.currentArrayBuffer = buffer;
        break;
      case 34963:
        self2.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;
      default:
    }
    return original.bindBuffer.apply(this, arguments);
  };
  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self2.currentVertexArrayObject;
    const attrib = vao.attribs[index];
    switch (pname) {
      case 34975:
        return attrib.buffer;
      case 34338:
        return attrib.enabled;
      case 34339:
        return attrib.size;
      case 34340:
        return attrib.stride;
      case 34341:
        return attrib.type;
      case 34922:
        return attrib.normalized;
      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };
  gl.vertexAttribPointer = function vertexAttribPointer(indx, size3, type, normalized, stride, offset) {
    const vao = self2.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self2.currentArrayBuffer;
    attrib.size = size3;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };
  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, "OES_vertex_array_object");
  }
  if (gl.canvas) {
    gl.canvas.addEventListener("webglcontextrestored", () => {
      log2("OESVertexArrayObject emulation library context restored");
      self2.reset_();
    }, true);
  }
  this.reset_();
};
OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== void 0;
  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }
  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(34921);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};
OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};
OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};
OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }
  return false;
};
OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;
  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
    return;
  }
  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;
  if (oldVAO === newVAO) {
    return;
  }
  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
  }
  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }
    if (attrib.enabled) {
      let bufferChanged = false;
      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, 34962, attrib.buffer);
          currentBinding = attrib.buffer;
        }
        bufferChanged = true;
      }
      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      }
    }
  }
  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
  }
};
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === "function") {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf("OES_vertex_array_object") < 0) {
      list.push("OES_vertex_array_object");
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== "OES_vertex_array_object") {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}

// node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
var OES_element_index = "OES_element_index";
var WEBGL_draw_buffers = "WEBGL_draw_buffers";
var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
var GL_DONT_CARE = 4352;
var GL_GPU_DISJOINT_EXT = 36795;
var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
var GL_UNMASKED_VENDOR_WEBGL = 37445;
var GL_UNMASKED_RENDERER_WEBGL = 37446;
var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
var WEBGL_PARAMETERS = {
  [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
  [35977]: getWebGL2ValueOrZero,
  [32937]: getWebGL2ValueOrZero,
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  },
  [32883]: getWebGL2ValueOrZero,
  [35071]: getWebGL2ValueOrZero,
  [37447]: getWebGL2ValueOrZero,
  [36063]: (gl, getParameter) => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return void 0;
  },
  [35379]: getWebGL2ValueOrZero,
  [35374]: getWebGL2ValueOrZero,
  [35377]: getWebGL2ValueOrZero,
  [34852]: (gl) => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return void 0;
  },
  [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
  [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
  [33e3]: (gl) => 16777216,
  [37157]: getWebGL2ValueOrZero,
  [35373]: getWebGL2ValueOrZero,
  [35657]: getWebGL2ValueOrZero,
  [36183]: getWebGL2ValueOrZero,
  [37137]: getWebGL2ValueOrZero,
  [34045]: getWebGL2ValueOrZero,
  [35978]: getWebGL2ValueOrZero,
  [35979]: getWebGL2ValueOrZero,
  [35968]: getWebGL2ValueOrZero,
  [35376]: getWebGL2ValueOrZero,
  [35375]: getWebGL2ValueOrZero,
  [35659]: getWebGL2ValueOrZero,
  [37154]: getWebGL2ValueOrZero,
  [35371]: getWebGL2ValueOrZero,
  [35658]: getWebGL2ValueOrZero,
  [35076]: getWebGL2ValueOrZero,
  [35077]: getWebGL2ValueOrZero,
  [35380]: getWebGL2ValueOrZero
};
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== void 0 ? value : originalGetParameter(pname);
  return result;
}

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
var OES_vertex_array_object = "OES_vertex_array_object";
var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}
var WEBGL2_CONTEXT_POLYFILLS = {
  [OES_vertex_array_object]: {
    meta: {
      suffix: "OES"
    },
    createVertexArray: () => {
      assert2(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {
    },
    bindVertexArray: () => {
    },
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: "ANGLE"
    },
    vertexAttribDivisor(location2, divisor) {
      assert2(divisor === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: () => {
    },
    drawArraysInstanced: () => {
    }
  },
  [WEBGL_draw_buffers2]: {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: () => {
      assert2(false);
    }
  },
  [EXT_disjoint_timer_query2]: {
    meta: {
      suffix: "EXT"
    },
    createQuery: () => {
      assert2(false);
    },
    deleteQuery: () => {
      assert2(false);
    },
    beginQuery: () => {
      assert2(false);
    },
    endQuery: () => {
    },
    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: () => {
    }
  }
};
var WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: (gl, originalFunc, attachment) => {
    if (isWebGL2(gl)) {
      originalFunc(attachment);
    } else {
    }
  },
  getVertexAttrib: (gl, originalFunc, location2, pname) => {
    const {
      webgl2,
      ext
    } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;
    switch (pname) {
      case 35069:
        result = !webgl2 ? false : void 0;
        break;
      case 35070:
        result = !webgl2 && !ext ? 0 : void 0;
        break;
      default:
    }
    return result !== void 0 ? result : originalFunc(location2, pname);
  },
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);
        default:
      }
    }
    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        const {
          extensions
        } = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic2];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: getParameterPolyfill,
  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;
  if (!luma.polyfilled) {
    polyfillVertexArrayObject(gl);
    initializeExtensions(gl);
    installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }
  return gl;
}
globalThis.polyfillContext = polyfillContext;
function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS2 = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS2) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}
function installOverrides(gl, _ref) {
  let {
    target,
    target2
  } = _ref;
  Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
    if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
      };
      const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}
function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== "overrides") {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}
function polyfillExtension(gl, _ref2) {
  let {
    extension,
    target,
    target2
  } = _ref2;
  const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
  assert2(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ""
  } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;
    if (key === "meta") {
    } else if (typeof gl[key] === "function") {
    } else if (ext && typeof ext[extKey] === "function") {
      polyfill = function() {
        return ext[extKey](...arguments);
      };
    } else if (typeof defaults[key] === "function") {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
var GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  [2930]: true,
  [3024]: true,
  [36006]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32938]: 1,
  [32939]: false,
  [3089]: false,
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 4294967295,
  [36005]: 4294967295,
  [2962]: 519,
  [2967]: 0,
  [2963]: 4294967295,
  [34816]: 519,
  [36003]: 0,
  [36004]: 4294967295,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  [2978]: [0, 0, 1024, 1024],
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
var hint = (gl, value, key) => gl.hint(key, value);
var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
var drawFramebuffer = (gl, value) => {
  const target = isWebGL2(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};
var readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(36008, value);
};
function isArray4(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}
var GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: "blendEquation",
  [34877]: "blendEquation",
  [32969]: "blendFunc",
  [32968]: "blendFunc",
  [32971]: "blendFunc",
  [32970]: "blendFunc",
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [36006]: drawFramebuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: "polygonOffset",
  [10752]: "polygonOffset",
  [35977]: enable,
  [32938]: "sampleCoverage",
  [32939]: "sampleCoverage",
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: "stencilFuncFront",
  [2967]: "stencilFuncFront",
  [2963]: "stencilFuncFront",
  [34816]: "stencilFuncBack",
  [36003]: "stencilFuncBack",
  [36004]: "stencilFuncBack",
  [2964]: "stencilOpFront",
  [2965]: "stencilOpFront",
  [2966]: "stencilOpFront",
  [34817]: "stencilOpBack",
  [34818]: "stencilOpBack",
  [34819]: "stencilOpBack",
  [2978]: (gl, value) => gl.viewport(...value),
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [36010]: readFramebuffer,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray4(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray4(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray4(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray4(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray4(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
function getValue(glEnum, values, cache4) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache4[glEnum];
}
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache4) => gl.blendEquationSeparate(getValue(32777, values, cache4), getValue(34877, values, cache4)),
  blendFunc: (gl, values, cache4) => gl.blendFuncSeparate(getValue(32969, values, cache4), getValue(32968, values, cache4), getValue(32971, values, cache4), getValue(32970, values, cache4)),
  polygonOffset: (gl, values, cache4) => gl.polygonOffset(getValue(32824, values, cache4), getValue(10752, values, cache4)),
  sampleCoverage: (gl, values, cache4) => gl.sampleCoverage(getValue(32938, values, cache4), getValue(32939, values, cache4)),
  stencilFuncFront: (gl, values, cache4) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache4), getValue(2967, values, cache4), getValue(2963, values, cache4)),
  stencilFuncBack: (gl, values, cache4) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache4), getValue(36003, values, cache4), getValue(36004, values, cache4)),
  stencilOpFront: (gl, values, cache4) => gl.stencilOpSeparate(1028, getValue(2964, values, cache4), getValue(2965, values, cache4), getValue(2966, values, cache4)),
  stencilOpBack: (gl, values, cache4) => gl.stencilOpSeparate(1029, getValue(34817, values, cache4), getValue(34818, values, cache4), getValue(34819, values, cache4))
};
var GL_HOOKED_SETTERS = {
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint2) => update({
    [pname]: hint2
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({
          [36006]: framebuffer
        });
      case 36008:
        return update({
          [36010]: framebuffer
        });
      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert2) => update({
    [32938]: value,
    [32939]: invert2
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};
var isEnabled = (gl, key) => gl.isEnabled(key);
var GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};

// node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get4() {
    const pname = arguments.length <= 0 ? void 0 : arguments[0];
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...arguments);
    }
    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set4() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}
var GLState = class {
  constructor(gl) {
    let {
      copyState = false,
      log: log4 = () => {
      }
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    this.log = log4;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push() {
    let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.stateStack.push({});
  }
  pop() {
    assert2(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const key in values) {
      assert2(key !== void 0);
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return {
      valueChanged,
      oldValue
    };
  }
};
function trackContextState(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: enable2 = true,
    copyState
  } = options;
  assert2(copyState !== void 0);
  if (!gl.state) {
    const {
      polyfillContext: polyfillContext2
    } = globalThis;
    if (polyfillContext2) {
      polyfillContext2(gl);
    }
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  gl.state.enable = enable2;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }
  gl.state.push();
}
function popContextState(gl) {
  assert2(gl.state);
  gl.state.pop();
}

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
function setParameters(gl, values) {
  assert2(isWebGL(gl), "setParameters requires a WebGL context");
  if (isObjectEmpty(values)) {
    return;
  }
  const compositeSetters = {};
  for (const key in values) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }
  const cache4 = gl.state && gl.state.cache;
  if (cache4) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache4);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || GL_PARAMETER_DEFAULTS;
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetParameters(gl) {
  setParameters(gl, GL_PARAMETER_DEFAULTS);
}
function withParameters(gl, parameters, func) {
  if (isObjectEmpty(parameters)) {
    return func(gl);
  }
  const {
    nocatch = true
  } = parameters;
  pushContextState(gl);
  setParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    popContextState(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      popContextState(gl);
    }
  }
  return value;
}

// node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;
  if (gl.canvas && luma) {
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  return 1;
}
function cssToDevicePixels(gl, cssPixel) {
  let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}

// node_modules/@luma.gl/gltools/dist/esm/context/context.js
var isBrowser3 = isBrowser();
var isPage = isBrowser3 && typeof document !== "undefined";
var CONTEXT_DEFAULTS = {
  webgl2: true,
  webgl1: true,
  throwOnError: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};
function createGLContext() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  assert2(isBrowser3, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    console.error(message);
    return null;
  }
  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);
  if (!gl) {
    return null;
  }
  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!gl || gl._instrumented) {
    return gl;
  }
  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug: debug2
  } = options;
  if (manageState) {
    trackContextState(gl, {
      copyState: false,
      log: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return log.log(1, ...args)();
      }
    });
  }
  if (isBrowser3 && debug2) {
    if (!globalThis.makeDebugContext) {
      log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      log.level = Math.max(log.level, 1);
    }
  }
  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (gl.canvas) {
    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }
  const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}
function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;
  const onCreateError = (error3) => errorMessage = error3.statusMessage || errorMessage;
  canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;
  if (webgl2) {
    gl = gl || canvas.getContext("webgl2", options);
    gl = gl || canvas.getContext("experimental-webgl2", options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext("webgl", options);
    gl = gl || canvas.getContext("experimental-webgl", options);
  }
  canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
  }
  if (options.onContextLost) {
    canvas.addEventListener("webglcontextlost", options.onContextLost, false);
  }
  if (options.onContextRestored) {
    canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
  }
  return gl;
}
function getCanvas(_ref) {
  let {
    canvas,
    width = 800,
    height = 600,
    onError
  } = _ref;
  let targetCanvas;
  if (typeof canvas === "string") {
    const isPageLoaded = isPage && document.readyState === "complete";
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-canvas";
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }
  return targetCanvas;
}
function logInfo(gl) {
  const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
  const debug2 = gl.debug ? " debug" : "";
  log.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
}
function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return 2;
  }
  return 1;
}
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
  if (!clientWidth || !clientHeight) {
    log.log(1, "Canvas clientWidth/clientHeight is 0")();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      log.warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }
    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}

// node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp2() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/stats/dist/esm/lib/stat.js
var Stat = class {
  constructor(name, type) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "sampleSize", 1);
    _defineProperty(this, "time", void 0);
    _defineProperty(this, "count", void 0);
    _defineProperty(this, "samples", void 0);
    _defineProperty(this, "lastTiming", void 0);
    _defineProperty(this, "lastSampleTime", void 0);
    _defineProperty(this, "lastSampleCount", void 0);
    _defineProperty(this, "_count", 0);
    _defineProperty(this, "_time", 0);
    _defineProperty(this, "_samples", 0);
    _defineProperty(this, "_startTime", 0);
    _defineProperty(this, "_timerPending", false);
    this.name = name;
    this.type = type;
    this.reset();
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = getHiResTimestamp2();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime(getHiResTimestamp2() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
};

// node_modules/@probe.gl/stats/dist/esm/lib/stats.js
var Stats = class {
  constructor(options) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "stats", {});
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }
    return this;
  }
  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }
  getTable() {
    const table = {};
    this.forEach((stat) => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    stats.forEach((stat) => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    if (!stat || !stat.name) {
      return null;
    }
    const {
      name,
      type
    } = stat;
    if (!this.stats[name]) {
      if (stat instanceof Stat) {
        this.stats[name] = stat;
      } else {
        this.stats[name] = new Stat(name, type);
      }
    }
    return this.stats[name];
  }
};

// node_modules/@luma.gl/webgl/dist/esm/init.js
var VERSION2 = true ? "8.5.21" : "untranspiled source";
var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
var StatsManager = class {
  constructor() {
    this.stats = /* @__PURE__ */ new Map();
  }
  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new Stats({
        id: name
      }));
    }
    return this.stats.get(name);
  }
};
var lumaStats = new StatsManager();
if (globalThis.luma && globalThis.luma.VERSION !== VERSION2) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION2));
}
if (!globalThis.luma) {
  if (isBrowser()) {
    log.log(1, "luma.gl ".concat(VERSION2, " - ").concat(STARTUP_MESSAGE))();
  }
  globalThis.luma = globalThis.luma || {
    VERSION: VERSION2,
    version: VERSION2,
    log,
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}
var init_default = globalThis.luma;

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
function requestAnimationFrame2(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}

// node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
function getKeyValue(gl, name) {
  if (typeof name !== "string") {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, "");
  const value = gl[name];
  assert3(value !== void 0, "Accessing undefined constant GL.".concat(name));
  return value;
}
function getKey(gl, value) {
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}

// node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
var uidCounters = {};
function uid3() {
  let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  uidCounters[id] = uidCounters[id] || 1;
  const count2 = uidCounters[id]++;
  return "".concat(id, "-").concat(count2);
}
function isPowerOfTwo(n) {
  assert3(typeof n === "number", "Input must be a number");
  return n && (n & n - 1) === 0;
}
function isObjectEmpty2(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}

// node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach((methodName) => {
    if (prototype.methodName) {
      return;
    }
    prototype[methodName] = () => {
      log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}

// node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
var Resource = class {
  get [Symbol.toStringTag]() {
    return "Resource";
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGLContext(gl);
    const {
      id,
      userData = {}
    } = opts;
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || uid3(this[Symbol.toStringTag]);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;
    if (this._handle === void 0) {
      this._handle = this._createHandle();
    }
    this.byteLength = 0;
    this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this._removeStats();
    }
    this._handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach((child) => child.delete());
    }
    return this;
  }
  bind() {
    let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof funcOrHandle !== "function") {
      this._bindHandle(funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(pname) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    pname = getKeyValue(this.gl, pname);
    assert3(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }
    return this._getParameter(pname, opts);
  }
  getParameters() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = isWebGL2(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (parameterAvailable) {
        const key = keys ? getKey(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, options);
        if (keys && parameter.type === "GLenum") {
          values[key] = getKey(this.gl, values[key]);
        }
      }
    }
    return values;
  }
  setParameter(pname, value) {
    pname = getKeyValue(this.gl, pname);
    assert3(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        throw new Error("Parameter not available on this platform");
      }
      if (parameter.type === "GLenum") {
        value = getKeyValue(value);
      }
    }
    this._setParameter(pname, value);
    return this;
  }
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }
  stubRemovedMethods(className, version, methodNames) {
    return stubRemovedMethods(this, className, version, methodNames);
  }
  initialize(opts) {
  }
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }
  _addStats() {
    const name = this[Symbol.toStringTag];
    const stats = lumaStats.get("Resource Counts");
    stats.get("Resources Created").incrementCount();
    stats.get("".concat(name, "s Created")).incrementCount();
    stats.get("".concat(name, "s Active")).incrementCount();
  }
  _removeStats() {
    const name = this[Symbol.toStringTag];
    const stats = lumaStats.get("Resource Counts");
    stats.get("".concat(name, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(bytes) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(bytes, name);
    this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = bytes;
  }
  _trackAllocatedMemoryForContext(bytes) {
    let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    const stats = lumaStats.get("Memory Usage".concat(id));
    stats.get("GPU Memory").addCount(bytes);
    stats.get("".concat(name, " Memory")).addCount(bytes);
  }
  _trackDeallocatedMemory() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(name);
    this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const stats = lumaStats.get("Memory Usage".concat(id));
    stats.get("GPU Memory").subtractCount(this.byteLength);
    stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType) {
  let {
    clamped = true
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function flipRows(_ref) {
  let {
    data: data3,
    width,
    height,
    bytesPerPixel = 4,
    temp
  } = _ref;
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data3.subarray(topOffset, topOffset + bytesPerRow));
    data3.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data3.set(temp, bottomOffset);
  }
}
function scalePixels2(_ref2) {
  let {
    data: data3,
    width,
    height
  } = _ref2;
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data3[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}

// node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
      log.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}

// node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
var DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
var PROP_CHECKS = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
var Accessor = class _Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    assert3(accessor.size);
    const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }
  static resolve() {
    for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
      accessors[_key] = arguments[_key];
    }
    return new _Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor() {
    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }
    accessors.forEach((accessor) => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return _Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return _Accessor.getBytesPerVertex(this);
  }
  _assign() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    props = checkProps("Accessor", props, PROP_CHECKS);
    if (props.type !== void 0) {
      this.type = props.type;
      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }
    if (props.size !== void 0) {
      this.size = props.size;
    }
    if (props.offset !== void 0) {
      this.offset = props.offset;
    }
    if (props.stride !== void 0) {
      this.stride = props.stride;
    }
    if (props.normalized !== void 0) {
      this.normalized = props.normalized;
    }
    if (props.integer !== void 0) {
      this.integer = props.integer;
    }
    if (props.divisor !== void 0) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== void 0) {
      this.buffer = props.buffer;
    }
    if (props.index !== void 0) {
      if (typeof props.index === "boolean") {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== void 0) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== void 0) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    return this;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
var DEBUG_DATA_LENGTH = 10;
var DEPRECATED_PROPS = {
  offset: "accessor.offset",
  stride: "accessor.stride",
  type: "accessor.type",
  size: "accessor.size",
  divisor: "accessor.divisor",
  normalized: "accessor.normalized",
  integer: "accessor.integer",
  instanced: "accessor.divisor",
  isInstanced: "accessor.divisor"
};
var PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: "byteLength"
  },
  deprecatedProps: DEPRECATED_PROPS
};
var PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};
var Buffer2 = class extends Resource {
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
    this.initialize(props);
    Object.seal(this);
  }
  getElementCount() {
    let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
  }
  getVertexCount() {
    let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    if (Number.isFinite(props)) {
      props = {
        byteLength: props
      };
    }
    props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
    this.usage = props.usage || 35044;
    this.debugData = null;
    this.setAccessor(Object.assign({}, props, props.accessor));
    if (props.data) {
      this._setData(props.data, props.offset, props.byteLength);
    } else {
      this._setByteLength(props.byteLength || 0);
    }
    return this;
  }
  setProps(props) {
    props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
    if ("accessor" in props) {
      this.setAccessor(props.accessor);
    }
    return this;
  }
  setAccessor(accessor) {
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;
    this.accessor = new Accessor(accessor);
    return this;
  }
  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);
      return true;
    }
    this.bytesUsed = byteLength;
    return false;
  }
  setData(props) {
    return this.initialize(props);
  }
  subData(props) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    const {
      data: data3,
      offset = 0,
      srcOffset = 0
    } = props;
    const byteLength = props.byteLength || props.length;
    assert3(data3);
    const target = this.gl.webgl2 ? 36663 : this.target;
    this.gl.bindBuffer(target, this.handle);
    if (srcOffset !== 0 || byteLength !== void 0) {
      assertWebGL2Context(this.gl);
      this.gl.bufferSubData(this.target, offset, data3, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data3);
    }
    this.gl.bindBuffer(target, null);
    this.debugData = null;
    this._inferType(data3);
    return this;
  }
  copyData(_ref) {
    let {
      sourceBuffer,
      readOffset = 0,
      writeOffset = 0,
      size: size3
    } = _ref;
    const {
      gl
    } = this;
    assertWebGL2Context(gl);
    gl.bindBuffer(36662, sourceBuffer.handle);
    gl.bindBuffer(36663, this.handle);
    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size3);
    gl.bindBuffer(36662, null);
    gl.bindBuffer(36663, null);
    this.debugData = null;
    return this;
  }
  getData() {
    let {
      dstData = null,
      srcByteOffset = 0,
      dstOffset = 0,
      length = 0
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    assertWebGL2Context(this.gl);
    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
    const dstElementOffset = dstOffset;
    let dstAvailableElementCount;
    let dstElementCount;
    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }
    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    assert3(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(36662, null);
    return dstData;
  }
  bind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index,
      offset = 0,
      size: size3
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (target === 35345 || target === 35982) {
      if (size3 !== void 0) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size3);
      } else {
        assert3(offset === 0);
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }
    return this;
  }
  unbind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const isIndexedBuffer = target === 35345 || target === 35982;
    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }
    return this;
  }
  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({
        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
      });
      return {
        data: this.debugData,
        changed: true
      };
    }
    return {
      data: this.debugData,
      changed: false
    };
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(data3) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data3.byteLength + offset;
    assert3(ArrayBuffer.isView(data3));
    this._trackDeallocatedMemory();
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, byteLength, this.usage);
    this.gl.bufferSubData(target, offset, data3);
    this.gl.bindBuffer(target, null);
    this.debugData = data3.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    const type = getGLTypeFromTypedArray(data3);
    assert3(type);
    this.setAccessor(new Accessor(this.accessor, {
      type
    }));
    return this;
  }
  _setByteLength(byteLength) {
    let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
    assert3(byteLength >= 0);
    this._trackDeallocatedMemory();
    let data3 = byteLength;
    if (byteLength === 0) {
      data3 = new Float32Array(0);
    }
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data3, usage);
    this.gl.bindBuffer(target, null);
    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    return this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }
  _inferType(data3) {
    if (!this.accessor.type) {
      this.setAccessor(new Accessor(this.accessor, {
        type: getGLTypeFromTypedArray(data3)
      }));
    }
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }
  get type() {
    log.deprecated("Buffer.type", "Buffer.accessor.type")();
    return this.accessor.type;
  }
  get bytes() {
    log.deprecated("Buffer.bytes", "Buffer.byteLength")();
    return this.byteLength;
  }
  setByteLength(byteLength) {
    log.deprecated("setByteLength", "reallocate")();
    return this.reallocate(byteLength);
  }
  updateAccessor(opts) {
    log.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
    this.accessor = new Accessor(this.accessor, opts);
    return this;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
var TEXTURE_FORMATS = {
  [6407]: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  [6408]: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  [6406]: {
    dataFormat: 6406,
    types: [5121]
  },
  [6409]: {
    dataFormat: 6409,
    types: [5121]
  },
  [6410]: {
    dataFormat: 6410,
    types: [5121]
  },
  [33326]: {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  },
  [33328]: {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  },
  [34837]: {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  },
  [34836]: {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }
};
var DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
var TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === void 0 && info.gl2 === void 0) {
    return true;
  }
  const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === "string" ? gl.getExtension(value) : value;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension("OES_texture_float_linear");
    case 5131:
      return gl.getExtension("OES_texture_half_float_linear");
    default:
      return true;
  }
}

// node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
var NPOT_MIN_FILTERS = [9729, 9728];
var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
};
var Texture = class extends Resource {
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      format,
      linearFiltering
    } = opts;
    let supported = true;
    if (format) {
      supported = supported && isFormatSupported(gl, format);
      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
    }
    return supported;
  }
  constructor(gl, props) {
    const {
      id = uid3("texture"),
      handle,
      target
    } = props;
    super(gl, {
      id,
      handle
    });
    this.target = target;
    this.textureUnit = void 0;
    this.loaded = false;
    this.width = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.format = void 0;
    this.type = void 0;
    this.dataFormat = void 0;
    this.border = void 0;
    this.textureUnit = void 0;
    this.mipmaps = void 0;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let data3 = props.data;
    if (data3 instanceof Promise) {
      data3.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }
    const isVideo = typeof HTMLVideoElement !== "undefined" && data3 instanceof HTMLVideoElement;
    if (isVideo && data3.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data3.addEventListener("loadeddata", () => this.initialize(props));
      return this;
    }
    const {
      pixels = null,
      format = 6408,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = void 0
    } = props;
    if (!data3) {
      data3 = pixels;
    }
    let {
      width,
      height,
      dataFormat,
      type,
      compressed = false,
      mipmaps = true
    } = props;
    const {
      depth = 0
    } = props;
    ({
      width,
      height,
      compressed,
      dataFormat,
      type
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data: data3,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;
    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }
    if (mipmaps && this._isNPOT()) {
      log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      mipmaps = false;
      this._updateForNPOT(parameters);
    }
    this.mipmaps = mipmaps;
    this.setImageData({
      data: data3,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: pixelStore,
      compressed
    });
    if (mipmaps) {
      this.generateMipmap();
    }
    this.setParameters(parameters);
    if (recreate) {
      this.data = data3;
    }
    if (isVideo) {
      this._video = {
        video: data3,
        parameters,
        lastTime: data3.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data3.currentTime : -1
      };
    }
    return this;
  }
  update() {
    if (this._video) {
      const {
        video,
        parameters,
        lastTime
      } = this._video;
      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }
      this.setSubImageData({
        data: video,
        parameters
      });
      if (this.mipmaps) {
        this.generateMipmap();
      }
      this._video.lastTime = video.currentTime;
    }
  }
  resize(_ref) {
    let {
      height,
      width,
      mipmaps = false
    } = _ref;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }
    return this;
  }
  generateMipmap() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._isNPOT()) {
      log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      return this;
    }
    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    withParameters(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }
  setImageData(options) {
    this._trackDeallocatedMemory("Texture");
    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data: data3 = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;
    if (!data3) {
      data3 = pixels;
    }
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data: data3,
      width,
      height
    }));
    const {
      gl
    } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({
      data: data3,
      dataType
    } = this._getDataType({
      data: data3,
      compressed
    }));
    let gl2;
    let compressedTextureSize = 0;
    withParameters(this.gl, parameters, () => {
      switch (dataType) {
        case "null":
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data3);
          break;
        case "typed-array":
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data3, offset);
          break;
        case "buffer":
          gl2 = assertWebGL2Context(gl);
          gl2.bindBuffer(35052, data3.handle || data3);
          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
          break;
        case "browser-object":
          if (isWebGL2(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data3);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data3);
          }
          break;
        case "compressed":
          for (const [levelIndex, levelData] of data3.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
            compressedTextureSize += levelData.levelSize;
          }
          break;
        default:
          assert3(false, "Unknown image data type");
      }
    });
    if (dataType === "compressed") {
      this._trackAllocatedMemory(compressedTextureSize, "Texture");
    } else if (data3 && data3.byteLength) {
      this._trackAllocatedMemory(data3.byteLength, "Texture");
    } else {
      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
    }
    this.loaded = true;
    return this;
  }
  setSubImageData(_ref2) {
    let {
      target = this.target,
      pixels = null,
      data: data3 = null,
      x = 0,
      y = 0,
      width = this.width,
      height = this.height,
      level = 0,
      format = this.format,
      type = this.type,
      dataFormat = this.dataFormat,
      compressed = false,
      offset = 0,
      border = this.border,
      parameters = {}
    } = _ref2;
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data: data3,
      width,
      height
    }));
    assert3(this.depth === 0, "texSubImage not supported for 3D textures");
    if (!data3) {
      data3 = pixels;
    }
    if (data3 && data3.data) {
      const ndarray = data3;
      data3 = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }
    if (data3 instanceof Buffer2) {
      data3 = data3.handle;
    }
    this.gl.bindTexture(this.target, this.handle);
    withParameters(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data3);
      } else if (data3 === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data3)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data3, offset);
      } else if (data3 instanceof WebGLBuffer) {
        const gl2 = assertWebGL2Context(this.gl);
        gl2.bindBuffer(35052, data3);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(35052, null);
      } else if (isWebGL2(this.gl)) {
        const gl2 = assertWebGL2Context(this.gl);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data3);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data3);
      }
    });
    this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
    return null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }
  unbind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, null);
    return textureUnit;
  }
  _getDataType(_ref3) {
    let {
      data: data3,
      compressed = false
    } = _ref3;
    if (compressed) {
      return {
        data: data3,
        dataType: "compressed"
      };
    }
    if (data3 === null) {
      return {
        data: data3,
        dataType: "null"
      };
    }
    if (ArrayBuffer.isView(data3)) {
      return {
        data: data3,
        dataType: "typed-array"
      };
    }
    if (data3 instanceof Buffer2) {
      return {
        data: data3.handle,
        dataType: "buffer"
      };
    }
    if (data3 instanceof WebGLBuffer) {
      return {
        data: data3,
        dataType: "buffer"
      };
    }
    return {
      data: data3,
      dataType: "browser-object"
    };
  }
  _deduceParameters(opts) {
    const {
      format,
      data: data3
    } = opts;
    let {
      width,
      height,
      dataFormat,
      type,
      compressed
    } = opts;
    const textureFormat = TEXTURE_FORMATS[format];
    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
    type = type || textureFormat && textureFormat.types[0];
    compressed = compressed || textureFormat && textureFormat.compressed;
    ({
      width,
      height
    } = this._deduceImageSize(data3, width, height));
    return {
      dataFormat,
      type,
      compressed,
      width,
      height,
      format,
      data: data3
    };
  }
  _deduceImageSize(data3, width, height) {
    let size3;
    if (typeof ImageData !== "undefined" && data3 instanceof ImageData) {
      size3 = {
        width: data3.width,
        height: data3.height
      };
    } else if (typeof HTMLImageElement !== "undefined" && data3 instanceof HTMLImageElement) {
      size3 = {
        width: data3.naturalWidth,
        height: data3.naturalHeight
      };
    } else if (typeof HTMLCanvasElement !== "undefined" && data3 instanceof HTMLCanvasElement) {
      size3 = {
        width: data3.width,
        height: data3.height
      };
    } else if (typeof ImageBitmap !== "undefined" && data3 instanceof ImageBitmap) {
      size3 = {
        width: data3.width,
        height: data3.height
      };
    } else if (typeof HTMLVideoElement !== "undefined" && data3 instanceof HTMLVideoElement) {
      size3 = {
        width: data3.videoWidth,
        height: data3.videoHeight
      };
    } else if (!data3) {
      size3 = {
        width: width >= 0 ? width : 1,
        height: height >= 0 ? height : 1
      };
    } else {
      size3 = {
        width,
        height
      };
    }
    assert3(size3, "Could not deduced texture size");
    assert3(width === void 0 || size3.width === width, "Deduced texture width does not match supplied width");
    assert3(height === void 0 || size3.height === height, "Deduced texture height does not match supplied height");
    return size3;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle);
    this._trackDeallocatedMemory("Texture");
  }
  _getParameter(pname) {
    switch (pname) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }
  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);
    param = this._getNPOTParam(pname, param);
    switch (pname) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, pname, param);
        break;
      case 4096:
      case 4097:
        assert3(false);
        break;
      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }
    this.gl.bindTexture(this.target, null);
    return this;
  }
  _isNPOT() {
    if (isWebGL2(this.gl)) {
      return false;
    }
    if (!this.width || !this.height) {
      return false;
    }
    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
  }
  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }
    if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }
    if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }
  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case 10241:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            param = 9729;
          }
          break;
        case 10242:
        case 10243:
          if (param !== 33071) {
            param = 33071;
          }
          break;
        default:
          break;
      }
    }
    return param;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
var pathPrefix = "";
function loadImage(url, opts) {
  assert3(typeof url === "string");
  url = pathPrefix + url;
  return new Promise((resolve2, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve2(image);
      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
      image.crossOrigin = opts && opts.crossOrigin || "anonymous";
      image.src = url;
    } catch (error3) {
      reject(error3);
    }
  });
}

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
var Texture2D = class extends Texture {
  get [Symbol.toStringTag]() {
    return "Texture2D";
  }
  static isSupported(gl, opts) {
    return Texture.isSupported(gl, opts);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGLContext(gl);
    if (props instanceof Promise || typeof props === "string") {
      props = {
        data: props
      };
    }
    if (typeof props.data === "string") {
      props = Object.assign({}, props, {
        data: loadImage(props.data)
      });
    }
    super(gl, Object.assign({}, props, {
      target: 3553
    }));
    this.initialize(props);
    Object.seal(this);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
var FACES = [34069, 34070, 34071, 34072, 34073, 34074];
var TextureCube = class extends Texture {
  get [Symbol.toStringTag]() {
    return "TextureCube";
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGLContext(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;
      if (mipmaps) {
        this.generateMipmap(props);
      }
      this.setParameters(parameters);
    });
    return this;
  }
  subImage(_ref) {
    let {
      face,
      data: data3,
      x = 0,
      y = 0,
      mipmapLevel = 0
    } = _ref;
    return this._subImage({
      target: face,
      data: data3,
      x,
      y,
      mipmapLevel
    });
  }
  async setCubeMapImageData(_ref2) {
    let {
      width,
      height,
      pixels,
      data: data3,
      border = 0,
      format = 6408,
      type = 5121
    } = _ref2;
    const {
      gl
    } = this;
    const imageDataMap = pixels || data3;
    const resolvedFaces = await Promise.all(FACES.map((face) => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        log.warn("".concat(this.id, " has mipmap and multiple LODs."))();
      }
      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data: data3,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data3;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }
    return this;
  }
};
TextureCube.FACES = FACES;

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
var Texture3D = class extends Texture {
  get [Symbol.toStringTag]() {
    return "Texture3D";
  }
  static isSupported(gl) {
    return isWebGL2(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    super(gl, props);
    this.initialize(props);
    Object.seal(this);
  }
  setImageData(_ref) {
    let {
      level = 0,
      dataFormat = 6408,
      width,
      height,
      depth = 1,
      border = 0,
      format,
      type = 5121,
      offset = 0,
      data: data3,
      parameters = {}
    } = _ref;
    this._trackDeallocatedMemory("Texture");
    this.gl.bindTexture(this.target, this.handle);
    withParameters(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data3)) {
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data3);
      }
      if (data3 instanceof Buffer2) {
        this.gl.bindBuffer(35052, data3.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
      }
    });
    if (data3 && data3.byteLength) {
      this._trackAllocatedMemory(data3.byteLength, "Texture");
    } else {
      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
    }
    this.loaded = true;
    return this;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
var renderbuffer_formats_default = {
  [33189]: {
    bpp: 2
  },
  [33190]: {
    gl2: true,
    bpp: 3
  },
  [36012]: {
    gl2: true,
    bpp: 4
  },
  [36168]: {
    bpp: 1
  },
  [34041]: {
    bpp: 4
  },
  [35056]: {
    gl2: true,
    bpp: 4
  },
  [36013]: {
    gl2: true,
    bpp: 5
  },
  [32854]: {
    bpp: 2
  },
  [36194]: {
    bpp: 2
  },
  [32855]: {
    bpp: 2
  },
  [33321]: {
    gl2: true,
    bpp: 1
  },
  [33330]: {
    gl2: true,
    bpp: 1
  },
  [33329]: {
    gl2: true,
    bpp: 1
  },
  [33332]: {
    gl2: true,
    bpp: 2
  },
  [33331]: {
    gl2: true,
    bpp: 2
  },
  [33334]: {
    gl2: true,
    bpp: 4
  },
  [33333]: {
    gl2: true,
    bpp: 4
  },
  [33323]: {
    gl2: true,
    bpp: 2
  },
  [33336]: {
    gl2: true,
    bpp: 2
  },
  [33335]: {
    gl2: true,
    bpp: 2
  },
  [33338]: {
    gl2: true,
    bpp: 4
  },
  [33337]: {
    gl2: true,
    bpp: 4
  },
  [33340]: {
    gl2: true,
    bpp: 8
  },
  [33339]: {
    gl2: true,
    bpp: 8
  },
  [32849]: {
    gl2: true,
    bpp: 3
  },
  [32856]: {
    gl2: true,
    bpp: 4
  },
  [32857]: {
    gl2: true,
    bpp: 4
  },
  [36220]: {
    gl2: true,
    bpp: 4
  },
  [36238]: {
    gl2: true,
    bpp: 4
  },
  [36975]: {
    gl2: true,
    bpp: 4
  },
  [36214]: {
    gl2: true,
    bpp: 8
  },
  [36232]: {
    gl2: true,
    bpp: 8
  },
  [36226]: {
    gl2: true,
    bpp: 16
  },
  [36208]: {
    gl2: true,
    bpp: 16
  },
  [33325]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  },
  [33327]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [34842]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [33326]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [33328]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [34836]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  },
  [35898]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
function isFormatSupported2(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value === "string") {
    return gl.getExtension(value);
  }
  return value;
}
var Renderbuffer = class extends Resource {
  get [Symbol.toStringTag]() {
    return "Renderbuffer";
  }
  static isSupported(gl) {
    let {
      format
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      format: null
    };
    return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
  }
  static getSamplesForFormat(gl, _ref) {
    let {
      format
    } = _ref;
    return gl.getInternalformatParameter(36161, format, 32937);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(gl, opts);
    this.initialize(opts);
    Object.seal(this);
  }
  initialize(_ref2) {
    let {
      format,
      width = 1,
      height = 1,
      samples = 0
    } = _ref2;
    assert3(format, "Needs format");
    this._trackDeallocatedMemory();
    this.gl.bindRenderbuffer(36161, this.handle);
    if (samples !== 0 && isWebGL2(this.gl)) {
      this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(36161, format, width, height);
    }
    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;
    this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
    return this;
  }
  resize(_ref3) {
    let {
      width,
      height
    } = _ref3;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        samples: this.samples
      });
    }
    return this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _bindHandle(handle) {
    this.gl.bindRenderbuffer(36161, handle);
  }
  _syncHandle(handle) {
    this.format = this.getParameter(36164);
    this.width = this.getParameter(36162);
    this.height = this.getParameter(36163);
    this.samples = this.getParameter(36011);
  }
  _getParameter(pname) {
    this.gl.bindRenderbuffer(36161, this.handle);
    const value = this.gl.getRenderbufferParameter(36161, pname);
    return value;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
var GL_DEPTH_BUFFER_BIT = 256;
var GL_STENCIL_BUFFER_BIT = 1024;
var GL_COLOR_BUFFER_BIT = 16384;
var GL_COLOR = 6144;
var GL_DEPTH = 6145;
var GL_STENCIL = 6146;
var GL_DEPTH_STENCIL = 34041;
var ERR_ARGUMENTS = "clear: bad arguments";
function clear3(gl) {
  let {
    framebuffer = null,
    color = null,
    depth = null,
    stencil = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  assert3(clearFlags !== 0, ERR_ARGUMENTS);
  withParameters(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl) {
  let {
    framebuffer = null,
    buffer = GL_COLOR,
    drawBuffer = 0,
    value = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  assertWebGL2Context(gl);
  withParameters(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }
        break;
      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;
      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;
      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;
      default:
        assert3(false, ERR_ARGUMENTS);
    }
  });
}

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      assert3(false);
      return 0;
  }
}

// node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
function readPixelsToArray(source) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert3(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }
  assert3(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function copyToDataUrl(source) {
  let {
    sourceAttachment = 36064,
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let data3 = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;
  while (height > targetMaxHeight) {
    ({
      data: data3,
      width,
      height
    } = scalePixels2({
      data: data3,
      width,
      height
    }));
  }
  flipRows({
    data: data3,
    width,
    height
  });
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");
  const imageData = context.createImageData(width, height);
  imageData.data.set(data3);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToTexture(source, target) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert3(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  assert3(target);
  let texture = null;
  if (target instanceof Texture) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }
  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        const gl2 = assertWebGL2Context(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}
function getFramebuffer(source) {
  if (!(source instanceof Framebuffer)) {
    return {
      framebuffer: toFramebuffer(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = getTypedArrayFromGLType(type, {
    clamped: false
  });
  const components = glFormatToComponents(format);
  return new ArrayType(width * height * components);
}

// node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
var FEATURES = {
  WEBGL2: "WEBGL2",
  VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
  TIMER_QUERY: "TIMER_QUERY",
  INSTANCED_RENDERING: "INSTANCED_RENDERING",
  MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
  ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
  BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
  FLOAT_BLEND: "FLOAT_BLEND",
  COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
  TEXTURE_DEPTH: "TEXTURE_DEPTH",
  TEXTURE_FLOAT: "TEXTURE_FLOAT",
  TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
  TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
  TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
  COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
  COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
  COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
  GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
  GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
  GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
  GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function checkFloat32ColorAttachment(gl) {
  const testTexture = new Texture2D(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new Framebuffer(gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}
var webgl_features_table_default = {
  [FEATURES.WEBGL2]: [false, true],
  [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
  [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
  [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
  [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
  [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
  [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
  [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
  [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
  [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
  [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
  [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
  [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
  [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
};

// node_modules/@luma.gl/webgl/dist/esm/features/features.js
var LOG_UNSUPPORTED_FEATURE = 2;
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  for (const cap in webgl_features_table_default) {
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}
function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  if (gl.luma.caps[cap] === void 0) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }
  if (!gl.luma.caps[cap]) {
    log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }
  return gl.luma.caps[cap];
}
function queryFeature(gl, cap) {
  const feature = webgl_features_table_default[cap];
  assert3(feature, cap);
  let isSupported;
  const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  if (typeof featureDefinition === "function") {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === "string") {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === "boolean") {
    isSupported = featureDefinition;
  } else {
    assert3(false);
  }
  return isSupported;
}

// node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
var Framebuffer = class _Framebuffer extends Resource {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      colorBufferFloat,
      colorBufferHalfFloat
    } = options;
    let supported = true;
    if (colorBufferFloat) {
      supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
    }
    if (colorBufferHalfFloat) {
      supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
    }
    return supported;
  }
  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new _Framebuffer(gl, {
      id: "default-framebuffer",
      handle: null,
      attachments: {}
    });
    return gl.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const gl2 = assertWebGL2Context(this.gl);
    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const gl2 = assertWebGL2Context(this.gl);
    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(gl, opts);
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.ownResources = [];
    this.initialize(opts);
    Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(_ref) {
    let {
      width = 1,
      height = 1,
      attachments = null,
      color = true,
      depth = true,
      stencil = false,
      check = true,
      readBuffer = void 0,
      drawBuffers = void 0
    } = _ref;
    assert3(width >= 0 && height >= 0, "Width and height need to be integers");
    this.width = width;
    this.height = height;
    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }
    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    });
    if (attachments && check) {
      this.checkStatus();
    }
  }
  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }
    super.delete();
    return this;
  }
  update(_ref2) {
    let {
      attachments = {},
      readBuffer,
      drawBuffers,
      clearAttachments = false,
      resizeAttachments = true
    } = _ref2;
    this.attach(attachments, {
      clearAttachments,
      resizeAttachments
    });
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }
    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }
    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  resize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let {
      width,
      height
    } = options;
    if (this.handle === null) {
      assert3(width === void 0 && height === void 0);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === void 0) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === void 0) {
      height = this.gl.drawingBufferHeight;
    }
    if (width !== this.width && height !== this.height) {
      log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
    }
    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }
    this.width = width;
    this.height = height;
    return this;
  }
  attach(attachments) {
    let {
      clearAttachments = false,
      resizeAttachments = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const newAttachments = {};
    if (clearAttachments) {
      Object.keys(this.attachments).forEach((key) => {
        newAttachments[key] = null;
      });
    }
    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    for (const key in newAttachments) {
      assert3(key !== void 0, "Misspelled framebuffer binding point?");
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;
      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof Renderbuffer) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;
        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      }
      if (resizeAttachments && object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }
    this.gl.bindFramebuffer(36160, prevHandle || null);
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
      delete this.attachments[key];
    });
  }
  checkStatus() {
    const {
      gl
    } = this;
    const status = this.getStatus();
    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }
    return this;
  }
  getStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    return status;
  }
  clear() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      color,
      depth,
      stencil,
      drawBuffers = []
    } = options;
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    if (color || depth || stencil) {
      clear3(this.gl, {
        color,
        depth,
        stencil
      });
    }
    drawBuffers.forEach((value, drawBuffer) => {
      clearBuffer(this.gl, {
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  readPixels() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
    return null;
  }
  readPixelsToBuffer() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
    return null;
  }
  copyToDataUrl() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
    return null;
  }
  copyToImage() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
    return null;
  }
  copyToTexture() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
    return null;
  }
  blit() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
    return null;
  }
  invalidate(_ref3) {
    let {
      attachments = [],
      x = 0,
      y = 0,
      width,
      height
    } = _ref3;
    const gl2 = assertWebGL2Context(this.gl);
    const prevHandle = gl2.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === void 0 && height === void 0;
    if (invalidateAll) {
      gl2.invalidateFramebuffer(36008, attachments);
    } else {
      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }
    gl2.bindFramebuffer(36008, prevHandle);
    return this;
  }
  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);
    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }
    if (keys && value > 1e3) {
      value = getKey(this.gl, value);
    }
    return value;
  }
  getAttachmentParameters() {
    let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
    let keys = arguments.length > 1 ? arguments[1] : void 0;
    let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const values = {};
    for (const pname of parameters) {
      const key = keys ? getKey(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }
    return values;
  }
  getParameters() {
    let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    const attachments = Object.keys(this.attachments);
    const parameters = {};
    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? getKey(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }
    return parameters;
  }
  show() {
    if (typeof window !== "undefined") {
      window.open(copyToDataUrl(this), "luma-debug-texture");
    }
    return this;
  }
  log() {
    let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (logLevel > log.level || typeof window === "undefined") {
      return this;
    }
    message = message || "Framebuffer ".concat(this.id);
    const image = copyToDataUrl(this, {
      targetMaxHeight: 100
    });
    log.image({
      logLevel,
      message,
      image
    }, message)();
    return this;
  }
  bind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }
  unbind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.gl.bindFramebuffer(target, null);
    return this;
  }
  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;
    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new Texture2D(this.gl, {
        id: "".concat(this.id, "-color0"),
        pixels: null,
        format: 6408,
        type: 5121,
        width,
        height,
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.ownResources.push(defaultAttachments[36064]);
    }
    if (depth && stencil) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new Renderbuffer(this.gl, {
        id: "".concat(this.id, "-depth-stencil"),
        format: 35056,
        width,
        height: 111
      });
      this.ownResources.push(defaultAttachments[33306]);
    } else if (depth) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new Renderbuffer(this.gl, {
        id: "".concat(this.id, "-depth"),
        format: 33189,
        width,
        height
      });
      this.ownResources.push(defaultAttachments[36096]);
    } else if (stencil) {
      assert3(false);
    }
    return defaultAttachments;
  }
  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];
    if (!oldAttachment) {
      return;
    }
    if (oldAttachment instanceof Renderbuffer) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    } else {
      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
    }
    delete this.attachments[attachment];
  }
  _attachRenderbuffer(_ref4) {
    let {
      attachment = 36064,
      renderbuffer
    } = _ref4;
    const {
      gl
    } = this;
    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    this.attachments[attachment] = renderbuffer;
  }
  _attachTexture(_ref5) {
    let {
      attachment = 36064,
      texture,
      layer,
      level
    } = _ref5;
    const {
      gl
    } = this;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case 35866:
      case 32879:
        const gl2 = assertWebGL2Context(gl);
        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        assert3(false, "Illegal texture type");
    }
    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }
  _setReadBuffer(readBuffer) {
    const gl2 = getWebGL2Context(this.gl);
    if (gl2) {
      gl2.readBuffer(readBuffer);
    } else {
      assert3(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }
    this.readBuffer = readBuffer;
  }
  _setDrawBuffers(drawBuffers) {
    const {
      gl
    } = this;
    const gl2 = assertWebGL2Context(gl);
    if (gl2) {
      gl2.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension("WEBGL_draw_buffers");
      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        assert3(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }
    this.drawBuffers = drawBuffers;
  }
  _getAttachmentParameterFallback(pname) {
    const caps = getFeatures(this.gl);
    switch (pname) {
      case 36052:
        return !caps.WEBGL2 ? 0 : null;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return !caps.WEBGL2 ? 8 : null;
      case 33297:
        return !caps.WEBGL2 ? 5125 : null;
      case 33296:
        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }
};
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}
var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
function cloneTextureFrom(refTexture, overrides) {
  assert3(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
function getShaderName(shader) {
  let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
var GL_FRAGMENT_SHADER = 35632;
var GL_VERTEX_SHADER = 35633;
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return "fragment";
    case GL_VERTEX_SHADER:
      return "vertex";
    default:
      return "unknown type";
  }
}

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || getShaderName(src) || "(unnamed)";
  const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name);
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(":");
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }
    if (type !== "WARNING") {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }
  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}
function formatErrors(errors, lines) {
  let message = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += "".concat(line, "\n");
    if (errors[i + 1]) {
      const error3 = errors[i + 1];
      const segments = error3.split(":", 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error3.substring(segments.join(":").length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }
  return message;
}
function addLineNumbers(string) {
  let start3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start3 - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start3);
    const digits = lineNumber.length;
    const prefix3 = padLeft(lineNumber, maxDigits - digits);
    return prefix3 + delim + line;
  });
}
function padLeft(string, digits) {
  let result = "";
  for (let i = 0; i < digits; ++i) {
    result += " ";
  }
  return "".concat(result).concat(string);
}

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === "#version") {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version = v;
    }
  }
  return version;
}

// node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
var Shader = class _Shader extends Resource {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  static getTypeName(shaderType) {
    switch (shaderType) {
      case 35633:
        return "vertex-shader";
      case 35632:
        return "fragment-shader";
      default:
        assert3(false);
        return "unknown";
    }
  }
  constructor(gl, props) {
    assertWebGLContext(gl);
    assert3(typeof props.source === "string", ERR_SOURCE);
    const id = getShaderName(props.source, null) || props.id || uid3("unnamed ".concat(_Shader.getTypeName(props.shaderType)));
    super(gl, {
      id
    });
    this.shaderType = props.shaderType;
    this.source = props.source;
    this.initialize(props);
  }
  initialize(_ref) {
    let {
      source
    } = _ref;
    const shaderName = getShaderName(source, null);
    if (shaderName) {
      this.id = uid3(shaderName);
    }
    this._compile(source);
  }
  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }
  toString() {
    return "".concat(_Shader.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return getShaderName(this.source) || "unnamed-shader";
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const extension = this.gl.getExtension("WEBGL_debug_shaders");
    return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
  }
  _compile() {
    let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
    if (!source.startsWith("#version ")) {
      source = "#version 100\n".concat(source);
    }
    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);
    const compileStatus = this.getParameter(35713);
    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {
        shaderName,
        errors,
        warnings
      } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
      log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
      log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
      throw new Error("GLSL compilation errors in ".concat(shaderName));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
};
var VertexShader = class extends Shader {
  get [Symbol.toStringTag]() {
    return "VertexShader";
  }
  constructor(gl, props) {
    if (typeof props === "string") {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
};
var FragmentShader = class extends Shader {
  get [Symbol.toStringTag]() {
    return "FragmentShader";
  }
  constructor(gl, props) {
    if (typeof props === "string") {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
var UNIFORM_SETTERS = {
  [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
  [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
  [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
  [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
  [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
  [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
  [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
  [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
  [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
  [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
  [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
  [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
  [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
  [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
  [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
  [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
  [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
  [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
  [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
  [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
  [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
  [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
  [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
  [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [35679]: getSamplerSetter,
  [35682]: getSamplerSetter,
  [36289]: getSamplerSetter,
  [36292]: getSamplerSetter,
  [36293]: getSamplerSetter,
  [36298]: getSamplerSetter,
  [36299]: getSamplerSetter,
  [36300]: getSamplerSetter,
  [36303]: getSamplerSetter,
  [36306]: getSamplerSetter,
  [36307]: getSamplerSetter,
  [36308]: getSamplerSetter,
  [36311]: getSamplerSetter
};
var FLOAT_ARRAY = {};
var INT_ARRAY = {};
var UINT_ARRAY = {};
var array1 = [0];
function toTypedArray(value, uniformLength, Type, cache4) {
  if (uniformLength === 1 && typeof value === "boolean") {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  const length = value.length;
  if (length % uniformLength) {
    log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }
  if (value instanceof Type) {
    return value;
  }
  let result = cache4[length];
  if (!result) {
    result = new Type(length);
    cache4[length] = result;
  }
  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }
  return result;
}
function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
function getUniformSetter(gl, location2, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl, location2);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== "]") {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches3 = name.match(UNIFORM_NAME_REGEXP);
  if (!matches3 || matches3.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches3[1],
    length: matches3[2] || 1,
    isArray: Boolean(matches3[2])
  };
}
function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : "";
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }
  return true;
}
function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }
  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof Texture) {
    return true;
  } else if (value instanceof Renderbuffer) {
    return true;
  } else if (value instanceof Framebuffer) {
    return Boolean(value.texture);
  }
  return false;
}
function copyUniform(uniforms, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms[key]) {
      const dest = uniforms[key];
      for (let i = 0, len = value.length; i < len; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms[key] = value.slice();
    }
  } else {
    uniforms[key] = value;
  }
}
function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }
  const checkLength = Math.min(value.length, 16);
  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }
  return true;
}
function getSamplerSetter() {
  let cache4 = null;
  return (gl, location2, value) => {
    const update = cache4 !== value;
    if (update) {
      gl.uniform1i(location2, value);
      cache4 = value;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size3, uniformSetter) {
  let cache4 = null;
  let cacheLength = null;
  return (gl, location2, value) => {
    const arrayValue = toArray(value, size3);
    const length = arrayValue.length;
    let update = false;
    if (cache4 === null) {
      cache4 = new Float32Array(length);
      cacheLength = length;
      update = true;
    } else {
      assert3(cacheLength === length, "Uniform length cannot change.");
      for (let i = 0; i < length; ++i) {
        if (arrayValue[i] !== cache4[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl, functionName, location2, arrayValue);
      cache4.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl, functionName, location2, value) {
  gl[functionName](location2, value);
}
function setMatrixUniform(gl, functionName, location2, value) {
  gl[functionName](location2, false, value);
}

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
var GL_BYTE = 5120;
var GL_UNSIGNED_BYTE = 5121;
var GL_SHORT = 5122;
var GL_UNSIGNED_SHORT = 5123;
var GL_POINTS = 0;
var GL_LINES = 1;
var GL_LINE_LOOP = 2;
var GL_LINE_STRIP = 3;
var GL_TRIANGLES = 4;
var GL_TRIANGLE_STRIP = 5;
var GL_TRIANGLE_FAN = 6;
var GL_FLOAT = 5126;
var GL_FLOAT_VEC2 = 35664;
var GL_FLOAT_VEC3 = 35665;
var GL_FLOAT_VEC4 = 35666;
var GL_INT = 5124;
var GL_INT_VEC2 = 35667;
var GL_INT_VEC3 = 35668;
var GL_INT_VEC4 = 35669;
var GL_UNSIGNED_INT = 5125;
var GL_UNSIGNED_INT_VEC2 = 36294;
var GL_UNSIGNED_INT_VEC3 = 36295;
var GL_UNSIGNED_INT_VEC4 = 36296;
var GL_BOOL = 35670;
var GL_BOOL_VEC2 = 35671;
var GL_BOOL_VEC3 = 35672;
var GL_BOOL_VEC4 = 35673;
var GL_FLOAT_MAT2 = 35674;
var GL_FLOAT_MAT3 = 35675;
var GL_FLOAT_MAT4 = 35676;
var GL_FLOAT_MAT2x3 = 35685;
var GL_FLOAT_MAT2x4 = 35686;
var GL_FLOAT_MAT3x2 = 35687;
var GL_FLOAT_MAT3x4 = 35688;
var GL_FLOAT_MAT4x2 = 35689;
var GL_FLOAT_MAT4x3 = 35690;
var COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, "float"],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
  [GL_INT]: [GL_INT, 1, "int"],
  [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
  [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
  [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
  [GL_BOOL]: [GL_FLOAT, 1, "bool"],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
};
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      assert3(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }
  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }
  return null;
}

// node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
var ProgramConfiguration = class {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);
    this._readAttributesFromProgram(program);
    this._readVaryingsFromProgram(program);
  }
  getAttributeInfo(locationOrName) {
    const location2 = Number(locationOrName);
    if (Number.isFinite(location2)) {
      return this.attributeInfosByLocation[location2];
    }
    return this.attributeInfosByName[locationOrName] || null;
  }
  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }
  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }
  getVaryingInfo(locationOrName) {
    const location2 = Number(locationOrName);
    if (Number.isFinite(location2)) {
      return this.varyingInfos[location2];
    }
    return this.varyingInfosByName[locationOrName] || null;
  }
  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }
  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }
  _readAttributesFromProgram(program) {
    const {
      gl
    } = program;
    const count2 = gl.getProgramParameter(program.handle, 35721);
    for (let index = 0; index < count2; index++) {
      const {
        name,
        type,
        size: size3
      } = gl.getActiveAttrib(program.handle, index);
      const location2 = gl.getAttribLocation(program.handle, name);
      if (location2 >= 0) {
        this._addAttribute(location2, name, type, size3);
      }
    }
    this.attributeInfos.sort((a, b) => a.location - b.location);
  }
  _readVaryingsFromProgram(program) {
    const {
      gl
    } = program;
    if (!isWebGL2(gl)) {
      return;
    }
    const count2 = gl.getProgramParameter(program.handle, 35971);
    for (let location2 = 0; location2 < count2; location2++) {
      const {
        name,
        type,
        size: size3
      } = gl.getTransformFeedbackVarying(program.handle, location2);
      this._addVarying(location2, name, type, size3);
    }
    this.varyingInfos.sort((a, b) => a.location - b.location);
  }
  _addAttribute(location2, name, compositeType, size3) {
    const {
      type,
      components
    } = decomposeCompositeGLType(compositeType);
    const accessor = {
      type,
      size: size3 * components
    };
    this._inferProperties(location2, name, accessor);
    const attributeInfo = {
      location: location2,
      name,
      accessor: new Accessor(accessor)
    };
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location2] = attributeInfo;
    this.attributeInfosByName[attributeInfo.name] = attributeInfo;
  }
  _inferProperties(location2, name, accessor) {
    if (/instance/i.test(name)) {
      accessor.divisor = 1;
    }
  }
  _addVarying(location2, name, compositeType, size3) {
    const {
      type,
      components
    } = decomposeCompositeGLType(compositeType);
    const accessor = new Accessor({
      type,
      size: size3 * components
    });
    const varying = {
      location: location2,
      name,
      accessor
    };
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying;
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/program.js
var LOG_PROGRAM_PERF_PRIORITY = 4;
var GL_SEPARATE_ATTRIBS = 35981;
var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
var Program = class extends Resource {
  get [Symbol.toStringTag]() {
    return "Program";
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
    this._isCached = false;
    this.initialize(props);
    Object.seal(this);
    this._setId(props.id);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      hash,
      vs: vs7,
      fs: fs4,
      varyings,
      bufferMode = GL_SEPARATE_ATTRIBS
    } = props;
    this.hash = hash || "";
    this.vs = typeof vs7 === "string" ? new VertexShader(this.gl, {
      id: "".concat(props.id, "-vs"),
      source: vs7
    }) : vs7;
    this.fs = typeof fs4 === "string" ? new FragmentShader(this.gl, {
      id: "".concat(props.id, "-fs"),
      source: fs4
    }) : fs4;
    assert3(this.vs instanceof VertexShader);
    assert3(this.fs instanceof FragmentShader);
    this.uniforms = {};
    this._textureUniforms = {};
    if (varyings && varyings.length > 0) {
      assertWebGL2Context(this.gl);
      this.varyings = varyings;
      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._compileAndLink();
    this._readUniformLocationsFromLinkedProgram();
    this.configuration = new ProgramConfiguration(this);
    return this.setProps(props);
  }
  delete() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._isCached) {
      return this;
    }
    return super.delete(options);
  }
  setProps(props) {
    if ("uniforms" in props) {
      this.setUniforms(props.uniforms);
    }
    return this;
  }
  draw(_ref) {
    let {
      logPriority,
      drawMode = 4,
      vertexCount,
      offset = 0,
      start: start3,
      end,
      isIndexed = false,
      indexType = 5123,
      instanceCount = 0,
      isInstanced = instanceCount > 0,
      vertexArray = null,
      transformFeedback,
      framebuffer,
      parameters = {},
      uniforms,
      samplers
    } = _ref;
    if (uniforms || samplers) {
      log.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
      this.setUniforms(uniforms || {});
    }
    if (log.priority >= logPriority) {
      const fb = framebuffer ? framebuffer.id : "default";
      const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
      log.log(logPriority, message)();
    }
    assert3(vertexArray);
    this.gl.useProgram(this.handle);
    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
      return false;
    }
    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== void 0) {
        parameters = Object.assign({}, parameters, {
          framebuffer
        });
      }
      if (transformFeedback) {
        const primitiveMode = getPrimitiveDrawMode(drawMode);
        transformFeedback.begin(primitiveMode);
      }
      this._bindTextures();
      withParameters(this.gl, parameters, () => {
        if (isIndexed && isInstanced) {
          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start3) && !isNaN(end)) {
          this.gl2.drawRangeElements(drawMode, start3, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    return true;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (log.priority >= 2) {
      checkUniformValues(uniforms, this.id, this._uniformSetters);
    }
    this.gl.useProgram(this.handle);
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];
      if (uniformSetter) {
        let value = uniform;
        let textureUpdate = false;
        if (value instanceof Framebuffer) {
          value = value.texture;
        }
        if (value instanceof Texture) {
          textureUpdate = this.uniforms[uniformName] !== uniform;
          if (textureUpdate) {
            if (uniformSetter.textureIndex === void 0) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }
            const texture = value;
            const {
              textureIndex
            } = uniformSetter;
            texture.bind(textureIndex);
            value = textureIndex;
            this._textureUniforms[uniformName] = texture;
          } else {
            value = uniformSetter.textureIndex;
          }
        } else if (this._textureUniforms[uniformName]) {
          delete this._textureUniforms[uniformName];
        }
        if (uniformSetter(value) || textureUpdate) {
          copyUniform(this.uniforms, uniformName, uniform);
        }
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const uniformName in this._textureUniforms) {
      const texture = this._textureUniforms[uniformName];
      texture.update();
      texturesRenderable = texturesRenderable && texture.loaded;
    }
    return texturesRenderable;
  }
  _bindTextures() {
    for (const uniformName in this._textureUniforms) {
      const textureIndex = this._uniformSetters[uniformName].textureIndex;
      this._textureUniforms[uniformName].bind(textureIndex);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};
    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, 35663);
      switch (type) {
        case 35633:
          opts.vs = new VertexShader({
            handle: shaderHandle
          });
          break;
        case 35632:
          opts.fs = new FragmentShader({
            handle: shaderHandle
          });
          break;
        default:
      }
    }
    return opts;
  }
  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }
  _setId(id) {
    if (!id) {
      const programName = this._getName();
      this.id = uid3(programName);
    }
  }
  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, "");
    programName = programName ? "".concat(programName, "-program") : "program";
    return programName;
  }
  _compileAndLink() {
    const {
      gl
    } = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    gl.linkProgram(this.handle);
    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    if (gl.debug || log.level > 0) {
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
      }
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl
    } = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(35718);
    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {
        name
      } = parseUniformName(info.name);
      let location2 = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = getUniformSetter(gl, location2, info);
      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location2 = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
          this._uniformSetters["".concat(name, "[").concat(l, "]")] = getUniformSetter(gl, location2, info);
        }
      }
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(uniformIndices, pname) {
    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
  }
  getUniformBlockIndex(blockName) {
    return this.gl2.getUniformBlockIndex(this.handle, blockName);
  }
  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }
  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/query.js
var GL_QUERY_RESULT = 34918;
var GL_QUERY_RESULT_AVAILABLE = 34919;
var GL_TIME_ELAPSED_EXT = 35007;
var GL_GPU_DISJOINT_EXT2 = 36795;
var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
var GL_ANY_SAMPLES_PASSED = 35887;
var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
var Query = class _Query extends Resource {
  get [Symbol.toStringTag]() {
    return "Query";
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const webgl2 = isWebGL2(gl);
    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;
    for (const key of opts) {
      switch (key) {
        case "queries":
          supported = supported && webgl2;
          break;
        case "timers":
          supported = supported && hasTimerQuery;
          break;
        default:
          assert3(false);
      }
    }
    return supported;
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }
  beginOcclusionQuery() {
    let {
      conservative = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }
  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }
  begin(target) {
    if (this._queryPending) {
      return this;
    }
    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }
  end() {
    if (this._queryPending) {
      return this;
    }
    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return this;
  }
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter2 = 0;
    this._pollingPromise = new Promise((resolve2, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve2(this.getResult());
          this._pollingPromise = null;
        } else if (counter2++ > limit) {
          reject("Timed out");
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
  _createHandle() {
    return _Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
var TransformFeedback = class extends Resource {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  static isSupported(gl) {
    return isWebGL2(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    super(gl, props);
    this.initialize(props);
    this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;
    if (!isObjectEmpty2(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }
    this.setProps(props);
    return this;
  }
  setProps(props) {
    if ("program" in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ("configuration" in props) {
      this.configuration = props.configuration;
    }
    if ("bindOnUse" in props) {
      props = props.bindOnUse;
    }
    if ("buffers" in props) {
      this.setBuffers(props.buffers);
    }
  }
  setBuffers() {
    let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }
  setBuffer(locationOrName, bufferOrParams) {
    const location2 = this._getVaryingIndex(locationOrName);
    const {
      buffer,
      byteSize,
      byteOffset
    } = this._getBufferParams(bufferOrParams);
    if (location2 < 0) {
      this.unused[locationOrName] = buffer;
      log.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
      return this;
    }
    this.buffers[location2] = bufferOrParams;
    if (!this.bindOnUse) {
      this._bindBuffer(location2, buffer, byteOffset, byteSize);
    }
    return this;
  }
  begin() {
    let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    this.gl.bindTransformFeedback(36386, this.handle);
    this._bindBuffers();
    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }
  end() {
    this.gl.endTransformFeedback();
    this._unbindBuffers();
    this.gl.bindTransformFeedback(36386, null);
    return this;
  }
  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;
    if (bufferOrParams instanceof Buffer2 === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }
    if (byteOffset !== void 0 || byteSize !== void 0) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }
    return {
      buffer,
      byteOffset,
      byteSize
    };
  }
  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }
  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }
    const location2 = Number(locationOrName);
    return Number.isFinite(location2) ? location2 : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(this.buffers[bufferIndex]);
        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }
  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }
  _bindBuffer(index, buffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let byteSize = arguments.length > 3 ? arguments[3] : void 0;
    const handle = buffer && buffer.handle;
    if (!handle || byteSize === void 0) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
    }
    return this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(handle) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
var arrayBuffer = null;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}
function fillArray(_ref) {
  let {
    target,
    source,
    start: start3 = 0,
    count: count2 = 1
  } = _ref;
  const length = source.length;
  const total = count2 * length;
  let copied = 0;
  for (let i = start3; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start3 + copied, start3, start3 + copied);
      copied *= 2;
    } else {
      target.copyWithin(start3 + copied, start3, start3 + total - copied);
      copied = total;
    }
  }
  return target;
}

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
var VertexArrayObject = class _VertexArrayObject extends Resource {
  get [Symbol.toStringTag]() {
    return "VertexArrayObject";
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (options.constantAttributeZero) {
      return isWebGL2(gl) || getBrowser() === "Chrome";
    }
    return true;
  }
  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};
    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new _VertexArrayObject(gl, {
        handle: null,
        isDefaultArray: true
      });
    }
    return gl.luma.defaultVertexArray;
  }
  static getMaxAttributes(gl) {
    _VertexArrayObject.MAX_ATTRIBUTES = _VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
    return _VertexArrayObject.MAX_ATTRIBUTES;
  }
  static setConstant(gl, location2, array) {
    switch (array.constructor) {
      case Float32Array:
        _VertexArrayObject._setConstantFloatArray(gl, location2, array);
        break;
      case Int32Array:
        _VertexArrayObject._setConstantIntArray(gl, location2, array);
        break;
      case Uint32Array:
        _VertexArrayObject._setConstantUintArray(gl, location2, array);
        break;
      default:
        assert3(false);
    }
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    super(gl, Object.assign({}, opts, {
      id
    }));
    this.buffer = null;
    this.bufferValue = null;
    this.isDefaultArray = opts.isDefaultArray || false;
    this.gl2 = gl;
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    super.delete();
    if (this.buffer) {
      this.buffer.delete();
    }
    return this;
  }
  get MAX_ATTRIBUTES() {
    return _VertexArrayObject.getMaxAttributes(this.gl);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.setProps(props);
  }
  setProps(props) {
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assert3(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
    this.bind(() => {
      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
    });
    return this;
  }
  setBuffer(location2, buffer, accessor) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, accessor);
    }
    const {
      size: size3,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = accessor;
    const {
      gl,
      gl2
    } = this;
    location2 = Number(location2);
    this.bind(() => {
      gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        assert3(isWebGL2(gl));
        gl2.vertexAttribIPointer(location2, size3, type, stride, offset);
      } else {
        gl.vertexAttribPointer(location2, size3, type, normalized, stride, offset);
      }
      gl.enableVertexAttribArray(location2);
      gl2.vertexAttribDivisor(location2, divisor || 0);
    });
    return this;
  }
  enable(location2) {
    let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const disablingAttributeZero = !enable2 && location2 === 0 && !_VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    });
    if (!disablingAttributeZero) {
      location2 = Number(location2);
      this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location2) : this.gl.disableVertexAttribArray(location2));
    }
    return this;
  }
  getConstantBuffer(elementCount, value) {
    const constantValue = this._normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = getScratchArray(value.constructor, length);
      fillArray({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  static _setConstantFloatArray(gl, location2, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location2, array);
        break;
      case 2:
        gl.vertexAttrib2fv(location2, array);
        break;
      case 3:
        gl.vertexAttrib3fv(location2, array);
        break;
      case 4:
        gl.vertexAttrib4fv(location2, array);
        break;
      default:
        assert3(false);
    }
  }
  static _setConstantIntArray(gl, location2, array) {
    assert3(isWebGL2(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location2, array);
        break;
      case 2:
        gl.vertexAttribI2iv(location2, array);
        break;
      case 3:
        gl.vertexAttribI3iv(location2, array);
        break;
      case 4:
        gl.vertexAttribI4iv(location2, array);
        break;
      default:
        assert3(false);
    }
  }
  static _setConstantUintArray(gl, location2, array) {
    assert3(isWebGL2(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location2, array);
        break;
      case 2:
        gl.vertexAttribI2uiv(location2, array);
        break;
      case 3:
        gl.vertexAttribI3uiv(location2, array);
        break;
      case 4:
        gl.vertexAttribI4uiv(location2, array);
        break;
      default:
        assert3(false);
    }
  }
  _createHandle() {
    const gl2 = this.gl;
    return gl2.createVertexArray();
  }
  _deleteHandle(handle) {
    this.gl2.deleteVertexArray(handle);
    return [this.elements];
  }
  _bindHandle(handle) {
    this.gl2.bindVertexArray(handle);
  }
  _getParameter(pname, _ref) {
    let {
      location: location2
    } = _ref;
    assert3(Number.isFinite(location2));
    return this.bind(() => {
      switch (pname) {
        case 34373:
          return this.gl.getVertexAttribOffset(location2, pname);
        default:
          return this.gl.getVertexAttrib(location2, pname);
      }
    });
  }
};

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
var VertexArray = class {
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.attributes = {};
    this.vertexArrayObject = new VertexArrayObject(gl);
    stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }
    this.vertexArrayObject.delete();
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }
  reset() {
    this.elements = null;
    this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES
    } = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};
    this.drawParams = null;
    return this;
  }
  setProps(props) {
    if ("program" in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ("configuration" in props) {
      this.configuration = props.configuration;
    }
    if ("attributes" in props) {
      this.setAttributes(props.attributes);
    }
    if ("elements" in props) {
      this.setElementBuffer(props.elements);
    }
    if ("bindOnUse" in props) {
      props = props.bindOnUse;
    }
    return this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    this.drawParams = this.drawParams || this._updateDrawParams();
    return this.drawParams;
  }
  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];
        this._setAttribute(locationOrName, value);
      }
      this.gl.bindBuffer(34962, null);
    });
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.elements = elementBuffer;
    this.elementsAccessor = accessor;
    this.clearDrawParams();
    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    return this;
  }
  setBuffer(locationOrName, buffer) {
    let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, appAccessor);
    }
    const {
      location: location2,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
    if (location2 >= 0) {
      this.values[location2] = buffer;
      this.accessors[location2] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setBuffer(location2, buffer, accessor);
    }
    return this;
  }
  setConstant(locationOrName, arrayValue) {
    let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      location: location2,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
      size: arrayValue.length
    }, appAccessor));
    if (location2 >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
      this.values[location2] = arrayValue;
      this.accessors[location2] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.enable(location2, false);
    }
    return this;
  }
  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.vertexArrayObject.setElementBuffer(null);
      }
      this.buffer = this.buffer || new Buffer2(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
        if (this.values[location2] instanceof Buffer2) {
          this.gl.disableVertexAttribArray(location2);
          this.gl.bindBuffer(34962, this.buffer.handle);
          this.gl.vertexAttribPointer(location2, 1, 5126, false, 0, 0);
        }
      }
    });
    return this;
  }
  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }
      for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
        const buffer = this.values[location2];
        if (buffer instanceof Buffer2) {
          this.setBuffer(location2, buffer);
        }
      }
    });
    return this;
  }
  bindForDraw(vertexCount, instanceCount, func) {
    let value;
    this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(vertexCount, instanceCount);
      value = func();
    });
    return value;
  }
  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const INVALID_RESULT = {
      location: -1,
      accessor: null
    };
    const {
      location: location2,
      name
    } = this._getAttributeIndex(locationOrName);
    if (!Number.isFinite(location2) || location2 < 0) {
      this.unused[locationOrName] = value;
      log.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
      return INVALID_RESULT;
    }
    const accessInfo = this._getAttributeInfo(name || location2);
    if (!accessInfo) {
      return INVALID_RESULT;
    }
    const currentAccessor = this.accessors[location2] || {};
    const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
    const {
      size: size3,
      type
    } = accessor;
    assert3(Number.isFinite(size3) && Number.isFinite(type));
    return {
      location: location2,
      accessor
    };
  }
  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }
  _getAttributeIndex(locationOrName) {
    const location2 = Number(locationOrName);
    if (Number.isFinite(location2)) {
      return {
        location: location2
      };
    }
    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }
    return {
      location: -1
    };
  }
  _setAttribute(locationOrName, value) {
    if (value instanceof Buffer2) {
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer2) {
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof Buffer2) {
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }
  _setConstantAttributes(vertexCount, instanceCount) {
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];
    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }
    for (let location2 = 1; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
      constant = this.values[location2];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location2, constant);
      }
    }
  }
  _setConstantAttributeZero(constant, elementCount) {
    if (VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    })) {
      this._setConstantAttribute(0, constant);
      return;
    }
    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }
  _setConstantAttribute(location2, constant) {
    VertexArrayObject.setConstant(this.gl, location2, constant);
  }
  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };
    for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
      this._updateDrawParamsForLocation(drawParams, location2);
    }
    if (this.elements) {
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }
    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }
    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }
    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }
    return drawParams;
  }
  _updateDrawParamsForLocation(drawParams, location2) {
    const value = this.values[location2];
    const accessor = this.accessors[location2];
    if (!value) {
      return;
    }
    const {
      divisor
    } = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;
    if (value instanceof Buffer2) {
      const buffer = value;
      if (isInstanced) {
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }
  setElements() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    log.deprecated("setElements", "setElementBuffer")();
    return this.setElementBuffer(elementBuffer, accessor);
  }
};

// node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size: size3 = 1
  } = opts;
  let string = "[";
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size3 === 0 ? " " : "");
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? "..." : "]";
  return "".concat(string).concat(terminator);
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const EPSILON3 = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON3) {
    return isInteger ? "0" : "0.";
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf(".0");
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
function getDebugTableForUniforms(_ref) {
  let {
    header = "Uniforms",
    program,
    uniforms,
    undefinedOnly = false
  } = _ref;
  assert3(program);
  const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
  const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count2 = 0;
  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: formatValue(uniform)
        };
      }
    }
  }
  return {
    table,
    count: count2,
    unusedTable,
    unusedCount
  };
}
function addUniformToTable(_ref2) {
  let {
    table,
    header,
    uniforms,
    uniformName,
    undefinedOnly
  } = _ref2;
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? formatValue(value) : "N/A",
      "Uniform Type": isDefined ? value : "NOT PROVIDED"
    };
    return true;
  }
  return false;
}
function isUniformDefined(value) {
  return value !== void 0 && value !== null;
}

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
function getDebugTableForVertexArray(_ref) {
  let {
    vertexArray,
    header = "Attributes"
  } = _ref;
  if (!vertexArray.configuration) {
    return {};
  }
  const table = {};
  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }
  const attributes = vertexArray.values;
  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }
      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }
  return table;
}
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;
  if (!attribute) {
    return {
      [header]: "null",
      "Format ": "N/A"
    };
  }
  let type = "NOT PROVIDED";
  let size3 = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;
  if (accessor) {
    type = accessor.type;
    size3 = accessor.size;
    type = String(type).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
  }
  if (attribute instanceof Buffer2) {
    const buffer = attribute;
    const {
      data: data3,
      changed
    } = buffer.getDebugData();
    marker = changed ? "*" : "";
    value = data3;
    bytes = buffer.byteLength;
    verts = bytes / data3.BYTES_PER_ELEMENT / size3;
    let format;
    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size3, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }
    return {
      [header]: "".concat(marker).concat(formatValue(value, {
        size: size3,
        isInteger
      })),
      "Format ": format
    };
  }
  value = attribute;
  size3 = attribute.length;
  type = String(attribute.constructor.name).replace("Array", "");
  isInteger = type.indexOf("nt") !== -1;
  return {
    [header]: "".concat(formatValue(value, {
      size: size3,
      isInteger
    }), " (constant)"),
    "Format ": "".concat(size3, "x").concat(type, " (constant)")
  };
}
function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size: size3
  } = accessor;
  const typeAndName = getCompositeGLType(type, size3);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
function getDebugTableForProgramConfiguration(config2) {
  const table = {};
  const header = "Accessors for ".concat(config2.id);
  for (const attributeInfo of config2.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration2(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }
  for (const varyingInfo of config2.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration2(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }
  return table;
}
function getGLSLDeclaration2(attributeInfo) {
  const {
    type,
    size: size3
  } = attributeInfo.accessor;
  const typeAndName = getCompositeGLType(type, size3);
  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }
  return attributeInfo.name;
}

// node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
var isPage2 = isBrowser() && typeof document !== "undefined";
var statIdCounter = 0;
var AnimationLoop = class {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      onCreateContext = (opts) => createGLContext(opts),
      onAddHTML = null,
      onInitialize = () => {
      },
      onRender = () => {
      },
      onFinalize = () => {
      },
      onError,
      gl = null,
      glOptions = {},
      debug: debug2 = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
    } = props;
    let {
      useDevicePixels = true
    } = props;
    if ("useDevicePixelRatio" in props) {
      log.deprecated("useDevicePixelRatio", "useDevicePixels")();
      useDevicePixels = props.useDevicePixelRatio;
    }
    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug: debug2,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get("CPU Time");
    this.gpuTime = this.stats.get("GPU Time");
    this.frameRate = this.stats.get("Frame Rate");
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop();
    this._setDisplay(null);
  }
  setNeedsRedraw(reason) {
    assert3(typeof reason === "string");
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  setProps(props) {
    if ("autoResizeViewport" in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }
    if ("autoResizeDrawingBuffer" in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }
    if ("useDevicePixels" in props) {
      this.useDevicePixels = props.useDevicePixels;
    }
    return this;
  }
  start() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._running) {
      return this;
    }
    this._running = true;
    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }
      this._createWebGLContext(opts);
      this._createFramebuffer();
      this._startEventHandling();
      this._initializeCallbackData();
      this._updateCallbackData();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then((appContext) => {
      if (this._running) {
        this._addCallbackData(appContext || {});
        if (appContext !== false) {
          this._startLoop();
        }
      }
    });
    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }
    return this;
  }
  redraw() {
    if (this.isContextLost()) {
      return this;
    }
    this._beginTimers();
    this._setupFrame();
    this._updateCallbackData();
    this._renderFrame(this.animationProps);
    this._clearNeedsRedraw();
    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endTimers();
    return this;
  }
  stop() {
    if (this._running) {
      this._finalizeCallbackData();
      this._cancelAnimationFrame(this._animationFrameId);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }
    return this;
  }
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    this.setNeedsRedraw("waitForRender");
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise((resolve2) => {
        this._resolveNextFrame = resolve2;
      });
    }
    return this._nextFramePromise;
  }
  async toDataURL() {
    this.setNeedsRedraw("toDataURL");
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(id) {
    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }
  setViewParameters() {
    log.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
    return this;
  }
  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };
    this._cancelAnimationFrame(this._animationFrameId);
    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }
  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage2 ? new Promise((resolve2, reject) => {
        if (isPage2 && document.readyState === "complete") {
          resolve2(document);
          return;
        }
        window.addEventListener("load", () => {
          resolve2(document);
        });
      }) : Promise.resolve({});
    }
    return this._pageLoadPromise;
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _cancelAnimationFrame(animationFrameId) {
    if (this.display && this.display.cancelAnimationFrame) {
      return this.display.cancelAnimationFrame(animationFrameId);
    }
    return cancelAnimationFrame(animationFrameId);
  }
  _requestAnimationFrame(renderFrameCallback) {
    if (this._running) {
      if (this.display && this.display.requestAnimationFrame) {
        return this.display.requestAnimationFrame(renderFrameCallback);
      }
      return requestAnimationFrame2(renderFrameCallback);
    }
    return void 0;
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
    this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw("drawing buffer resized");
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw("drawing buffer aspect changed");
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(appContext) {
    if (typeof appContext === "object" && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }
  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
    if (!isWebGL(this.gl)) {
      throw new Error("AnimationLoop.onCreateContext - illegal context returned");
    }
    resetParameters(this.gl);
    this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement("div");
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = "relative";
      const div = document.createElement("div");
      div.style.position = "absolute";
      div.style.left = "10px";
      div.style.bottom = "10px";
      div.style.width = "300px";
      div.style.background = "white";
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;
    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return {
      width,
      height,
      aspect
    };
  }
  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }
  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      resizeGLContext(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }
  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new Framebuffer(this.gl);
    }
  }
  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }
  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }
    this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd();
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }
  _startEventHandling() {
    const {
      canvas
    } = this.gl;
    if (canvas) {
      canvas.addEventListener("mousemove", this._onMousemove);
      canvas.addEventListener("mouseleave", this._onMouseleave);
    }
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
};

// node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
var VERTEX_SHADER = "vs";
var FRAGMENT_SHADER = "fs";

// node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "shadertools: assertion failed.");
  }
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
var TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
    }
  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === "object") {
    if (!propDef) {
      return {
        type: "object",
        value: null
      };
    }
    if ("type" in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!("value" in propDef)) {
      return {
        type: "object",
        value: propDef
      };
    }
    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return "array";
  }
  return typeof value;
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
var VERTEX_SHADER2 = "vs";
var FRAGMENT_SHADER2 = "fs";
var ShaderModule = class {
  constructor(_ref) {
    let {
      name,
      vs: vs7,
      fs: fs4,
      dependencies = [],
      uniforms,
      getUniforms: getUniforms5,
      deprecations = [],
      defines: defines2 = {},
      inject = {},
      vertexShader,
      fragmentShader
    } = _ref;
    assert4(typeof name === "string");
    this.name = name;
    this.vs = vs7 || vertexShader;
    this.fs = fs4 || fragmentShader;
    this.getModuleUniforms = getUniforms5;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines2;
    this.injections = normalizeInjections(inject);
    if (uniforms) {
      this.uniforms = parsePropTypes(uniforms);
    }
  }
  getModuleSource(type) {
    let moduleSource;
    switch (type) {
      case VERTEX_SHADER2:
        moduleSource = this.vs || "";
        break;
      case FRAGMENT_SHADER2:
        moduleSource = this.fs || "";
        break;
      default:
        assert4(false);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
  }
  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }
    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }
    return {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(shaderSource, log4) {
    this.deprecations.forEach((def) => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log4.deprecated(def.old, def.new)();
        } else {
          log4.removed(def.old, def.new)();
        }
      }
    });
  }
  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach((def) => {
      switch (def.type) {
        case "function":
          def.regex = new RegExp("\\b".concat(def.old, "\\("));
          break;
        default:
          def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
      }
    });
    return deprecations;
  }
  _defaultGetUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const uniforms = {};
    const propTypes = this.uniforms;
    for (const key in propTypes) {
      const propDef = propTypes[key];
      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          assert4(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
        }
        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }
    return uniforms;
  }
};
function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map((name) => moduleMap[name]);
}
function getDependencyGraph(_ref) {
  let {
    modules,
    level,
    moduleMap,
    moduleDepth
  } = _ref;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}
function instantiateModules(modules, seen) {
  return modules.map((module) => {
    if (module instanceof ShaderModule) {
      return module;
    }
    assert4(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    assert4(module.name, "shader module has no name");
    module = new ShaderModule(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}

// node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
function isOldIE() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
  const userAgent2 = opts.userAgent || navigator2.userAgent || "";
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  return isMSIE || isTrident;
}

// node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
var GL_VENDOR = 7936;
var GL_RENDERER = 7937;
var GL_VERSION = 7938;
var GL_SHADING_LANGUAGE_VERSION = 35724;
var WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
  GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
  GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
  GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
};
var FEATURES2 = {};
Object.keys(WEBGL_FEATURES).forEach((key) => {
  FEATURES2[key] = key;
});
function isWebGL22(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContextInfo(gl) {
  const info = gl.getExtension("WEBGL_debug_renderer_info");
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}
function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return "NVIDIA";
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return "INTEL";
  }
  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return "AMD";
  }
  return "UNKNOWN GPU";
}
var compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const feature = WEBGL_FEATURES[cap];
  assert4(feature, cap);
  if (!isOldIE(opts)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const behavior = opts.behavior || "enable";
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  assert4(feature, cap);
  const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
  assert4(value === false || value === true);
  return value;
}
function hasFeatures2(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => getFeature(gl, feature));
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
function getPlatformShaderDefines(gl) {
  const debugInfo = getContextInfo(gl);
  switch (debugInfo.gpuVendor.toLowerCase()) {
    case "nvidia":
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
    case "intel":
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    case "amd":
      return "#define AMD_GPU\n";
    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
    behavior: "require"
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }
  return versionDefines;
}

// node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

// node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
var MODULE_INJECTORS = {
  [VERTEX_SHADER]: MODULE_INJECTORS_VS,
  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
};
var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];
function injectShader(source, type, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const isVertex = type === VERTEX_SHADER;
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = "".concat(fragments.join("\n"), "\n");
    switch (key) {
      case "vs:#decl":
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "vs:#main-start":
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "vs:#main-end":
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      case "fs:#decl":
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "fs:#main-start":
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "fs:#main-end":
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, (match) => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
  }
  return source;
}
function combineInjects(injects) {
  const result = {};
  assert4(Array.isArray(injects) && injects.length > 1);
  injects.forEach((inject) => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
var REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  } else {
    const outputName = "fragmentColor";
    source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}

// node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
var SHADER_TYPE = {
  [VERTEX_SHADER]: "vertex",
  [FRAGMENT_SHADER]: "fragment"
};
var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function assembleShaders(gl, opts) {
  const {
    vs: vs7,
    fs: fs4
  } = opts;
  const modules = resolveModules(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs7,
      type: VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs4,
      type: FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules,
    defines: defines2 = {},
    hookFunctions = [],
    inject = {},
    transpileToGLSL100 = false,
    prologue = true,
    log: log4
  } = _ref;
  assert4(typeof source === "string", "shader source must be a string");
  const isVertex = type === VERTEX_SHADER;
  const sourceLines = source.split("\n");
  let glslVersion = 100;
  let versionLine = "";
  let coreSource = source;
  if (sourceLines[0].indexOf("#version ") === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join("\n");
  } else {
    versionLine = "#version ".concat(glslVersion);
  }
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines2);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log4) {
      module.checkDeprecations(coreSource, log4);
    }
    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];
    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);
      if (match) {
        const name = match[2];
        const injectionType = name === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, type, mainInjections);
  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}
function assembleGetUniforms(modules) {
  return function getUniforms5(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}
function getShaderName2(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
}
function getApplicationDefines() {
  let defines2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let count2 = 0;
  let sourceText = "";
  for (const define2 in defines2) {
    if (count2 === 0) {
      sourceText += "\n// APPLICATION DEFINES\n";
    }
    count2++;
    const value = defines2[define2];
    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines2[define2], "\n");
    }
  }
  if (count2 === 0) {
    sourceText += "\n";
  }
  return sourceText;
}
function getHookFunctions(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");
    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);
      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }
    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }
    result += "}\n";
  }
  return result;
}
function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach((hook) => {
    let opts;
    if (typeof hook !== "string") {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(":");
    const name = hook.replace(/\(.+/, "");
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}

// node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
var FS100 = "void main() {gl_FragColor = vec4(0);}";
var FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
var FS300 = "#version 300 es\n".concat(FS_GLES);
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, "").split(/\s+/);
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(";")[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;
  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }
  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      assert4(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      assert4(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case "float":
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(variable, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(variable, ", 1.0)");
    case "vec4":
      return variable;
    default:
      assert4(false);
      return null;
  }
}

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
var fp32 = {
  name: "fp32",
  vs: fp32shader,
  fs: null
};

// node_modules/@math.gl/core/dist/esm/lib/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}

// node_modules/@math.gl/core/dist/esm/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var config = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true
};
function formatValue2(value, {
  precision = config.precision
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray5(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clamp(value, min, max) {
  return map(value, (value2) => Math.max(min, Math.min(max, value2)));
}
function lerp(a, b, t) {
  if (isArray5(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }
  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a === b) {
      return true;
    }
    if (isArray5(a) && isArray5(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a && a.equals) {
      return a.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a);
    }
    if (typeof a === "number" && typeof b === "number") {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray5(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i = 0; i < result.length && i < array.length; ++i) {
      result[i] = func(value[i], i, result);
    }
    return result;
  }
  return func(value);
}

// node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
var MathArray = class extends _extendableBuiltin(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }
    return targetArray;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray5(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  formatString(opts) {
    let string = "";
    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ", " : "") + formatValue2(this[i], opts);
    }
    return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!equals(this[i], array[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a, b, t) {
    if (t === void 0) {
      return this.lerp(this, a, b);
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }
    return this.check();
  }
  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale3) {
    if (typeof scale3 === "number") {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale3;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale3.length; ++i) {
        this[i] *= scale3[i];
      }
    }
    return this.check();
  }
  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  check() {
    if (config.debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }
    return this;
  }
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  sub(a) {
    return this.subtract(a);
  }
  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }
    return this.check();
  }
  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }
    return this.check();
  }
  subScalar(a) {
    return this.addScalar(-a);
  }
  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  divideScalar(a) {
    return this.multiplyByScalar(1 / a);
  }
  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }
    return this.check();
  }
  get elements() {
    return this;
  }
};

// node_modules/@math.gl/core/dist/esm/lib/validators.js
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }
  return value;
}
function checkVector(v, length, callerName = "") {
  if (config.debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }
  return v;
}

// node_modules/@math.gl/core/dist/esm/classes/base/vector.js
var Vector = class extends MathArray {
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return checkNumber(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return checkNumber(product);
  }
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i]);
  }
  setComponent(i, value) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    this[i] = value;
    return this.check();
  }
  addVectors(a, b) {
    return this.copy(a).add(b);
  }
  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }
  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }
  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }
};

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/vec2.js
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
var forEach = function() {
  var vec = create();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}

// node_modules/@math.gl/core/dist/esm/classes/vector2.js
var Vector2 = class extends Vector {
  constructor(x = 0, y = 0) {
    super(2);
    if (isArray5(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (config.debug) {
        checkNumber(x);
        checkNumber(y);
      }
      this[0] = x;
      this[1] = y;
    }
  }
  set(x, y) {
    this[0] = x;
    this[1] = y;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
    }
    this[0] = object.x;
    this[1] = object.y;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    return object;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    vec2_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2x3(matrix2x3) {
    transformMat2d(this, this, matrix2x3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    transformMat2(this, this, matrix2);
    return this.check();
  }
};

// node_modules/gl-matrix/esm/vec3.js
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
var sub = subtract;
var forEach2 = function() {
  var vec = create2();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/@math.gl/core/dist/esm/classes/vector3.js
var ORIGIN = [0, 0, 0];
var ZERO;
var Vector3 = class _Vector3 extends Vector {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new _Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray5(x)) {
      this.copy(x);
    } else {
      if (config.debug) {
        checkNumber(x);
        checkNumber(y);
        checkNumber(z);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }
  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  angle(vector) {
    return angle(this, vector);
  }
  cross(vector) {
    cross(this, this, vector);
    return this.check();
  }
  rotateX({
    radians: radians2,
    origin = ORIGIN
  }) {
    rotateX(this, this, origin, radians2);
    return this.check();
  }
  rotateY({
    radians: radians2,
    origin = ORIGIN
  }) {
    rotateY(this, this, origin, radians2);
    return this.check();
  }
  rotateZ({
    radians: radians2,
    origin = ORIGIN
  }) {
    rotateZ(this, this, origin, radians2);
    return this.check();
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    transformMat42(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat32(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
};

// node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
var Matrix = class extends MathArray {
  toString() {
    let string = "[";
    if (config.printRowMajor) {
      string += "row-major:";
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += "column-major:";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }
    string += "]";
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
};

// node_modules/gl-matrix/esm/mat4.js
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX2(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY2(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ2(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}

// node_modules/gl-matrix/esm/vec4.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
var forEach3 = function() {
  var vec = create3();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/@math.gl/core/dist/esm/classes/matrix4.js
var INDICES;
(function(INDICES2) {
  INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = 0.1;
var DEFAULT_FAR = 500;
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
var Matrix4 = class extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(quaternion) {
    fromQuat(this, quaternion);
    return this.check();
  }
  frustum(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  lookAt(view) {
    const {
      eye,
      center = [0, 0, 0],
      up = [0, 1, 0]
    } = view;
    lookAt(this, eye, center, up);
    return this.check();
  }
  ortho(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  orthographic(view) {
    const {
      fovy = DEFAULT_FOVY,
      aspect = DEFAULT_ASPECT,
      focalDistance = 1,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  perspective(view) {
    const {
      fovy = 45 * Math.PI / 180,
      aspect = 1,
      near = 0.1,
      far = 500
    } = view;
    checkRadians(fovy);
    perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  determinant() {
    return determinant(this);
  }
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale3 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale3[0];
    const inverseScale1 = 1 / scale3[1];
    const inverseScale2 = 1 / scale3[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale3 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale3[0];
    const inverseScale1 = 1 / scale3[1];
    const inverseScale2 = 1 / scale3[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  transpose() {
    transpose(this, this);
    return this.check();
  }
  invert() {
    invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    multiply(this, this, a);
    return this.check();
  }
  rotateX(radians2) {
    rotateX2(this, this, radians2);
    return this.check();
  }
  rotateY(radians2) {
    rotateY2(this, this, radians2);
    return this.check();
  }
  rotateZ(radians2) {
    rotateZ2(this, this, radians2);
    return this.check();
  }
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  rotateAxis(radians2, axis) {
    rotate(this, this, radians2, axis);
    return this.check();
  }
  scale(factor) {
    scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  translate(vector) {
    translate(this, this, vector);
    return this.check();
  }
  transform(vector, result) {
    if (vector.length === 4) {
      result = transformMat43(result || [-0, -0, -0, -0], vector, this);
      checkVector(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  transformAsPoint(vector, result) {
    const {
      length
    } = vector;
    let out;
    switch (length) {
      case 2:
        out = transformMat4(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat42(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  makeRotationX(radians2) {
    return this.identity().rotateX(radians2);
  }
  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }
};
var ZERO2;
var IDENTITY;
function getZeroMatrix() {
  if (!ZERO2) {
    ZERO2 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO2);
  }
  return ZERO2;
}
function getIdentityMatrix() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
var lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
var INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};
function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return color.map((component) => component * intensity / 255);
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
  } else {
    lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if ("lightSources" in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }
    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }
  if ("lights" in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case "ambient":
          lightSources.ambientLight = light;
          break;
        case "directional":
          lightSources.directionalLights.push(light);
          break;
        case "point":
          lightSources.pointLights.push(light);
          break;
        default:
      }
    }
    return getUniforms({
      lightSources
    });
  }
  return {};
}
var lights = {
  name: "lights",
  vs: lights_glsl_default,
  fs: lights_glsl_default,
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};

// node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
var DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};
function getUniforms2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};
  if (opts.pickingSelectedColor !== void 0) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, (x) => x / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms.picking_uHighlightColor = color;
  }
  if (opts.pickingActive !== void 0) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }
  return uniforms;
}
var vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
var picking = {
  name: "picking",
  vs,
  fs,
  getUniforms: getUniforms2
};

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
var phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
var INITIAL_MODULE_OPTIONS2 = {};
function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map((x) => x / 255)
  };
}
function getUniforms3() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
  if (!("material" in opts)) {
    return {};
  }
  const {
    material
  } = opts;
  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }
  return getMaterialUniforms(material);
}
var gouraudLighting = {
  name: "gouraud-lighting",
  dependencies: [lights],
  vs: phong_lighting_glsl_default,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: getUniforms3
};

// node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
var vs2 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
var transform = {
  name: "transform",
  vs: vs2,
  fs: null
};

// node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
var ProgramManager = class _ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new _ProgramManager(gl);
    return gl.luma.defaultProgramManager;
  }
  constructor(gl) {
    this.gl = gl;
    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._hookFunctions = [];
    this._defaultModules = [];
    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0;
    this._useCounts = {};
  }
  addDefaultModule(module) {
    if (!this._defaultModules.find((m) => m.name === module.name)) {
      this._defaultModules.push(module);
    }
    this.stateHash++;
  }
  removeDefaultModule(module) {
    const moduleName = typeof module === "string" ? module : module.name;
    this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
    this.stateHash++;
  }
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, {
        hook
      });
    }
    this._hookFunctions.push(hook);
    this.stateHash++;
  }
  get() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      vs: vs7 = "",
      fs: fs4 = "",
      defines: defines2 = {},
      inject = {},
      varyings = [],
      bufferMode = 35981,
      transpileToGLSL100 = false
    } = props;
    const modules = this._getModuleList(props.modules);
    const vsHash = this._getHash(vs7);
    const fsHash = this._getHash(fs4);
    const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
    const varyingHashes = varyings.map((v) => this._getHash(v));
    const defineKeys = Object.keys(defines2).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];
    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines2[key]));
    }
    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }
    const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
    if (!this._programCache[hash]) {
      const assembled = assembleShaders(this.gl, {
        vs: vs7,
        fs: fs4,
        modules,
        inject,
        defines: defines2,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100
      });
      this._programCache[hash] = new Program(this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });
      this._getUniforms[hash] = assembled.getUniforms || ((x) => {
      });
      this._useCounts[hash] = 0;
    }
    this._useCounts[hash]++;
    return this._programCache[hash];
  }
  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }
  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;
    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();
      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }
  _getHash(key) {
    if (this._hashes[key] === void 0) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
  _getModuleList() {
    let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count2 = 0;
    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = module.name;
      modules[count2++] = module;
      seen[name] = true;
    }
    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = module.name;
      if (!seen[name]) {
        modules[count2++] = module;
        seen[name] = true;
      }
    }
    modules.length = count2;
    return modules;
  }
};

// node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: "positions",
  NORMAL: "normals",
  COLOR_0: "colors",
  TEXCOORD_0: "texCoords",
  TEXCOORD_1: "texCoords1",
  TEXCOORD_2: "texCoords2"
};
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;
  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);
    if (name === "indices") {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = {
        ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }
  if (indices) {
    const data3 = indices.value || indices;
    assert3(data3 instanceof Uint16Array || data3 instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
    };
    buffers.indices = [new Buffer2(gl, {
      data: data3,
      target: 34963
    }), accessor];
  }
  return buffers;
}
function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      category = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      category = "vectors";
      break;
    default:
  }
  switch (category) {
    case "vectors":
      attribute.size = attribute.size || 3;
      break;
    case "uvs":
      attribute.size = attribute.size || 2;
      break;
    default:
  }
  assert3(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}

// node_modules/@luma.gl/engine/dist/esm/lib/model.js
var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 1e4;
var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
var NOOP = () => {
};
var DRAW_PARAMS = {};
var Model = class {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      id = uid3("model")
    } = props;
    assert3(isWebGL(gl));
    this.id = id;
    this.gl = gl;
    this.id = props.id || uid3("Model");
    this.lastLogTime = 0;
    this.animated = false;
    this.initialize(props);
  }
  initialize(props) {
    this.props = {};
    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;
    const {
      program = null,
      vs: vs7,
      fs: fs4,
      modules,
      defines: defines2,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs: vs7,
      fs: fs4,
      modules,
      defines: defines2,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;
    this.userData = {};
    this.needsRedraw = true;
    this._attributes = {};
    this.attributes = {};
    this.uniforms = {};
    this.pickable = true;
    this._checkProgram();
    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
    this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
    this.vertexCount = props.vertexCount || 0;
    this.geometryBuffers = {};
    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
    this._setModelProps(props);
    this.geometry = {};
    assert3(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }
  setProps(props) {
    this._setModelProps(props);
  }
  delete() {
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }
    if (this._managedProgram) {
      this.programManager.release(this.program);
      this._managedProgram = false;
    }
    this.vertexArray.delete();
    this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(props) {
    const {
      program,
      vs: vs7,
      fs: fs4,
      modules,
      defines: defines2,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs: vs7,
      fs: fs4,
      modules,
      defines: defines2,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this._programDirty = true;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }
  setVertexCount(vertexCount) {
    assert3(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }
  setInstanceCount(instanceCount) {
    assert3(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }
  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();
    this._deleteGeometryBuffers();
    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }
  setAttributes() {
    let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (isObjectEmpty2(attributes)) {
      return this;
    }
    const normalizedAttributes = {};
    for (const name in attributes) {
      const attribute = attributes[name];
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }
    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this.uniforms, uniforms);
    return this;
  }
  getModuleUniforms(opts) {
    this._checkProgram();
    const getUniforms5 = this.programManager.getUniforms(this.program);
    if (getUniforms5) {
      return getUniforms5(opts);
    }
    return {};
  }
  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }
  clear(opts) {
    clear3(this.program.gl, opts);
    return this;
  }
  draw() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray
    } = opts;
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);
    let logPriority;
    if (log.priority >= LOG_DRAW_PRIORITY) {
      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
    }
    const drawParams = this.vertexArray.getDrawParams();
    const {
      isIndexed = drawParams.isIndexed,
      indexType = drawParams.indexType,
      indexOffset = drawParams.indexOffset,
      vertexArrayInstanced = drawParams.isInstanced
    } = this.props;
    if (vertexArrayInstanced && !this.isInstanced) {
      log.warn("Found instanced attributes on non-instanced model", this.id)();
    }
    const {
      isInstanced,
      instanceCount
    } = this;
    const {
      onBeforeRender = NOOP,
      onAfterRender = NOOP
    } = this.props;
    onBeforeRender();
    this.program.setUniforms(this.uniforms);
    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
      logPriority,
      uniforms: null,
      framebuffer,
      parameters,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray,
      transformFeedback,
      isIndexed,
      indexType,
      isInstanced,
      instanceCount,
      offset: isIndexed ? indexOffset : 0
    }));
    onAfterRender();
    if (log.priority >= LOG_DRAW_PRIORITY) {
      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
    }
    return didDraw;
  }
  transform() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      discard = true,
      feedbackBuffers,
      unbindModels = []
    } = opts;
    let {
      parameters
    } = opts;
    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }
    if (discard) {
      parameters = Object.assign({}, parameters, {
        [35977]: discard
      });
    }
    unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, opts, {
        parameters
      }));
    } finally {
      unbindModels.forEach((model) => model.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    log.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
    return this.setUniforms(uniforms).draw();
  }
  _setModelProps(props) {
    Object.assign(this.props, props);
    if ("uniforms" in props) {
      this.setUniforms(props.uniforms);
    }
    if ("pickable" in props) {
      this.pickable = props.pickable;
    }
    if ("instanceCount" in props) {
      this.instanceCount = props.instanceCount;
    }
    if ("geometry" in props) {
      this.setGeometry(props.geometry);
    }
    if ("attributes" in props) {
      this.setAttributes(props.attributes);
    }
    if ("_feedbackBuffers" in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }
  _checkProgram() {
    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
    if (!needsUpdate) {
      return;
    }
    let {
      program
    } = this.programProps;
    if (program) {
      this._managedProgram = false;
    } else {
      const {
        vs: vs7,
        fs: fs4,
        modules,
        inject,
        defines: defines2,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = this.programProps;
      program = this.programManager.get({
        vs: vs7,
        fs: fs4,
        modules,
        inject,
        defines: defines2,
        varyings,
        bufferMode,
        transpileToGLSL100
      });
      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }
      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }
    assert3(program instanceof Program, "Model needs a program");
    this._programDirty = false;
    if (program === this.program) {
      return;
    }
    this.program = program;
    if (this.vertexArray) {
      this.vertexArray.setProps({
        program: this.program,
        attributes: this.vertexArray.attributes
      });
    } else {
      this.vertexArray = new VertexArray(this.gl, {
        program: this.program
      });
    }
    this.setUniforms(Object.assign({}, this.getModuleUniforms()));
  }
  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
      if (buffer instanceof Buffer2) {
        buffer.delete();
      }
    }
  }
  _setAnimationProps(animationProps) {
    if (this.animated) {
      assert3(animationProps, "Model.draw(): animated uniforms but no animationProps");
    }
  }
  _setFeedbackBuffers() {
    let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (isObjectEmpty2(feedbackBuffers)) {
      return this;
    }
    const {
      gl
    } = this.program;
    this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
      program: this.program
    });
    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }
  _logDrawCallStart(logLevel) {
    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (Date.now() - this.lastLogTime < logDrawTimeout) {
      return void 0;
    }
    this.lastLogTime = Date.now();
    log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
      collapsed: log.level <= 2
    })();
    return logLevel;
  }
  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
    if (logLevel === void 0) {
      return;
    }
    const attributeTable = getDebugTableForVertexArray({
      vertexArray,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    });
    const {
      table: uniformTable,
      unusedTable,
      unusedCount
    } = getDebugTableForUniforms({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });
    const {
      table: missingTable,
      count: missingCount
    } = getDebugTableForUniforms({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });
    if (missingCount > 0) {
      log.log("MISSING UNIFORMS", Object.keys(missingTable))();
    }
    if (unusedCount > 0) {
      log.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
    }
    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
    log.table(logLevel, attributeTable)();
    log.table(logLevel, uniformTable)();
    log.table(logLevel + 1, configTable)();
    if (framebuffer) {
      framebuffer.log({
        logLevel: LOG_DRAW_PRIORITY,
        message: "Rendered to ".concat(framebuffer.id)
      });
    }
    log.groupEnd(LOG_DRAW_PRIORITY)();
  }
};

// node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
var BufferTransform = class {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyings
    } = this;
    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }
    return props;
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }
  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(opts);
  }
  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
    if (!bufferOrParams) {
      return null;
    }
    return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
  }
  getData() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);
    if (buffer) {
      return buffer.getData();
    }
    return null;
  }
  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(props);
    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
    if (this.varyings.length > 0) {
      assert3(isWebGL2(this.gl));
    }
  }
  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};
    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }
    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];
        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }
    Object.assign(feedbackBuffers, props.feedbackBuffers);
    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];
      if (typeof bufferOrRef === "string") {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }
    return feedbackBuffers;
  }
  _setupBuffers() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);
    const feedbackBuffers = this._getFeedbackBuffers(props);
    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }
  _setupTransformFeedback(binding, _ref) {
    let {
      model
    } = _ref;
    const {
      program
    } = model;
    binding.transformFeedback = new TransformFeedback(this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }
  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }
    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }
    return binding;
  }
  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }
    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      assert3(feedbackBuffers[dstName] instanceof Buffer2);
    }
    return {
      sourceBuffers,
      feedbackBuffers
    };
  }
  _createNewBuffer(name, opts) {
    const buffer = new Buffer2(this.gl, opts);
    if (this.resources[name]) {
      this.resources[name].delete();
    }
    this.resources[name] = buffer;
    return buffer;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
};

// node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
var SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
var SIZE_UNIFORM_PREFIX = "transform_uSize_";
var VS_POS_VARIABLE = "transform_position";
function updateForTextures(_ref) {
  let {
    vs: vs7,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs7;
  let finalInject = {};
  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split("\n");
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = combineInjects([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });
    if (targetTextureVarying) {
      assert3(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        "vs:#decl": uniformDeclaration,
        "vs:#main-start": posInstructions
      };
      finalInject = combineInjects([finalInject, inject]);
    }
    updatedVs = updateVsLines.join("\n");
  }
  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }
  return uniforms;
}
function getAttributeDefinition(line) {
  return getQualifierDetails(line, ["attribute", "in"]);
}
function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}
function getVaryingType(line, varying) {
  const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {
    type,
    name
  } = attributeData;
  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = typeToChannelSuffix(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      "vs:#decl": uniformDeclerations,
      "vs:#main-start": sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }
  return null;
}

// node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
var SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
var FS_OUTPUT_VARIABLE = "transform_output";
var TextureTransform = class {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const updatedModelProps = this._processVertexShader(props);
    return Object.assign({}, props, updatedModelProps);
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;
      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }
      this._setSourceTextureParameters();
      const sizeUniforms = getSizeUniforms({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }
    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }
    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }
  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupTextures(opts);
  }
  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }
  getData() {
    let {
      packed = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = readPixelsToArray(framebuffer);
    if (!packed) {
      return pixels;
    }
    const ArrayType = pixels.constructor;
    const channelCount = typeToChannelCount(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }
    return packedPixels;
  }
  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }
  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;
    this._setupTextures(props);
  }
  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;
    if (textureOrReference instanceof Texture2D) {
      return textureOrReference;
    }
    const refTexture = sourceTextures[textureOrReference];
    if (!refTexture) {
      return null;
    }
    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }
  _setupTextures() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;
    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });
    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });
    if ("elementCount" in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }
  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
      return;
    }
    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });
    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new Buffer2(this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }
    this.elementCount = elementCount;
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }
  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;
    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }
    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);
    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;
      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new Framebuffer(this.gl, {
          id: "transform-framebuffer",
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }
    return binding;
  }
  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];
    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }
  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }
    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }
  _createNewTexture(refTexture) {
    const texture = cloneTextureFrom(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    this.ownTexture = texture;
    return texture;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs: vs7,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = updateForTextures({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = combineInjects([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs4 = props._fs || getPassthroughFS({
      version: getShaderVersion(vs7),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
    return {
      vs: vs7,
      fs: fs4,
      modules,
      uniforms,
      inject: combinedInject
    };
  }
};

// node_modules/@luma.gl/engine/dist/esm/transform/transform.js
var Transform = class {
  static isSupported(gl) {
    return isWebGL2(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;
    this._initialize(props);
    Object.seal(this);
  }
  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;
    if (model) {
      model.delete();
    }
    if (bufferTransform) {
      bufferTransform.delete();
    }
    if (textureTransform) {
      textureTransform.delete();
    }
  }
  run() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      clearRenderTarget = true
    } = opts;
    const updatedOpts = this._updateDrawOptions(opts);
    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }
    this.model.transform(updatedOpts);
  }
  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }
    assert3(swapped, "Nothing to swap");
  }
  getBuffer() {
    let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }
  getData() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      const data3 = resourceTransform.getData(opts);
      if (data3) {
        return data3;
      }
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if ("elementCount" in opts) {
      this.model.setVertexCount(opts.elementCount);
    }
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      gl
    } = this;
    this._buildResourceTransforms(gl, props);
    props = this._updateModelProps(props);
    this.model = new Model(gl, Object.assign({}, props, {
      fs: props.fs || getPassthroughFS({
        version: getShaderVersion(props.vs)
      }),
      id: props.id || "transform-model",
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }
    return updatedProps;
  }
  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new BufferTransform(gl, props);
    }
    if (canCreateTextureTransform(props)) {
      this.textureTransform = new TextureTransform(gl, props);
    }
    assert3(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
  }
  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }
    return updatedOpts;
  }
};
function canCreateBufferTransform(props) {
  if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }
  return false;
}
function canCreateTextureTransform(props) {
  if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }
  return false;
}

// node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
var DRAW_MODE = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
var Geometry = class {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id = uid3("geometry"),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};
    this._setAttributes(attributes, indices);
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(attributeName) {
    return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
  }
  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }
    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];
      attribute = ArrayBuffer.isView(attribute) ? {
        value: attribute
      } : attribute;
      assert3(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
      if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === "indices") {
        assert3(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== void 0) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        value,
        size: size3,
        constant
      } = attribute;
      if (!constant && value && size3 >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size3);
      }
    }
    assert3(Number.isFinite(vertexCount));
    return vertexCount;
  }
};

// node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
var channelHandles = 1;
var animationHandles = 1;
var Timeline = class {
  constructor() {
    this.time = 0;
    this.channels = /* @__PURE__ */ new Map();
    this.animations = /* @__PURE__ */ new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }
  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(handle, channel);
    return handle;
  }
  removeChannel(handle) {
    this.channels.delete(handle);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(handle) {
    const channel = this.channels.get(handle);
    if (channel === void 0) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(handle) {
    if (handle === void 0) {
      return this.time;
    }
    const channel = this.channels.get(handle);
    if (channel === void 0) {
      return -1;
    }
    return channel.time;
  }
  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();
    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(handle) {
    this.animations.delete(handle);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
};

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_2 = globals2.window || globals2.self || globals2.global || {};
var global_2 = globals2.global || globals2.self || globals2.window || {};
var document_2 = globals2.document || {};
var isBrowser4 = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
var VERSION3 = true ? "3.4.14" : DEFAULT_VERSION;
if (false) {
  console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
function assert7(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
var globals3 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_3 = globals3.self || globals3.window || globals3.global || {};
var window_3 = globals3.window || globals3.self || globals3.global || {};
var global_3 = globals3.global || globals3.self || globals3.window || {};
var document_3 = globals3.document || {};
var isBrowser5 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
var isMobile2 = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
var WorkerJob = class {
  constructor(jobName, workerThread) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "workerThread", void 0);
    _defineProperty(this, "isRunning", true);
    _defineProperty(this, "result", void 0);
    _defineProperty(this, "_resolve", () => {
    });
    _defineProperty(this, "_reject", () => {
    });
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type,
      payload
    });
  }
  done(value) {
    assert7(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error3) {
    assert7(this.isRunning);
    this.isRunning = false;
    this._reject(error3);
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
var Worker2 = class {
  terminate() {
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert7(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert7(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: "application/javascript"
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : void 0;
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
var NOOP2 = () => {
};
var WorkerThread = class {
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser5 || typeof Worker2 !== "undefined" && !isBrowser5;
  }
  constructor(props) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "source", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "terminated", false);
    _defineProperty(this, "worker", void 0);
    _defineProperty(this, "onMessage", void 0);
    _defineProperty(this, "onError", void 0);
    _defineProperty(this, "_loadableURL", "");
    const {
      name,
      source,
      url
    } = props;
    assert7(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP2;
    this.onError = (error3) => console.log(error3);
    this.worker = isBrowser5 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP2;
    this.onError = NOOP2;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data3, transferList) {
    transferList = transferList || getTransferList(data3);
    this.worker.postMessage(data3, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
    if (event.message) {
      message += "".concat(event.message, " in ");
    }
    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error3) => {
      this.onError(this._getErrorFromErrorEvent(error3));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : "./".concat(this.url);
      worker = new Worker2(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new Worker2(this.source, {
        eval: true
      });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data3) => {
      this.onMessage(data3);
    });
    worker.on("error", (error3) => {
      this.onError(error3);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
var WorkerPool = class {
  static isSupported() {
    return WorkerThread.isSupported();
  }
  constructor(props) {
    _defineProperty(this, "name", "unnamed");
    _defineProperty(this, "source", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "maxConcurrency", 1);
    _defineProperty(this, "maxMobileConcurrency", 1);
    _defineProperty(this, "onDebug", () => {
    });
    _defineProperty(this, "reuseWorkers", true);
    _defineProperty(this, "props", {});
    _defineProperty(this, "jobQueue", []);
    _defineProperty(this, "idleQueue", []);
    _defineProperty(this, "count", 0);
    _defineProperty(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data3) => job.done(data3);
    let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error3) => job.error(error3);
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({
        name,
        onMessage: onMessage2,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data3) => queuedJob.onMessage(job, data3.type, data3.payload);
      workerThread.onError = (error3) => queuedJob.onError(job, error3);
      queuedJob.onStart(job);
      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new WorkerThread({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile2 ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var WorkerFarm = class _WorkerFarm {
  static isSupported() {
    return WorkerThread.isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
    _WorkerFarm._workerFarm.setProps(props);
    return _WorkerFarm._workerFarm;
  }
  constructor(props) {
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = {
      ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
_defineProperty(WorkerFarm, "_workerFarm", void 0);

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
var NPM_TAG = "latest";
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }
  if (!url) {
    let version = worker.version;
    if (version === "latest") {
      version = NPM_TAG;
    }
    const versionTag = version ? "@".concat(version) : "";
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }
  assert7(url);
  return url;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION3;
  assert7(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser5 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data3, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
  job.postMessage("process", {
    input: data3,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", {
          id,
          result
        });
      } catch (error3) {
        const message = error3 instanceof Error ? error3.message : "unknown error";
        job.postMessage("error", {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array12 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array12.length; ++i) {
    if (array12[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
var pathPrefix2 = "";
var fileAliases = {};
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = "".concat(pathPrefix2).concat(filename2);
  }
  return filename2;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js
function toArrayBuffer(buffer) {
  return buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data3) {
  if (isBuffer(data3)) {
    return toArrayBuffer(data3);
  }
  if (data3 instanceof ArrayBuffer) {
    return data3;
  }
  if (ArrayBuffer.isView(data3)) {
    if (data3.byteOffset === 0 && data3.byteLength === data3.buffer.byteLength) {
      return data3.buffer;
    }
    return data3.buffer.slice(data3.byteOffset, data3.byteOffset + data3.byteLength);
  }
  if (typeof data3 === "string") {
    const text = data3;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data3 && typeof data3 === "object" && data3._toArrayBuffer) {
    return data3._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join,
  resolve: () => resolve
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js
function getCWD() {
  var _window$location;
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
  return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve() {
  const paths = [];
  for (let _i = 0; _i < arguments.length; _i++) {
    paths[_i] = _i < 0 || arguments.length <= _i ? void 0 : arguments[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === void 0) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = "".concat(path, "/").concat(resolvedPath);
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return "/".concat(resolvedPath);
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res2 = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res2.length < 2 || !isAboveRoot || res2.charCodeAt(res2.length - 1) !== DOT || res2.charCodeAt(res2.length - 2) !== DOT) {
          if (res2.length > 2) {
            const start3 = res2.length - 1;
            let j = start3;
            for (; j >= 0; --j) {
              if (res2.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start3) {
              res2 = j === -1 ? "" : res2.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res2.length === 2 || res2.length === 1) {
            res2 = "";
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res2.length > 0) {
            res2 += "/..";
          } else {
            res2 = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res2.length > 0) {
          res2 += "/".concat(slice);
        } else {
          res2 = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res2;
}

// node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
var isObject3 = (x) => x !== null && typeof x === "object";
var isPureObject = (x) => isObject3(x) && x.constructor === {}.constructor;
var isIterable = (x) => x && typeof x[Symbol.iterator] === "function";
var isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
var isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
var isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
var isBuffer2 = (x) => x && typeof x === "object" && x.isBuffer;
var isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject3(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
var isReadableNodeStream = (x) => isObject3(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
var isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);

// node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches3 = url.match(QUERY_STRING_PATTERN);
  return matches3 && matches3[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, "url", {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
  try {
    const contentType = response.headers.get("Content-Type");
    let text = response.statusText;
    if (contentType.includes("application/json")) {
      text += " ".concat(await response.text());
    }
    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error3) {
  }
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve2) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        var _event$target;
        return resolve2(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
async function fetchFile(url, options) {
  if (typeof url === "string") {
    url = resolvePath(url);
    let fetchOptions = options;
    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") {
      fetchOptions = options.fetch;
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(url);
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron2(mockUserAgent) {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
  const userAgent2 = mockUserAgent || realUserAgent;
  if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js
function isBrowser6() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
  return !isNode || isElectron2();
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js
var self_4 = globalThis.self || globalThis.window || globalThis.global;
var window_4 = globalThis.window || globalThis.self || globalThis.global;
var document_4 = globalThis.document || {};
var process_2 = globalThis.process || {};
var console_2 = globalThis.console;
var navigator_ = globalThis.navigator || {};

// node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js
var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
var isBrowser7 = isBrowser6();

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage2(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
var LocalStorage2 = class {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    this.storage = void 0;
    this.id = void 0;
    this.config = void 0;
    this.storage = getStorage2(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js
function formatTime2(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1e3) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1e3).toFixed(2), "s");
  }
  return formatted;
}
function leftPad2(string) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(" ".repeat(padLength)).concat(string);
}
function formatImage2(image, message, scale3) {
  let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  if (image.width > maxWidth) {
    scale3 = Math.min(scale3, maxWidth / image.width);
  }
  const width = image.width * scale3;
  const height = image.height * scale3;
  const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
  return ["".concat(message, " %c+"), style];
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js
var COLOR2;
(function(COLOR3) {
  COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
  COLOR3[COLOR3["RED"] = 31] = "RED";
  COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
  COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
  COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
  COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
  COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
  COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
  COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR2 || (COLOR2 = {}));
var BACKGROUND_INCREMENT = 10;
function getColor2(color) {
  if (typeof color !== "string") {
    return color;
  }
  color = color.toUpperCase();
  return COLOR2[color] || COLOR2.WHITE;
}
function addColor2(string, color, background) {
  if (!isBrowser6 && typeof string === "string") {
    if (color) {
      const colorCode = getColor2(color);
      string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      const colorCode = getColor2(background);
      string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js
function autobind2(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === "function") {
      if (!predefined.find((name) => key === name)) {
        object[key] = value.bind(obj);
      }
    }
  }
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js
function assert8(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
function getHiResTimestamp3() {
  let timestamp;
  if (isBrowser6() && window_4.performance) {
    var _window$performance, _window$performance$n;
    timestamp = window_4 === null || window_4 === void 0 ? void 0 : (_window$performance = window_4.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ("hrtime" in process_2) {
    var _process$hrtime;
    const timeParts = process_2 === null || process_2 === void 0 ? void 0 : (_process$hrtime = process_2.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_2);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js
var originalConsole2 = {
  debug: isBrowser6() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop2() {
}
var cache2 = {};
var ONCE2 = {
  once: true
};
var Log2 = class {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    this.id = void 0;
    this.VERSION = VERSION4;
    this._startTs = getHiResTimestamp3();
    this._deltaTs = getHiResTimestamp3();
    this._storage = void 0;
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage2("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
    this.timeStamp("".concat(this.id, " started"));
    autobind2(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((getHiResTimestamp3() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((getHiResTimestamp3() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    assert8(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole2.warn, arguments, ONCE2);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole2.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole2.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole2.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole2.debug || originalConsole2.info, arguments, ONCE2);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop2, columns && [columns], {
        tag: getTableHeader2(table)
      });
    }
    return noop2;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = "",
      scale: scale3 = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop2;
    }
    return isBrowser6() ? logImageInBrowser2({
      image,
      message,
      scale: scale3
    }) : logImageInNode2({
      image,
      message,
      scale: scale3
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop2);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments2({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop2);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel2(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments2({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      assert8(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp3();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache2[tag]) {
          cache2[tag] = getHiResTimestamp3();
        } else {
          return noop2;
        }
      }
      message = decorateMessage2(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop2;
  }
};
Log2.VERSION = VERSION4;
function normalizeLogLevel2(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert8(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments2(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel2(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert8(messageType === "string" || messageType === "object");
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage2(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad2(formatTime2(opts.total)) : "";
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = addColor2(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode2(_ref2) {
  let {
    image,
    message = "",
    scale: scale3 = 1
  } = _ref2;
  console.warn("removed");
  return noop2;
}
function logImageInBrowser2(_ref3) {
  let {
    image,
    message = "",
    scale: scale3 = 1
  } = _ref3;
  if (typeof image === "string") {
    const img = new Image();
    img.onload = () => {
      const args = formatImage2(img, message, scale3);
      console.log(...args);
    };
    img.src = image;
    return noop2;
  }
  const element = image.nodeName || "";
  if (element.toLowerCase() === "img") {
    console.log(...formatImage2(image, message, scale3));
    return noop2;
  }
  if (element.toLowerCase() === "canvas") {
    const img = new Image();
    img.onload = () => console.log(...formatImage2(img, message, scale3));
    img.src = image.toDataURL();
    return noop2;
  }
  return noop2;
}
function getTableHeader2(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log2({
  id: "@probe.gl/log"
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
var probeLog = new Log2({
  id: "loaders.gl"
});
var NullLog = class {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
};
var ConsoleLog = class {
  constructor() {
    _defineProperty(this, "console", void 0);
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
};

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: isBrowser4,
  _nodeWorkers: false,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
var getGlobalLoaderOptions = () => {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ...DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
};
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix3 = id ? "".concat(id, ".") : "";
  for (const key in options) {
    const isSubOptions = !id && isObject3(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix3).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix3).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  assert6(loader, "null loader");
  assert6(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
var log3 = new Log2({
  id: "loaders.gl"
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data3) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data3)) {
    return null;
  }
  let loader = selectLoaderSync(data3, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data3)) {
    data3 = await data3.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data3, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data3));
  }
  return loader;
}
function selectLoaderSync(data3) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data3)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data3, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data3));
  }
  return loader;
}
function selectLoaderInternal(data3, loaders, options, context) {
  const url = getResourceUrl(data3);
  const type = getResourceMIMEType(data3);
  const testUrl = stripQueryString(url) || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = "";
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : "");
  loader = loader || findLoaderByInitialBytes(loaders, data3);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data3)) : "");
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
  if (reason) {
    var _loader;
    log3.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }
  return loader;
}
function validHTTPResponse(data3) {
  if (data3 instanceof Response) {
    if (data3.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data3) {
  const url = getResourceUrl(data3);
  const type = getResourceMIMEType(data3);
  let message = "No valid loader found (";
  message += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
  message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
  const firstCharacters = data3 ? getFirstCharacters(data3) : "";
  message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data3) {
  if (!data3) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data3 === "string") {
      if (testDataAgainstText(data3, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data3)) {
      if (testDataAgainstBinary(data3.buffer, data3.byteOffset, loader)) {
        return loader;
      }
    } else if (data3 instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data3, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data3, loader) {
  if (loader.testText) {
    return loader.testText(data3);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data3.startsWith(test));
}
function testDataAgainstBinary(data3, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data3, byteOffset, loader, test));
}
function testBinary(data3, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data3, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data3, loader);
    case "string":
      const magic3 = getMagicString(data3, byteOffset, test.length);
      return test === magic3;
    default:
      return false;
  }
}
function getFirstCharacters(data3) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data3 === "string") {
    return data3.slice(0, length);
  } else if (ArrayBuffer.isView(data3)) {
    return getMagicString(data3.buffer, data3.byteOffset, length);
  } else if (data3 instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data3, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer2, byteOffset, length) {
  if (arrayBuffer2.byteLength < byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer2);
  let magic3 = "";
  for (let i = 0; i < length; i++) {
    magic3 += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic3;
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function makeArrayBufferIterator(arrayBuffer2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE2
    } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer2.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }();
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser4 ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer2(value);
    }
  } catch (error3) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer2(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
function makeIterator(data3, options) {
  if (typeof data3 === "string") {
    return makeStringIterator(data3, options);
  }
  if (data3 instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data3, options);
  }
  if (isBlob(data3)) {
    return makeBlobIterator(data3, options);
  }
  if (isReadableStream(data3)) {
    return makeStreamIterator(data3, options);
  }
  if (isResponse(data3)) {
    const response = data3;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data3, loader, options) {
  if (loader.text && typeof data3 === "string") {
    return data3;
  }
  if (isBuffer2(data3)) {
    data3 = data3.buffer;
  }
  if (data3 instanceof ArrayBuffer) {
    const arrayBuffer2 = data3;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer2);
    }
    return arrayBuffer2;
  }
  if (ArrayBuffer.isView(data3)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data3);
    }
    let arrayBuffer2 = data3.buffer;
    const byteLength = data3.byteLength || data3.length;
    if (data3.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
      arrayBuffer2 = arrayBuffer2.slice(data3.byteOffset, data3.byteOffset + byteLength);
    }
    return arrayBuffer2;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data3, loader, options) {
  const isArrayBuffer = data3 instanceof ArrayBuffer || ArrayBuffer.isView(data3);
  if (typeof data3 === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data3, loader, options);
  }
  if (isBlob(data3)) {
    data3 = await makeResponse(data3);
  }
  if (isResponse(data3)) {
    const response = data3;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data3)) {
    data3 = makeIterator(data3, options);
  }
  if (isIterable(data3) || isAsyncIterable(data3)) {
    return concatenateArrayBuffersAsync(data3);
  }
  throw new Error(ERR_DATA);
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const fetchOptions = options || globalOptions;
  if (typeof fetchOptions.fetch === "function") {
    return fetchOptions.fetch;
  }
  if (isObject3(fetchOptions.fetch)) {
    return (url) => fetchFile(url, fetchOptions);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return fetchFile;
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = path_exports.filename(baseUrl);
    newContext.baseUrl = path_exports.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
async function parse(data3, loaders, options, context) {
  assert7(!context || typeof context === "object");
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data3 = await data3;
  options = options || {};
  const url = getResourceUrl(data3);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data3, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context || null);
  return await parseWithLoader(loader, data3, options, context);
}
async function parseWithLoader(loader, data3, options, context) {
  validateWorkerVersion(loader);
  if (isResponse(data3)) {
    const response = data3;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data3 = await getArrayBufferOrStringFromData(data3, loader, options);
  if (loader.parseTextSync && typeof data3 === "string") {
    options.dataType = "text";
    return loader.parseTextSync(data3, options, context, loader);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data3, options, context, parse);
  }
  if (loader.parseText && typeof data3 === "string") {
    return await loader.parseText(data3, options, context, loader);
  }
  if (loader.parse) {
    return await loader.parse(data3, options, context, loader);
  }
  assert7(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  const fetch2 = getFetchFunction(options);
  let data3 = url;
  if (typeof url === "string") {
    data3 = await fetch2(url);
  }
  if (isBlob(url)) {
    data3 = await fetch2(url);
  }
  return await parse(data3, loaders, options);
}

// node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
var VERSION5 = true ? "3.4.14" : "latest";

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
var {
  _parseImageNode
} = globalThis;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
var DATA_SUPPORTED = isBrowser4 ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer2, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer2);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error3) {
      throw new Error(error3.message);
    }
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer2, url);
}
function getBlob(arrayBuffer2, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer2)]);
}

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer2, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve2, reject) => {
    try {
      image.onload = () => resolve2(image);
      image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error3) {
      reject(error3);
    }
  });
}

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer2, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer2, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer2, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob) {
  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error3) {
      console.warn(error3);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, "ftyp", 4)) {
    return null;
  }
  if ((buffer[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function getUTF8String(array, start3, end) {
  return String.fromCharCode(...array.slice(start3, end));
}
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header) {
  let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data3) {
  if (data3 instanceof DataView) {
    return data3;
  }
  if (ArrayBuffer.isView(data3)) {
    return new DataView(data3.buffer);
  }
  if (data3 instanceof ArrayBuffer) {
    return new DataView(data3);
  }
  throw new Error("toDataView");
}

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer2, options) {
  const {
    mimeType
  } = getBinaryImageMetadata(arrayBuffer2) || {};
  const _parseImageNode2 = globalThis._parseImageNode;
  assert6(_parseImageNode2);
  return await _parseImageNode2(arrayBuffer2, mimeType);
}

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
async function parseImage(arrayBuffer2, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer2, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer2, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer2, options);
      break;
    default:
      assert6(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}

// node_modules/@loaders.gl/images/dist/esm/image-loader.js
var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
var DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
  }
};
var ImageLoader = {
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION5,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};

// node_modules/@deck.gl/core/dist/esm/utils/log.js
var log_default = new Log({
  id: "deck"
});

// node_modules/@deck.gl/core/dist/esm/debug/loggers.js
var logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
var LOG_LEVEL_MAJOR_UPDATE = 1;
var LOG_LEVEL_MINOR_UPDATE = 2;
var LOG_LEVEL_UPDATE_DETAIL = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DRAW = 2;
var getLoggers = (log4) => ({
  "layer.changeFlag": (layer, key, flags) => {
    log4.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
  },
  "layer.initialize": (layer) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
  },
  "layer.update": (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter((key) => flags[key]).join(", ")))();
    } else {
      log4.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
    }
  },
  "layer.matched": (layer, changed) => {
    if (changed) {
      log4.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
    }
  },
  "layer.finalize": (layer) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
  },
  "compositeLayer.renderLayers": (layer, updated, subLayers) => {
    if (updated) {
      log4.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
    } else {
      log4.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
    }
  },
  "layerManager.setLayers": (layerManager, updated, layers) => {
    if (updated) {
      log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
    }
  },
  "layerManager.activateViewport": (layerManager, viewport) => {
    log4.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
  },
  "attributeManager.invalidate": (attributeManager, trigger3, attributeNames) => {
    log4.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger3, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
  },
  "attributeManager.updateStart": (attributeManager) => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log4.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
    for (const updateMessage of logState.attributeUpdateMessages) {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }
    log4.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  "attribute.updateStart": (attribute) => {
    logState.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (attribute, numInstances) => {
    const message = "".concat(attribute.id, " allocated ").concat(numInstances);
    logState.attributeUpdateMessages.push(message);
  },
  "attribute.updateEnd": (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
    logState.attributeUpdateMessages.push(message);
  },
  "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
    const {
      pass,
      redrawReason,
      stats
    } = opts;
    for (const status of renderStats) {
      const {
        totalCount,
        visibleCount,
        compositeCount,
        pickableCount
      } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log4.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
      if (stats) {
        stats.get("Redraw Layers").add(visibleCount);
      }
    }
  }
});

// node_modules/@deck.gl/core/dist/esm/debug/index.js
var loggers = {};
if (true) {
  loggers = getLoggers(log_default);
}
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (log_default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}

// node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default = {
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: isJSON,
  parseTextSync: JSON.parse
};

// node_modules/@deck.gl/core/dist/esm/lib/init.js
function checkVersion() {
  const version = true ? "8.9.30" : globalThis.DECK_VERSION || "untranspiled source";
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }
  if (!existingVersion) {
    log_default.log(1, "deck.gl ".concat(version))();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version,
      version,
      log: log_default,
      _registerLoggers: register
    };
    registerLoaders([json_loader_default, [ImageLoader, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]]);
  }
  return version;
}
var VERSION6 = checkVersion();

// node_modules/@deck.gl/core/dist/esm/lib/constants.js
var COORDINATE_SYSTEM = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
  get: () => {
    log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
    return 0;
  }
});
var PROJECTION_MODE = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
};
var UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
var EVENTS = {
  click: {
    handler: "onClick"
  },
  panstart: {
    handler: "onDragStart"
  },
  panmove: {
    handler: "onDrag"
  },
  panend: {
    handler: "onDragEnd"
  }
};

// node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY = 1;
var idCount = 0;
var AmbientLight = class {
  constructor(props = {}) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "color", void 0);
    _defineProperty(this, "intensity", void 0);
    _defineProperty(this, "type", "ambient");
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
  }
};

// node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY2 = 1;
var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
var idCount2 = 0;
var DirectionalLight = class {
  constructor(props = {}) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "color", void 0);
    _defineProperty(this, "intensity", void 0);
    _defineProperty(this, "type", "directional");
    _defineProperty(this, "direction", void 0);
    _defineProperty(this, "shadow", void 0);
    const {
      color = DEFAULT_LIGHT_COLOR2
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY2
    } = props;
    const {
      direction = DEFAULT_LIGHT_DIRECTION
    } = props;
    const {
      _shadow = false
    } = props;
    this.id = props.id || "directional-".concat(idCount2++);
    this.color = color;
    this.intensity = intensity;
    this.type = "directional";
    this.direction = new Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
};

// node_modules/@deck.gl/core/dist/esm/passes/pass.js
var Pass = class {
  constructor(gl, props = {
    id: "pass"
  }) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "props", void 0);
    const {
      id
    } = props;
    this.id = id;
    this.gl = gl;
    this.props = {
      ...props
    };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {
  }
  cleanup() {
  }
};

// node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
var LayersPass = class extends Pass {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "_lastRenderIndex", -1);
  }
  render(options) {
    const gl = this.gl;
    setParameters(gl, {
      framebuffer: options.target
    });
    return this._drawLayers(options);
  }
  _drawLayers(options) {
    const {
      target,
      moduleParameters,
      viewports,
      views,
      onViewportActive,
      clearStack = true,
      clearCanvas = true
    } = options;
    options.pass = options.pass || "unknown";
    const gl = this.gl;
    if (clearCanvas) {
      clearGLCanvas(gl, target);
    }
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(gl, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  _getDrawLayerParams(viewport, {
    layers,
    pass,
    isPicking = false,
    layerFilter,
    cullRect,
    effects,
    moduleParameters
  }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = {
        shouldDrawLayer
      };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  _drawLayersInViewport(gl, {
    layers,
    moduleParameters: globalModuleParameters,
    pass,
    target,
    viewport,
    view
  }, drawLayerParams) {
    const glViewport = getGLViewport(gl, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });
    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? {
        color: true,
        depth: true
      } : view.props.clear;
      withParameters(gl, {
        scissorTest: true,
        scissor: glViewport
      }, () => clear3(gl, clearOpts));
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    setParameters(gl, {
      viewport: glViewport
    });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const {
        shouldDrawLayer,
        layerRenderIndex,
        moduleParameters,
        layerParameters
      } = drawLayerParams[layerIndex];
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        moduleParameters.viewport = viewport;
        try {
          layer._drawLayer({
            moduleParameters,
            uniforms: {
              layerIndex: layerRenderIndex
            },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
        }
      }
    }
    return renderStatus;
  }
  shouldDrawLayer(layer) {
    return true;
  }
  getModuleParameters(layer, effects) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getModuleParameters(layer, effects, pass, overrides) {
    var _layer$internalState;
    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: cssToDeviceRatio(this.gl)
    });
    if (effects) {
      for (const effect4 of effects) {
        var _effect$getModulePara;
        Object.assign(moduleParameters, (_effect$getModulePara = effect4.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect4, layer));
      }
    }
    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }
};
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== "default-framebuffer";
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}
function clearGLCanvas(gl, targetFramebuffer) {
  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
  setParameters(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}

// node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
var ShadowPass = class extends LayersPass {
  constructor(gl, props) {
    super(gl, props);
    _defineProperty(this, "shadowMap", void 0);
    _defineProperty(this, "depthBuffer", void 0);
    _defineProperty(this, "fbo", void 0);
    this.shadowMap = new Texture2D(gl, {
      width: 1,
      height: 1,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.depthBuffer = new Renderbuffer(gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    this.fbo = new Framebuffer(gl, {
      id: "shadowmap",
      width: 1,
      height: 1,
      attachments: {
        [36064]: this.shadowMap,
        [36096]: this.depthBuffer
      }
    });
  }
  render(params) {
    const target = this.fbo;
    withParameters(this.gl, {
      depthRange: [0, 1],
      depthTest: true,
      blend: false,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const viewport = params.viewports[0];
      const pixelRatio = cssToDeviceRatio(this.gl);
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;
      if (width !== target.width || height !== target.height) {
        target.resize({
          width,
          height
        });
      }
      super.render({
        ...params,
        target,
        pass: "shadow"
      });
    });
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }
  delete() {
    if (this.fbo) {
      this.fbo.delete();
      this.fbo = null;
    }
    if (this.shadowMap) {
      this.shadowMap.delete();
      this.shadowMap = null;
    }
    if (this.depthBuffer) {
      this.depthBuffer.delete();
      this.depthBuffer = null;
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
var vs3 = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
var fs2 = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var geometry_default = {
  name: "geometry",
  vs: vs3,
  fs: fs2
};

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";")).join("");
var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";")).join("");
var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(UNIT[key], ";")).join("");
var project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");

// node_modules/@deck.gl/core/dist/esm/utils/memoize.js
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
var ZERO_VECTOR = [0, 0, 0, 0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = transformMat43([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX2;
  return uniforms;
}
function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = transformMat43([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX2,
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms;
}

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
var INITIAL_MODULE_OPTIONS3 = {};
function getUniforms4(opts = INITIAL_MODULE_OPTIONS3) {
  if ("viewport" in opts) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
var project_default = {
  name: "project",
  dependencies: [fp32, geometry_default],
  vs: project_glsl_default,
  getUniforms: getUniforms4
};

// node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = transformMat43([], vector, matrix);
  scale2(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function clamp2(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}
var log22 = Math.log2 || ieLog2;

// node_modules/@math.gl/web-mercator/dist/esm/assert.js
function assert9(condition, message) {
  if (!condition) {
    throw new Error(message || "@math.gl/web-mercator: assertion failed.");
  }
}

// node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS2 = PI / 180;
var RADIANS_TO_DEGREES2 = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
var MAX_LATITUDE = 85.051129;
var DEFAULT_ALTITUDE = 1.5;
function scaleToZoom(scale3) {
  return log22(scale3);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert9(Number.isFinite(lng));
  assert9(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS2;
  const phi2 = lat * DEGREES_TO_RADIANS2;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
}
function getMeterZoom(options) {
  const {
    latitude
  } = options;
  assert9(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const {
    latitude,
    longitude,
    highPrecision = false
  } = options;
  assert9(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x, y, z] = xyz;
  const {
    unitsPerMeter: unitsPerMeter2,
    unitsPerMeter2: unitsPerMeter22
  } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x * (unitsPerMeter2[0] + unitsPerMeter22[0] * y);
  worldspace[1] += y * (unitsPerMeter2[1] + unitsPerMeter22[1] * y);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    height,
    pitch,
    bearing,
    altitude,
    scale: scale3,
    center
  } = options;
  const vm = createMat4();
  translate(vm, vm, [0, 0, -altitude]);
  rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
  rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
  const relativeScale = scale3 / height;
  scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    translate(vm, vm, negate2([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const {
    width,
    height,
    altitude,
    pitch = 0,
    offset,
    center,
    scale: scale3,
    nearZMultiplier = 1,
    farZMultiplier = 1
  } = options;
  let {
    fovy = altitudeToFovy(DEFAULT_ALTITUDE)
  } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS2;
  const pitchRadians = pitch * DEGREES_TO_RADIANS2;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale3 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  assert9(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  assert9(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
  if (Number.isFinite(z)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return lerp2([], coord0, coord1, t);
}

// node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    maxZoom = 24,
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size3 = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  assert9(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX2 = targetSize[0] / size3[0];
  const scaleY2 = targetSize[1] / size3[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX2;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
  assert9(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert9(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}

// node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
var DEGREES_TO_RADIANS3 = Math.PI / 180;
function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = lerp2([], coord0, coord1, t);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}

// node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
var TILE_SIZE2 = 512;
function normalizeViewportProps(props) {
  const {
    width,
    height,
    pitch = 0
  } = props;
  let {
    longitude,
    latitude,
    zoom,
    bearing = 0
  } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = mod(bearing + 180, 360) - 180;
  }
  const minZoom = log22(height / TILE_SIZE2);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}

// node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
var vs4 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
var fs3 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({
  viewport,
  center
}) {
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? void 0 : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
    const positions = corners.map((corner) => viewMatrix.transform(corner));
    const projectionMatrix = new Matrix4().ortho({
      left: Math.min(...positions.map((position) => position[0])),
      right: Math.max(...positions.map((position) => position[0])),
      bottom: Math.min(...positions.map((position) => position[1])),
      top: Math.max(...positions.map((position) => position[1])),
      near: Math.min(...positions.map((position) => -position[2])),
      far: Math.max(...positions.map((position) => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts, context) {
  const {
    shadowEnabled = true
  } = opts;
  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false
    };
  }
  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];
    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }
  return uniforms;
}
var shadow_default = {
  name: "shadow",
  dependencies: [project_default],
  vs: vs4,
  fs: fs3,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
    "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
  },
  getUniforms: (opts = {}, context = {}) => {
    if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
      return createShadowUniforms(opts, context);
    }
    return {};
  }
};

// node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1
};
var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}];
var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
var LightingEffect = class {
  constructor(props = {}) {
    _defineProperty(this, "id", "lighting-effect");
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "shadowColor", DEFAULT_SHADOW_COLOR2);
    _defineProperty(this, "shadow", void 0);
    _defineProperty(this, "ambientLight", void 0);
    _defineProperty(this, "directionalLights", void 0);
    _defineProperty(this, "pointLights", void 0);
    _defineProperty(this, "shadowPasses", []);
    _defineProperty(this, "shadowMaps", []);
    _defineProperty(this, "dummyShadowMap", null);
    _defineProperty(this, "programManager", void 0);
    _defineProperty(this, "shadowMatrices", void 0);
    this.setProps(props);
  }
  setProps(props) {
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case "ambient":
          this.ambientLight = lightSource;
          break;
        case "directional":
          this.directionalLights.push(lightSource);
          break;
        case "point":
          this.pointLights.push(lightSource);
          break;
        default:
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some((light) => light.shadow);
    this.props = props;
  }
  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.shadow)
      return;
    this.shadowMatrices = this._calculateMatrices();
    if (this.shadowPasses.length === 0) {
      this._createShadowPasses(gl);
    }
    if (!this.programManager) {
      this.programManager = ProgramManager.getDefaultProgramManager(gl);
      if (shadow_default) {
        this.programManager.addDefaultModule(shadow_default);
      }
    }
    if (!this.dummyShadowMap) {
      this.dummyShadowMap = new Texture2D(gl, {
        width: 1,
        height: 1
      });
    }
    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }
  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({
        layer
      })),
      pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({
        layer
      }))
    };
    return parameters;
  }
  cleanup() {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.delete();
      this.dummyShadowMap = null;
    }
    if (this.shadow && this.programManager) {
      this.programManager.removeDefaultModule(shadow_default);
      this.programManager = null;
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix = new Matrix4().lookAt({
        eye: new Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }
    return lightMatrices;
  }
  _createShadowPasses(gl) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new ShadowPass(gl);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
var TypedArrayManager = class {
  constructor(options = {}) {
    _defineProperty(this, "_pool", []);
    _defineProperty(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    });
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count2, {
    size: size3 = 1,
    type,
    padding = 0,
    copy: copy2 = false,
    initialize = false,
    maxCount
  }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count2 * size3 + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size3 + padding;
    }
    const newArray = this._allocate(Type, newSize, initialize, maxSize);
    if (typedArray && copy2) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type, size3, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size3 * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex((b) => b.byteLength >= byteLength);
    if (i >= 0) {
      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array.fill(0);
      }
      return array;
    }
    return new Type(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const {
      buffer
    } = typedArray;
    const {
      byteLength
    } = buffer;
    const i = pool.findIndex((b) => b.byteLength >= byteLength);
    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i, 0, buffer);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
};
var typed_array_manager_default = new TypedArrayManager();

// node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
function createMat42() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
var scratchVector = new Vector3();
function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new Vector3(-a / L, -b / L, -c / L)
  };
}
function fp64LowPart(x) {
  return x - Math.fround(x);
}
var scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const {
    size: size3 = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
  const count2 = (endIndex - startIndex) / size3;
  scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
    type: Float32Array,
    size: size3 * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j = 0; j < size3; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size3] = fp64LowPart(value);
    }
    targetIndex += size3 * 2;
  }
  return scratchArray.subarray(0, count2 * size3 * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds)
      continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}

// node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
var DEGREES_TO_RADIANS4 = Math.PI / 180;
var IDENTITY2 = createMat42();
var ZERO_VECTOR2 = [0, 0, 0];
var DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({
  width,
  height,
  orthographic,
  fovyRadians,
  focalDistance,
  padding,
  near,
  far
}) {
  const aspect = width / height;
  const matrix = orthographic ? new Matrix4().orthographic({
    fovy: fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) : new Matrix4().perspective({
    fovy: fovyRadians,
    aspect,
    near,
    far
  });
  if (padding) {
    const {
      left = 0,
      right = 0,
      top = 0,
      bottom = 0
    } = padding;
    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
var Viewport = class _Viewport {
  constructor(opts = {}) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "padding", void 0);
    _defineProperty(this, "isGeospatial", void 0);
    _defineProperty(this, "zoom", void 0);
    _defineProperty(this, "focalDistance", void 0);
    _defineProperty(this, "position", void 0);
    _defineProperty(this, "modelMatrix", void 0);
    _defineProperty(this, "distanceScales", void 0);
    _defineProperty(this, "scale", void 0);
    _defineProperty(this, "center", void 0);
    _defineProperty(this, "cameraPosition", void 0);
    _defineProperty(this, "projectionMatrix", void 0);
    _defineProperty(this, "viewMatrix", void 0);
    _defineProperty(this, "viewMatrixUncentered", void 0);
    _defineProperty(this, "viewMatrixInverse", void 0);
    _defineProperty(this, "viewProjectionMatrix", void 0);
    _defineProperty(this, "pixelProjectionMatrix", void 0);
    _defineProperty(this, "pixelUnprojectionMatrix", void 0);
    _defineProperty(this, "resolution", void 0);
    _defineProperty(this, "_frustumPlanes", {});
    this.id = opts.id || this.constructor.displayName || "viewport";
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR2;
    this.modelMatrix = opts.modelMatrix || null;
    const {
      longitude,
      latitude
    } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return PROJECTION_MODE.IDENTITY;
  }
  equals(viewport) {
    if (!(viewport instanceof _Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
  }
  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }
  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }
    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }
  projectPosition(xyz) {
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = lngLatToWorld(xyz);
      result[1] = clamp(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return worldToLngLat(xyz);
    }
    return xyz;
  }
  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin) {
      return getDistanceScales({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({
    x,
    y,
    width = 1,
    height = 1
  }) {
    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
  }
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  panByPosition(coords, pixel) {
    return null;
  }
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = getMeterZoom({
          latitude
        }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || getDistanceScales({
        latitude,
        longitude
      });
    }
    const scale3 = Math.pow(2, this.zoom);
    this.scale = scale3;
    const {
      position,
      modelMatrix
    } = opts;
    let meterOffset = ZERO_VECTOR2;
    if (position) {
      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  _initMatrices(opts) {
    const {
      viewMatrix = IDENTITY2,
      projectionMatrix = null,
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      far = 1e3,
      padding = null,
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = createMat42();
    multiply(vpm, vpm, this.projectionMatrix);
    multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
    const viewportMatrix = createMat42();
    const pixelProjectionMatrix = createMat42();
    scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = invert(createMat42(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      log_default.warn("Pixel project matrix not invertible")();
    }
  }
};
_defineProperty(Viewport, "displayName", "Viewport");

// node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
var WebMercatorViewport2 = class _WebMercatorViewport extends Viewport {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      nearZ,
      farZ,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      legacyMeterSizes = false
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    const scale3 = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = altitudeToFovy(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = fovyToAltitude(fovy);
      } else {
        fovy = altitudeToFovy(altitude);
      }
      let offset;
      if (padding) {
        const {
          top = 0,
          bottom = 0
        } = padding;
        offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = getProjectionParameters({
        width,
        height,
        scale: scale3,
        center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
      if (Number.isFinite(nearZ)) {
        projectionParameters.near = nearZ;
      }
      if (Number.isFinite(farZ)) {
        projectionParameters.far = farZ;
      }
    }
    let viewMatrixUncentered = getViewMatrix({
      height,
      pitch,
      bearing,
      scale: scale3,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      width,
      height,
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    _defineProperty(this, "longitude", void 0);
    _defineProperty(this, "latitude", void 0);
    _defineProperty(this, "pitch", void 0);
    _defineProperty(this, "bearing", void 0);
    _defineProperty(this, "altitude", void 0);
    _defineProperty(this, "fovy", void 0);
    _defineProperty(this, "orthographic", void 0);
    _defineProperty(this, "_subViewports", void 0);
    _defineProperty(this, "_pseudoMeters", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x = minOffset; x <= maxOffset; x++) {
        const offsetViewport = x ? new _WebMercatorViewport({
          ...this,
          worldOffset: x
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) / unitsPerMeter(Y);
    return [X, Y, Z];
  }
  addMetersToLngLat(lngLatZ, xyz) {
    return addMetersToLngLat(lngLatZ, xyz);
  }
  panByPosition(coords, pixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate2 = add3([], toLocation, negate([], fromLocation));
    const newCenter = add3([], this.center, translate2);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return {
      longitude,
      latitude
    };
  }
  getBounds(options = {}) {
    const corners = getBounds(this, options.z || 0);
    return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = fitBounds({
      width,
      height,
      bounds,
      ...options
    });
    return new _WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
};
_defineProperty(WebMercatorViewport2, "displayName", "WebMercatorViewport");

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof WebMercatorViewport2) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p;
}
function normalizeParameters(opts) {
  const {
    viewport,
    modelMatrix,
    coordinateOrigin
  } = opts;
  let {
    coordinateSystem,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;
  if (modelMatrix) {
    [x, y, z] = transformMat43([], [x, y, z, 1], modelMatrix);
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    autoOffset = true
  } = params;
  const {
    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
    offsetMode = false
  } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}

// node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
var PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
var PickLayersPass = class extends LayersPass {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "pickZ", void 0);
    _defineProperty(this, "_colorEncoderState", null);
  }
  render(props) {
    if ("pickingFBO" in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    cullRect,
    effects,
    pass = "picking",
    pickZ,
    moduleParameters
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const renderStatus = withParameters(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects === null || effects === void 0 ? void 0 : effects.filter((e) => e.useInPicking),
      pass,
      isPicking: true,
      moduleParameters
    }));
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }
  shouldDrawLayer(layer) {
    const {
      pickable,
      operation
    } = layer.props;
    return pickable && operation.includes("draw") || operation.includes("terrain");
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      ...layer.props.parameters
    };
    const {
      pickable,
      operation
    } = layer.props;
    if (!this._colorEncoderState) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes("draw")) {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    if (operation.includes("terrain")) {
      pickParameters.blend = false;
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
};
function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;
    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      log_default.warn("Too many pickable layers, only picking the first 255")();
      a = 0;
    }
  }
  return [0, 0, 0, a / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}

// node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
var LIFECYCLE = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
};
var COMPONENT_SYMBOL = Symbol.for("component");
var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

// node_modules/@deck.gl/core/dist/esm/utils/flatten.js
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray2({
  target,
  source,
  start: start3 = 0,
  count: count2 = 1
}) {
  const length = source.length;
  const total = count2 * length;
  let copied = 0;
  for (let i = start3; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start3 + copied, start3, start3 + copied);
      copied *= 2;
    } else {
      target.copyWithin(start3 + copied, start3, start3 + total - copied);
      copied = total;
    }
  }
  return target;
}

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
var Resource2 = class {
  constructor(id, data3, context) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "isLoaded", void 0);
    _defineProperty(this, "persistent", void 0);
    _defineProperty(this, "_loadCount", 0);
    _defineProperty(this, "_subscribers", /* @__PURE__ */ new Set());
    _defineProperty(this, "_data", void 0);
    _defineProperty(this, "_loader", void 0);
    _defineProperty(this, "_error", void 0);
    _defineProperty(this, "_content", void 0);
    this.id = id;
    this.context = context;
    this.setData(data3);
  }
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data3, forceUpdate) {
    if (data3 === this._data && !forceUpdate) {
      return;
    }
    this._data = data3;
    const loadCount = ++this._loadCount;
    let loader = data3;
    if (typeof data3 === "string") {
      loader = load(data3);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then((result) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = void 0;
          this._content = result;
        }
      }).catch((error3) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error3 || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = void 0;
      this._content = data3;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
var ResourceManager = class {
  constructor({
    gl,
    protocol
  }) {
    _defineProperty(this, "protocol", void 0);
    _defineProperty(this, "_context", void 0);
    _defineProperty(this, "_resources", void 0);
    _defineProperty(this, "_consumers", void 0);
    _defineProperty(this, "_pruneRequest", void 0);
    this.protocol = protocol || "resource://";
    this._context = {
      gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({
    resourceId,
    data: data3,
    forceUpdate = false,
    persistent = true
  }) {
    let res2 = this._resources[resourceId];
    if (res2) {
      res2.setData(data3, forceUpdate);
    } else {
      res2 = new Resource2(resourceId, data3, this._context);
      this._resources[resourceId] = res2;
    }
    res2.persistent = persistent;
  }
  remove(resourceId) {
    const res2 = this._resources[resourceId];
    if (res2) {
      res2.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({
    consumerId
  }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({
    resourceId,
    onChange,
    consumerId,
    requestId = "default"
  }) {
    const {
      _resources: resources,
      protocol
    } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, "");
      if (!resources[resourceId]) {
        this.add({
          resourceId,
          data: null,
          persistent: false
        });
      }
    }
    const res2 = resources[resourceId];
    this._track(consumerId, requestId, res2, onChange);
    if (res2) {
      return res2.getData();
    }
    return void 0;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    const request = consumer[requestId] || {};
    const oldResource = request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      consumer[requestId] = request;
      request.onChange = onChange;
      request.resourceId = resource.id;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res2 = this._resources[key];
      if (!res2.persistent && !res2.inUse()) {
        res2.delete();
        delete this._resources[key];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
var vs5 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var project32_default = {
  name: "project32",
  dependencies: [project_default],
  vs: vs5
};

// node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
var picking_default = {
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
    "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
    "fs:#decl": "\nuniform bool picking_uAttribute;\n  ",
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
    }
  },
  ...picking
};

// node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
var DEFAULT_MODULES = [project_default];
var SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
function createProgramManager(gl) {
  const programManager = ProgramManager.getDefaultProgramManager(gl);
  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }
  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }
  return programManager;
}

// node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
var TRACE_SET_LAYERS = "layerManager.setLayers";
var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
var LayerManager = class {
  constructor(gl, {
    deck,
    stats,
    viewport: _viewport,
    timeline
  } = {}) {
    _defineProperty(this, "layers", void 0);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "resourceManager", void 0);
    _defineProperty(this, "_lastRenderedLayers", []);
    _defineProperty(this, "_needsRedraw", false);
    _defineProperty(this, "_needsUpdate", false);
    _defineProperty(this, "_nextLayers", null);
    _defineProperty(this, "_debug", false);
    _defineProperty(this, "activateViewport", (viewport) => {
      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
      if (viewport) {
        this.context.viewport = viewport;
      }
    });
    this.layers = [];
    this.resourceManager = new ResourceManager({
      gl,
      protocol: "deck://"
    });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl,
      deck,
      programManager: gl && createProgramManager(gl),
      stats: stats || new Stats({
        id: "deck.gl"
      }),
      viewport: _viewport || new Viewport({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      timeline: timeline || new Timeline(),
      resourceManager: this.resourceManager,
      onError: void 0
    };
    Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return "layers changed";
    }
    return this._needsUpdate;
  }
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  getLayers({
    layerIds
  } = {}) {
    return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  setProps(props) {
    if ("debug" in props) {
      this._debug = props.debug;
    }
    if ("userData" in props) {
      this.context.userData = props.userData;
    }
    if ("layers" in props) {
      this._nextLayers = props.layers;
    }
    if ("onError" in props) {
      this.context.onError = props.onError;
    }
  }
  setLayers(newLayers, reason) {
    debug(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = flatten(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw("updating layers: ".concat(reason));
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  _handleError(stage, error3, layer) {
    layer.raiseError(error3, "".concat(stage, " of ").concat(layer));
  }
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        log_default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = "Uniform transition in ".concat(layer);
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        log_default.warn("Multiple new layers with same id ".concat(newLayer.id))();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError("matching", err, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError("initialization", err, layer);
    }
  }
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
    }
  }
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError("update", err, layer);
    }
  }
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError("finalization", err, layer);
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
function deepEqual(a, b, depth) {
  if (a === b) {
    return true;
  }
  if (!depth || !a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a === "object" && typeof b === "object") {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
var ViewManager = class {
  constructor(props) {
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "views", void 0);
    _defineProperty(this, "viewState", void 0);
    _defineProperty(this, "controllers", void 0);
    _defineProperty(this, "timeline", void 0);
    _defineProperty(this, "_viewports", void 0);
    _defineProperty(this, "_viewportMap", void 0);
    _defineProperty(this, "_isUpdating", void 0);
    _defineProperty(this, "_needsRedraw", void 0);
    _defineProperty(this, "_needsUpdate", void 0);
    _defineProperty(this, "_eventManager", void 0);
    _defineProperty(this, "_eventCallbacks", void 0);
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = "First render";
    this._needsUpdate = "Initialize";
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter((viewport) => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  getViews() {
    const viewMap = {};
    this.views.forEach((view) => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  getView(viewId) {
    return this.views.find((view) => view.id === viewId);
  }
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = {
      x: xyz[0],
      y: xyz[1]
    };
    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];
      if (viewport.containsPixel(pixel)) {
        const p = xyz.slice();
        p[0] -= viewport.x;
        p[1] -= viewport.y;
        return viewport.unproject(p, opts);
      }
    }
    return null;
  }
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ("width" in props || "height" in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate("Size changed");
    }
  }
  _setViews(views) {
    views = flatten(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate("views changed");
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate("viewState changed");
      }
      this.viewState = viewState;
    } else {
      log_default.warn("missing `viewState` or `initialViewState`")();
    }
  }
  _onViewStateChange(viewId, event) {
    if (this._eventCallbacks.onViewStateChange) {
      this._eventCallbacks.onViewStateChange({
        ...event,
        viewId
      });
    }
  }
  _createController(view, props) {
    const Controller2 = props.type;
    const controller = new Controller2({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, props.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (viewState) => {
        var _this$getView;
        return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
      }
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps && viewport) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller || controller.constructor !== controllerProps.type) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views
    } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i = views.length; i--; ) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      if (viewport) {
        this._viewports.unshift(viewport);
      }
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach((viewport) => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }
};

// node_modules/@deck.gl/core/dist/esm/utils/positions.js
var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case "number":
      return {
        position: value,
        relative: false
      };
    case "string":
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === "%";
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}

// node_modules/@deck.gl/core/dist/esm/utils/assert.js
function assert10(condition, message) {
  if (!condition) {
    throw new Error(message || "deck.gl: assertion failed.");
  }
}

// node_modules/@deck.gl/core/dist/esm/views/view.js
var View = class {
  constructor(props) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "viewportInstance", void 0);
    _defineProperty(this, "_x", void 0);
    _defineProperty(this, "_y", void 0);
    _defineProperty(this, "_width", void 0);
    _defineProperty(this, "_height", void 0);
    _defineProperty(this, "_padding", void 0);
    _defineProperty(this, "props", void 0);
    const {
      id,
      x = 0,
      y = 0,
      width = "100%",
      height = "100%",
      padding = null,
      viewportInstance
    } = props || {};
    assert10(!viewportInstance || viewportInstance instanceof Viewport);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || "view";
    this.props = {
      ...props,
      id: this.id
    };
    this._x = parsePosition(x);
    this._y = parsePosition(y);
    this._width = parsePosition(width);
    this._height = parsePosition(height);
    this._padding = padding && {
      left: parsePosition(padding.left || 0),
      right: parsePosition(padding.right || 0),
      top: parsePosition(padding.top || 0),
      bottom: parsePosition(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    if (this.viewportInstance) {
      return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
    }
    return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
  }
  makeViewport({
    width,
    height,
    viewState
  }) {
    if (this.viewportInstance) {
      return this.viewportInstance;
    }
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({
      width,
      height
    });
    if (!viewportDimensions.height || !viewportDimensions.width) {
      return null;
    }
    return new this.ViewportType({
      ...viewState,
      ...this.props,
      ...viewportDimensions
    });
  }
  getViewStateId() {
    const {
      viewState
    } = this.props;
    if (typeof viewState === "string") {
      return viewState;
    }
    return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
  }
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === "object") {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = {
        ...viewState
      };
      for (const key in this.props.viewState) {
        if (key !== "id") {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  getDimensions({
    width,
    height
  }) {
    const dimensions = {
      x: getPosition(this._x, width),
      y: getPosition(this._y, height),
      width: getPosition(this._width, width),
      height: getPosition(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: getPosition(this._padding.left, width),
        top: getPosition(this._padding.top, height),
        right: getPosition(this._padding.right, width),
        bottom: getPosition(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return {
        type: this.ControllerType
      };
    }
    if (typeof opts === "function") {
      return {
        type: opts
      };
    }
    return {
      type: this.ControllerType,
      ...opts
    };
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/transition.js
var Transition = class {
  constructor(timeline) {
    _defineProperty(this, "_inProgress", void 0);
    _defineProperty(this, "_handle", void 0);
    _defineProperty(this, "_timeline", void 0);
    _defineProperty(this, "time", void 0);
    _defineProperty(this, "settings", void 0);
    this._inProgress = false;
    this._handle = null;
    this._timeline = timeline;
    this.time = 0;
    this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(settings) {
    var _this$settings$onStar, _this$settings;
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
  }
  end() {
    if (this._inProgress) {
      var _this$settings$onEnd, _this$settings2;
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var _this$settings$onInte, _this$settings3;
      (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  update() {
    var _this$settings$onUpda, _this$settings4;
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const {
        _timeline: timeline,
        settings
      } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  _onUpdate() {
  }
};

// node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
var noop3 = () => {
};
var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
var DEFAULT_EASING = (t) => t;
var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
var TransitionManager = class {
  constructor(opts) {
    _defineProperty(this, "getControllerState", void 0);
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "propsInTransition", void 0);
    _defineProperty(this, "transition", void 0);
    _defineProperty(this, "onViewStateChange", void 0);
    _defineProperty(this, "onStateChange", void 0);
    _defineProperty(this, "_onTransitionUpdate", (transition3) => {
      const {
        time,
        settings: {
          interpolator,
          startProps,
          endProps,
          duration,
          easing
        }
      } = transition3;
      const t = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    });
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new Transition(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop3;
    this.onStateChange = opts.onStateChange || noop3;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const {
          interruption,
          endProps
        } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(props) {
    const {
      transitionDuration,
      transitionInterpolator
    } = props;
    return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({
      inTransition: true
    });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return (transition3) => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback === null || callback === void 0 ? void 0 : callback(transition3);
    };
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
var TransitionInterpolator = class {
  constructor(opts) {
    _defineProperty(this, "_propsToCompare", void 0);
    _defineProperty(this, "_propsToExtract", void 0);
    _defineProperty(this, "_requiredProps", void 0);
    const {
      compare,
      extract,
      required
    } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return {
      start: startViewStateProps,
      end: endViewStateProps
    };
  }
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach((propName) => {
      const value = props[propName];
      assert10(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
    });
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
var DEFAULT_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
var LinearInterpolator = class extends TransitionInterpolator {
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS2,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    _defineProperty(this, "opts", void 0);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const {
      makeViewport,
      around
    } = this.opts;
    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }
    return result;
  }
  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({
        ...endProps,
        ...propsInTransition
      });
      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp(startProps.around, endProps.around, t)));
    }
    return propsInTransition;
  }
};

// node_modules/@deck.gl/core/dist/esm/controllers/controller.js
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var DEFAULT_INERTIA = 300;
var INERTIA_EASING = (t) => 1 - (1 - t) * (1 - t);
var EVENT_TYPES = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
};
var pinchEventWorkaround = {};
var Controller = class {
  constructor(opts) {
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "state", {});
    _defineProperty(this, "transitionManager", void 0);
    _defineProperty(this, "eventManager", void 0);
    _defineProperty(this, "onViewStateChange", void 0);
    _defineProperty(this, "onStateChange", void 0);
    _defineProperty(this, "makeViewport", void 0);
    _defineProperty(this, "_controllerState", void 0);
    _defineProperty(this, "_events", {});
    _defineProperty(this, "_interactionState", {
      isDragging: false
    });
    _defineProperty(this, "_customEvents", []);
    _defineProperty(this, "_eventStartBlocked", null);
    _defineProperty(this, "_panMove", false);
    _defineProperty(this, "invertPan", false);
    _defineProperty(this, "dragMode", "rotate");
    _defineProperty(this, "inertia", 0);
    _defineProperty(this, "scrollZoom", true);
    _defineProperty(this, "dragPan", true);
    _defineProperty(this, "dragRotate", true);
    _defineProperty(this, "doubleClickZoom", true);
    _defineProperty(this, "touchZoom", true);
    _defineProperty(this, "touchRotate", false);
    _defineProperty(this, "keyboard", true);
    this.transitionManager = new TransitionManager({
      ...opts,
      getControllerState: (props) => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {
    });
    this.onStateChange = opts.onStateChange || (() => {
    });
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        var _this$eventManager;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  handleEvent(event) {
    this._controllerState = void 0;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case "panstart":
        return eventStartBlocked ? false : this._onPanStart(event);
      case "panmove":
        return this._onPan(event);
      case "panend":
        return this._onPanEnd(event);
      case "pinchstart":
        return eventStartBlocked ? false : this._onPinchStart(event);
      case "pinchmove":
        return this._onPinch(event);
      case "pinchend":
        return this._onPinchEnd(event);
      case "tripanstart":
        return eventStartBlocked ? false : this._onTriplePanStart(event);
      case "tripanmove":
        return this._onTriplePan(event);
      case "tripanend":
        return this._onTriplePanEnd(event);
      case "doubletap":
        return this._onDoubleTap(event);
      case "wheel":
        return this._onWheel(event);
      case "keydown":
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const {
      x,
      y
    } = this.props;
    const {
      offsetCenter
    } = event;
    return [offsetCenter.x - x, offsetCenter.y - y];
  }
  isPointInBounds(pos, event) {
    const {
      width,
      height
    } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const {
      srcEvent
    } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!("transitionInterpolator" in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const {
      inertia
    } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const {
      scrollZoom = true,
      dragPan = true,
      dragRotate = true,
      doubleClickZoom = true,
      touchZoom = true,
      touchRotate = false,
      keyboard = true
    } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach((eventName) => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = {
      ...newControllerState.getViewportProps(),
      ...extraProps
    };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState,
          interactionState: this._interactionState,
          oldViewState
        });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({
      ...params,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === "pan") {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.pan({
        pos: endPos
      }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    event.srcEvent.preventDefault();
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const {
      speed = 0.01,
      smooth = false
    } = this.scrollZoom === true ? {} : this.scrollZoom;
    const {
      delta
    } = event;
    let scale3 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale3 !== 0) {
      scale3 = 1 / scale3;
    }
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: scale3
    });
    this.updateViewport(newControllerState, {
      ...this._getTransitionProps({
        around: pos
      }),
      transitionDuration: smooth ? 250 : 1
    }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }
  _onTriplePanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({
      pos
    }).rotateStart({
      pos
    });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: scale3
      } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({
        pos,
        scale: scale3
      });
    }
    if (this.touchRotate) {
      const {
        rotation
      } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    const {
      _lastPinchEvent
    } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);
      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({
        pos,
        scale: endScale
      }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: isZoomOut ? 0.5 : 2
    });
    this.updateViewport(newControllerState, this._getTransitionProps({
      around: pos
    }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const {
      zoomSpeed,
      moveSpeed,
      rotateSpeedX,
      rotateSpeedY
    } = this.keyboard === true ? {} : this.keyboard;
    const {
      controllerState
    } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case "Minus":
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "Equal":
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "ArrowLeft":
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowRight":
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowUp":
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowDown":
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const {
      transition: transition3
    } = this;
    if (!transition3 || !transition3.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition3,
      transitionInterpolator: new LinearInterpolator({
        ...opts,
        ...transition3.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition3;
  }
};

// node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
var ViewState = class {
  constructor(props, state) {
    _defineProperty(this, "_viewportProps", void 0);
    _defineProperty(this, "_state", void 0);
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
};

// node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var MapState = class extends ViewState {
  constructor(options) {
    const {
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing = 0,
      pitch = 0,
      altitude = 1.5,
      position = [0, 0, 0],
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom,
      normalize: normalize2 = true
    } = options;
    assert10(Number.isFinite(longitude));
    assert10(Number.isFinite(latitude));
    assert10(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize: normalize2,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    _defineProperty(this, "makeViewport", void 0);
    this.makeViewport = options.makeViewport;
  }
  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  pan({
    pos,
    startPos
  }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom({
    pos,
    startPos,
    scale: scale3
  }) {
    let {
      startZoom,
      startZoomLngLat
    } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale3);
    zoom = clamp(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({
      ...this.getViewportProps(),
      zoom
    });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = clamp(zoom, minZoom, maxZoom);
    const {
      maxPitch,
      minPitch,
      pitch
    } = props;
    props.pitch = clamp(pitch, minPitch, maxPitch);
    const {
      normalize: normalize2 = true
    } = props;
    if (normalize2) {
      Object.assign(props, normalizeViewportProps(props));
    }
    return props;
  }
  _zoomFromCenter(scale3) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale: scale3
    });
  }
  _panFromCenter(offset) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const {
      width,
      height
    } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = clamp(deltaScaleY, -1, 1);
    const {
      minPitch,
      maxPitch
    } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing
    };
  }
};
var MapController = class extends Controller {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ControllerState", MapState);
    _defineProperty(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    });
    _defineProperty(this, "dragMode", "pan");
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/views/map-view.js
var MapView = class extends View {
  get ViewportType() {
    return WebMercatorViewport2;
  }
  get ControllerType() {
    return MapController;
  }
};
_defineProperty(MapView, "displayName", "MapView");

// node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
function compareEffects(e1, e2) {
  var _e1$order, _e2$order;
  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
  return o1 - o2;
}
var EffectManager = class {
  constructor() {
    _defineProperty(this, "effects", void 0);
    _defineProperty(this, "_resolvedEffects", []);
    _defineProperty(this, "_defaultEffects", []);
    _defineProperty(this, "_needsRedraw", void 0);
    this.effects = [];
    this._needsRedraw = "Initial render";
    this._setEffects([]);
  }
  addDefaultEffect(effect4) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find((e) => e.id === effect4.id)) {
      const index = defaultEffects.findIndex((e) => compareEffects(e, effect4) > 0);
      if (index < 0) {
        defaultEffects.push(effect4);
      } else {
        defaultEffects.splice(index, 0, effect4);
      }
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ("effects" in props) {
      if (!deepEqual(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect4 of this.effects) {
      oldEffectsMap[effect4.id] = effect4;
    }
    const nextEffects = [];
    for (const effect4 of effects) {
      const oldEffect = oldEffectsMap[effect4.id];
      if (oldEffect && oldEffect !== effect4) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect4.props);
          nextEffects.push(oldEffect);
        } else {
          oldEffect.cleanup();
          nextEffects.push(effect4);
        }
      } else {
        nextEffects.push(effect4);
      }
      delete oldEffectsMap[effect4.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup();
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some((effect4) => effect4 instanceof LightingEffect)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const effect4 of this._resolvedEffects) {
      effect4.cleanup();
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
};

// node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
var DrawLayersPass = class extends LayersPass {
  shouldDrawLayer(layer) {
    const {
      operation
    } = layer.props;
    return operation.includes("draw") || operation.includes("terrain");
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
var DeckRenderer = class {
  constructor(gl) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "layerFilter", void 0);
    _defineProperty(this, "drawPickingColors", void 0);
    _defineProperty(this, "drawLayersPass", void 0);
    _defineProperty(this, "pickLayersPass", void 0);
    _defineProperty(this, "renderCount", void 0);
    _defineProperty(this, "_needsRedraw", void 0);
    _defineProperty(this, "renderBuffers", void 0);
    _defineProperty(this, "lastPostProcessEffect", void 0);
    this.gl = gl;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new DrawLayersPass(gl);
    this.pickLayersPass = new PickLayersPass(gl);
    this.renderCount = 0;
    this._needsRedraw = "Initial render";
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = "layerFilter changed";
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = "drawPickingColors changed";
    }
  }
  renderLayers(opts) {
    if (!opts.viewports.length) {
      return;
    }
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts,
      target: opts.target || Framebuffer.getDefaultFramebuffer(this.gl)
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    const renderStats = layerPass.render({
      ...renderOpts,
      target: outputBuffer
    });
    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const {
      renderBuffers
    } = this;
    for (const buffer of renderBuffers) {
      buffer.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect4 of effects) {
      opts.preRenderStats[effect4.id] = effect4.preRender(this.gl, opts);
      if (effect4.postRender) {
        this.lastPostProcessEffect = effect4.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers
    } = this;
    if (renderBuffers.length === 0) {
      renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
    }
    for (const buffer of renderBuffers) {
      buffer.resize();
    }
  }
  _postRender(effects, opts) {
    const {
      renderBuffers
    } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1],
      target: null
    };
    for (const effect4 of effects) {
      if (effect4.postRender) {
        if (effect4.id === this.lastPostProcessEffect) {
          params.target = opts.target;
          effect4.postRender(this.gl, params);
          break;
        }
        const buffer = effect4.postRender(this.gl, params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  const {
    x,
    y,
    width,
    height
  } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x + dx,
        pickedY: y + dy
      };
    }
    log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}

// node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x - pickedViewport.x, y - pickedViewport.y];
    if (z !== void 0) {
      point[2] = z;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach((layer) => {
    let info = {
      ...baseInfo
    };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === "hover") {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}

// node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
var DeckPicker = class {
  constructor(gl) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "depthFBO", void 0);
    _defineProperty(this, "pickLayersPass", void 0);
    _defineProperty(this, "layerFilter", void 0);
    _defineProperty(this, "lastPickedInfo", void 0);
    _defineProperty(this, "_pickable", true);
    this.gl = gl;
    this.pickLayersPass = new PickLayersPass(gl);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ("layerFilter" in props) {
      this.layerFilter = props.layerFilter;
    }
    if ("_pickable" in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.delete();
    }
    if (this.depthFBO) {
      this.depthFBO.color.delete();
      this.depthFBO.delete();
    }
  }
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find((l) => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find((v) => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
    const info = {
      x,
      y,
      viewport,
      coordinate,
      layer
    };
    return {
      ...lastPickedInfo,
      ...info
    };
  }
  _resizeBuffer() {
    var _this$pickingFBO, _this$depthFBO;
    const {
      gl
    } = this;
    if (!this.pickingFBO) {
      this.pickingFBO = new Framebuffer(gl);
      if (Framebuffer.isSupported(gl, {
        colorBufferFloat: true
      })) {
        const depthFBO = new Framebuffer(gl);
        depthFBO.attach({
          [36064]: new Texture2D(gl, {
            format: isWebGL2(gl) ? 34836 : 6408,
            type: 5126
          })
        });
        this.depthFBO = depthFBO;
      }
    }
    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
  }
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  _pickClosestObject({
    layers,
    views,
    viewports,
    x,
    y,
    radius = 0,
    depth = 1,
    mode = "query",
    unproject3D,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    const pixelRatio = cssToDeviceRatio(this.gl);
    if (!pickableLayers) {
      return {
        result: [],
        emptyInfo: getEmptyPickingInfo({
          viewports,
          x,
          y,
          pixelRatio
        })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x - radius,
      y: y - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = /* @__PURE__ */ new Set();
    for (let i = 0; i < depth; i++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: "picking:".concat(mode)
        });
        pickInfo = getClosestObject({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const {
          pickedColors: pickedColors2
        } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: "picking:".concat(mode, ":z")
        }, true);
        if (pickedColors2[3]) {
          z = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x,
        y,
        z,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return {
      result,
      emptyInfo: infos.get(null)
    };
  }
  _pickVisibleObjects({
    layers,
    views,
    viewports,
    x,
    y,
    width = 1,
    height = 1,
    mode = "query",
    maxObjects = null,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = cssToDeviceRatio(this.gl);
    const leftTop = cssToDevicePixels(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: {
        x,
        y,
        width,
        height
      },
      effects,
      pass: "picking:".concat(mode)
    });
    const pickInfos = getUniqueObjects(pickedResult);
    const uniqueInfos = /* @__PURE__ */ new Map();
    const isMaxObjects = Number.isFinite(maxObjects);
    for (let i = 0; i < pickInfos.length; i++) {
      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        pixelRatio
      };
      info = getLayerPickingInfo({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });
      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    }
    return Array.from(uniqueInfos.values());
  }
  _drawAndSample({
    layers,
    views,
    viewports,
    onViewportActive,
    deviceRect,
    cullRect,
    effects,
    pass
  }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {}
    };
    for (const effect4 of effects) {
      if (effect4.useInPicking) {
        opts.preRenderStats[effect4.id] = effect4.preRender(this.gl, opts);
      }
    }
    const {
      decodePickingColor
    } = this.pickLayersPass.render(opts);
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    readPixelsToArray(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return {
      pickedColors,
      decodePickingColor
    };
  }
  _getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
var defaultStyle = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
var Tooltip = class {
  constructor(canvas) {
    _defineProperty(this, "el", null);
    _defineProperty(this, "isVisible", false);
    const canvasParent = canvas.parentElement;
    if (canvasParent) {
      this.el = document.createElement("div");
      this.el.className = "deck-tooltip";
      Object.assign(this.el.style, defaultStyle);
      canvasParent.appendChild(this.el);
    }
  }
  setTooltip(displayInfo, x, y) {
    const el = this.el;
    if (!el) {
      return;
    }
    if (typeof displayInfo === "string") {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = "none";
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
    }
    this.isVisible = true;
    el.style.display = "block";
    el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
    if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
      Object.assign(el.style, displayInfo.style);
    }
  }
  remove() {
    if (this.el) {
      this.el.remove();
      this.el = null;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
var hammerjs = __toESM(require_hammer());

// node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }
  return false;
}
function enhancePointerEventInput(PointerEventInput2) {
  const oldHandler = PointerEventInput2.prototype.handler;
  PointerEventInput2.prototype.handler = function handler5(ev) {
    const store3 = this.store;
    if (ev.button > 0 && ev.type === "pointerdown") {
      if (!some(store3, (e) => e.pointerId === ev.pointerId)) {
        store3.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
function enhanceMouseInput(MouseInput2) {
  MouseInput2.prototype.handler = function handler5(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: "mouse",
      srcEvent: ev
    });
  };
}

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
enhancePointerEventInput(hammerjs.PointerEventInput);
enhanceMouseInput(hammerjs.MouseInput);
var Manager2 = hammerjs.Manager;
var hammer_browser_default = hammerjs;

// node_modules/mjolnir.js/dist/esm/inputs/input.js
var Input = class {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = { enable: true, ...options };
  }
};

// node_modules/mjolnir.js/dist/esm/constants.js
var RECOGNIZERS = hammer_browser_default ? [
  [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
  [hammer_browser_default.Rotate, { enable: false }],
  [hammer_browser_default.Pinch, { enable: false }],
  [hammer_browser_default.Swipe, { enable: false }],
  [hammer_browser_default.Pan, { threshold: 0, enable: false }],
  [hammer_browser_default.Press, { enable: false }],
  [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [hammer_browser_default.Tap, { event: "anytap", enable: false }],
  [hammer_browser_default.Tap, { enable: false }]
] : null;
var RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
};
var RECOGNIZER_FALLBACK_MAP = {
  doubletap: ["tap"]
};
var BASIC_EVENT_ALIASES = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
};
var INPUT_EVENT_TYPES = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
};
var EVENT_RECOGNIZER_MAP = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
};
var GESTURE_EVENT_ALIASES = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
};

// node_modules/mjolnir.js/dist/esm/utils/globals.js
var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_5 = typeof window !== "undefined" ? window : global;
var passiveSupported = false;
try {
  const options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      passiveSupported = true;
      return true;
    }
  };
  window_5.addEventListener("test", null, options);
  window_5.removeEventListener("test", null);
} catch (err) {
  passiveSupported = false;
}

// node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
var EVENT_TYPE = "wheel";
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = 0.25;
var WheelInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (window_5.WheelEvent) {
        if (firefox && event.deltaMode === window_5.WheelEvent.DOM_DELTA_PIXEL) {
          value /= window_5.devicePixelRatio;
        }
        if (event.deltaMode === window_5.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    this.events = (this.options.events || []).concat(WHEEL_EVENTS);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/move-input.js
var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
var MOVE_EVENT_TYPE = "pointermove";
var OVER_EVENT_TYPE = "pointerover";
var OUT_EVENT_TYPE = "pointerout";
var ENTER_EVENT_TYPE = "pointerenter";
var LEAVE_EVENT_TYPE = "pointerleave";
var MoveInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const { enable: enable2 } = this.options;
    this.enableMoveEvent = enable2;
    this.enableLeaveEvent = enable2;
    this.enableEnterEvent = enable2;
    this.enableOutEvent = enable2;
    this.enableOverEvent = enable2;
    this.events = (this.options.events || []).concat(MOUSE_EVENTS);
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }
    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }
    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }
    if (eventType === ENTER_EVENT_TYPE) {
      this.enableEnterEvent = enabled;
    }
    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === "mouseover") {
        this._emit(OVER_EVENT_TYPE, event);
      }
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === "mouseout") {
        this._emit(OUT_EVENT_TYPE, event);
      }
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent) {
      if (event.type === "mouseenter") {
        this._emit(ENTER_EVENT_TYPE, event);
      }
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === "mouseleave") {
        this._emit(LEAVE_EVENT_TYPE, event);
      }
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case "mousedown":
          if (event.button >= 0) {
            this.pressed = true;
          }
          break;
        case "mousemove":
          if (event.which === 0) {
            this.pressed = false;
          }
          if (!this.pressed) {
            this._emit(MOVE_EVENT_TYPE, event);
          }
          break;
        case "mouseup":
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: "mouse",
      target: event.target
    });
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/key-input.js
var { KEY_EVENTS } = INPUT_EVENT_TYPES;
var DOWN_EVENT_TYPE = "keydown";
var UP_EVENT_TYPE = "keyup";
var KeyInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
        return;
      }
      if (this.enableDownEvent && event.type === "keydown") {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === "keyup") {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = (this.options.events || []).concat(KEY_EVENTS);
    element.tabIndex = this.options.tabIndex || 0;
    element.style.outline = "none";
    this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }
    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
var EVENT_TYPE2 = "contextmenu";
var ContextmenuInput = class extends Input {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: EVENT_TYPE2,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE2) {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/esm/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS2 = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
var MOUSE_EVENT_WHICH_LEFT = 1;
var MOUSE_EVENT_WHICH_MIDDLE = 2;
var MOUSE_EVENT_WHICH_RIGHT = 3;
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button, which } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
    // button is up, need to find out which one was pressed before
    eventType === UP_EVENT || // moving but does not support `buttons` API
    eventType === MOVE_EVENT && !Number.isFinite(buttons)
  ) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX2 = rect.width / rootElement.offsetWidth || 1;
  const scaleY2 = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY2
  };
  return { center, offsetCenter };
}

// node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
var DEFAULT_OPTIONS = {
  srcElement: "root",
  priority: 0
};
var EventRegistrar = class {
  constructor(eventManager) {
    this.handleEvent = (event) => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, "root");
    };
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = /* @__PURE__ */ new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler5, options, once3 = false, passive = false) {
    const { handlers, handlersByElement } = this;
    let opts = DEFAULT_OPTIONS;
    if (typeof options === "string" || options && options.addEventListener) {
      opts = { ...DEFAULT_OPTIONS, srcElement: options };
    } else if (options) {
      opts = { ...DEFAULT_OPTIONS, ...options };
    }
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type,
      handler: handler5,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once3) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler5) {
    const { handlers, handlersByElement } = this;
    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];
      if (entry.type === type && entry.handler === handler5) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some((entry) => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      const stopPropagation = () => {
        event.handled = true;
      };
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i = 0; i < entries.length; i++) {
        const { type, handler: handler5, once: once3 } = entries[i];
        handler5({
          ...event,
          // @ts-ignore
          type,
          stopPropagation,
          stopImmediatePropagation
        });
        if (once3) {
          entriesToRemove.push(entries[i]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i = 0; i < entriesToRemove.length; i++) {
        const { type, handler: handler5 } = entriesToRemove[i];
        this.remove(type, handler5);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...whichButtons(event),
      ...getOffsetPosition(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement
    };
  }
};

// node_modules/mjolnir.js/dist/esm/event-manager.js
var DEFAULT_OPTIONS2 = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: Manager2,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
var EventManager = class {
  constructor(element = null, options) {
    this._onBasicInput = (event) => {
      const { srcEvent } = event;
      const alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        this.manager.emit(alias, event);
      }
    };
    this._onOtherEvent = (event) => {
      this.manager.emit(event.type, event);
    };
    this.options = { ...DEFAULT_OPTIONS2, ...options };
    this.events = /* @__PURE__ */ new Map();
    this.setElement(element);
    const { events } = this.options;
    if (events) {
      this.on(events);
    }
  }
  getElement() {
    return this.element;
  }
  setElement(element) {
    if (this.element) {
      this.destroy();
    }
    this.element = element;
    if (!element) {
      return;
    }
    const { options } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || RECOGNIZERS
    }).on("hammer.input", this._onBasicInput);
    if (!options.recognizers) {
      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name) => {
        const recognizer = this.manager.get(name);
        if (recognizer) {
          RECOGNIZER_COMPATIBLE_MAP[name].forEach((otherName) => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }
    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);
      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }
    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });
    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }
  // Tear down internal event management implementations.
  destroy() {
    if (this.element) {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler5, opts) {
    this._addEventHandler(event, handler5, opts, false);
  }
  once(event, handler5, opts) {
    this._addEventHandler(event, handler5, opts, true);
  }
  watch(event, handler5, opts) {
    this._addEventHandler(event, handler5, opts, false, true);
  }
  off(event, handler5) {
    this._removeEventHandler(event, handler5);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name, enabled) {
    const { manager } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name);
    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({ enable: enabled });
      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
      if (fallbackRecognizers && !this.options.recognizers) {
        fallbackRecognizers.forEach((otherName) => {
          const otherRecognizer = manager.get(otherName);
          if (enabled) {
            otherRecognizer.requireFailure(name);
            recognizer.dropRequireFailure(otherName);
          } else {
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }
    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler5, opts, once3, passive) {
    if (typeof event !== "string") {
      opts = handler5;
      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once3, passive);
      }
      return;
    }
    const { manager, events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      eventRegistrar = new EventRegistrar(this);
      events.set(eventAlias, eventRegistrar);
      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler5, opts, once3, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler5) {
    if (typeof event !== "string") {
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }
      return;
    }
    const { events } = this;
    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler5);
    if (eventRegistrar.isEmpty()) {
      const { recognizerName } = eventRegistrar;
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/deck.js
function noop4() {
}
var getCursor = ({
  isDragging
}) => isDragging ? "grabbing" : "grab";
var defaultProps = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: noop4,
  onResize: noop4,
  onViewStateChange: noop4,
  onInteractionStateChange: noop4,
  onBeforeRender: noop4,
  onAfterRender: noop4,
  onLoad: noop4,
  onError: (error3) => log_default.error(error3.message, error3.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
var Deck = class {
  constructor(props) {
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "userData", {});
    _defineProperty(this, "canvas", null);
    _defineProperty(this, "viewManager", null);
    _defineProperty(this, "layerManager", null);
    _defineProperty(this, "effectManager", null);
    _defineProperty(this, "deckRenderer", null);
    _defineProperty(this, "deckPicker", null);
    _defineProperty(this, "eventManager", null);
    _defineProperty(this, "tooltip", null);
    _defineProperty(this, "metrics", void 0);
    _defineProperty(this, "animationLoop", void 0);
    _defineProperty(this, "stats", void 0);
    _defineProperty(this, "viewState", void 0);
    _defineProperty(this, "cursorState", void 0);
    _defineProperty(this, "_needsRedraw", void 0);
    _defineProperty(this, "_pickRequest", void 0);
    _defineProperty(this, "_lastPointerDownInfo", null);
    _defineProperty(this, "_metricsCounter", void 0);
    _defineProperty(this, "_onPointerMove", (event) => {
      const {
        _pickRequest
      } = this;
      if (event.type === "pointerleave") {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }
      _pickRequest.event = event;
    });
    _defineProperty(this, "_onEvent", (event) => {
      const eventOptions = EVENTS[event.type];
      const pos = event.offsetCenter;
      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const {
        layer
      } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    });
    _defineProperty(this, "_onPointerDown", (event) => {
      const pos = event.offsetCenter;
      const pickedInfo = this._pick("pickObject", "pickObject Time", {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    });
    this.props = {
      ...defaultProps,
      ...props
    };
    props = this.props;
    this._needsRedraw = "Initial render";
    this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    if (props.viewState && props.initialViewState) {
      log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
    }
    if (getBrowser() === "IE") {
      log_default.warn("IE 11 is not supported")();
    }
    this.viewState = props.initialViewState;
    if (!props.gl) {
      if (typeof document !== "undefined") {
        this.canvas = this._createCanvas(props);
      }
    }
    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new Stats({
      id: "deck.gl"
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      typed_array_manager_default.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  finalize() {
    var _this$animationLoop, _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
    (_this$animationLoop = this.animationLoop) === null || _this$animationLoop === void 0 ? void 0 : _this$animationLoop.stop();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
    this.layerManager = null;
    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
    this.viewManager = null;
    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
    this.effectManager = null;
    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
    this.deckRenderer = null;
    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
    this.deckPicker = null;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
    this.eventManager = null;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
    this.tooltip = null;
    if (!this.props.canvas && !this.props.gl && this.canvas) {
      var _this$canvas$parentEl;
      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  setProps(props) {
    this.stats.get("setProps Time").timeStart();
    if ("onLayerHover" in props) {
      log_default.removed("onLayerHover", "onHover")();
    }
    if ("onLayerClick" in props) {
      log_default.removed("onLayerClick", "onClick")();
    }
    if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop.setProps(resolvedProps);
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
    }
    this.stats.get("setProps Time").timeEnd();
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return "Deck._animate";
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({
      clearRedrawFlags: true
    });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get("Redraw Count").incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    assert10(this.viewManager);
    return this.viewManager.views;
  }
  getViewports(rect) {
    assert10(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  pickObject(opts) {
    const infos = this._pick("pickObject", "pickObject Time", opts).result;
    return infos.length ? infos[0] : null;
  }
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
  }
  pickObjects(opts) {
    return this._pick("pickObjects", "pickObjects Time", opts);
  }
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({
        resourceId: id,
        data: resources[id],
        forceUpdate
      });
    }
  }
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  _addDefaultEffect(effect4) {
    this.effectManager.addDefaultEffect(effect4);
  }
  _pick(method, statKey, opts) {
    assert10(this.deckPicker);
    const {
      stats
    } = this;
    stats.get("Pick Count").incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  _createCanvas(props) {
    let canvas = props.canvas;
    if (typeof canvas === "string") {
      canvas = document.getElementById(canvas);
      assert10(canvas);
    }
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = props.id || "deckgl-overlay";
      const parent = props.parent || document.body;
      parent.appendChild(canvas);
    }
    Object.assign(canvas.style, props.style);
    return canvas;
  }
  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }
    const {
      width,
      height
    } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      var _props$style;
      const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
      this.canvas.style.height = cssHeight;
    }
  }
  _updateCanvasSize() {
    var _canvas$clientWidth, _canvas$clientHeight;
    const {
      canvas
    } = this;
    if (!canvas) {
      return;
    }
    const newWidth = (_canvas$clientWidth = canvas.clientWidth) !== null && _canvas$clientWidth !== void 0 ? _canvas$clientWidth : canvas.width;
    const newHeight = (_canvas$clientHeight = canvas.clientHeight) !== null && _canvas$clientHeight !== void 0 ? _canvas$clientHeight : canvas.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      var _this$viewManager2, _this$layerManager2;
      this.width = newWidth;
      this.height = newHeight;
      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
        width: newWidth,
        height: newHeight
      });
      (_this$layerManager2 = this.layerManager) === null || _this$layerManager2 === void 0 ? void 0 : _this$layerManager2.activateViewport(this.getViewports()[0]);
      this.props.onResize({
        width: newWidth,
        height: newHeight
      });
    }
  }
  _createAnimationLoop(props) {
    const {
      width,
      height,
      gl,
      glOptions,
      debug: debug2,
      onError,
      onBeforeRender,
      onAfterRender,
      useDevicePixels
    } = props;
    return new AnimationLoop({
      width,
      height,
      useDevicePixels,
      autoResizeDrawingBuffer: !gl,
      autoResizeViewport: false,
      gl,
      onCreateContext: (opts) => createGLContext({
        ...glOptions,
        ...opts,
        canvas: this.canvas,
        debug: debug2,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: (context) => this._setGLContext(context.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender,
      onAfterRender,
      onError
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let views = this.props.views || [new MapView({
      id: "default-view"
    })];
    views = Array.isArray(views) ? views : [views];
    if (views.length && this.props.controller) {
      views[0].props.controller = this.props.controller;
    }
    return views;
  }
  _onContextLost() {
    const {
      onError
    } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error("WebGL context is lost"));
    }
  }
  _pickAndCallback() {
    const {
      _pickRequest
    } = this;
    if (_pickRequest.event) {
      const {
        result,
        emptyInfo
      } = this._pick("pickObject", "pickObject Time", _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        var _info$layer;
        pickedInfo = info;
        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
      }
      if (!handled && this.props.onHover) {
        this.props.onHover(pickedInfo, _pickRequest.event);
      }
      if (this.props.getTooltip && this.tooltip) {
        const displayInfo = this.props.getTooltip(pickedInfo);
        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setGLContext(gl) {
    if (this.layerManager) {
      return;
    }
    if (!this.canvas) {
      this.canvas = gl.canvas;
      instrumentGLContext(gl, {
        enable: true,
        copyState: true
      });
    }
    this.tooltip = new Tooltip(this.canvas);
    setParameters(gl, {
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onWebGLInitialized(gl);
    const timeline = new Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new EventManager(this.props.parent || gl.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new ViewManager({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new LayerManager(gl, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new EffectManager();
    this.deckRenderer = new DeckRenderer(gl);
    this.deckPicker = new DeckPicker(gl);
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  _drawLayers(redrawReason, renderOptions) {
    const {
      gl
    } = this.layerManager.context;
    setParameters(gl, this.props.parameters);
    this.props.onBeforeRender({
      gl
    });
    this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...renderOptions
    });
    this.props.onAfterRender({
      gl
    });
  }
  _onRenderFrame(animationProps) {
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      log_default.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
      this.tooltip.setTooltip(null);
    }
    this.layerManager.updateLayers();
    this._pickAndCallback();
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = {
        ...this.viewState,
        [params.viewId]: viewState
      };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({
            viewState: this.viewState
          });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const {
      stats
    } = this;
    stats.get("frameRate").timeEnd();
    stats.get("frameRate").timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
    stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics,
      stats
    } = this;
    metrics.fps = stats.get("frameRate").getHz();
    metrics.setPropsTime = stats.get("setProps Time").time;
    metrics.updateAttributesTime = stats.get("Update Attributes").time;
    metrics.framesRedrawn = stats.get("Redraw Count").count;
    metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
    metrics.pickCount = stats.get("Pick Count").count;
    metrics.gpuTime = stats.get("GPU Time").time;
    metrics.cpuTime = stats.get("CPU Time").time;
    metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
    metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
    const memoryStats = lumaStats.get("Memory Usage");
    metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
    metrics.textureMemory = memoryStats.get("Texture Memory").count;
    metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
    metrics.gpuMemory = memoryStats.get("GPU Memory").count;
  }
};
_defineProperty(Deck, "defaultProps", defaultProps);
_defineProperty(Deck, "VERSION", VERSION6);

// node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
var ShaderAttribute = class {
  constructor(dataColumn, opts) {
    _defineProperty(this, "opts", void 0);
    _defineProperty(this, "source", void 0);
    this.opts = opts;
    this.source = dataColumn;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const buffer = this.source.getBuffer();
    const accessor = this.getAccessor();
    if (buffer) {
      return [buffer, accessor];
    }
    const {
      value
    } = this.source;
    const {
      size: size3
    } = accessor;
    let constantValue = value;
    if (value && value.length !== size3) {
      constantValue = new Float32Array(size3);
      const index = accessor.elementOffset || 0;
      for (let i = 0; i < size3; ++i) {
        constantValue[i] = value[index + i];
      }
    }
    return constantValue;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}

// node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
var DataColumn = class {
  constructor(gl, opts, state) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "size", void 0);
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "value", void 0);
    _defineProperty(this, "doublePrecision", void 0);
    _defineProperty(this, "_buffer", void 0);
    _defineProperty(this, "state", void 0);
    this.gl = gl;
    this.id = opts.id || "";
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === 5130;
    let {
      defaultValue
    } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = 5126;
    } else if (!logicalType && opts.isIndexed) {
      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    } else {
      bufferType = logicalType || 5126;
    }
    let defaultType = glArrayFromType(logicalType || bufferType || 5126);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue,
      logicalType,
      type: bufferType,
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
    this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed,
        type
      } = this.settings;
      this._buffer = new Buffer2(this.gl, {
        id: this.id,
        target: isIndexed ? 34963 : 34962,
        accessor: {
          type
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n) {
    this.state.numInstances = n;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    typed_array_manager_default.release(this.state.allocatedValue);
  }
  getShaderAttributes(id, options) {
    if (this.doublePrecision) {
      const shaderAttributes = {};
      const isBuffer64Bit = this.value instanceof Float64Array;
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
      return shaderAttributes;
    }
    if (options) {
      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
      return {
        [id]: new ShaderAttribute(this, shaderAttributeDef)
      };
    }
    return {
      [id]: this
    };
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue() {
    if (this.state.constant) {
      return this.value;
    }
    return [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min = Array.from(this.value);
      result = [min, min];
    } else {
      const {
        value,
        numInstances,
        size: size3
      } = this;
      const len = numInstances * size3;
      if (value && len && value.length >= len) {
        const min = new Array(size3).fill(Infinity);
        const max = new Array(size3).fill(-Infinity);
        for (let i = 0; i < len; ) {
          for (let j = 0; j < size3; j++) {
            const v = value[i++];
            if (v < min[j])
              min[j] = v;
            if (v > max[j])
              max[j] = v;
          }
        }
        result = [min, max];
      }
    }
    this.state.bounds = result;
    return result;
  }
  setData(data3) {
    const {
      state
    } = this;
    let opts;
    if (ArrayBuffer.isView(data3)) {
      opts = {
        value: data3
      };
    } else if (data3 instanceof Buffer2) {
      opts = {
        buffer: data3
      };
    } else {
      opts = data3;
    }
    const accessor = {
      ...this.settings,
      ...opts
    };
    state.bufferAccessor = accessor;
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged3 = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged3) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = value;
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
      const isBuffer64Bit = opts.value instanceof Float64Array;
      accessor.type = opts.type || buffer.accessor.type;
      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
      accessor.stride = getStride(accessor);
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
      const {
        buffer,
        byteOffset
      } = this;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = toDoublePrecisionArray(value, accessor);
      }
      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
      if (buffer.byteLength < requiredBufferSize) {
        buffer.reallocate(requiredBufferSize);
      }
      buffer.setAccessor(null);
      buffer.subData({
        data: value,
        offset: byteOffset
      });
      accessor.type = opts.type || buffer.accessor.type;
    }
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const {
      startOffset = 0,
      endOffset
    } = opts;
    this.buffer.subData({
      data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
        size: this.size,
        startIndex: startOffset,
        endIndex: endOffset
      }) : value.subarray(startOffset, endOffset),
      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(numInstances, copy2 = false) {
    const {
      state
    } = this;
    const oldValue = state.allocatedValue;
    const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: copy2
    });
    this.value = value;
    const {
      buffer,
      byteOffset
    } = this;
    if (buffer.byteLength < value.byteLength + byteOffset) {
      buffer.reallocate(value.byteLength + byteOffset);
      if (copy2 && oldValue) {
        buffer.subData({
          data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
          offset: byteOffset
        });
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    state.bufferAccessor = this.settings;
    return true;
  }
  _checkExternalBuffer(opts) {
    const {
      value
    } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    }
    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
    }
    if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
      log_default.warn("Attribute ".concat(this.id, " is normalized"))();
    }
  }
  normalizeConstant(value) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(value).map((x) => (x + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(value).map((x) => (x + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(value).map((x) => x / 255);
      case 5123:
        return new Float32Array(value).map((x) => x / 65535);
      default:
        return value;
    }
  }
  _normalizeValue(value, out, start3) {
    const {
      defaultValue,
      size: size3
    } = this.settings;
    if (Number.isFinite(value)) {
      out[start3] = value;
      return out;
    }
    if (!value) {
      let i = size3;
      while (--i >= 0) {
        out[start3 + i] = defaultValue[i];
      }
      return out;
    }
    switch (size3) {
      case 4:
        out[start3 + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start3 + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start3 + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start3 + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i = size3;
        while (--i >= 0) {
          out[start3 + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const {
      size: size3
    } = this;
    for (let i = 0; i < size3; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
var EMPTY_ARRAY = [];
var placeholderArray = [];
function createIterable(data3, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data: data3,
    target: []
  };
  if (!data3) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data3[Symbol.iterator] === "function") {
    iterable = data3;
  } else if (data3.length > 0) {
    placeholderArray.length = data3.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable2(data3) {
  return data3 && data3[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const {
    size: size3,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size3;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j = 0; j < size3; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size3);
        for (let j = 0; j < size3; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size3) {
      result = typedArray.subarray(startIndex * size3 + elementOffset, endIndex * size3 + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size3);
      let targetIndex = 0;
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        for (let j = 0; j < size3; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }
    return result;
  };
}

// node_modules/@deck.gl/core/dist/esm/utils/range.js
var EMPTY = [];
var FULL = [[0, Infinity]];
function add4(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;
  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}

// node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
function padArrayChunk(options) {
  const {
    source,
    target,
    start: start3 = 0,
    size: size3,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start3;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start3);
    return;
  }
  target.set(source, start3);
  if (!getData) {
    return;
  }
  let i = sourceLength;
  while (i < targetLength) {
    const datum = getData(i, source);
    for (let j = 0; j < size3; j++) {
      target[start3 + i] = datum[j] || 0;
      i++;
    }
  }
}
function padArray({
  source,
  target,
  size: size3,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size: size3,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size3;
    const nextTargetIndex = targetStartIndices[i] * size3;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size: size3,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size: size3,
      getData: getChunkData
    });
  }
  return target;
}

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
var DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: (t) => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = {
      type: "interpolation",
      duration: userSettings
    };
  }
  const type = userSettings.type || "interpolation";
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();
  if (buffer) {
    return [buffer, {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }
  return attribute.value;
}
function getAttributeTypeFromSize(size3) {
  switch (size3) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(size3, '"'));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size: size3
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size3) * multiplier;
}
function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = (x) => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size3 = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }
  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size3), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data3 = new Float32Array(toLength);
  padArray({
    source,
    target: data3,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size: size3,
    getData: getMissingData
  });
  if (buffer.byteLength < data3.byteLength + byteOffset) {
    buffer.reallocate(data3.byteLength + byteOffset);
  }
  buffer.subData({
    data: data3,
    offset: byteOffset
  });
}

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
var Attribute = class extends DataColumn {
  constructor(gl, opts) {
    super(gl, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      updateRanges: FULL
    });
    _defineProperty(this, "constant", false);
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({
    clearChangedFlags = false
  } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  getUpdateTriggers() {
    const {
      accessor
    } = this.settings;
    return [this.id].concat(typeof accessor !== "function" && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const {
      accessor
    } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? opts[accessor.find((a) => opts[a])] : opts[accessor];
    return normalizeTransitionSettings(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange;
      this.state.updateRanges = add4(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const {
      state,
      settings
    } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== FULL);
      return true;
    }
    return false;
  }
  updateBuffer({
    numInstances,
    data: data3,
    props,
    context
  }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const {
      state: {
        updateRanges
      },
      settings: {
        update,
        noAlloc
      }
    } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, {
          data: data3,
          startRow,
          endRow,
          props,
          numInstances
        });
      }
      if (!this.value) {
      } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({
            startOffset,
            endOffset
          });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  setConstantValue(value) {
    if (value === void 0 || typeof value === "function") {
      return false;
    }
    const hasChanged3 = this.setData({
      constant: true,
      value
    });
    if (hasChanged3) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  setExternalBuffer(buffer) {
    const {
      state
    } = this;
    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer) {
      return true;
    }
    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }
  setBinaryValue(buffer, startIndices = null) {
    const {
      state,
      settings
    } = this;
    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = {
          value: buffer
        };
      }
      const binaryValue = buffer;
      assert10(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }
  getVertexOffset(row) {
    const {
      startIndices
    } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getShaderAttributes() {
    const shaderAttributeDefs = this.settings.shaderAttributes || {
      [this.id]: null
    };
    const shaderAttributes = {};
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return shaderAttributes;
  }
  _autoUpdater(attribute, {
    data: data3,
    startRow,
    endRow,
    props,
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const {
      settings,
      state,
      value,
      size: size3,
      startIndices
    } = attribute;
    const {
      accessor,
      transform: transform2
    } = settings;
    const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
    assert10(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
    let i = attribute.getVertexOffset(startRow);
    const {
      iterable,
      objectInfo
    } = createIterable(data3, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);
      if (transform2) {
        objectValue = transform2.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size3;
          }
        } else if (objectValue && objectValue.length > size3) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          fillArray2({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }
        i += numVertices * size3;
      } else {
        attribute._normalizeValue(objectValue, value, i);
        i += size3;
      }
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings
    } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === "function";
    if (!hasUpdater) {
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
  }
  _checkAttributeArray() {
    const {
      value
    } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
var GPUInterpolationTransition = class {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "type", "interpolation");
    _defineProperty(this, "attributeInTransition", void 0);
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "attribute", void 0);
    _defineProperty(this, "transition", void 0);
    _defineProperty(this, "currentStartIndices", void 0);
    _defineProperty(this, "currentLength", void 0);
    _defineProperty(this, "transform", void 0);
    _defineProperty(this, "buffers", void 0);
    this.gl = gl;
    this.transition = new Transition(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new Attribute(gl, attribute.settings);
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.transform = getTransform(gl, attribute);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = transitionSettings;
    const {
      gl,
      buffers,
      attribute
    } = this;
    cycleBuffers(buffers);
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      padBuffer({
        buffer,
        ...padBufferOpts
      });
    }
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = getAttributeBufferLength(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aFrom: buffers[0],
        aTo: getSourceBufferAttribute(gl, attribute)
      },
      feedbackBuffers: {
        vCurrent: buffers[1]
      }
    });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      const {
        duration,
        easing
      } = this.settings;
      const {
        time
      } = this.transition;
      let t = time / duration;
      if (easing) {
        t = easing(t);
      }
      this.transform.run({
        uniforms: {
          time: t
        }
      });
    }
    return updated;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
  }
};
var vs6 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
function getTransform(gl, attribute) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform(gl, {
    vs: vs6,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"]
  });
}

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
var GPUSpringTransition = class {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "type", "spring");
    _defineProperty(this, "attributeInTransition", void 0);
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "attribute", void 0);
    _defineProperty(this, "transition", void 0);
    _defineProperty(this, "currentStartIndices", void 0);
    _defineProperty(this, "currentLength", void 0);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "framebuffer", void 0);
    _defineProperty(this, "transform", void 0);
    _defineProperty(this, "buffers", void 0);
    this.gl = gl;
    this.type = "spring";
    this.transition = new Transition(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new Attribute(gl, {
      ...attribute.settings,
      normalized: false
    });
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.texture = getTexture(gl);
    this.framebuffer = getFramebuffer2(gl, this.texture);
    this.transform = getTransform2(gl, attribute, this.framebuffer);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    const {
      gl,
      buffers,
      attribute
    } = this;
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      padBuffer({
        buffer,
        ...padBufferOpts
      });
    }
    this.settings = transitionSettings;
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = getAttributeBufferLength(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start({
      ...transitionSettings,
      duration: Infinity
    });
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aTo: getSourceBufferAttribute(gl, attribute)
      }
    });
  }
  update() {
    const {
      buffers,
      transform: transform2,
      framebuffer,
      transition: transition3
    } = this;
    const updated = transition3.update();
    if (!updated) {
      return false;
    }
    const settings = this.settings;
    transform2.update({
      sourceBuffers: {
        aPrev: buffers[0],
        aCur: buffers[1]
      },
      feedbackBuffers: {
        vNext: buffers[2]
      }
    });
    transform2.run({
      framebuffer,
      discard: false,
      clearRenderTarget: true,
      uniforms: {
        stiffness: settings.stiffness,
        damping: settings.damping
      },
      parameters: {
        depthTest: false,
        blend: true,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    });
    cycleBuffers(buffers);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: this.attribute.value
    });
    const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition3.end();
    }
    return true;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
    this.texture.delete();
    this.framebuffer.delete();
  }
};
function getTransform2(gl, attribute, framebuffer) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vNext"]
  });
}
function getTexture(gl) {
  return new Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function getFramebuffer2(gl, texture) {
  return new Framebuffer(gl, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES = {
  interpolation: GPUInterpolationTransition,
  spring: GPUSpringTransition
};
var AttributeTransitionManager = class {
  constructor(gl, {
    id,
    timeline
  }) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "isSupported", void 0);
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "timeline", void 0);
    _defineProperty(this, "transitions", void 0);
    _defineProperty(this, "needsRedraw", void 0);
    _defineProperty(this, "numInstances", void 0);
    this.id = id;
    this.gl = gl;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
    this.isSupported = Transform.isSupported(gl);
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  update({
    attributes,
    transitions,
    numInstances
  }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings)
        continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  hasAttribute(attributeName) {
    const transition3 = this.transitions[attributeName];
    return transition3 && transition3.inProgress;
  }
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition3 = this.transitions[attributeName];
      if (transition3.inProgress) {
        animatedAttributes[attributeName] = transition3.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  _removeTransition(attributeName) {
    this.transitions[attributeName].cancel();
    delete this.transitions[attributeName];
  }
  _updateAttribute(attributeName, attribute, settings) {
    const transition3 = this.transitions[attributeName];
    let isNew = !transition3 || transition3.type !== settings.type;
    if (isNew) {
      if (!this.isSupported) {
        log_default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
        return;
      }
      if (transition3) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          gl: this.gl
        });
      } else {
        log_default.error("unsupported transition type '".concat(settings.type, "'"))();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE = "attributeManager.invalidate";
var TRACE_UPDATE_START = "attributeManager.updateStart";
var TRACE_UPDATE_END = "attributeManager.updateEnd";
var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
var AttributeManager = class {
  constructor(gl, {
    id = "attribute-manager",
    stats,
    timeline
  } = {}) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "attributes", void 0);
    _defineProperty(this, "updateTriggers", void 0);
    _defineProperty(this, "needsRedraw", void 0);
    _defineProperty(this, "userData", void 0);
    _defineProperty(this, "stats", void 0);
    _defineProperty(this, "attributeTransitionManager", void 0);
    _defineProperty(this, "mergeBoundsMemoized", memoize(mergeBounds));
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new AttributeTransitionManager(gl, {
      id: "".concat(id, "-transitions"),
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  add(attributes) {
    this._add(attributes);
  }
  addInstanced(attributes) {
    this._add(attributes, {
      instanced: 1
    });
  }
  remove(attributeNameArray) {
    for (const name of attributeNameArray) {
      if (this.attributes[name] !== void 0) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    debug(TRACE_INVALIDATE, this, "all");
  }
  update({
    data: data3,
    numInstances,
    startIndices = null,
    transitions,
    props = {},
    buffers = {},
    context = {}
  }) {
    let updated = false;
    debug(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get("Update Attributes").timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) {
      } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data3.startIndices)) {
      } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
      } else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data: data3,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      debug(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get("Update Attributes").timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager
    } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(attributeNames) {
    const bounds = attributeNames.map((attributeName) => {
      var _this$attributes$attr;
      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
    });
    return this.mergeBoundsMemoized(bounds);
  }
  getChangedAttributes(opts = {
    clearChangedFlags: false
  }) {
    const {
      attributes,
      attributeTransitionManager
    } = this;
    const changedAttributes = {
      ...attributeTransitionManager.getAttributes()
    };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  getShaderAttributes(attributes, excludeAttributes = {}) {
    if (!attributes) {
      attributes = this.getAttributes();
    }
    const shaderAttributes = {};
    for (const attributeName in attributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
      }
    }
    return shaderAttributes;
  }
  _add(attributes, extraProps = {}) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(name, attribute, extraProps) {
    const props = {
      ...attribute,
      id: name,
      size: attribute.isIndexed && 1 || attribute.size || 1,
      divisor: extraProps.instanced ? 1 : attribute.divisor || 0
    };
    return new Attribute(this.gl, props);
  }
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach((triggerName) => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const {
      attributes,
      updateTriggers
    } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach((name) => {
        const attribute = attributes[name];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const {
      attribute,
      numInstances
    } = opts;
    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition = class extends Transition {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time,
      settings: {
        fromValue,
        toValue,
        duration,
        easing
      }
    } = this;
    const t = easing(time / duration);
    this._value = lerp(fromValue, toValue, t);
  }
};

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
var EPSILON2 = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
var CPUSpringTransition = class extends Transition {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue,
      toValue,
      damping,
      stiffness
    } = this.settings;
    const {
      _prevValue = fromValue,
      _currValue = fromValue
    } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);
    if (delta < EPSILON2 && velocity < EPSILON2) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
var TRANSITION_TYPES2 = {
  interpolation: CPUInterpolationTransition,
  spring: CPUSpringTransition
};
var UniformTransitionManager = class {
  constructor(timeline) {
    this.transitions = /* @__PURE__ */ new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      const transition4 = transitions.get(key);
      const {
        value = transition4.settings.fromValue
      } = transition4;
      fromValue = value;
      this.remove(key);
    }
    settings = normalizeTransitionSettings(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES2[settings.type];
    if (!TransitionType) {
      log_default.error("unsupported transition type '".concat(settings.type, "'"))();
      return;
    }
    const transition3 = new TransitionType(this.timeline);
    transition3.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition3);
  }
  remove(key) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition3] of this.transitions) {
      transition3.update();
      propsInTransition[key] = transition3.value;
      if (!transition3.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
function validateProps(props) {
  const propTypes = props[PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate: validate2
    } = propType;
    if (validate2 && !validate2(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[PROP_TYPES_SYMBOL],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = "props"
}) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== "object" || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  if (typeof oldProps !== "object" || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  let dataChanged = false;
  const {
    dataComparator,
    _dataDiff
  } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return {
      all: true
    };
  }
  if ("all" in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return {
        all: true
      };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}

// node_modules/@deck.gl/core/dist/esm/utils/count.js
var ERR_NOT_OBJECT = "count(): argument not an object";
var ERR_NOT_CONTAINER = "count(): argument not a container";
function count(container) {
  if (!isObject4(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object;
}
function isObject4(value) {
  return value !== null && typeof value === "object";
}

// node_modules/@deck.gl/core/dist/esm/utils/shader.js
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  const result = {
    ...target,
    ...source
  };
  if ("defines" in source) {
    result.defines = {
      ...target.defines,
      ...source.defines
    };
  }
  if ("modules" in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some((module) => module.name === "project64")) {
      const index = result.modules.findIndex((module) => module.name === "project32");
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ("inject" in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = {
        ...target.inject
      };
      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}

// node_modules/@deck.gl/core/dist/esm/utils/texture.js
var DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
var internalTextures = {};
function createTexture(owner, gl, image, parameters) {
  if (image instanceof Texture2D) {
    return image;
  } else if (image.constructor && image.constructor.name !== "Object") {
    image = {
      data: image
    };
  }
  let specialTextureParameters = null;
  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }
  const texture = new Texture2D(gl, {
    ...image,
    parameters: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...parameters
    }
  });
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof Texture2D)) {
    return;
  }
  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}

// node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
var TYPE_DEFINITIONS2 = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray6(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return deepEqual(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf2(value);
      return valueType === "function" || valueType === getTypeOf2(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === "function") {
        return true;
      }
      return deepEqual(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray6(value);
    },
    equal(value1, value2, propType) {
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === "function";
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      const {
        dataTransform
      } = component.props;
      return dataTransform && value ? dataTransform(value) : value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.gl) {
        return null;
      }
      return createTexture(component.id, context.gl, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: (value, propType, component) => {
      destroyTexture(component.id, value);
    }
  }
};
function parsePropTypes2(propDefs) {
  const propTypes = {};
  const defaultProps12 = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType2(propName, propDef);
      propTypes[propName] = propType;
      defaultProps12[propName] = propType.value;
    }
  }
  return {
    propTypes,
    defaultProps: defaultProps12,
    deprecatedProps
  };
}
function parsePropType2(name, propDef) {
  switch (getTypeOf2(propDef)) {
    case "object":
      return normalizePropDefinition(name, propDef);
    case "array":
      return normalizePropDefinition(name, {
        type: "array",
        value: propDef,
        compare: false
      });
    case "boolean":
      return normalizePropDefinition(name, {
        type: "boolean",
        value: propDef
      });
    case "number":
      return normalizePropDefinition(name, {
        type: "number",
        value: propDef
      });
    case "function":
      return normalizePropDefinition(name, {
        type: "function",
        value: propDef,
        compare: true
      });
    default:
      return {
        name,
        type: "unknown",
        value: propDef
      };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return {
        name,
        type: "object",
        value: propDef
      };
    }
    return {
      name,
      type: getTypeOf2(propDef.value),
      ...propDef
    };
  }
  return {
    name,
    ...TYPE_DEFINITIONS2[propDef.type],
    ...propDef
  };
}
function isArray6(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf2(value) {
  if (isArray6(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
}

// node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
function createProps(component, propObjects) {
  let extensions;
  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];
    if ("extensions" in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT_SYMBOL] = component;
  propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
      }
    }
  }
  const defaultProps12 = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps12) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps12;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  const componentPropDefs = parsePropTypes2(componentDefaultProps);
  const defaultProps12 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps12, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps12, componentClass);
  addAsyncPropsToPropPrototype(defaultProps12, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps12, deprecatedProps);
  defaultProps12[PROP_TYPES_SYMBOL] = propTypes;
  defaultProps12[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty3(componentClass, "_propTypes")) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps12;
}
function createPropsPrototype(defaultProps12, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps12, {
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps12, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps12, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty3(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps12, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;
    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }
  defaultProps12[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps12[ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps12, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    set(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
        this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },
    get() {
      if (this[ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[ASYNC_RESOLVED_SYMBOL]) {
          const value = this[ASYNC_RESOLVED_SYMBOL][name];
          return value || this[ASYNC_DEFAULTS_SYMBOL][name];
        }
        if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }
      return this[ASYNC_DEFAULTS_SYMBOL][name];
    }
  };
}
function hasOwnProperty3(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty3(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = componentClass.componentName;
  if (!componentName) {
    log_default.warn("".concat(componentClass.name, ".componentName not specified"))();
  }
  return componentName || componentClass.name;
}

// node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
var counter = 0;
var Component = class {
  constructor(...propObjects) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "count", void 0);
    this.props = createProps(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  clone(newProps) {
    const {
      props
    } = this;
    const asyncProps = {};
    for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({
      ...props,
      ...asyncProps,
      ...newProps
    });
  }
};
_defineProperty(Component, "componentName", "Component");
_defineProperty(Component, "defaultProps", {});

// node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
var EMPTY_PROPS = Object.freeze({});
var ComponentState = class {
  constructor(component) {
    _defineProperty(this, "component", void 0);
    _defineProperty(this, "onAsyncPropUpdated", void 0);
    _defineProperty(this, "asyncProps", void 0);
    _defineProperty(this, "oldProps", void 0);
    _defineProperty(this, "oldAsyncProps", void 0);
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {
    };
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  setAsyncProps(props) {
    this.component = props[COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {
  }
  _onError(propName, error3) {
  }
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === "string") {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if (isAsyncIterable2(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then((data3) => {
        if (!this.component) {
          return;
        }
        data3 = this._postProcessValue(asyncProp, data3);
        this._setAsyncPropValue(propName, data3, loadCount);
        this._onResolve(propName, data3);
      }).catch((error3) => {
        this._onError(propName, error3);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== "data") {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data3 = [];
    let count2 = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const {
        dataTransform
      } = this.component.props;
      if (dataTransform) {
        data3 = dataTransform(chunk, data3);
      } else {
        data3 = data3.concat(chunk);
      }
      Object.defineProperty(data3, "__diff", {
        enumerable: false,
        value: [{
          startRow: count2,
          endRow: data3.length
        }]
      });
      count2 = data3.length;
      this._setAsyncPropValue(propName, data3, loadCount);
    }
    this._onResolve(propName, data3);
  }
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
var LayerState = class extends ComponentState {
  constructor({
    attributeManager,
    layer
  }) {
    super(layer);
    _defineProperty(this, "attributeManager", void 0);
    _defineProperty(this, "needsRedraw", void 0);
    _defineProperty(this, "needsUpdate", void 0);
    _defineProperty(this, "subLayers", void 0);
    _defineProperty(this, "usesPickingColorCache", void 0);
    _defineProperty(this, "hasPickingBuffer", void 0);
    _defineProperty(this, "changeFlags", void 0);
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "uniformTransitions", void 0);
    _defineProperty(this, "propsInTransition", void 0);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch2 = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
    if (fetch2) {
      return fetch2(url, {
        propName,
        layer
      });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === "data" && onDataLoad) {
        onDataLoad(value, {
          propName,
          layer
        });
      }
    }
  }
  _onError(propName, error3) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error3, "loading ".concat(propName, " of ").concat(this.layer));
    }
  }
};

// node_modules/@deck.gl/core/dist/esm/lib/layer.js
var TRACE_CHANGE_FLAG = "layer.changeFlag";
var TRACE_INITIALIZE = "layer.initialize";
var TRACE_UPDATE = "layer.update";
var TRACE_FINALIZE = "layer.finalize";
var TRACE_MATCHED = "layer.matched";
var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
var EMPTY_ARRAY2 = Object.freeze([]);
var areViewportsEqual = memoize(({
  oldViewport,
  viewport
}) => {
  return oldViewport.equals(viewport);
});
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps2 = {
  data: {
    type: "data",
    value: EMPTY_ARRAY2,
    async: true
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: true
  },
  _dataDiff: {
    type: "function",
    value: (data3) => data3 && data3.__diff,
    optional: true
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: true
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: true
  },
  onError: {
    type: "function",
    value: null,
    optional: true
  },
  fetch: {
    type: "function",
    value: (url, {
      propName,
      layer,
      loaders,
      loadOptions,
      signal
    }) => {
      const {
        resourceManager
      } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        var _loadOptions;
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({
          resourceId: url,
          data: load(url, loaders),
          persistent: false
        });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: (data3) => {
            var _layer$internalState;
            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data3);
          },
          consumerId: layer.id,
          requestId: propName
        });
      }
      return load(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  visible: true,
  pickable: false,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: true
  },
  onClick: {
    type: "function",
    value: null,
    optional: true
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: true
  },
  onDrag: {
    type: "function",
    value: null,
    optional: true
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: true
  },
  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: true,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: true,
    ignore: true
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: true,
    ignore: true
  },
  getPolygonOffset: {
    type: "function",
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100]
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
var Layer = class extends Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "internalState", null);
    _defineProperty(this, "lifecycle", LIFECYCLE.NO_STATE);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "parent", null);
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }
  project(xyz) {
    assert10(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = getWorldPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }
  unproject(xy) {
    assert10(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  projectPosition(xyz, params) {
    assert10(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return projectPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  get isComposite() {
    return false;
  }
  setState(partialState) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem
    } = this.props;
    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
  }
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }
  decodePickingColor(color) {
    assert10(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== void 0) {
      return this.state.numInstances;
    }
    return count(this.props.data);
  }
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["positions", "instancePositions"]);
  }
  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const {
      dataChanged
    } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const {
        props
      } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const {
          pickingColors,
          instancePickingColors
        } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.delete();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({
        consumerId: this.id
      });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }
  getPickingInfo({
    info,
    mode,
    sourceLayer
  }) {
    const {
      index
    } = info;
    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }
    return info;
  }
  raiseError(error3, message) {
    var _this$props$onError, _this$props;
    if (message) {
      error3 = new Error("".concat(message, ": ").concat(error3.message), {
        cause: error3
      });
    }
    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error3))) {
      var _this$context, _this$context$onError;
      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error3, this);
    }
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  hasUniformTransition() {
    var _this$internalState;
    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
  }
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({
      oldViewport,
      viewport
    })) {
      this.setChangeFlags({
        viewportChanged: true
      });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  invalidateAttribute(name = "all") {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name === "all") {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }
  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }
      return props;
    }
    return this.props;
  }
  calculateInstancePickingColors(attribute, {
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 3);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
      }
      pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
        size: 3,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 3);
      const pickingColor = [];
      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 3 + 0] = pickingColor[0];
        pickingColorCache[i * 3 + 1] = pickingColor[1];
        pickingColorCache[i * 3 + 2] = pickingColor[2];
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 3);
  }
  _setModelAttributes(model, changedAttributes) {
    const attributeManager = this.getAttributeManager();
    const excludeAttributes = model.userData.excludeAttributes || {};
    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
    model.setAttributes(shaderAttributes);
  }
  disablePickingIndex(objectIndex) {
    const data3 = this.props.data;
    if (!("attributes" in data3)) {
      this._disablePickingIndex(objectIndex);
      return;
    }
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const externalColorAttribute = colors && data3.attributes && data3.attributes[colors.id];
    if (externalColorAttribute && externalColorAttribute.value) {
      const values = externalColorAttribute.value;
      const objectColor = this.encodePickingColor(objectIndex);
      for (let index = 0; index < data3.length; index++) {
        const i = colors.getVertexOffset(index);
        if (values[i] === objectColor[0] && values[i + 1] === objectColor[1] && values[i + 2] === objectColor[2]) {
          this._disablePickingIndex(index);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  _disablePickingIndex(objectIndex) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start3 = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start3),
      offset: start3
    });
  }
  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({
      startOffset: 0
    });
  }
  _initialize() {
    assert10(!this.internalState);
    assert10(Number.isFinite(this.props.coordinateSystem));
    debug(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new LayerState({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, "attributeManager", {
      get: () => {
        log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  _transferState(oldLayer) {
    debug(TRACE_MATCHED, this, this === oldLayer);
    const {
      state,
      internalState
    } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    debug(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error3) {
        }
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  _finalize() {
    debug(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  _drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    const opacity = this.props.opacity;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);
    try {
      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }
      const {
        getPolygonOffset
      } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      setParameters(context.gl, {
        polygonOffset: offsets
      });
      withParameters(context.gl, parameters, () => {
        const opts = {
          moduleParameters,
          uniforms,
          parameters,
          context
        };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }
  getChangeFlags() {
    var _this$internalState2;
    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
  }
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const {
      changeFlags
    } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case "dataChanged":
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          debug(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  _diffProps(newProps, oldProps) {
    const changeFlags = diffProps(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        var _newProps$transitions;
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  validateProps() {
    validateProps(this.props);
  }
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  _updateAutoHighlight(info) {
    const pickingModuleParameters = {
      pickingSelectedColor: info.picked ? info.color : null
    };
    const {
      highlightColor
    } = this.props;
    if (info.picked && typeof highlightColor === "function") {
      pickingModuleParameters.pickingHighlightColor = highlightColor(info);
    }
    this.setModuleParameters(pickingModuleParameters);
    this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const context = this.context;
    return new AttributeManager(context.gl, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  _postUpdate(updateParams, forceUpdate) {
    const {
      props,
      oldProps
    } = updateParams;
    this.setNeedsRedraw();
    this._updateAttributes();
    const {
      model
    } = this.state;
    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight,
      highlightedObjectIndex,
      highlightColor
    } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const parameters = {};
      if (!autoHighlight) {
        parameters.pickingSelectedColor = null;
      }
      if (Array.isArray(highlightColor)) {
        parameters.pickingHighlightColor = highlightColor;
      }
      if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setModuleParameters(parameters);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
};
_defineProperty(Layer, "defaultProps", defaultProps2);
_defineProperty(Layer, "layerName", "Layer");

// node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js
var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
var CompositeLayer = class extends Layer {
  get isComposite() {
    return true;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(context) {
  }
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  getPickingInfo({
    info
  }) {
    const {
      object
    } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }
  filterSubLayer(context) {
    return true;
  }
  shouldRenderSubLayer(subLayerId, data3) {
    return data3 && data3.length;
  }
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const {
      _subLayerProps: overridingProps
    } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  getSubLayerAccessor(accessor) {
    if (typeof accessor === "function") {
      const objectInfo = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (x, i) => {
        if (x && x.__source) {
          objectInfo.index = x.__source.index;
          return accessor(x.__source.object, objectInfo);
        }
        return accessor(x, i);
      };
    }
    return accessor;
  }
  getSubLayerProps(sublayerProps = {}) {
    var _this$props$updateTri;
    const {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch: fetch2,
      operation,
      _subLayerProps: overridingProps
    } = this.props;
    const newProps = {
      id: "",
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch: fetch2,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || "sublayer";
    if (overridingSublayerProps) {
      const propTypes = this.props[PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];
        if (propType && propType.type === "accessor") {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(newProps, sublayerProps, overridingSublayerProps);
    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
    newProps.updateTriggers = {
      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = flatten(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
};
_defineProperty(CompositeLayer, "layerName", "CompositeLayer");

// node_modules/@deck.gl/core/dist/esm/utils/tesselator.js
var Tesselator = class {
  constructor(opts) {
    _defineProperty(this, "opts", void 0);
    _defineProperty(this, "typedArrayManager", void 0);
    _defineProperty(this, "indexStarts", [0]);
    _defineProperty(this, "vertexStarts", [0]);
    _defineProperty(this, "vertexCount", 0);
    _defineProperty(this, "instanceCount", 0);
    _defineProperty(this, "attributes", void 0);
    _defineProperty(this, "_attributeDefs", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "getGeometry", void 0);
    _defineProperty(this, "geometryBuffer", void 0);
    _defineProperty(this, "buffers", void 0);
    _defineProperty(this, "positionSize", void 0);
    _defineProperty(this, "normalize", void 0);
    const {
      attributes = {}
    } = opts;
    this.typedArrayManager = typed_array_manager_default;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const {
      data: data3,
      buffers = {},
      getGeometry,
      geometryBuffer,
      positionFormat,
      dataChanged,
      normalize: normalize2 = true
    } = this.opts;
    this.data = data3;
    this.getGeometry = getGeometry;
    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize2;
    if (geometryBuffer) {
      assert10(data3.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize2) {
        buffers.positions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.positions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({
    startRow,
    endRow
  }) {
    this._rebuildGeometry({
      startRow,
      endRow
    });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return getAccessorFromBuffer(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  _allocate(instanceCount, copy2) {
    const {
      attributes,
      buffers,
      _attributeDefs,
      typedArrayManager
    } = this;
    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy2;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }
  _forEachGeometry(visitor, startRow, endRow) {
    const {
      data: data3,
      getGeometry
    } = this;
    const {
      iterable,
      objectInfo
    } = createIterable(data3, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let {
      indexStarts,
      vertexStarts,
      instanceCount
    } = this;
    const {
      data: data3,
      geometryBuffer
    } = this;
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data3.startIndices;
      instanceCount = vertexStarts[data3.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof Buffer2) {
        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
};

// node_modules/@deck.gl/google-maps/dist/esm/utils.js
var MAX_LATITUDE2 = 85.05113;
function createDeckInstance(map2, overlay, deck, props) {
  if (deck) {
    if (deck.userData._googleMap === map2) {
      return deck;
    }
    destroyDeckInstance(deck);
  }
  const eventListeners = {
    click: null,
    rightclick: null,
    dblclick: null,
    mousemove: null,
    mouseout: null
  };
  const newDeck = new Deck({
    ...props,
    useDevicePixels: props.interleaved ? true : props.useDevicePixels,
    style: props.interleaved ? null : {
      pointerEvents: "none"
    },
    parent: getContainer(overlay, props.style),
    initialViewState: {
      longitude: 0,
      latitude: 0,
      zoom: 1
    },
    controller: false
  });
  for (const eventType in eventListeners) {
    eventListeners[eventType] = map2.addListener(eventType, (evt) => handleMouseEvent(newDeck, eventType, evt));
  }
  newDeck.userData._googleMap = map2;
  newDeck.userData._eventListeners = eventListeners;
  return newDeck;
}
function getContainer(overlay, style) {
  const container = document.createElement("div");
  container.style.position = "absolute";
  Object.assign(container.style, style);
  if ("getPanes" in overlay) {
    var _overlay$getPanes;
    (_overlay$getPanes = overlay.getPanes()) === null || _overlay$getPanes === void 0 ? void 0 : _overlay$getPanes.overlayLayer.appendChild(container);
  } else {
    var _overlay$getMap;
    (_overlay$getMap = overlay.getMap()) === null || _overlay$getMap === void 0 ? void 0 : _overlay$getMap.getDiv().appendChild(container);
  }
  return container;
}
function destroyDeckInstance(deck) {
  const {
    _eventListeners: eventListeners
  } = deck.userData;
  for (const eventType in eventListeners) {
    if (eventListeners[eventType]) {
      eventListeners[eventType].remove();
    }
  }
  deck.finalize();
}
function getViewPropsFromOverlay(map2, overlay) {
  const {
    width,
    height
  } = getMapSize(map2);
  const projection = overlay.getProjection();
  const bounds = map2.getBounds();
  if (!bounds) {
    return {
      width,
      height,
      left: 0,
      top: 0
    };
  }
  const ne = bounds.getNorthEast();
  const sw = bounds.getSouthWest();
  const topRight = projection.fromLatLngToDivPixel(ne);
  const bottomLeft = projection.fromLatLngToDivPixel(sw);
  const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);
  const centerH = new google.maps.LatLng(0, centerLngLat[0]);
  const centerContainerPx = projection.fromLatLngToContainerPixel(centerH);
  const centerDivPx = projection.fromLatLngToDivPixel(centerH);
  if (!topRight || !bottomLeft || !centerDivPx || !centerContainerPx) {
    return {
      width,
      height,
      left: 0,
      top: 0
    };
  }
  const leftOffset = Math.round(centerDivPx.x - centerContainerPx.x);
  let topOffset = centerDivPx.y - centerContainerPx.y;
  const topLngLat = pixelToLngLat(projection, width / 2, 0);
  const bottomLngLat = pixelToLngLat(projection, width / 2, height);
  let latitude = centerLngLat[1];
  const longitude = centerLngLat[0];
  if (Math.abs(latitude) > MAX_LATITUDE2) {
    latitude = latitude > 0 ? MAX_LATITUDE2 : -MAX_LATITUDE2;
    const center = new google.maps.LatLng(latitude, longitude);
    const centerPx = projection.fromLatLngToContainerPixel(center);
    topOffset += centerPx.y - height / 2;
  }
  topOffset = Math.round(topOffset);
  const delta = new Vector2(topLngLat).sub(bottomLngLat);
  let bearing = 180 * delta.verticalAngle() / Math.PI;
  if (bearing < 0)
    bearing += 360;
  const heading = map2.getHeading() || 0;
  let zoom = map2.getZoom() - 1;
  let scale3;
  if (bearing === 0) {
    scale3 = height ? (bottomLeft.y - topRight.y) / height : 1;
  } else if (bearing === heading) {
    const viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();
    const mapDiagonal = new Vector2([width, -height]).len();
    scale3 = mapDiagonal ? viewDiagonal / mapDiagonal : 1;
  }
  zoom += Math.log2(scale3 || 1);
  return {
    width,
    height,
    left: leftOffset,
    top: topOffset,
    zoom,
    bearing,
    pitch: map2.getTilt(),
    latitude,
    longitude
  };
}
function getViewPropsFromCoordinateTransformer(map2, transformer) {
  const {
    width,
    height
  } = getMapSize(map2);
  const {
    center,
    heading: bearing,
    tilt: pitch,
    zoom
  } = transformer.getCameraParams();
  const fovy = 25;
  const aspect = height ? width / height : 1;
  const near = 0.75;
  const far = 3e14;
  const projectionMatrix = new Matrix4().perspective({
    fovy: fovy * Math.PI / 180,
    aspect,
    near,
    far
  });
  const focalDistance = 0.5 * projectionMatrix[5];
  return {
    width,
    height,
    viewState: {
      altitude: focalDistance,
      bearing,
      latitude: center.lat(),
      longitude: center.lng(),
      pitch,
      projectionMatrix,
      repeat: true,
      zoom: zoom - 1
    }
  };
}
function getMapSize(map2) {
  const container = map2.getDiv().firstChild;
  return {
    width: container.offsetWidth,
    height: container.offsetHeight
  };
}
function pixelToLngLat(projection, x, y) {
  const point = new google.maps.Point(x, y);
  const latLng = projection.fromContainerPixelToLatLng(point);
  return [latLng.lng(), latLng.lat()];
}
function getEventPixel(event, deck) {
  if (event.pixel) {
    return event.pixel;
  }
  const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);
  return {
    x: point[0],
    y: point[1]
  };
}
function handleMouseEvent(deck, type, event) {
  if (!deck.isInitialized) {
    return;
  }
  const mockEvent = {
    type,
    offsetCenter: getEventPixel(event, deck),
    srcEvent: event
  };
  switch (type) {
    case "click":
    case "rightclick":
      mockEvent.type = "click";
      mockEvent.tapCount = 1;
      deck._onPointerDown(mockEvent);
      deck._onEvent(mockEvent);
      break;
    case "dblclick":
      mockEvent.type = "click";
      mockEvent.tapCount = 2;
      deck._onEvent(mockEvent);
      break;
    case "mousemove":
      mockEvent.type = "pointermove";
      deck._onPointerMove(mockEvent);
      break;
    case "mouseout":
      mockEvent.type = "pointerleave";
      deck._onPointerMove(mockEvent);
      break;
    default:
      return;
  }
}

// node_modules/@deck.gl/google-maps/dist/esm/google-maps-overlay.js
var HIDE_ALL_LAYERS = () => false;
var GL_STATE = {
  depthMask: true,
  depthTest: true,
  blend: true,
  blendFunc: [770, 771, 1, 771],
  blendEquation: 32774
};
function noop5() {
}
var defaultProps3 = {
  interleaved: true
};
var GoogleMapsOverlay = class {
  constructor(props) {
    _defineProperty(this, "props", {});
    _defineProperty(this, "_map", null);
    _defineProperty(this, "_deck", null);
    _defineProperty(this, "_overlay", null);
    this.setProps({
      ...defaultProps3,
      ...props
    });
  }
  setMap(map2) {
    if (map2 === this._map) {
      return;
    }
    const {
      VECTOR,
      UNINITIALIZED
    } = google.maps.RenderingType;
    if (this._map) {
      var _this$_overlay;
      if (!map2 && this._map.getRenderingType() === VECTOR && this.props.interleaved) {
        this._overlay.requestRedraw();
      }
      (_this$_overlay = this._overlay) === null || _this$_overlay === void 0 ? void 0 : _this$_overlay.setMap(null);
      this._map = null;
    }
    if (map2) {
      this._map = map2;
      const renderingType = map2.getRenderingType();
      if (renderingType !== UNINITIALIZED) {
        this._createOverlay(map2);
      } else {
        map2.addListener("renderingtype_changed", () => {
          this._createOverlay(map2);
        });
      }
    }
  }
  setProps(props) {
    Object.assign(this.props, props);
    if (this._deck) {
      if (props.style) {
        const parentStyle = this._deck.canvas.parentElement.style;
        Object.assign(parentStyle, props.style);
        props.style = null;
      }
      this._deck.setProps(props);
    }
  }
  pickObject(params) {
    return this._deck && this._deck.pickObject(params);
  }
  pickMultipleObjects(params) {
    return this._deck && this._deck.pickMultipleObjects(params);
  }
  pickObjects(params) {
    return this._deck && this._deck.pickObjects(params);
  }
  finalize() {
    this.setMap(null);
    if (this._deck) {
      destroyDeckInstance(this._deck);
      this._deck = null;
    }
  }
  _createOverlay(map2) {
    const {
      interleaved
    } = this.props;
    const {
      VECTOR,
      UNINITIALIZED
    } = google.maps.RenderingType;
    const renderingType = map2.getRenderingType();
    if (renderingType === UNINITIALIZED) {
      return;
    }
    const isVectorMap = renderingType === VECTOR && google.maps.WebGLOverlayView;
    const OverlayView = isVectorMap ? google.maps.WebGLOverlayView : google.maps.OverlayView;
    const overlay = new OverlayView();
    if (overlay instanceof google.maps.WebGLOverlayView) {
      if (interleaved) {
        overlay.onAdd = noop5;
        overlay.onContextRestored = this._onContextRestored.bind(this);
        overlay.onDraw = this._onDrawVectorInterleaved.bind(this);
      } else {
        overlay.onAdd = this._onAdd.bind(this);
        overlay.onContextRestored = noop5;
        overlay.onDraw = this._onDrawVectorOverlay.bind(this);
      }
      overlay.onContextLost = this._onContextLost.bind(this);
    } else {
      overlay.onAdd = this._onAdd.bind(this);
      overlay.draw = this._onDrawRaster.bind(this);
    }
    overlay.onRemove = this._onRemove.bind(this);
    this._overlay = overlay;
    this._overlay.setMap(map2);
  }
  _onAdd() {
    this._deck = createDeckInstance(this._map, this._overlay, this._deck, this.props);
  }
  _onContextRestored({
    gl
  }) {
    if (!this._map || !this._overlay) {
      return;
    }
    const _customRender = () => {
      if (this._overlay) {
        this._overlay.requestRedraw();
      }
    };
    const deck = createDeckInstance(this._map, this._overlay, this._deck, {
      gl,
      _customRender,
      ...this.props
    });
    this._deck = deck;
    const {
      animationLoop
    } = deck;
    animationLoop._renderFrame = () => {
      const ab = gl.getParameter(34964);
      withParameters(gl, {}, () => {
        animationLoop.onRender();
      });
      gl.bindBuffer(34962, ab);
    };
  }
  _onContextLost() {
    if (this._deck) {
      destroyDeckInstance(this._deck);
      this._deck = null;
    }
  }
  _onRemove() {
    var _this$_deck;
    (_this$_deck = this._deck) === null || _this$_deck === void 0 ? void 0 : _this$_deck.setProps({
      layerFilter: HIDE_ALL_LAYERS
    });
  }
  _onDrawRaster() {
    if (!this._deck || !this._map) {
      return;
    }
    const deck = this._deck;
    const {
      width,
      height,
      left,
      top,
      ...rest
    } = getViewPropsFromOverlay(this._map, this._overlay);
    const parentStyle = deck.canvas.parentElement.style;
    parentStyle.left = "".concat(left, "px");
    parentStyle.top = "".concat(top, "px");
    const altitude = 1e4;
    deck.setProps({
      width,
      height,
      viewState: {
        altitude,
        repeat: true,
        ...rest
      }
    });
    deck.redraw();
  }
  _onDrawVectorInterleaved({
    gl,
    transformer
  }) {
    if (!this._deck || !this._map) {
      return;
    }
    const deck = this._deck;
    deck.setProps({
      ...getViewPropsFromCoordinateTransformer(this._map, transformer),
      width: null,
      height: null
    });
    if (deck.isInitialized) {
      const _framebuffer = getParameters(gl, 36006);
      deck.setProps({
        _framebuffer
      });
      deck.needsRedraw({
        clearRedrawFlags: true
      });
      setParameters(gl, {
        viewport: [0, 0, gl.canvas.width, gl.canvas.height],
        scissor: [0, 0, gl.canvas.width, gl.canvas.height],
        stencilFunc: [519, 0, 255, 519, 0, 255]
      });
      withParameters(gl, GL_STATE, () => {
        deck._drawLayers("google-vector", {
          clearCanvas: false
        });
      });
    }
  }
  _onDrawVectorOverlay({
    transformer
  }) {
    if (!this._deck || !this._map) {
      return;
    }
    const deck = this._deck;
    deck.setProps({
      ...getViewPropsFromCoordinateTransformer(this._map, transformer)
    });
    deck.redraw();
  }
};

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop6 = () => {
};
var DEFAULT_TEXTURE_PARAMETERS2 = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return {
      data: imageData,
      width,
      height
    };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return {
    data: ctx.canvas,
    width,
    height
  };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, parameters) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const newTexture = new Texture2D(texture.gl, {
    width,
    height,
    parameters
  });
  copyToTexture(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture.delete();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const {
      icon,
      xOffset
    } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({
  icons,
  buffer,
  mapping = {},
  xOffset = 0,
  yOffset = 0,
  rowHeight = 0,
  canvasWidth
}) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const {
        height,
        width
      } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data3, getIcon, cachedIcons) {
  if (!data3 || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const {
    iterable,
    objectInfo
  } = createIterable(data3);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = {
        ...icon,
        source: object,
        sourceIndex: objectInfo.index
      };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(gl, {
    onUpdate = noop6,
    onError = noop6
  }) {
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "onUpdate", void 0);
    _defineProperty(this, "onError", void 0);
    _defineProperty(this, "_loadOptions", null);
    _defineProperty(this, "_texture", null);
    _defineProperty(this, "_externalTexture", null);
    _defineProperty(this, "_mapping", {});
    _defineProperty(this, "_textureParameters", null);
    _defineProperty(this, "_pendingCount", 0);
    _defineProperty(this, "_autoPacking", false);
    _defineProperty(this, "_xOffset", 0);
    _defineProperty(this, "_yOffset", 0);
    _defineProperty(this, "_rowHeight", 0);
    _defineProperty(this, "_buffer", DEFAULT_BUFFER);
    _defineProperty(this, "_canvasWidth", DEFAULT_CANVAS_WIDTH);
    _defineProperty(this, "_canvasHeight", 0);
    _defineProperty(this, "_canvas", null);
    this.gl = gl;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _this$_texture;
    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || {};
  }
  setProps({
    loadOptions,
    autoPacking,
    iconAtlas,
    iconMapping,
    textureParameters
  }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      var _this$_texture2;
      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._textureParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data3, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data3, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const {
        mapping,
        xOffset,
        yOffset,
        rowHeight,
        canvasHeight
      } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = new Texture2D(this.gl, {
          width: this._canvasWidth,
          height: this._canvasHeight,
          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS2
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS2);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const {
          x,
          y,
          width: maxWidth,
          height: maxHeight
        } = iconDef;
        const {
          data: data3,
          width,
          height
        } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        this._texture.setSubImageData({
          data: data3,
          x: x + (maxWidth - width) / 2,
          y: y + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error3) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error: error3
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps4 = {
  iconAtlas: {
    type: "image",
    value: null,
    async: true
  },
  iconMapping: {
    type: "object",
    value: {},
    async: true
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  alphaCutoff: {
    type: "number",
    value: 0.05,
    min: 0,
    max: 1
  },
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getIcon: {
    type: "accessor",
    value: (x) => x.icon
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR
  },
  getSize: {
    type: "accessor",
    value: 1
  },
  getAngle: {
    type: "accessor",
    value: 0
  },
  getPixelOffset: {
    type: "accessor",
    value: [0, 0]
  },
  onIconError: {
    type: "function",
    value: null,
    optional: true
  },
  textureParameters: {
    type: "object",
    ignore: true
  }
};
var IconLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: icon_layer_vertex_glsl_default,
      fs: icon_layer_fragment_glsl_default,
      modules: [project32_default, picking_default]
    });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.gl, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: 5121,
        accessor: "getIcon",
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const {
      iconAtlas,
      iconMapping,
      data: data3,
      getIcon,
      textureParameters
    } = props;
    const {
      iconManager
    } = this.state;
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data3, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({
    uniforms
  }) {
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      sizeUnits,
      billboard,
      alphaCutoff
    } = this.props;
    const {
      iconManager
    } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      this.state.model.setUniforms(uniforms).setUniforms({
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      }).draw();
    }
  }
  _getModel(gl) {
    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: 6,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _this$getCurrentLayer;
    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const {
      width,
      height,
      anchorX = width / 2,
      anchorY = height / 2
    } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const {
      x,
      y,
      width,
      height
    } = this.state.iconManager.getIconMapping(icon);
    return [x, y, width, height];
  }
};
_defineProperty(IconLayer, "defaultProps", defaultProps4);
_defineProperty(IconLayer, "layerName", "IconLayer");

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (!filled) {\n    discard;\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps5 = {
  radiusUnits: "meters",
  radiusScale: {
    type: "number",
    min: 0,
    value: 1
  },
  radiusMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  radiusMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  lineWidthUnits: "meters",
  lineWidthScale: {
    type: "number",
    min: 0,
    value: 1
  },
  lineWidthMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  lineWidthMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getRadius: {
    type: "accessor",
    value: 1
  },
  getFillColor: {
    type: "accessor",
    value: DEFAULT_COLOR2
  },
  getLineColor: {
    type: "accessor",
    value: DEFAULT_COLOR2
  },
  getLineWidth: {
    type: "accessor",
    value: 1
  },
  strokeWidth: {
    deprecatedFor: "getLineWidth"
  },
  outline: {
    deprecatedFor: "stroked"
  },
  getColor: {
    deprecatedFor: ["getFillColor", "getLineColor"]
  }
};
var ScatterplotLayer = class extends Layer {
  getShaders() {
    return super.getShaders({
      vs: scatterplot_layer_vertex_glsl_default,
      fs: scatterplot_layer_fragment_glsl_default,
      modules: [project32_default, picking_default]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      radiusUnits,
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      stroked,
      filled,
      billboard,
      antialiasing,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 3,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
};
_defineProperty(ScatterplotLayer, "defaultProps", defaultProps5);
_defineProperty(ScatterplotLayer, "layerName", "ScatterplotLayer");

// node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
function getPolygonSignedArea(points, options = {}) {
  const {
    start: start3 = 0,
    end = points.length
  } = options;
  const dim = options.size || 2;
  let area = 0;
  for (let i = start3, j = end - dim; i < end; i += dim) {
    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);
    j = i;
  }
  return area / 2;
}
function reversePolygon(points, options) {
  const {
    start: start3 = 0,
    end = points.length,
    size: size3 = 2
  } = options;
  const numPoints = (end - start3) / size3;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start3 + i * size3;
    const b2 = start3 + (numPoints - 1 - i) * size3;
    for (let j = 0; j < size3; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}

// node_modules/@math.gl/polygon/dist/esm/utils.js
function push(target, source) {
  const size3 = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size3; i++) {
      if (target[startIndex - size3 + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size3; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size3 = source.length;
  for (let i = 0; i < size3; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size3, offset, out = []) {
  const startI = offset + index * size3;
  for (let i = 0; i < size3; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}

// node_modules/@math.gl/polygon/dist/esm/lineclip.js
function intersect(a, b, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0])
    code |= 1;
  else if (p[0] > bbox[2])
    code |= 2;
  if (p[1] < bbox[1])
    code |= 4;
  else if (p[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const {
    size: size3 = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size3;
  let part = [];
  const result = [part];
  const a = getPointAtIndex(positions, 0, size3, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a);
  for (let i = 1; i < numPoints; i++) {
    b = getPointAtIndex(positions, i, size3, startIndex, b);
    codeB = bitCode(b, cell);
    while (codeB) {
      intersect(a, b, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size3) {
        part = [];
        result.push(part);
        push(part, a);
      }
      codeB = bitCode(b, cell);
    }
    push(part, b);
    copy(a, b);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const {
    size: size3 = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options || {};
  const result = [];
  const queue3 = [{
    pos: positions,
    types: edgeTypes ? new Array(positions.length / size3).fill(TYPE_BORDER) : null,
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];
  while (queue3.length) {
    const {
      pos,
      types,
      holes
    } = queue3.shift();
    getBoundingBox(pos, size3, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size3, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue3.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size3, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size3, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size3;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size3, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = getPointAtIndex(positions, i, size3, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size3 + i];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size3, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size3) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}

// node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const {
    size: size3 = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize: normalize2 = true
  } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size3, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size: size3,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size3);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const {
    size: size3 = 2,
    normalize: normalize2 = true,
    edgeTypes = false
  } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size3, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size3, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size3, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size: size3,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size3);
    }
  }
  return parts;
}
function findSplitIndex(positions, size3, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size3) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size3, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size3];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = getPointAtIndex(positions, 0, size3, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    push(positions, p);
    p[0] = firstLng;
    push(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size3, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size3) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size3) {
  let refLng;
  const pointCount = positions.length / size3;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size3];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size3] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/esm/path-layer/path.js
function normalizePath(path, size3, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length = path.length * size3;
    flatPath = new Array(length);
    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size3; j++) {
        flatPath[i * size3 + j] = path[i][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, {
      size: size3,
      gridResolution
    });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, {
      size: size3
    });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: {
          size: 1,
          type: Uint8ClampedArray
        }
      }
    });
  }
  get(attributeName) {
    return this.attributes[attributeName];
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  getGeometrySize(path) {
    if (isCut(path)) {
      let size3 = 0;
      for (const subPath of path) {
        size3 += this.getGeometrySize(subPath);
      }
      return size3;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const {
      vertexStart,
      geometrySize
    } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const {
      positions
    } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const {
      vertexStart,
      geometrySize
    } = context;
    const p = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  getPointOnPath(path, index, target = []) {
    const {
      positionSize
    } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const {
      positionSize
    } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps6 = {
  widthUnits: "meters",
  widthScale: {
    type: "number",
    min: 0,
    value: 1
  },
  widthMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  widthMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  jointRounded: false,
  capRounded: false,
  miterLimit: {
    type: "number",
    min: 0,
    value: 4
  },
  billboard: false,
  _pathType: null,
  getPath: {
    type: "accessor",
    value: (object) => object.path
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR3
  },
  getWidth: {
    type: "accessor",
    value: 1
  },
  rounded: {
    deprecatedFor: ["jointRounded", "capRounded"]
  }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var PathLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: path_layer_vertex_glsl_default,
      fs: path_layer_fragment_glsl_default,
      modules: [project32_default, picking_default]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      positions: {
        size: 3,
        vertexOffset: 1,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: 5121,
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR3
      },
      instancePickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const {
        pathTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data: data3
    } = this.props;
    if (data3[0] && data3[0].__source) {
      info.object = data3.find((d) => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data: data3
    } = this.props;
    if (data3[0] && data3[0].__source) {
      for (let i = 0; i < data3.length; i++) {
        if (data3[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      jointRounded,
      capRounded,
      billboard,
      miterLimit,
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: 4,
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: {
            value: new Float32Array(SEGMENT_POSITIONS),
            size: 2
          }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
_defineProperty(PathLayer, "defaultProps", defaultProps6);
_defineProperty(PathLayer, "layerName", "PathLayer");

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut());
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size3, startIndex, endIndex) {
  for (let i = 0; i < size3; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size3 + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size3, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size3; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size3; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size3;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size3, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size3, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size3; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size3;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i = 0; i < numVerts; i++) {
    const j = (i + 1) % numVerts;
    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];
    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x = positions[o + 0];
    const y = positions[o + 1];
    const z = positions[o + 2];
    positions[o + xIndex] = x;
    positions[o + yIndex] = y;
    positions[o + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const {
      fp64: fp642,
      IndexType = Uint32Array
    } = opts;
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          type: fp642 ? Float64Array : Float32Array
        },
        vertexValid: {
          type: Uint8ClampedArray,
          size: 1
        },
        indices: {
          type: IndexType,
          size: 1
        }
      }
    });
  }
  get(attributeName) {
    const {
      attributes
    } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size3 = 0;
      for (const subPolygon of polygon) {
        size3 += this.getGeometrySize(subPolygon);
      }
      return size3;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      this._updateIndices(polygon, context);
      this._updatePositions(polygon, context);
      this._updateVertexValid(polygon, context);
    }
  }
  _updateIndices(polygon, {
    geometryIndex,
    vertexStart: offset,
    indexStart
  }) {
    const {
      attributes,
      indexStarts,
      typedArrayManager
    } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  _updatePositions(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      attributes: {
        positions
      },
      positionSize
    } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      positionSize
    } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var defaultProps7 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: {
    type: "number",
    min: 0,
    value: 1
  },
  getPolygon: {
    type: "accessor",
    value: (f) => f.polygon
  },
  getElevation: {
    type: "accessor",
    value: 1e3
  },
  getFillColor: {
    type: "accessor",
    value: DEFAULT_COLOR4
  },
  getLineColor: {
    type: "accessor",
    value: DEFAULT_COLOR4
  },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var SolidPolygonLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudLighting, picking_default]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const {
      gl,
      viewport
    } = this.context;
    let {
      coordinateSystem
    } = this.props;
    const {
      _full3d
    } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: this.calculateIndices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          positions: {
            vertexOffset: 0,
            divisor: 0
          },
          instancePositions: {
            vertexOffset: 0,
            divisor: 1
          },
          nextPositions: {
            vertexOffset: 1,
            divisor: 1
          }
        }
      },
      vertexValid: {
        size: 1,
        divisor: 1,
        type: 5121,
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation",
        shaderAttributes: {
          elevations: {
            divisor: 0
          },
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR4,
        shaderAttributes: {
          fillColors: {
            divisor: 0
          },
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR4,
        shaderAttributes: {
          lineColors: {
            divisor: 0
          },
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
        shaderAttributes: {
          pickingColors: {
            divisor: 0
          },
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data: data3
    } = this.props;
    if (data3[0] && data3[0].__source) {
      info.object = data3.find((d) => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data: data3
    } = this.props;
    if (data3[0] && data3[0].__source) {
      for (let i = 0; i < data3.length; i++) {
        if (data3[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      extruded,
      filled,
      wireframe,
      elevationScale
    } = this.props;
    const {
      topModel,
      sideModel,
      polygonTesselator
    } = this.state;
    const renderUniforms = {
      ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };
    if (sideModel) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      if (wireframe) {
        sideModel.setDrawMode(3);
        sideModel.setUniforms({
          isWireframe: true
        }).draw();
      }
      if (filled) {
        sideModel.setDrawMode(6);
        sideModel.setUniforms({
          isWireframe: false
        }).draw();
      }
    }
    if (topModel) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms).draw();
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const {
      props,
      oldProps,
      changeFlags
    } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      var _this$state$models;
      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach((model) => model.delete());
      this.setState(this._getModels(this.context.gl));
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({
    props,
    oldProps,
    changeFlags
  }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const {
        polygonTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels(gl) {
    const {
      id,
      filled,
      extruded
    } = this.props;
    let topModel;
    let sideModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      topModel = new Model(gl, {
        ...shaders,
        id: "".concat(id, "-top"),
        drawMode: 4,
        attributes: {
          vertexPositions: new Float32Array([0, 1])
        },
        uniforms: {
          isWireframe: false,
          isSideVertex: false
        },
        vertexCount: 0,
        isIndexed: true
      });
    }
    if (extruded) {
      sideModel = new Model(gl, {
        ...this.getShaders("side"),
        id: "".concat(id, "-side"),
        geometry: new Geometry({
          drawMode: 1,
          vertexCount: 4,
          attributes: {
            vertexPositions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        instanceCount: 0,
        isInstanced: 1
      });
      sideModel.userData.excludeAttributes = {
        indices: true
      };
    }
    return {
      models: [sideModel, topModel].filter(Boolean),
      topModel,
      sideModel
    };
  }
  calculateIndices(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
_defineProperty(SolidPolygonLayer, "defaultProps", defaultProps7);
_defineProperty(SolidPolygonLayer, "layerName", "SolidPolygonLayer");

// node_modules/@deck.gl/layers/dist/esm/utils.js
function replaceInRange({
  data: data3,
  getIndex,
  dataRange,
  replace
}) {
  const {
    startRow = 0,
    endRow = Infinity
  } = dataRange;
  const count2 = data3.length;
  let replaceStart = count2;
  let replaceEnd = count2;
  for (let i = 0; i < count2; i++) {
    const row = getIndex(data3[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data3.slice(replaceEnd) : void 0;
  for (let i = 0; i < replace.length; i++) {
    data3[index++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data3[index++] = endChunk[i];
    }
    data3.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data3, index) {
  if (!data3) {
    return null;
  }
  const featureIndex = "startIndices" in data3 ? data3.startIndices[index] : index;
  const geometryIndex = data3.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data3, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data3, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: {
      ...data3.properties[propertiesIndex]
    }
  };
  for (const prop in data3.numericProps) {
    feature.properties[prop] = data3.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 3 + 0] = pickingColor[0];
      pickingColors[key][i * 3 + 1] = pickingColor[1];
      pickingColors[key][i * 3 + 2] = pickingColor[2];
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY3 = [];
var defaultProps8 = {
  getIconOffsets: {
    type: "accessor",
    value: (x) => x.offsets
  },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: {
    type: "color",
    value: [0, 0, 0, 255]
  }
};
var MultiIconLayer = class extends IconLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    return {
      ...super.getShaders(),
      fs: multi_icon_layer_fragment_glsl_default
    };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: 5121,
        size: 3,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    let {
      outlineColor
    } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x) => x / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
    }
  }
  draw(params) {
    const {
      sdf,
      smoothing,
      outlineWidth
    } = this.props;
    const {
      outlineColor
    } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    params.uniforms = {
      ...params.uniforms,
      sdfBuffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
    if (sdf && outlineWidth) {
      const {
        iconManager
      } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        this.state.model.draw({
          uniforms: {
            outlineBuffer: DEFAULT_BUFFER2
          }
        });
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY3;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY3;
  }
};
_defineProperty(MultiIconLayer, "defaultProps", defaultProps8);
_defineProperty(MultiIconLayer, "layerName", "MultiIconLayer");

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal"
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    const size3 = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size3);
    const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    ctx.fillStyle = "black";
    this.gridOuter = new Float64Array(size3 * size3);
    this.gridInner = new Float64Array(size3 * size3);
    this.f = new Float64Array(size3);
    this.z = new Float64Array(size3 + 1);
    this.v = new Uint16Array(size3);
  }
  _createCanvas(size3) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size3;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data3 = new Uint8ClampedArray(len);
    const glyph = { data: data3, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0)
      return glyph;
    const { ctx, buffer, gridInner, gridOuter } = this;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y = 0; y < glyphHeight; y++) {
      for (let x = 0; x < glyphWidth; x++) {
        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255;
        if (a === 0)
          continue;
        const j = (y + buffer) * width + x + buffer;
        if (a === 1) {
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          const d = 0.5 - a;
          gridOuter[j] = d > 0 ? d * d : 0;
          gridInner[j] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len; i++) {
      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data3[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data3, x0, y0, width, height, gridSize, f, v, z) {
  for (let x = x0; x < x0 + width; x++)
    edt1d(data3, y0 * gridSize + x, gridSize, height, f, v, z);
  for (let y = y0; y < y0 + height; y++)
    edt1d(data3, y * gridSize + x0, 1, width, f, v, z);
}
function edt1d(grid, offset, stride, length, f, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f[0] = grid[offset];
  for (let q = 1, k = 0, s = 0; q < length; q++) {
    f[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r = v[k];
      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
    } while (s <= z[k] && --k > -1);
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length; q++) {
    while (z[k + 1] < q)
      k++;
    const r = v[k];
    const qr = q - r;
    grid[offset + q * stride] = f[r] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    var _mapping$character;
    const character = text[i];
    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === " ") {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === " " || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x + frame.layoutWidth / 2;
      x += frame.layoutWidth;
    } else {
      log_default.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();
      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x = new Array(numCharacters);
  const y = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size3 = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === "\n" || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          var _iconMapping$char;
          const char2 = characters[j];
          const layoutOffsetY = ((_iconMapping$char = iconMapping[char2]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;
          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size3[0] = Math.max(size3[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x[lineStartIndex] = 0;
      y[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size3[1] = rowOffsetTop;
  return {
    x,
    y,
    rowWidth,
    size: size3
  };
}
function getTextFromBuffer({
  value,
  length,
  stride,
  offset,
  startIndices,
  characterSet
}) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return {
    texts,
    characterCount
  };
}

// node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    _defineProperty(this, "limit", void 0);
    _defineProperty(this, "_cache", {});
    _defineProperty(this, "_order", []);
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache3 = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache3.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache3 = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    _defineProperty(this, "props", {
      ...DEFAULT_FONT_SETTINGS
    });
    _defineProperty(this, "_key", void 0);
    _defineProperty(this, "_atlas", void 0);
  }
  get texture() {
    return this._atlas;
  }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const {
      fontSize,
      buffer
    } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache3.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache3.set(this._key, fontAtlas);
  }
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = buildMapping2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: "".concat(fontWeight)
      });
      for (const char of characterSet) {
        const {
          data: data3,
          width,
          height,
          glyphTop
        } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data3, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    if (sdf) {
      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
    }
    return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
  }
};

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js
var defaultProps9 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: {
    type: "array",
    value: [0, 0, 0, 0]
  },
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getSize: {
    type: "accessor",
    value: 1
  },
  getAngle: {
    type: "accessor",
    value: 0
  },
  getPixelOffset: {
    type: "accessor",
    value: [0, 0]
  },
  getBoundingRect: {
    type: "accessor",
    value: [0, 0, 0, 0]
  },
  getFillColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  getLineColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  getLineWidth: {
    type: "accessor",
    value: 1
  }
};
var TextBackgroundLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: text_background_layer_vertex_glsl_default,
      fs: text_background_layer_fragment_glsl_default,
      modules: [project32_default, picking_default]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      changeFlags
    } = params;
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      getLineWidth
    } = this.props;
    let {
      padding
    } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    this.state.model.setUniforms(uniforms).setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
};
_defineProperty(TextBackgroundLayer, "defaultProps", defaultProps9);
_defineProperty(TextBackgroundLayer, "layerName", "TextBackgroundLayer");

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps10 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: {
    type: "accessor",
    value: [255, 255, 255, 255]
  },
  getBorderColor: {
    type: "accessor",
    value: DEFAULT_COLOR5
  },
  getBorderWidth: {
    type: "accessor",
    value: 0
  },
  backgroundPadding: {
    type: "array",
    value: [0, 0, 0, 0]
  },
  characterSet: {
    type: "object",
    value: DEFAULT_FONT_SETTINGS.characterSet
  },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: {
    type: "number",
    value: 0,
    min: 0
  },
  outlineColor: {
    type: "color",
    value: DEFAULT_COLOR5
  },
  fontSettings: {
    type: "object",
    value: {},
    compare: 1
  },
  wordBreak: "break-word",
  maxWidth: {
    type: "number",
    value: -1
  },
  getText: {
    type: "accessor",
    value: (x) => x.text
  },
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR5
  },
  getSize: {
    type: "accessor",
    value: 32
  },
  getAngle: {
    type: "accessor",
    value: 0
  },
  getTextAnchor: {
    type: "accessor",
    value: "middle"
  },
  getAlignmentBaseline: {
    type: "accessor",
    value: "center"
  },
  getPixelOffset: {
    type: "accessor",
    value: [0, 0]
  },
  backgroundColor: {
    deprecatedFor: ["background", "getBackgroundColor"]
  }
};
var TextLayer = class extends CompositeLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "getBoundingRect", (object, objectInfo) => {
      let {
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const {
        fontSize
      } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    });
    _defineProperty(this, "getIconOffsets", (object, objectInfo) => {
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const {
        x,
        y,
        rowWidth,
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
        offsets[index++] = (anchorY - 1) * height / 2 + y[i];
      }
      return offsets;
    });
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  updateState(params) {
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({
    info
  }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  _updateFontAtlas() {
    const {
      fontSettings,
      fontFamily,
      fontWeight
    } = this.props;
    const {
      fontAtlasManager,
      characterSet
    } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  _updateText() {
    var _attributes;
    const {
      data: data3,
      characterSet
    } = this.props;
    const textBuffer = (_attributes = data3.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;
    let {
      getText
    } = this.props;
    let startIndices = data3.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const {
        texts,
        characterCount
      } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? {
          value: textBuffer
        } : textBuffer,
        length: data3.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_, {
        index
      }) => texts[index];
    } else {
      const {
        iterable,
        objectInfo
      } = createIterable(data3);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  transformParagraph(object, objectInfo) {
    const {
      fontAtlasManager
    } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const {
      wordBreak,
      lineHeight,
      maxWidth
    } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const {
      startIndices,
      numInstances,
      getText,
      fontAtlasManager: {
        scale: scale3,
        texture,
        mapping
      },
      styleVersion
    } = this.state;
    const {
      data: data3,
      _dataDiff,
      getPosition: getPosition2,
      getColor: getColor3,
      getSize,
      getAngle,
      getPixelOffset,
      getBackgroundColor,
      getBorderColor,
      getBorderWidth,
      backgroundPadding,
      background,
      billboard,
      fontSettings,
      outlineWidth,
      outlineColor,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions,
      updateTriggers
    } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
    const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
    return [background && new BackgroundLayerClass({
      getFillColor: getBackgroundColor,
      getLineColor: getBorderColor,
      getLineWidth: getBorderWidth,
      padding: backgroundPadding,
      getPosition: getPosition2,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getSize: transitions.getSize,
        getFillColor: transitions.getBackgroundColor,
        getLineColor: transitions.getBorderColor,
        getLineWidth: transitions.getBorderWidth,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: "background",
      updateTriggers: {
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getSize: updateTriggers.getSize,
        getFillColor: updateTriggers.getBackgroundColor,
        getLineColor: updateTriggers.getBorderColor,
        getLineWidth: updateTriggers.getBorderWidth,
        getPixelOffset: updateTriggers.getPixelOffset,
        getBoundingRect: {
          getText: updateTriggers.getText,
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data: data3.attributes && data3.attributes.background ? {
        length: data3.length,
        attributes: data3.attributes.background
      } : data3,
      _dataDiff,
      autoHighlight: false,
      getBoundingRect: this.getBoundingRect
    }), new CharactersLayerClass({
      sdf: fontSettings.sdf,
      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
      outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
      outlineColor,
      iconAtlas: texture,
      iconMapping: mapping,
      getPosition: getPosition2,
      getColor: getColor3,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale: sizeScale * scale3,
      sizeUnits,
      sizeMinPixels: sizeMinPixels * scale3,
      sizeMaxPixels: sizeMaxPixels * scale3,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getColor: transitions.getColor,
        getSize: transitions.getSize,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: "characters",
      updateTriggers: {
        all: updateTriggers.getText,
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getColor: updateTriggers.getColor,
        getSize: updateTriggers.getSize,
        getPixelOffset: updateTriggers.getPixelOffset,
        getIconOffsets: {
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data: data3,
      _dataDiff,
      startIndices,
      numInstances,
      getIconOffsets: this.getIconOffsets,
      getIcon: getText
    })];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
_defineProperty(TextLayer, "defaultProps", defaultProps10);
_defineProperty(TextLayer, "layerName", "TextLayer");

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: ScatterplotLayer,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: IconLayer,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: TextLayer,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: PathLayer,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: SolidPolygonLayer,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({
  type,
  props
}) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const {
    transitions,
    updateTriggers
  } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{
        geometry: geojson
      }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const {
    startRow = 0,
    endRow = features.length
  } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const {
      geometry
    } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const {
        geometries
      } = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const {
    type,
    coordinates
  } = geometry;
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn("".concat(type, " coordinates are malformed"))();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point) => {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: "Point",
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: "Polygon",
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const {
    points,
    lines,
    polygons
  } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps11 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: {
    type: "object",
    value: null
  },
  iconMapping: {
    type: "object",
    value: {}
  },
  getIcon: {
    type: "accessor",
    value: (f) => f.properties.icon
  },
  getText: {
    type: "accessor",
    value: (f) => f.properties.text
  },
  pointType: "circle",
  getRadius: {
    deprecatedFor: "getPointRadius"
  }
};
var GeoJsonLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {}
    };
  }
  updateState({
    props,
    changeFlags
  }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const {
      data: data3
    } = this.props;
    const binary = data3 && "points" in data3 && "polygons" in data3 && "lines" in data3;
    this.setState({
      binary
    });
    if (binary) {
      this._updateStateBinary({
        props,
        changeFlags
      });
    } else {
      this._updateStateJSON({
        props,
        changeFlags
      });
    }
  }
  _updateStateBinary({
    props,
    changeFlags
  }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({
      layerProps
    });
  }
  _updateStateJSON({
    props,
    changeFlags
  }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f) => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index,
      sourceLayer
    } = info;
    info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith("".concat(this.id, "-").concat(ft, "-")));
    if (index >= 0 && sourceLayer.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = "".concat(this.id, "-points-");
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const {
      extruded,
      wireframe
    } = this.props;
    const {
      layerProps
    } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const {
      extruded,
      stroked
    } = this.props;
    const {
      layerProps
    } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
        id: polygonStrokeLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
        id: lineStringsLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.lines)];
    }
    return null;
  }
  _renderPointLayers() {
    const {
      pointType
    } = this.props;
    const {
      layerProps,
      binary
    } = this.state;
    let {
      highlightedObjectIndex
    } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = "points-".concat(type);
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const {
            instancePickingColors,
            ...rest
          } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            data: {
              ...pointsLayerProps.data,
              attributes: rest
            }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const {
      extruded
    } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];
  }
  getSubLayerAccessor(accessor) {
    const {
      binary
    } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const {
        data: data3,
        index
      } = info;
      const feature = binaryToFeatureForAccesor(data3, index);
      return accessor(feature, info);
    };
  }
};
_defineProperty(GeoJsonLayer, "layerName", "GeoJsonLayer");
_defineProperty(GeoJsonLayer, "defaultProps", defaultProps11);

// src/js/property_map/PublicLayerBarriosWebGL.ts
var PublicLayerBarriosWebGL = ({ index, slug_name, name, layer_options }, comunas2) => ({
  mapTypes: [],
  lastType: null,
  layer_options,
  filters_open: false,
  _map: null,
  index,
  controls: [
    //  { property: 'className', name: 'Icon', inputType: 'icon' },
    { property: "fillOpacity", name: "Opacidad", min: 0, max: 1, step: 0.01, inputType: "range" },
    { property: "strokeWeight", name: "Grosor", min: 0, max: 5, step: 0.05, inputType: "range" },
    { property: "scale", name: "Tama\xF1o", min: 0, max: 1, step: 0.05, inputType: "range" },
    { property: "strokeColor", name: "Color", inputType: "color" }
  ],
  boundingBox: {
    "south": -33.49850221364226,
    "west": -70.70542845963612,
    "north": -33.33716710494213,
    "east": -70.4681924366869
  },
  bounds: null,
  ...saveLayer({ slug_name, layer_options }),
  codigo_interno: null,
  geoJsonLayer: {},
  async init() {
    this.bounds = new google.maps.LatLngBounds(this.boundingBox);
    let qs = new URL(location.href);
    if (qs.searchParams.get("codigo_interno")) {
      this.codigo_interno = qs.searchParams.get("codigo_interno");
    }
    this.layer_options = { ...this.layer_options, ...layer_options };
    globalThis.exampleLayerObject = PublicLayersObject;
    let example_layer = PublicLayersObject[slug_name] || { layer_options }, icon = null;
    const checked = this.layer_options.checked;
    this.name = name;
    this.slug_name = slug_name;
    globalThis.layers = globalThis.layers || {};
    globalThis.layerComponents = globalThis.layerComponents || {};
    globalThis.layerComponents[this.slug_name] = this;
    this.addLayerToMap();
    this.layer_options.checked = false;
    this.layer_options = { ...layer_options, name, slug_name };
    setTimeout(() => {
      google.maps.event.addListenerOnce(globalThis.gmap, "odle", () => {
        this.checked = checked;
      });
    }, 2e3);
  },
  updateIcon(defaultScale = 1) {
    let {
      text,
      fontFamily,
      strokeColor,
      fillOpacity,
      fillColor,
      strokeOpacity,
      fontSize,
      scale: scale3,
      icon,
      strokeWeight,
      rotation
    } = this.layer_options;
    if (!icon)
      return null;
    if (icon.path) {
      return {
        path: icon.path,
        scale: (scale3 ?? icon.scale) / 10,
        fillColor: strokeColor || icon.strokeColor || strokeColor,
        strokeColor,
        strokeOpacity,
        strokeWeight: icon.strokeWeight ?? (strokeWeight || 0.1),
        fillOpacity,
        rotation: icon.rotation ?? (rotation ?? 90),
        anchor: new google.maps.Point(96, 48)
      };
    }
    if (icon.url) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: icon.url,
        size: new google.maps.Size(54, 54),
        anchor: { x: width / 2, y: height },
        scaledSize: new google.maps.Size(width, height)
      };
    }
  },
  get base64Icon() {
    return (this.iconPreview ?? this.layer_options.icon ?? {}).url;
  },
  get iconUrl() {
    return this.blobUrl || this.base64Icon;
  },
  getIconOptions(defaultScale = 1) {
    let iconUrl = this.iconUrl;
    if (iconUrl) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: iconUrl,
        size: { width: 54, height: 54 },
        anchor: { x: width / 2, y: height },
        scaledSize: { width, height },
        labelOrigin: { x: 0.8 * width, y: height }
      };
    }
  },
  getOverlay() {
    return Alpine.raw(this.getLayer()._overlay);
  },
  get checked() {
    return this.layer_options.checked;
  },
  set checked(value) {
    this.getOverlay()?.setMap(value ? globalThis.gmap : null);
    this.layer_options.checked = value;
  },
  toggleMap() {
    const map2 = this.getOverlay().getMap() ? null : globalThis.gmap;
    this.getLayer().setProps({ visible: !!map2 });
    this.getOverlay().setMap(map2);
    this._map = map2;
  },
  setStyle() {
    const layer = this.getLayer();
    const highlightLabelClassname = "uppercase max-w-[125px] text-gray-500 markerLabel_break_words markerLabel bg-gray-200   p-1 bg-opacity-50";
    return this;
    requestAnimationPromise3().then(() => {
      let icon = this.iconPreview;
      let { labelVisibility } = this.layer_options;
      let laberIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 5,
        strokeWeight: 2,
        labelOrigin: new google.maps.Point(0, 2),
        strokeColor: "rgba(200,200,200,0)"
      };
      this.getLayer().setStyle((feature) => {
        let featureName = feature.getProperty(this.layer_options.labelProperty), comuna = feature.getProperty("Comuna"), comunaOffset = Object.keys(comunas2).indexOf(comuna);
        if (!comuna || comunaOffset === -1) {
          comunaOffset = 0;
        }
        comunaOffset -= 1;
        let highlighted = feature.getProperty("highlighted"), matches3 = feature.getProperty("matches"), transparencia = feature.getProperty("Transparencia") ?? 0, fillOpacity = this.layer_options.fillOpacity * //(1 - transparencia / 10) *
        ((matches3 ? 2.5 : 0.9) * highlighted ? 1.6 : 0.8), fillColor = `hsl(${(matches3 ? 20 : transparencia * 7) + comunaOffset * 50},${matches3 ? 65 : 55}%,${matches3 ? 60 : 70}%)`;
        let styleObj = {
          // label,
          fillColor: feature.getProperty("fillColor") || fillColor,
          strokeColor: feature.getProperty("strokeColor") || `hsl(${comunaOffset * 60},45%,40%)`,
          strokeWeight: this.layer_options.strokeWeight || 1,
          strokeOpacity: matches3 ? 1 : 0.7,
          // visible: feature.getProperty('comuna') && comunas[feature.getProperty('comuna')] === true,
          fillOpacity
        };
        return styleObj;
      });
    });
    return this;
  },
  fontSize: 33,
  setFontSize(fontSize) {
    this.fontSize = fontSize;
    this.setStyle();
  },
  mouseover_added: false,
  infowindow_added: false,
  addLayerToMap() {
    const layer = globalThis.layers[this.slug_name] || new GoogleMapsOverlay({
      layers: []
    });
    globalThis.layers[this.slug_name] = layer;
    return this.appendFeatures();
  },
  mouseOverListener: null,
  mouseOutListener: null,
  clickListener: null,
  async declareEventHandlers() {
    const labelProperty = this.layer_options.labelProperty || "Nombre_de_Barrio";
    this.marker = globalThis.gmap.labelMarker;
    if (!this.mouseOverListener) {
      this.marker = this.marker || new google.maps.Marker({
        position: this.getLayer().getBounds().getCenter(),
        visible: true,
        map: globalThis.gmap,
        zIndex: 210,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 5,
          strokeWeight: 2,
          labelOrigin: new google.maps.Point(0, 2),
          strokeColor: "rgba(200,200,200,0)"
        }
      });
      const layer = this.getLayer();
      let visibilityZoom = this.layer_options.labelVisibility.zoom;
      if (visibilityZoom) {
        let previousZoom = globalThis.gmap.getZoom();
        const zoomChangedHandler = (e) => {
          let currentZoom = globalThis.gmap.getZoom();
          if (currentZoom >= visibilityZoom && previousZoom <= visibilityZoom) {
            console.zinfo("went above visibility zoom", currentZoom);
            document.querySelector(".gm-style").classList.remove("hide-labels");
            document.querySelector(".gm-style").classList.add("show-labels");
          }
          if (currentZoom < visibilityZoom && previousZoom >= visibilityZoom) {
            console.zinfo("went below visibility zoom", currentZoom);
            document.querySelector(".gm-style").classList.remove("show-labels");
            document.querySelector(".gm-style").classList.add("hide-labels");
          }
          console.timerInfo(`zoom changed from ${previousZoom} to ${currentZoom}`);
          previousZoom = currentZoom;
        };
        this.gmap.addListener("idle", () => zoomChangedHandler(null));
      }
      if (this.layer_options.labelVisibility.highlighted) {
        this.mouseOverListener = (event) => {
          const { feature } = event;
          feature.setProperty("highlighted", true);
          let featureLabel = feature.getProperty(labelProperty);
          if (featureLabel) {
            this.marker.setLabel(this.getNameLabel(featureLabel, "uppercase max-w-[125px] text-gray-500 markerLabel_break_words markerLabel bg-gray-50   p-1 bg-opacity-10"));
            this.marker.setPosition(feature.getCenter());
            this.marker.setVisible(true);
          }
        };
      }
      if (!this.mouseOutListener && this.layer_options.labelVisibility.highlighted) {
        this.mouseOutListener = (event) => {
          event.feature.setProperty("highlighted", false);
          this.marker.setLabel("");
          this.marker.setVisible(false);
        };
      }
    }
    if (!this.clickListener && this.layer_options.infoWindow) {
      this.clickListener = (event) => {
        globalThis.gmap.infowindow.close();
        let negocio = event.feature;
        console.log({ latLng: event.latLng });
        this.getMap().panTo(event.latLng);
        let html = new genericFeatureToHtml(negocio, this.layer_options.campos).content;
        this.getInfoWindow().setContent(html);
        this.getInfoWindow().setPosition(event.latLng);
        this.getInfoWindow().open({ map: globalThis.gmap });
      };
    }
  },
  get infowindow() {
    return globalThis.gmap.infowindow;
  },
  getInfoWindow() {
    return globalThis.gmap.infowindow;
  },
  getLayer() {
    return globalThis.layers[this.slug_name];
  },
  getLength() {
    let { layers } = this.getLayer().props;
    return layers.length ? layers[0].count : 0;
  },
  length: 0,
  setMap(map2) {
    return this.getLayer().setMap(map2);
  },
  getMap() {
    return this.getLayer().getMap();
  },
  get gmap() {
    return globalThis.gmap;
  },
  get layer() {
    return this.getLayer();
  },
  removeFeatures() {
    return;
  },
  async appendFeatures() {
    if (this.getLayer() && this.getLength() > 0)
      return this.getLayer();
    const geoJsonLayer = new GeoJsonLayer({
      id: "barrios",
      data: this.layer_options.url,
      ///Alpine.raw(this.featureCollection),//, "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson",
      filled: true,
      opacity: 0.4,
      getFillColor: (f) => {
        console.log(f);
        if (!f.properties.rgbaColor) {
          return [190, 190, 190];
        }
        let { r, g, b, a } = f.properties.rgbaColor;
        let fillColor = [r, g, b];
        console.log({ fillColor });
        return fillColor;
      },
      autoHighlight: true,
      onDataLoad: () => {
        console.log("onDataLoad");
      }
    });
    this.getLayer().setProps({ layers: [geoJsonLayer] });
    return this.getLayer();
  },
  mapDialogOpen: false
});

// src/js/property_map/public_map_modules/b64toBlob.ts
var b64toBlob = (b64Data, contentType = "", sliceSize = 512) => {
  const byteCharacters = atob(b64Data);
  const byteArrays = [];
  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    const slice = byteCharacters.slice(offset, offset + sliceSize);
    const byteNumbers = new Array(slice.length);
    for (let i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  const blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

// src/js/property_map/public_map_modules/iconOptions.ts
var iconOptions = [
  //{ fontFamily: 'FontAwesome5Free', className: 'fas fa-house-user', text: '0f9' ,
  //{ fontFamily: 'LineIcons', className: 'lni lni-apartment', text: 'e800' },
  //{ fontFamily: 'LineIcons', className: 'lni lni-home', text: 'e800' },
  { fontFamily: "fontello", className: "icon-home", text: "e800" },
  { fontFamily: "fontello", className: "icon-home-1", text: "e801" },
  { fontFamily: "fontello", className: "icon-home-outline", text: "e802" },
  { fontFamily: "fontello", className: "icon-home-2", text: "e803" },
  { fontFamily: "fontello", className: "icon-home-3", text: "e804" },
  { fontFamily: "fontello", className: "icon-home-4", text: "e805" },
  { fontFamily: "fontello", className: "icon-home-5", text: "e806" },
  //{ fontFamily: 'fontello', className: 'icon-home-circled', text: 'e807' },
  //{ fontFamily: 'fontello', className: 'icon-iphone-home', text: 'e808' },
  //{ fontFamily: 'fontello', className: 'icon-tree', text: 'e809' },
  { fontFamily: "fontello", className: "icon-leaf", text: "e80a" },
  { fontFamily: "fontello", className: "icon-belowground-rail", text: "e80b" },
  //{ fontFamily: 'fontello', className: 'icon-bus-1', text: 'e80c' },
  //{ fontFamily: 'fontello', className: 'icon-basket', text: 'e80d' },
  //{ fontFamily: 'fontello', className: 'icon-basket-1', text: 'e80e' },
  { fontFamily: "fontello", className: "icon-commerical-building", text: "e811" },
  { fontFamily: "fontello", className: "icon-industrial-building", text: "e822" },
  { fontFamily: "fontello", className: "icon-school", text: "e834" },
  //{ fontFamily: 'fontello', className: 'icon-tree-2', text: 'e83f' },
  { fontFamily: "fontello", className: "icon-warehouse", text: "e840" },
  { fontFamily: "fontello", className: "icon-building", text: "f0f7" },
  { fontFamily: "fontello", className: "icon-graduation-cap", text: "f19d" },
  { fontFamily: "fontello", className: "icon-building-filled", text: "f1ad" },
  //{ fontFamily: 'fontello', className: 'icon-bus', text: 'f207' },
  { fontFamily: "fontello", className: "icon-train", text: "f238" },
  { fontFamily: "fontello", className: "icon-subway", text: "f239" },
  //{ fontFamily: 'fontello', className: 'icon-shopping-basket', text: 'f291' },
  //{ fontFamily: 'fontello', className: 'icon-spread', text: 'f527' },
  //{ fontFamily: 'fontello', className: 'icon-graduation-cap-2', text: 'e812' },
  { fontFamily: "fontello", className: "icon-college", text: "e813" },
  { fontFamily: "fontello", className: "icon-person", text: "e814" },
  { fontFamily: "fontello", className: "icon-child", text: "e815" },
  { fontFamily: "fontello", className: "icon-adult", text: "e816" }
].map((icon) => {
  icon.label = `${icon.fontFamily} ${icon.className.replace("lni ", "").replace("fas ", "")}`;
  return icon;
});

// src/js/property_map/public_map_modules/marker_factory/markerFactory.ts
var computeColorAlpha = (color, opacity) => {
  let colorHexAlpha = color, colorRgb = color, colorRgba = color;
  if (/#[a-fA-F0-9]{3}/.test(color)) {
    let alpha = (255 * Number(opacity)).toString(16).slice(0, 2);
    colorHexAlpha = color + alpha.padStart(2, "0");
    let [r, g, b] = [color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)].map((c) => parseInt(c, 16));
    colorRgba = `rgba(${r},${g},${b},${opacity})`;
    colorRgb = `rgb(${r},${g},${b})`;
  }
  return { colorRgba, colorRgb, colorHexAlpha };
};

// src/js/property_map/public_map_modules/negocioFeatureToHtml.ts
var negocioFeatureToHtml = class {
  constructor(feature, campos, variant = "public") {
    this.variant = "public";
    this.feature = feature;
    campos = {
      "ubicacion": "Ubicaci\xF3n",
      "tipo": "Tipo",
      "dormitorios_total": "Dormitorios",
      "banos_total": "Ba\xF1os",
      "servicios": "Servicios",
      ...campos,
      tipo_negocio: "Modalidad",
      tipo_propiedad: "Tipo Propiedad",
      "titulo-resumen-web": "Resumen",
      nombre: "Nombre",
      comuna: "Ubicaci\xF3n",
      "banos-completos": "Ba\xF1os",
      dormitorios_completos: "Dormitorios",
      "precio": "Precio"
    };
    this.variant = variant;
    this.campos = campos;
    this.normalizeProperties();
    this.id = feature.getId();
    this.coordinates = feature.getCenter().toJSON();
    this.container = new Wrapper("flex flex-col");
    console.log({ feature, campos, id: this.id });
    this.container.addClass(window.top.location.pathname).addClass("flex").addClass("flex-col").addStyle("lineHeight", "1.5em").addStyle("fontSize", "13px").addStyle("fontFamily", "Inter, sans-serif").addStyle("fontWeight", "400").addStyle("maxWidth", "350px");
    this.appendProperties();
  }
  get ubicacion() {
    let barrio = this.getProperty("barrio").replace("Barrio ", ""), comuna = this.getProperty("comuna");
    return barrio ? `Barrio ${barrio}, ${comuna}` : comuna;
  }
  get precio() {
    return this.getProperty("precio-publicacion") + " (UF)";
  }
  get tipo() {
    return `<span class="font-semibold">${this.getProperty("tipo_propiedad")}</span>
        <span style="margin-left:0.25em;margin-right:0.25em;">en</span>
        <span class="font-semibold">${this.getProperty("tipo_negocio")}</span>`;
  }
  normalizeProperties() {
    this.feature.setProperty("ubicacion", this.ubicacion);
    this.feature.setProperty("tipo", this.tipo);
    this.feature.setProperty("precio", this.precio);
    this.feature.setProperty("servicios", `${this.dormitorios_total}, ${this.banos_total}`);
    this.feature.setProperty("fecha-publicacion", this.getProperty("fecha-publicacion").split("-").reverse().join("-"));
  }
  get content() {
    this.container.div.classList.add("flex");
    this.container.div.classList.add("flex-col");
    return this.container.div;
  }
  getProperty(slug_name) {
    return this.feature.getProperty(slug_name);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  get linkWeb() {
    const postId = this.getProperty("codigo-wordpress") || this.getProperty("codigo_wordpress");
    return this.getProperty("link-publicacion-web") || postId && `"https://lacasadejuana.cl/?p=${postId}"` || null;
  }
  get hiddenSlugs() {
    return [
      "lat",
      "lng",
      "searchstring",
      "id_etapa_negocio",
      "precio-publicacion",
      "codigo_interno",
      "codigo-wordpress",
      "codigo_wordpress",
      "link-publicacion",
      "thumbnail",
      "barrio",
      "img-portada-wordpress",
      "id_tipo_negocio",
      "id_tipo_propiedad",
      "dormitorios",
      "banos-completos",
      "banos-servicio",
      "banos",
      "tipo_negocio",
      "tipo_propiedad",
      "comuna",
      "titulo-resumen-web",
      "dormitorios-servicio",
      "servicios",
      "fecha-publicacion"
    ];
  }
  appendProperties() {
    this.feature.forEachProperty((value, slug_name) => {
      if (slug_name === "nombre")
        console.log({ value, slug_name });
      if (this.shouldSkip(slug_name, value))
        return;
      let wrapper = new Wrapper(
        "flex w-full justify-between align-items-center " + slug_name
      );
      if (slug_name.includes("thumbnail") || slug_name.includes("img-portada-wordpress")) {
        this.printImagenPortada(wrapper, value);
      } else if (slug_name.includes("seudonimo") || slug_name.includes("nombre")) {
        this.printLinkWeb(wrapper, value);
      } else if (slug_name.includes("ubicacion")) {
        this.printUbicacion(wrapper, value);
      }
    });
  }
  printUbicacion(wrapper, value) {
    value = `<span class="nowrap font-bold text-bold">${value}</span>`;
    wrapper.setInnerHTML(value);
    wrapper.addClass("justify").addStyle("textAlign", "justify").addStyle("fontWeight", "500").addStyle("order", "3").addStyle("fontSize", "1.15em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("display", "block").addStyle("marginTop", "0em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printServicios(wrapper, value) {
    wrapper.setInnerHTML(value);
    wrapper.addStyle("fontWeight", "500").addStyle("order", "4").addStyle("fontSize", "1em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("marginTop", "0em").addStyle("marginBottom", "0.5em").prependTo(this.container.div);
  }
  shouldSkip(slug_name, value) {
    return !value || slug_name.includes("etapa") || this.hiddenSlugs.includes(slug_name) || slug_name.includes("codigo-wordpress") || slug_name.includes("codigo_wordpress") || slug_name.includes("link-publicacion") || !this.campos[slug_name] && slug_name !== "thumbnail";
  }
  printImagenPortada(wrapper, value) {
    const link = `<img src="${value}" style="width:100%;height:120px;object-fit:cover;"/>`;
    wrapper.setInnerHTML(link).addStyle("fontWeight", "600").addStyle("fontSize", "1.1em").addStyle("marginBottom", "0.3em").addStyle("order", "1").appendTo(this.container.div);
  }
  printLinkWeb(wrapper, value) {
    if (this.linkWeb) {
      wrapper.setInnerHTML(
        ` <a href=${this.linkWeb} target="_blank"><i class="fas fa-link"></i> ${value}</a>`
      );
    } else {
      wrapper.setInnerHTML(`  ${value}`);
    }
    wrapper.addStyle("fontWeight", "600").addStyle("order", "2").addStyle("fontSize", "1.35em").addStyle("marginTop", "0.7em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printTipo(wrapper, value) {
    wrapper.div.setAttribute("rel", "tipo");
    new Wrapper("py-1 pl-1 flex border border-1/2 min-w-[150px]").addStyle("fontFamily", "Inter, sans-serif").setTextContent(this.campos.tipo).addStyle("minWidth", "130px").addStyle("maxWidth", "140px").appendTo(wrapper.div);
    new Wrapper(
      "py-1 flex border border-1/2 pl-2 max-w-[350px] min-w-[200px] flex-grow overflow-hidden whitespace-nowrap"
    ).addStyle("maxWidth", "350px").addStyle("minWidth", "200px").addStyle("overflow", "hidden").addStyle("fontFamily", "Inter, sans-serif").setInnerHTML(value).appendTo(wrapper.div);
    wrapper.addStyle("order", "4").addStyle("fontWeight", "500").appendTo(this.container.div);
  }
  printTituloResumen(wrapper, value) {
    let words = value.split("|"), wordsQuantity = words.length, firstRow = words.slice(0, wordsQuantity / 2).join(" "), secondRow = words.slice(wordsQuantity / 2).join(" ");
    wrapper.setInnerHTML(value);
    wrapper.addStyle("fontWeight", "500").addStyle("fontWeight", "500").addStyle("order", "3").addStyle("fontSize", "1.1em").addStyle("maxWidth", "350px").addStyle("white-space", "normal").addStyle("marginTop", "0.2em").addStyle("marginBottom", "0.3em").prependTo(this.container.div);
  }
  printOtherCampos(wrapper, slug_name, value) {
    wrapper.div.setAttribute("rel", slug_name);
    new Wrapper("py-1 pl-1 flex border border-1/2 min-w-[165px]").addStyle("fontFamily", "Inter, sans-serif").addStyle("fontWeight", "400").addStyle("minWidth", "130px").addStyle("maxWidth", "140px").setTextContent(this.campos[slug_name]).appendTo(wrapper.div);
    new Wrapper(
      "py-1 flex border border-1/2 pl-2 max-w-[350px] min-w-[200px] flex-grow overflow-hidden whitespace-nowrap"
    ).addStyle("maxWidth", "350px").addStyle("minWidth", "200px").addStyle("overflow", "hidden").addStyle("fontFamily", "Inter, sans-serif").setTextContent(value).appendTo(wrapper.div);
    wrapper.addStyle("order", "5").addStyle("fontWeight", "500").appendTo(this.container.div);
  }
};

// src/js/property_map/PublicLayerDeals.ts
var PublicLayerDeals = ({ index, slug_name, name, path, layer_options, criteria }, comunas2) => ({
  //   features,
  layer_options,
  path,
  slug_name,
  filters_open: false,
  _map: null,
  index,
  controls: [
    // { property: 'className', name: 'Icon', inputType: 'icon' },
    //   { property: 'fillOpacity', name: 'Opacidad', min: 0, max: 1, step: 0.01, inputType: 'range' },
    { property: "scale", name: "Tama\xF1o", min: 0, max: 1, step: 0.05, inputType: "range" },
    { property: "strokeColor", name: "Color", inputType: "color" }
  ],
  get searchValue() {
    return this.$store.negocios.searchValue;
  },
  saveLayer() {
  },
  iconPreview: "",
  ...saveLayer({ slug_name, layer_options }),
  async init() {
    this.original_icon = JSON.parse(JSON.stringify(this.layer_options.icon ?? {}));
    this.iconPreview = this.updateIcon();
    this.layer_options.icon = this.updateIcon();
    this.name = name;
    this.slug_name = slug_name;
    this.criteria = criteria;
    layer_options.fillOpacity = layer_options.fillOpacity || 0.85;
    layer_options.scale = layer_options.scale || 0.05;
    this.debouncedSaveLayer = Alpine.debounce(this.saveLayer);
    const { fontFamily, className, text } = iconOptions.find((option) => option.className === layer_options.className);
    this.layer_options = { ...layer_options, name, slug_name, fontFamily, className, text };
    this.$watch("searchValue", this.setStyle.bind(this));
    this.$watch("index", this.setStyle.bind(this));
    this.addLayerToMap({ slug_name });
    this.declareEventHandlers();
    this._checked = globalThis.layers[slug_name].getMap() ? true : false;
    globalThis.layerComponents = globalThis.layerComponents || {};
    globalThis.layerComponents[this.slug_name] = this;
    this.watch();
    const checked = this.layer_options.checked;
    this.layer_options.checked = false;
    let strokeColor = this.layer_options.strokeColor;
    this.$watch("base64Icon", (newUrl) => {
      if (this.blobUrl)
        this.blobUrls.push(this.blobUrl);
      let b64Data = newUrl.replace("data:image/png;base64,", "");
      const contentType = "image/png";
      const blob = b64toBlob(b64Data, contentType);
      this.blobUrl = URL.createObjectURL(blob);
      this.lowEmphasisBlobUrl = URL.createObjectURL(b64toBlob(this.layer_options.url_low_emphasis.replace("data:image/png;base64,", ""), "image/png"));
    });
    setTimeout(async () => {
      this.layer_options.checked = true;
      const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
      const priceTag = document.createElement("div");
      priceTag.className = "price-tag";
      priceTag.textContent = "$2.5M";
      const marker = new AdvancedMarkerElement({
        map: this.gmap,
        position: this.gmap.getCenter(),
        content: priceTag
      });
    });
  },
  blobUrls: [],
  destroy() {
    Array.from(new Set(this.blobUrls)).forEach((blobUrl) => URL.revokeObjectURL(String(blobUrl)));
  },
  refreshStrokeColor() {
    let strokeColor = this.layer_options.strokeColor;
    let colors = computeColorAlpha(strokeColor, 1);
    colors.strokeColor = strokeColor;
    console.table(colors);
    this.layer_options.strokeColor = "#ffffff";
    requestAnimationFrame(() => this.layer_options.strokeColor = colors.colorRgba);
  },
  updateIcon(defaultScale = 1) {
    let {
      icon
    } = this.layer_options;
    if (!icon)
      return null;
    if (icon.url) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: icon.url,
        size: new google.maps.Size(54, 54),
        anchor: { x: width / 2, y: height },
        scaledSize: new google.maps.Size(width, height)
      };
    }
  },
  blobUrl: "",
  get base64Icon() {
    return (this.iconPreview ?? this.layer_options.icon).url;
  },
  get iconUrl() {
    return this.blobUrl || this.base64Icon;
  },
  get dealsWithCoords() {
    return this.$store.public_maps.dealsWithCoords;
  },
  toggleMap() {
    console.log("toggleMap " + this.slug_name);
    const map2 = this.getLayer().getMap() ? null : globalThis.gmap;
    this.getLayer().setMap(map2);
    this._map = map2;
  },
  fontSize: 33,
  setFontSize(fontSize) {
    this.fontSize = fontSize;
    this.setStyle();
  },
  get featuresMatchingSearch() {
    return this.getLayer().getArray().filter((feature) => feature.getProperty("searchstring").includes(this.searchValue));
  },
  setStyle() {
    let label = this.getMarkerLabel(), icon = this.getIconOptions(), highlightedIcon = this.getIconOptions(1.25);
    return globalThis.layers[this.slug_name].setStyle((feature) => {
      let codigo_interno = null, defaultScale = 1, highlighted = feature.getProperty("highlighted");
      if (codigo_interno === this.$store.public_maps.codigo_interno) {
        icon = this.getIconOptions(highlighted ? 1.25 : 1.15, codigo_interno);
      }
      const result = {
        visible: !this.searchValue || feature.getProperty("searchstring").includes(this.searchValue),
        zIndex: 140 - (this.index ?? 0) * 10 + 100 * (feature.getProperty("highlighted") ? 1 : 0),
        draggable: feature.getProperty("draggable"),
        //icon: this.layer_options.icon.url,
        icon: highlighted ? highlightedIcon : icon,
        label: feature.getProperty("draggable") ? label : null
      };
      return result;
    });
    return this;
  },
  isLowEmphasis(codigo_interno) {
    return this.$store.public_maps.codigo_interno && this.$store.public_maps.codigo_interno != codigo_interno;
  },
  getIconOptions(defaultScale = 1, codigo_interno = null) {
    let iconUrl = this.iconUrl;
    if (iconUrl) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: iconUrl,
        size: { width: 54, height: 54 },
        anchor: { x: width / 2, y: height },
        scaledSize: { width, height }
      };
    }
  },
  addLayerToMap({ slug_name: slug_name2 }) {
    if (globalThis.layers[slug_name2] instanceof google.maps.Data)
      return;
    const layer = new google.maps.Data();
    globalThis.layers[slug_name2] = layer;
    google.maps.event.addListener(layer, "map_changed", () => {
      this.checked = layer.getMap() ? true : false;
      if (this.checked) {
        this.addMouseOverBehavior(layer);
        this.addInfoWindowBehavior(layer);
      } else {
        this.removeMouseOverBehavior(layer);
        this.removeInfoWindowBehavior(layer);
      }
    });
    this.setStyle(layer);
    setTimeout(() => {
      this.setFontSize(48);
    }, 500);
    return this;
  },
  removeInfoWindowBehavior(layer) {
    if (!this.infowindow_added)
      return;
    this.infowindow_added = false;
    google.maps.event.clearListeners(layer, "click");
  },
  addInfoWindowBehavior(layer) {
    if (this.infowindow_added)
      return;
    this.infowindow_added = true;
    google.maps.event.addListener(layer, "click", (event) => {
      globalThis.gmap.infowindow.close();
      let negocio = event.feature;
      this.getMap().panTo(event.latLng);
      let html = new negocioFeatureToHtml(negocio, this.$store.columnas_actuales.featureProperties).content;
      this.getInfoWindow().setContent(html);
      this.getInfoWindow().setPosition(event.latLng);
      this.getInfoWindow().open({ map: globalThis.gmap });
    });
  },
  get infowindow() {
    return globalThis.gmap.infowindow;
  },
  getInfoWindow() {
    return globalThis.gmap.infowindow;
  },
  mouseover_added: false,
  infowindow_added: false,
  mouseOverListener: null,
  mouseOutListener: null,
  clickListener: null,
  declareEventHandlers() {
    const labelProperty = this.layer_options.labelProperty || "seudonimo-propiedad";
    this.marker = globalThis.gmap.labelMarker;
    if (!this.mouseOverListener) {
      this.mouseOverListener = (event) => {
        const { feature } = event;
        if (this.marker.featuredProperty) {
          this.marker.featuredProperty.setProperty("highlighted", false);
        }
        this.marker.featuredProperty = feature;
        feature.setProperty("highlighted", true);
        const featureLabel = feature.getProperty(labelProperty);
        if (featureLabel) {
          this.marker.setLabel(this.getNameLabel(featureLabel));
          this.marker.setPosition(feature.getCenter());
          this.marker.setVisible(true);
          this.marker.setMap(globalThis.gmap);
        }
      };
    }
    if (!this.mouseOutListener) {
      this.mouseOutListener = (event) => {
        event.feature.setProperty("highlighted", false);
        if (this.marker.featuredProperty) {
          this.marker.featuredProperty.setProperty("highlighted", false);
        }
        this.marker.setLabel("");
        this.marker.setVisible(false);
        this.marker.setMap(null);
      };
    }
    if (!this.clickListener) {
      this.clickListener = (event) => {
        globalThis.gmap.infowindow.close();
        let negocio = event.feature, { domEvent } = event || {}, { shiftKey } = domEvent || {};
        console.info("clickListener", { domEvent, shiftKey });
        this.getMap().panTo(event.latLng);
        let html = new negocioFeatureToHtml(negocio, this.campos).content;
        this.getInfoWindow().setContent(html);
        this.getInfoWindow().setPosition(event.latLng);
        this.getInfoWindow().open({ map: globalThis.gmap });
      };
    }
  },
  get map() {
    return this.getLayer().getMap();
  },
  getMap() {
    return this.getLayer().getMap();
  },
  getLength() {
    return this.getLayer().getLength();
  },
  get layer() {
    return this.getLayer();
  },
  get gmap() {
    return globalThis.gmap;
  },
  async removeFeatures() {
    const lengthBefore = this.getLength();
    this.getLayer().forEach((feature) => {
      this.getLayer().remove(feature);
    });
    this.length = this.getLength();
    console.log({ layer: this.slug_name, lengthBefore, lengthAfter: this.length });
    return this;
  },
  mapDialogOpen: false,
  async appendFeatures(dealsWithCoords) {
    this.features = (dealsWithCoords || this.dealsWithCoords).filter((negocio) => negocio.match(this.criteria)).map((n) => n.toFeature());
    for (let feature of this.features) {
      this.getLayer().addGeoJson(feature);
    }
    this.length = this.getLength();
    return this.getLayer();
  },
  tomselect: null
});

// src/js/property_map/PublicLayerGeoJson.ts
var PublicLayerGeoJson = ({ index, slug_name, name, layer_options }, comunas2) => ({
  mapTypes: [],
  lastType: null,
  layer_options,
  filters_open: false,
  _map: null,
  index,
  controls: [
    //  { property: 'className', name: 'Icon', inputType: 'icon' },
    { property: "fillOpacity", name: "Opacidad", min: 0, max: 1, step: 0.01, inputType: "range" },
    { property: "strokeWeight", name: "Grosor", min: 0, max: 5, step: 0.05, inputType: "range" },
    { property: "scale", name: "Tama\xF1o", min: 0, max: 1, step: 0.05, inputType: "range" },
    { property: "strokeColor", name: "Color", inputType: "color" }
  ],
  boundingBox: {
    "south": -33.48730404102389,
    "west": -70.68367683729824,
    "north": -33.35133207833821,
    "east": -70.4783698304623
  },
  bounds: null,
  ...saveLayer({ slug_name, layer_options }),
  codigo_interno: null,
  async init() {
    if (!google.maps.Data.Feature.prototype.getCenter) {
      extendMapDataProtoType(google.maps);
    }
    this.bounds = new google.maps.LatLngBounds(this.boundingBox);
    let qs = new URL(location.href);
    if (qs.searchParams.get("codigo_interno")) {
      this.codigo_interno = qs.searchParams.get("codigo_interno");
    }
    let { layer_options: layer_options2, ...featureCollection } = await staticFetchWrapper(this.layer_options.url, {});
    this.layer_options = { ...this.layer_options, ...layer_options2 };
    this.featureCollection = featureCollection;
    this.original_icon = JSON.parse(JSON.stringify(this.layer_options.icon ?? {}));
    this.iconPreview = this.updateIcon();
    globalThis.exampleLayerObject = PublicLayersObject;
    let example_layer = PublicLayersObject[slug_name] || { layer_options: layer_options2 }, icon = (example_layer.layer_options || layer_options2).icon;
    this.name = name;
    this.slug_name = slug_name;
    globalThis.layers = globalThis.layers || {};
    this.addLayerToMap();
    this.declareEventHandlers();
    globalThis.layerComponents = globalThis.layerComponents || {};
    globalThis.layerComponents[this.slug_name] = this;
    this.watch();
    const checked = this.layer_options.checked;
    this.layer_options.checked = false;
    this.layer_options = { ...layer_options2, name, slug_name };
    setTimeout(() => {
      this.layer_options.checked = checked;
    }, 1e3);
  },
  updateIcon(defaultScale = 1) {
    let {
      text,
      fontFamily,
      strokeColor,
      fillOpacity,
      fillColor,
      strokeOpacity,
      fontSize,
      scale: scale3,
      icon,
      strokeWeight,
      rotation
    } = this.layer_options;
    if (!icon)
      return null;
    if (icon.path) {
      return {
        path: icon.path,
        scale: (scale3 ?? icon.scale) / 10,
        fillColor: strokeColor || icon.strokeColor || strokeColor,
        strokeColor,
        strokeOpacity,
        strokeWeight: icon.strokeWeight ?? (strokeWeight || 0.1),
        fillOpacity,
        rotation: icon.rotation ?? (rotation ?? 90),
        anchor: new google.maps.Point(96, 48)
      };
    }
    if (icon.url) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: icon.url,
        size: new google.maps.Size(54, 54),
        anchor: { x: width / 2, y: height },
        scaledSize: new google.maps.Size(width, height)
      };
    }
  },
  get base64Icon() {
    return (this.iconPreview ?? this.layer_options.icon ?? {}).url;
  },
  get iconUrl() {
    return this.blobUrl || this.base64Icon;
  },
  getIconOptions(defaultScale = 1) {
    let iconUrl = this.iconUrl;
    if (iconUrl) {
      defaultScale = defaultScale * Number(this.layer_options.scale);
      let width = 54 * defaultScale, height = 54 * defaultScale;
      return {
        scale: defaultScale,
        url: iconUrl,
        size: { width: 96, height: 96 },
        anchor: { x: width / 2, y: height },
        scaledSize: { width, height }
      };
    }
  },
  setStyle() {
    requestAnimationPromise3().then(() => {
      let icon = this.iconPreview;
      let label = this.getMarkerLabel();
      icon = this.getIconOptions();
      this.getLayer().setStyle((feature) => {
        let comuna = feature.getProperty("Comuna"), comunaOffset = Object.keys(comunas2).indexOf(comuna);
        if (!comuna || comunaOffset === -1) {
          comunaOffset = 0;
        }
        let styleObj = {
          icon
          //      visible: isVisible,
          // label,
        };
        return styleObj;
      });
    });
    return this;
  },
  fontSize: 33,
  setFontSize(fontSize) {
    this.fontSize = fontSize;
    this.setStyle();
  },
  mouseover_added: false,
  infowindow_added: false,
  addLayerToMap() {
    const layer = globalThis.layers[this.slug_name] || new google.maps.Data();
    globalThis.layers[this.slug_name] = layer;
    return this.appendFeatures().then(() => {
      google.maps.event.addListener(layer, "map_changed", () => {
        this.checked = layer.getMap() ? true : false;
        if (this.checked) {
          this.addMouseOverBehavior(layer);
          this.addInfoWindowBehavior(layer);
        } else {
          this.removeMouseOverBehavior(layer);
          this.removeInfoWindowBehavior(layer);
        }
      });
      this.length = layer.getLength();
      return this.setStyle();
    });
  },
  mouseOverListener: null,
  mouseOutListener: null,
  clickListener: null,
  declareEventHandlers() {
    const labelProperty = this.layer_options.labelProperty || "Nombre_de_Barrio";
    this.marker = this.marker || new google.maps.Marker({
      position: this.getLayer().getBounds().getCenter(),
      visible: true,
      map: globalThis.gmap,
      zIndex: 210,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 5,
        strokeWeight: 2,
        labelOrigin: new google.maps.Point(0, 2),
        strokeColor: "rgba(200,200,200,0)"
      }
    });
    if (!this.mouseOverListener) {
      this.mouseOverListener = (event) => {
        const { feature } = event;
        feature.setProperty("highlighted", true);
        let featureLabel = feature.getProperty(labelProperty);
        if (featureLabel) {
          this.marker.setLabel(this.getNameLabel(featureLabel));
          this.marker.setPosition(feature.getCenter());
          this.marker.setVisible(true);
        }
      };
    }
    if (!this.mouseOutListener) {
      this.mouseOutListener = (event) => {
        event.feature.setProperty("highlighted", false);
        this.marker.setLabel("");
        this.marker.setVisible(false);
      };
    }
    if (!this.clickListener) {
      this.clickListener = (event) => {
        globalThis.gmap.infowindow.close();
        let negocio = event.feature;
        console.log({ latLng: event.latLng });
        this.getMap().panTo(event.latLng);
        let html = new genericFeatureToHtml(negocio, this.layer_options.campos).content;
        this.getInfoWindow().setContent(html);
        this.getInfoWindow().setPosition(event.latLng);
        this.getInfoWindow().open({ map: globalThis.gmap });
      };
    }
  },
  get infowindow() {
    return globalThis.gmap.infowindow;
  },
  getInfoWindow() {
    return globalThis.gmap.infowindow;
  },
  getLayer() {
    return globalThis.layers[this.slug_name];
  },
  getLength() {
    return this.getLayer().getLength();
  },
  length: 0,
  setMap(map2) {
    return this.getLayer().setMap(map2);
  },
  getMap() {
    return this.getLayer().getMap();
  },
  get gmap() {
    return globalThis.gmap;
  },
  get layer() {
    return this.getLayer();
  },
  removeFeatures() {
    return;
  },
  async appendFeatures() {
    if (this.getLayer() && this.getLayer().getLength() > 0)
      return this.getLayer();
    if (this.featureCollection) {
      this.getLayer().addGeoJson(this.featureCollection);
    } else if (this.layer_options.url) {
      this.getLayer().loadGeoJson(this.layer_options.url);
    }
    setTimeout(() => this.length = this.getLength(), 1500);
    return this.getLayer();
  },
  mapDialogOpen: false
});

// src/js/property_map/public_map_modules/extendMapDataProtoType.ts
function extendMapDataProtoType2() {
  let maps = google.maps;
  console.info({ googleMaps: maps });
  var MAP_PIN = "M0-48c-9.8 0-17.7 7.8-17.7 17.4 0 15.5 17.7 30.6 17.7 30.6s17.7-15.4 17.7-30.6c0-9.6-7.9-17.4-17.7-17.4z";
  var SQUARE_PIN = "M22-48h-44v43h16l6 5 6-5h16z";
  var SHIELD = "M18.8-31.8c.3-3.4 1.3-6.6 3.2-9.5l-7-6.7c-2.2 1.8-4.8 2.8-7.6 3-2.6.2-5.1-.2-7.5-1.4-2.4 1.1-4.9 1.6-7.5 1.4-2.7-.2-5.1-1.1-7.3-2.7l-7.1 6.7c1.7 2.9 2.7 6 2.9 9.2.1 1.5-.3 3.5-1.3 6.1-.5 1.5-.9 2.7-1.2 3.8-.2 1-.4 1.9-.5 2.5 0 2.8.8 5.3 2.5 7.5 1.3 1.6 3.5 3.4 6.5 5.4 3.3 1.6 5.8 2.6 7.6 3.1.5.2 1 .4 1.5.7l1.5.6c1.2.7 2 1.4 2.4 2.1.5-.8 1.3-1.5 2.4-2.1.7-.3 1.3-.5 1.9-.8.5-.2.9-.4 1.1-.5.4-.1.9-.3 1.5-.6.6-.2 1.3-.5 2.2-.8 1.7-.6 3-1.1 3.8-1.6 2.9-2 5.1-3.8 6.4-5.3 1.7-2.2 2.6-4.8 2.5-7.6-.1-1.3-.7-3.3-1.7-6.1-.9-2.8-1.3-4.9-1.2-6.4z";
  var ROUTE = "M24-28.3c-.2-13.3-7.9-18.5-8.3-18.7l-1.2-.8-1.2.8c-2 1.4-4.1 2-6.1 2-3.4 0-5.8-1.9-5.9-1.9l-1.3-1.1-1.3 1.1c-.1.1-2.5 1.9-5.9 1.9-2.1 0-4.1-.7-6.1-2l-1.2-.8-1.2.8c-.8.6-8 5.9-8.2 18.7-.2 1.1 2.9 22.2 23.9 28.3 22.9-6.7 24.1-26.9 24-28.3z";
  var SQUARE = "M-24-48h48v48h-48z";
  var SQUARE_ROUNDED = "M24-8c0 4.4-3.6 8-8 8h-32c-4.4 0-8-3.6-8-8v-32c0-4.4 3.6-8 8-8h32c4.4 0 8 3.6 8 8v32z";
  var inherits = function(childCtor, parentCtor) {
    function tempCtor() {
    }
    ;
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
  };
  class MarkerLabel extends maps.OverlayView {
    constructor(options) {
      super();
      var self2 = this;
      this.setValues(options);
      this.div = document.createElement("div");
      this.div.className = "map-icon-label";
      maps.event.addDomListener(this.div, "click", function(e) {
        e.stopPropagation && e.stopPropagation();
        maps.event.trigger(self2.marker, "click");
      });
    }
    onAdd() {
      var pane = this.getPanes().overlayImage.appendChild(this.div);
      var self2 = this;
      this.listeners = [
        google.maps.event.addListener(this, "position_changed", function() {
          self2.draw();
        }),
        google.maps.event.addListener(this, "text_changed", function() {
          self2.draw();
        }),
        google.maps.event.addListener(this, "zindex_changed", function() {
          self2.draw();
        })
      ];
    }
    // Marker Label onRemove
    onRemove() {
      this.div.parentNode.removeChild(this.div);
      for (var i = 0, I = this.listeners.length; i < I; ++i) {
        google.maps.event.removeListener(this.listeners[i]);
      }
    }
    draw() {
      var projection = this.getProjection();
      var position = projection.fromLatLngToDivPixel(this.get("position"));
      var div = this.div;
      this.div.innerHTML = this.get("text").toString();
      div.style.zIndex = this.get("zIndex");
      div.style.position = "absolute";
      div.style.display = "block";
      div.style.left = position.x - div.offsetWidth / 2 + "px";
      div.style.top = position.y - div.offsetHeight + "px";
    }
  }
  ;
  maps.importLibrary("marker").then(() => {
    class Marker extends maps.Marker {
      constructor(options) {
        super();
        maps.Marker.apply(this, arguments);
        if (options.map_icon_label) {
          this.MarkerLabel = new MarkerLabel({
            map: this.map,
            marker: this,
            text: options.map_icon_label
          });
          this.MarkerLabel.bindTo("position", this, "position");
        }
      }
      setMap() {
        maps.Marker.prototype.setMap.apply(this, arguments);
        this.MarkerLabel && this.MarkerLabel.setMap.apply(this.MarkerLabel, arguments);
      }
    }
  });
  google.maps.Data.Feature.prototype.getCenter = function() {
    return this.getBounds().getCenter();
  };
  google.maps.Data.prototype.getBounds = function() {
    var featuresArray = [];
    var bounds = new google.maps.LatLngBounds();
    this.forEach(function(feature) {
      bounds.union(feature.getBounds());
    });
    return bounds;
  };
  google.maps.Data.Feature.prototype.getBounds = function() {
    const bounds = new google.maps.LatLngBounds();
    this.getGeometry().forEachLatLng(function(latLng) {
      bounds.extend(latLng);
    });
    return bounds;
  };
  google.maps.Data.Geometry.prototype.getBounds = function() {
    const bounds = new google.maps.LatLngBounds();
    this.forEachLatLng(function(latLng) {
      bounds.extend(latLng);
    });
    return bounds;
  };
  maps.Data.prototype.getBounds = function() {
    var featuresArray = [];
    var bounds = new maps.LatLngBounds();
    this.forEach(function(feature) {
      bounds.union(feature.getBounds());
    });
    return bounds;
  };
  maps.Data.prototype.removeFeatures = function() {
    this.forEach((feature) => {
      this.remove(feature);
    });
  };
  maps.Data.prototype.getArray = function() {
    const featuresArray = [];
    this.forEach(function(feature) {
      featuresArray.push(feature);
    });
    return featuresArray;
  };
  maps.Data.Feature.prototype.getProperties = function() {
    const properties = {};
    this.forEachProperty((value, name) => {
      properties[name] = value;
    });
    return properties;
  };
  maps.Data.prototype.getLength = function() {
    let length = 0;
    this.forEach(function(feature) {
      length++;
    });
    return length;
  };
  return maps;
}

// src/js/property_map/public_map_modules/map_styles/BentleyMap.ts
var BentleyMap = {
  name: "Bentley Map",
  alt: "A subtle style reminiscent of old paper printed road maps.",
  img: "/img/maptypes/bentleymap_100.png",
  styles: [
    {
      featureType: "landscape",
      stylers: [
        {
          hue: "#F1FF00"
        },
        {
          saturation: -27.4
        },
        {
          lightness: 9.4
        },
        {
          gamma: 1
        }
      ]
    },
    {
      featureType: "road.highway",
      stylers: [
        {
          hue: "#0099FF"
        },
        {
          saturation: -20
        },
        {
          lightness: 36.4
        },
        {
          gamma: 1
        }
      ]
    },
    {
      featureType: "road.arterial",
      stylers: [
        {
          hue: "#00FF4F"
        },
        {
          saturation: 0
        },
        {
          lightness: 0
        },
        {
          gamma: 1
        }
      ]
    },
    {
      featureType: "road.local",
      stylers: [
        {
          hue: "#FFB300"
        },
        {
          saturation: -38
        },
        {
          lightness: 11.2
        },
        {
          gamma: 1
        }
      ]
    },
    {
      featureType: "water",
      stylers: [
        {
          hue: "#00B6FF"
        },
        {
          saturation: 4.2
        },
        {
          lightness: -63.4
        },
        {
          gamma: 1
        }
      ]
    },
    {
      featureType: "poi",
      stylers: [
        {
          hue: "#9FFF00"
        },
        {
          saturation: 0
        },
        {
          lightness: 0
        },
        {
          gamma: 1
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/map_styles/FlatDesign.ts
var FlatDesign = {
  name: "Flat Map",
  alt: "Flat Design Map Without Labels",
  styles: [
    {
      featureType: "all",
      elementType: "labels",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "administrative",
      elementType: "all",
      stylers: [
        {
          visibility: "simplified"
        },
        {
          color: "#5b6571"
        },
        {
          lightness: "35"
        }
      ]
    },
    {
      featureType: "administrative.neighborhood",
      elementType: "all",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "landscape",
      elementType: "all",
      stylers: [
        {
          visibility: "on"
        },
        {
          color: "#f3f4f4"
        }
      ]
    },
    {
      featureType: "landscape.man_made",
      elementType: "geometry",
      stylers: [
        {
          weight: 0.9
        },
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "poi.park",
      elementType: "geometry.fill",
      stylers: [
        {
          visibility: "on"
        },
        {
          color: "#83cead"
        }
      ]
    },
    {
      featureType: "road",
      elementType: "all",
      stylers: [
        {
          visibility: "on"
        },
        {
          color: "#ffffff"
        }
      ]
    },
    {
      featureType: "road",
      elementType: "labels",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "road.highway",
      elementType: "all",
      stylers: [
        {
          visibility: "on"
        },
        {
          color: "#fee379"
        }
      ]
    },
    {
      featureType: "road.highway",
      elementType: "geometry",
      stylers: [
        {
          visibility: "on"
        }
      ]
    },
    {
      featureType: "road.highway",
      elementType: "labels",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "road.highway",
      elementType: "labels.icon",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "road.highway.controlled_access",
      elementType: "labels.icon",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "road.arterial",
      elementType: "all",
      stylers: [
        {
          visibility: "simplified"
        },
        {
          color: "#ffffff"
        }
      ]
    },
    {
      featureType: "road.arterial",
      elementType: "labels",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "road.arterial",
      elementType: "labels.icon",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "water",
      elementType: "all",
      stylers: [
        {
          visibility: "on"
        },
        {
          color: "#7fc8ed"
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/map_styles/Grass.ts
var Grass = {
  name: "Grass Map",
  alt: "Grass is greener, Water is bluer",
  styles: [
    {
      stylers: [
        {
          saturation: -100
        }
      ]
    },
    {
      featureType: "water",
      elementType: "geometry.fill",
      stylers: [
        {
          color: "#0099dd"
        }
      ]
    },
    {
      elementType: "labels",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      featureType: "poi.park",
      elementType: "geometry.fill",
      stylers: [
        {
          color: "#aadd55"
        }
      ]
    },
    {
      featureType: "road.highway",
      elementType: "labels",
      stylers: [
        {
          visibility: "on"
        }
      ]
    },
    {
      featureType: "road.arterial",
      elementType: "labels.text",
      stylers: [
        {
          visibility: "on"
        }
      ]
    },
    {
      featureType: "road.local",
      elementType: "labels.text",
      stylers: [
        {
          visibility: "on"
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/map_styles/LightBlueMap.ts
var LightBlueMap = {
  name: "Light Blue",
  alt: "Light blue and white style.",
  img: "/img/maptypes/lightbluemap_100.png",
  styles: [
    {
      elementType: "all",
      featureType: "water",
      stylers: [
        {
          hue: "#71d6ff"
        },
        {
          saturation: 100
        },
        {
          lightness: -5
        },
        {
          visibility: "on"
        }
      ]
    },
    {
      elementType: "all",
      featureType: "poi",
      stylers: [
        {
          hue: "#ffffff"
        },
        {
          saturation: -100
        },
        {
          lightness: 100
        },
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "all",
      featureType: "transit",
      stylers: [
        {
          hue: "#ffffff"
        },
        {
          saturation: 0
        },
        {
          lightness: 100
        },
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "geometry",
      featureType: "road.highway",
      stylers: [
        {
          hue: "#deecec"
        },
        {
          saturation: -73
        },
        {
          lightness: 72
        },
        {
          visibility: "on"
        }
      ]
    },
    {
      elementType: "labels",
      featureType: "road.highway",
      stylers: [
        {
          hue: "#bababa"
        },
        {
          saturation: -100
        },
        {
          lightness: 25
        },
        {
          visibility: "on"
        }
      ]
    },
    {
      elementType: "geometry",
      featureType: "landscape",
      stylers: [
        {
          hue: "#e3e3e3"
        },
        {
          saturation: -100
        },
        {
          lightness: 0
        },
        {
          visibility: "on"
        }
      ]
    },
    {
      elementType: "geometry",
      featureType: "road",
      stylers: [
        {
          hue: "#ffffff"
        },
        {
          saturation: -100
        },
        {
          lightness: 100
        },
        {
          visibility: "simplified"
        }
      ]
    },
    {
      elementType: "labels",
      featureType: "administrative",
      stylers: [
        {
          hue: "#59cfff"
        },
        {
          saturation: 100
        },
        {
          lightness: 34
        },
        {
          visibility: "on"
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/map_styles/PaperMap.ts
var PaperMap = {
  name: "Paper Map",
  styles: [
    {
      "featureType": "administrative",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "off"
        }
      ]
    },
    {
      "featureType": "landscape",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        },
        {
          "hue": "#0066ff"
        },
        {
          "saturation": 74
        },
        {
          "lightness": 100
        }
      ]
    },
    {
      "featureType": "poi",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        }
      ]
    },
    {
      "featureType": "road",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        }
      ]
    },
    {
      "featureType": "road.highway",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "off"
        },
        {
          "weight": 0.6
        },
        {
          "saturation": -85
        },
        {
          "lightness": 61
        }
      ]
    },
    {
      "featureType": "road.highway",
      "elementType": "geometry",
      "stylers": [
        {
          "visibility": "on"
        }
      ]
    },
    {
      "featureType": "road.arterial",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "off"
        }
      ]
    },
    {
      "featureType": "road.local",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "on"
        }
      ]
    },
    {
      "featureType": "transit",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        }
      ]
    },
    {
      "featureType": "water",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        },
        {
          "color": "#5f94ff"
        },
        {
          "lightness": 26
        },
        {
          "gamma": 5.86
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/map_styles/ShiftWorker.ts
var ShiftWorker = {
  name: "Shift Worker",
  alt: "Display streets with a minimum of distractions. Best used around zoom level 16 to show a local address.",
  img: "/img/maptypes/shiftworkermap_100.png",
  styles: [
    {
      stylers: [
        {
          saturation: -100
        },
        {
          gamma: 1
        }
      ]
    },
    {
      elementType: "labels.text.stroke",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "labels.text",
      featureType: "poi.business",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "labels.icon",
      featureType: "poi.business",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "labels.text",
      featureType: "poi.place_of_worship",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "labels.icon",
      featureType: "poi.place_of_worship",
      stylers: [
        {
          visibility: "off"
        }
      ]
    },
    {
      elementType: "geometry",
      featureType: "road",
      stylers: [
        {
          visibility: "simplified"
        }
      ]
    },
    {
      featureType: "water",
      stylers: [
        {
          visibility: "on"
        },
        {
          saturation: 50
        },
        {
          gamma: 0
        },
        {
          hue: "#50a5d1"
        }
      ]
    },
    {
      elementType: "labels.text.fill",
      featureType: "administrative.neighborhood",
      stylers: [
        {
          color: "#333333"
        }
      ]
    },
    {
      elementType: "labels.text",
      featureType: "road.local",
      stylers: [
        {
          weight: 0.5
        },
        {
          color: "#333333"
        }
      ]
    },
    {
      elementType: "labels.icon",
      featureType: "transit.station",
      stylers: [
        {
          gamma: 1
        },
        {
          saturation: 50
        }
      ]
    }
  ]
};

// src/js/property_map/public_map_modules/MapTypeListener.ts
var MapTypeListener = class extends BaseClass {
  constructor(gmap) {
    super();
    this.onChangedHandlers = [];
    this.onSaveHandlers = [];
    this.buttonpromises = [];
    this.gmap = gmap;
    this.addCustomStyles().then(async () => {
      this.addClickListener();
      if (Alpine.store("public_maps").full_map) {
        let mapSearch = document.querySelector("#searchCampo");
        this.gmap.controls[google.maps.ControlPosition.TOP_RIGHT].push(mapSearch);
      } else {
        console.log("inject styles to gmap");
        let styleTag2 = document.createElement("style");
        styleTag2.textContent = `@import url('/css/app.css')`;
        this.gmap.controls[google.maps.ControlPosition.TOP_RIGHT].push(styleTag2);
      }
      return this;
    });
  }
  onChanged(handler5) {
    this.on("changed", handler5);
    return this;
  }
  addCustomStyles() {
    if (this.buttonpromises.length)
      return Promise.all(this.buttonpromises);
    Object.entries({ BentleyMap, ShiftWorker, LightBlueMap, Grass, FlatDesign, PaperMap }).forEach(([id, { name, alt, img, styles }]) => {
      const promise = new Promise((resolve2) => {
        const styledMapType = new google.maps.StyledMapType(styles, { alt, name });
        console.log(`Adding mapType ${name}`);
        this.gmap.mapTypes.set(id, styledMapType);
        resolve2(id);
      });
      this.buttonpromises.push(
        promise
      );
    });
    return Promise.all(this.buttonpromises);
  }
  addClickListener() {
    this.gmnoPrint = this.gmnoPrint || document.querySelector(".gmnoprint.custom_maps");
    this.gmnoPrint && this.gmnoPrint.addEventListener("click", (e) => {
      const button = e.target, { id, rel, name } = button;
      this.gmap.setMapTypeId(button.id);
    });
  }
  addMapTypeChangedListener() {
    google.maps.event.addListener(this.gmap, "maptypeid_changed", () => {
      const id = 1;
      this.processEventListeners("changed", id);
      const gmnoPrint = this.gmnoPrint || document.querySelector(".gmnoprint.custom_maps");
      if (!gmnoPrint)
        return;
      gmnoPrint.className = `gmnoprint custom_maps ${id}`;
      const mapButtons = Array.from(gmnoPrint.querySelectorAll("button"));
      const mapTypeButtons = Array.from(gmnoPrint.querySelectorAll("button.mapType"));
      const button = gmnoPrint.querySelector(`#${id}`);
      if (button) {
        mapButtons.forEach((button2) => {
          button2.style.fontWeight = "normal";
          button2.classList.remove("font-bold");
        });
        button.style.fontWeight = "500";
      } else {
        mapTypeButtons.forEach((button2) => {
          button2.style.fontWeight = "normal";
          button2.classList.remove("font-bold");
        });
      }
    });
  }
};

// src/js/property_map/public_map_modules/populateMapFields.ts
var populateMapFields = (columnas_actuales, campos_busqueda) => {
  return columnas_actuales.columnDefs.concat([
    campos_busqueda.find("nombre"),
    campos_busqueda.find("id"),
    campos_busqueda.find("id_tipo_negocio"),
    campos_busqueda.find("id_tipo_propiedad"),
    campos_busqueda.find("lng"),
    campos_busqueda.find("lat"),
    campos_busqueda.find("comuna"),
    campos_busqueda.find("seudonimo-propiedad"),
    campos_busqueda.find("codigo-interno"),
    campos_busqueda.find("codigo_interno"),
    campos_busqueda.find("link-img-portada-wordpress"),
    campos_busqueda.find("titulo-resumen-web"),
    campos_busqueda.find("link-publicacion-web"),
    campos_busqueda.find("codigo-wordpress"),
    campos_busqueda.find("id_wordpress")
  ]).filter(
    (c) => c && c.id_input_type !== "8" /* INPUT_CHECKBOX */ && c.id_input_type !== "9" /* INPUT_SELECT_MULTIPLE */ && c.slug_name !== "direccion"
  ).reduce((accum, campo) => {
    accum[campo.slug_name.replace(
      "fecha_creacion_visual",
      "created_at"
    )] = campo.name.replace(/^F\.\s/, "Fecha ");
    return accum;
  }, {});
};

// src/js/property_map/PublicMapFrameData.ts
var comunas = [
  "Lo Barnechea",
  "Las Condes",
  "La Reina",
  "\xD1u\xF1oa",
  "Providencia",
  "Vitacura",
  "Santiago"
];
var PublicMapFrameData = ({ codigo_interno = null, extent = null }) => {
  return {
    gmap: null,
    mapTypes: [],
    lastType: null,
    barriosButton: null,
    barriosVisible: false,
    mapOptions: {
      zoom: 15,
      bounds: {},
      center: {
        lat: -33.41,
        lng: -70.575
      },
      mapTypeControl: true,
      fullscreenControl: true,
      gestureHandling: "greedy",
      scaleControl: true,
      zoomControl: true,
      streetViewControl: true
    },
    comunas: comunas.reduce((accum, comuna) => {
      accum[comuna] = true;
      return accum;
    }, {}),
    get searchValue() {
      return this.$store.negocios.searchValue;
    },
    get filters_open() {
      return this.$store.active_filter.filters_open;
    },
    set filters_open(value) {
      this.$store.active_filter.filters_open = value;
      this.$dispatch("filtersopen", value);
    },
    bounds: null,
    codigo_interno: null,
    async init() {
      let mapPromise = google.maps.importLibrary("maps"), markerPromise = google.maps.importLibrary("marker"), qs = new URL(location.href);
      if (qs.searchParams.get("extent")) {
        let [west, north, east, south] = qs.searchParams.get("extent").split(",");
        this.bounds = {
          east: Number(east),
          north: Number(north),
          west: Number(west),
          south: Number(south)
        };
      } else if (codigo_interno) {
        this.bounds = {
          "south": -33.47262469572745,
          "west": -70.61415217498778,
          "north": -33.4076631444587,
          "east": -70.5119278250122
        };
      } else {
        this.bounds = { "south": -33.46, "west": -70.67, "north": -33.336, "east": -70.49 };
      }
      if (qs.searchParams.get("codigo_interno")) {
        this.codigo_interno = qs.searchParams.get("codigo_interno");
        this.$store.public_maps.setCodigoInterno(this.codigo_interno);
      }
      this.$store.negocios.on("complete", () => this.appendFeatures());
      this.$watch("comunas", (comunas2) => {
        Object.keys(globalThis.layers).forEach((key) => {
          globalThis.layerComponents[key] && globalThis.layerComponents[key].setStyle();
        });
      });
      this.$watch("searchValue", Alpine.debounce(this.fitBoundsMatchingSearch.bind(this), 500));
      globalThis.mapFrameData = this;
      this.$store.campos_busqueda.on("ready").then((columnas_actuales) => {
        this.campos = populateMapFields(
          { columnDefs: [] },
          this.$store.campos_busqueda
        );
      });
      console.warn("deciding between createMap and store ready");
      this.$store.public_maps.once("ready", (maps) => {
        console.info("mapFrameData, received store ready event");
        console.info({ googleMaps: maps });
        extendMapDataProtoType2(maps);
        this.$store.public_maps.once("map_created", (gmap) => {
          this.$store.public_maps.fetchPublicaciones();
          console.log("map_created", this.gmap, gmap);
          this.gmap = this.$store.public_maps.customElementsMap;
          globalThis.gmap = Alpine.raw(this.gmap);
          this.mapCreatedHandlers.forEach((handler5) => handler5(this.gmap));
          this.googleReady = true;
          this.marker = this.createMarker();
          globalThis.layers = {};
          this.$store.public_maps.once("layers_added").then(async () => {
            console.trace("layers added");
            this.appendFeatures();
            this.onMapCreated((gmap2) => {
              console.warn("map created");
              this.panToCodigoInterno();
            });
            if (this.bounds) {
              this.gmap.fitBounds(this.bounds);
            } else if (this.storedStatus.center && this.storedStatus.zoom) {
              this.gmap.setOptions(this.storedStatus);
            } else {
              await waitFor(1e3);
              this.fitBounds();
            }
            this.$store.negocios.next_page_url = "https://maps.lacasadejuana.cl/api/publicaciones";
            this.$store.negocios.complete = false;
            this.$store.public_maps.fetchPublicaciones();
          });
          this.$store.public_maps.layer_object = PublicLayersObject;
          this.$store.public_maps.createLayers(this);
          this.createDomManager(this.codigo_interno ?? codigo_interno);
          setTimeout(() => {
            if (globalThis.layerComponents.colegios)
              globalThis.layerComponents.colegios.layer_options.checked = true;
            if (globalThis.layerComponents.metro)
              globalThis.layerComponents.metro.layer_options.checked = true;
          }, 2e3);
          return gmap;
        });
        let mapStatusObj = {};
        this.url = new URL(window.location.href);
        if (!mapStatusObj.center) {
          mapStatusObj = this.storedStatus;
        }
        let mergedOptions = {
          rotateControl: true,
          isFractionalZoomEnabled: false,
          streetViewControl: false,
          mapTypeControl: !this.codigo_interno && !this.extent,
          tiltControl: true,
          ...mapStatusObj,
          mapId: "3b1abace91810cf"
        };
        if (this.$store.public_maps.skipMapCreation || this.$store.public_maps.full_map) {
          this.gmap = new google.maps.Map(this.$el.querySelector("#map_container"), mergedOptions);
          this.$store.public_maps.customElementsMap = this.gmap;
        }
      });
    },
    marker: null,
    createMarker() {
      this.marker = this.marker || new google.maps.Marker({
        position: this.gmap.getCenter(),
        visible: false,
        map: globalThis.gmap,
        zIndex: 210,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 5,
          strokeWeight: 2,
          labelOrigin: new google.maps.Point(0, 2),
          strokeColor: "rgba(200,200,200,0)"
        }
      });
      globalThis.gmap.labelMarker = this.marker;
      return this.marker;
    },
    async createMap() {
      globalThis.mapframe = this;
      console.warn("creating map or waiting for the store to create it");
      console.info("deciding between initMap and map_created");
    },
    mapCreatedHandlers: [],
    onMapCreated(handler5) {
      this.mapCreatedHandlers.push(handler5);
    },
    createDomManager(codigo_interno2) {
      if (codigo_interno2) {
        this.gmap.setZoom(15);
      } else {
        this.gmap.controls[google.maps.ControlPosition.LEFT_TOP].push(document.querySelector("#map_controls"));
        setTimeout(() => {
          this.$nextTick(() => this.mapDialogOpen = true);
        }, 2e3);
      }
      this.$refs.map_container.classList.remove("hidden");
      this.$refs.map_container.style.height = `${this.mapHeight}px`;
      this.mapTypeListener = new MapTypeListener(this.gmap);
      this.mapTypeListener.addCustomStyles().then(() => {
      });
      this.infowindow = new google.maps.InfoWindow();
      this.gmap.infowindow = this.infowindow;
    },
    googleReady: null,
    get scrollableElement() {
      return this.$el.closest(".map_outer_container");
    },
    get mapHeight() {
      if (!(this.scrollableElement instanceof HTMLElement))
        return "auto";
      let offsetTop = 20;
      return window.innerHeight - this.scrollableElement.getBoundingClientRect().top - offsetTop;
    },
    get layerSlugs() {
      return this.$store.public_maps.layerSlugs;
    },
    set layerSlugs(slugs) {
      this.$store.public_maps.layerSlugs = slugs;
    },
    get mapStatus() {
      if (!this.gmap)
        return {};
      let center = this.gmap?.getCenter();
      if (!center)
        return {};
      let lat = Number(Number(center?.lat()).toFixed(6)), lng = Number(Number(center?.lng()).toFixed(6));
      return {
        center: { lat, lng },
        zoom: Number(Number(this.gmap?.getZoom()).toFixed(1))
      };
    },
    get dealsWithCoords() {
      return this.$store.public_maps.dealsWithCoords;
    },
    listFeatures() {
      console.table(this.dataLayers.filter((f) => f.type === "deals").map((f) => ({
        slug_name: f.slug_name,
        features: f.getLength()
      })));
    },
    async removeFeatures() {
      for (let dataLayer of this.dataLayers.filter((f) => f && f.type === "deals" && f.removeFeatures)) {
        await requestAnimationPromise3().then(() => Promise.all([
          dataLayer.removeFeatures(),
          waitFor(50)
        ]));
      }
    },
    async appendFeatures(dealsWithCoords) {
      for (let layer of this.dataLayers) {
        if (layer && layer.appendFeatures) {
          await layer.appendFeatures(dealsWithCoords ?? this.dealsWithCoords);
          await waitFor(50);
        }
      }
    },
    panToCodigoInterno() {
      if (this.codigo_interno) {
        console.log("looking for deal with codigo_interno " + this.codigo_interno);
        let negocio = this.$store.public_maps.dealsWithCoords.find((n) => n.codigo_interno == this.codigo_interno || n.id == this.codigo_interno);
        if (negocio) {
          let gmap = this.gmap;
          this.gmap.setCenter({ lat: Number(negocio.lat), lng: Number(negocio.lng) });
          this.gmap.setZoom(Math.max(this.gmap.getZoom(), 15));
        }
      }
    },
    reload() {
      this.removeFeatures().then(() => this.appendFeatures());
    },
    getLayer(slug_name) {
      return globalThis.layers[slug_name];
    },
    get layers() {
      return this.layerSlugs.map(
        (slug) => this.$store.public_maps.layer_array.find((l) => l.slug_name === slug)
      );
    },
    moveCollapsibles(oldIndex, newIndex) {
      let collapsibles = this.layerSlugs.slice(0);
      this.layerSlugs = [];
      let moved = collapsibles.splice(oldIndex, 1);
      collapsibles.splice(newIndex, 0, moved[0]);
      this.$nextTick(() => this.layerSlugs = collapsibles);
    },
    get featuresMatchingSearch() {
      return this.dataLayers.reduce((accum, layer) => {
        if (layer) {
          accum = accum.concat(layer.featuresMatchingSearch);
        }
        return accum;
      }, []);
    },
    fitBoundsMatchingSearch() {
      let bounds = new google.maps.LatLngBounds();
      this.featuresMatchingSearch.forEach((feature) => {
        bounds.extend(feature.getCenter());
      });
      if (this.searchValue && this.featuresMatchingSearch.length > 0) {
        this.gmap.panTo(bounds.getCenter());
      }
    },
    fitBounds(type) {
      const bounds = this.gmap.getBounds();
      this.dataLayers.forEach((layer) => {
        if (layer && (layer.type === type || type === "all")) {
          let gmapLayer = layer.getLayer();
          if (gmapLayer.getBounds)
            bounds.union(gmapLayer.getBounds());
        }
      });
      this.gmap.fitBounds(bounds);
      return bounds;
    },
    get dataLayers() {
      globalThis.layerComponents = globalThis.layerComponents || {};
      return this.layerSlugs.map(
        (slug_name) => globalThis.layerComponents[slug_name]
      );
    },
    url: null,
    get storedStatus() {
      return this.$store.public_maps.storedStatus;
    },
    set storedStatus(mapStatus) {
      this.$store.public_maps.storedStatus = mapStatus;
    },
    getLength() {
      return this.dataLayers.filter((d) => d.type === "deals").reduce((accum, layer) => {
        accum = accum + layer.getLength();
        return accum;
      }, 0);
    },
    search(term) {
      console.log("searching for", term);
    },
    campos: [],
    infowindow: null,
    mapDialogOpen: false,
    _buildingOptions: {
      strokeColor: "#0000cc",
      scale: 0.05
    },
    _houseOptions: {
      strokeColor: "#009900",
      scale: 0.05
    },
    get mapTypeId() {
      return 1;
    },
    set mapTypeId(mapTypeId) {
    },
    get mapTypeOptions() {
      return this.gmap ? Object.entries(
        this.gmap.mapTypes
      ).filter(([id, mapType]) => {
        const { name } = mapType;
        return name && !name.startsWith("gm_") && !name.startsWith("_");
      }).map(([id, mapType]) => {
        return {
          id,
          name: mapType.name.replace(/^Mapa$/, "Roadmap")
        };
      }).sort((a, b) => a.name.localeCompare(b.name)) : [];
    },
    get tomselectOptions() {
      return {
        valueField: "id",
        maxItems: 1,
        create: false,
        labelField: "name",
        options: this.mapTypeOptions,
        items: [this.gmap.getMapTypeId()],
        onChange: (newValue) => {
          this.gmap.setMapTypeId(newValue);
        }
      };
    },
    tomSelect: null
  };
};

// src/js/property_map/public_map_modules/sharingLevels.ts
var sharingLevels = {
  private: {
    id: "private",
    title: "Privado",
    description: "El mapa s\xF3lo ser\xE1 visible para usted y los administradores",
    icon: "fa fa-lock"
  },
  shared: {
    id: "shared",
    title: "Compartido",
    description: "Otros usuarios podr\xE1n ver el mapa, pero no guardar cambios",
    icon: "fa fa-eye"
  },
  collaborative: {
    id: "collaborative",
    title: "Colaborativo",
    description: "Otros usuarios podr\xE1n ver y guardar cambios el mapa",
    icon: "fa fa-users"
  },
  public: {
    id: "public",
    title: "P\xFAblico",
    description: "Visitantes externos podr\xE1n ver una versi\xF3n simplificada del mapa",
    icon: "fa fa-globe"
  }
};

// node_modules/@googlemaps/js-api-loader/dist/index.esm.js
var LoaderStatus;
(function(LoaderStatus2) {
  LoaderStatus2[LoaderStatus2["INITIALIZED"] = 0] = "INITIALIZED";
  LoaderStatus2[LoaderStatus2["LOADING"] = 1] = "LOADING";
  LoaderStatus2[LoaderStatus2["SUCCESS"] = 2] = "SUCCESS";
  LoaderStatus2[LoaderStatus2["FAILURE"] = 3] = "FAILURE";
})(LoaderStatus || (LoaderStatus = {}));

// src/js/property_map/public_map_modules/iconSelector.ts
var import_tom_select = __toESM(require_tom_select_complete());

// src/js/property_map/PublicMapStore.ts
var PublicMapStore = class extends BaseClass {
  constructor() {
    super();
    this.map_name = null;
    this.map_description = null;
    this.sharing_level = null;
    this.map_type = null;
    this.layer_object = null;
    this.id = null;
    this.filter_id = null;
    this.user_id = null;
    this.sharingLevels = sharingLevels;
    this.PublicLayersObject = PublicLayersObject;
    this.map_sharing_level = "private";
    this.token = null;
    this.active_tab = "tabs-savemap";
    this.ready = false;
    this.layer_array = [];
    this.savedMaps = [];
    this.feature_collection = { type: "FeatureCollection", features: [] };
    this.layerSlugs = [];
    this.codigo_interno = null;
    this._customElementsMap = null;
    this.skipMapCreation = false;
    this.barrioLabels = [];
    this.full_map = false;
    this.no_labels = false;
    //@ts-ignore
    this.__$store = {
      tipos_busqueda: module_default.store("tipos_busqueda"),
      columnas_actuales: module_default.store("columnas_actuales"),
      campos_busqueda: module_default.store("campos_busqueda"),
      negocios: module_default.store("negocios"),
      roles_negocio: module_default.store("roles_negocio"),
      active_filter: module_default.store("active_filter"),
      user: module_default.store("user")
    };
    this._$store = {
      tipos_busqueda: module_default.store("tipos_busqueda"),
      columnas_actuales: module_default.store("columnas_actuales"),
      campos_busqueda: module_default.store("campos_busqueda"),
      negocios: module_default.store("negocios"),
      roles_negocio: module_default.store("roles_negocio"),
      active_filter: module_default.store("active_filter"),
      user: module_default.store("user")
    };
    this._console = bindConsole(this.className, this.classNameColor);
    this.exampleLayers = exampleLayers;
    this.url = new URL(window.location.href);
    let qs = this.url.searchParams;
    this.no_labels = qs.has("no_labels");
    this.no_infowindows = qs.has("no_infowindows");
    this.waitForGoogleMapsLoaded().then((maps) => {
      console.log("will extend prototype", maps);
      extendMapDataProtoType2(maps);
      this.ready = true;
      this.processEventListeners("ready", maps);
    });
  }
  get customElementsMap() {
    return this._customElementsMap;
  }
  set customElementsMap(customElementsMap) {
    if (customElementsMap) {
      if (!this._customElementsMap)
        this._customElementsMap = customElementsMap;
      if (!this.ready)
        this.processEventListeners("ready", google.maps);
      globalThis.gmap = customElementsMap;
      this.processEventListeners("map_created", customElementsMap);
      this.marquee("received customElementsMap");
      if (this.codigo_interno) {
        this.marquee("setting center on codigo interno");
        let negocio = this.$store.negocios.get(this.codigo_interno);
        if (negocio) {
          let { lat, lng } = negocio;
          customElementsMap.setCenter({ lat, lng });
        }
      }
    }
  }
  get verifiers() {
    return {
      map_created: !!this.customElementsMap,
      ready: !!this.ready,
      layers_added: this.layer_array.length > 0
    };
  }
  getNameLabel(text = "", className = "markerLabel bg-white border radius-4 p-1  ") {
    return {
      text,
      color: "#444",
      fontSize: "14px",
      className
    };
  }
  async waitForGmStyleElement(selector, attempt = 0) {
    let gm = document.querySelector(selector);
    if (gm)
      return Promise.resolve(gm);
    return attempt > 10 ? Promise.reject(new Error("Cannot find an element with thaat elector")) : waitFor2(300).then(() => this.waitForGmStyleElement(selector, attempt + 1));
  }
  setBarrioLabels(features) {
    this.barrioMarkers = /* @__PURE__ */ new Map();
    this.barrioLabels = features.map((feature) => {
      let { geometry, id, properties } = feature;
      let [lng, lat] = geometry.coordinates;
      return { position: { lng, lat }, id, name: properties.Nombre_de_Barrio };
    });
    if (this.no_labels)
      return;
    this.once("map_created", async (gmap) => {
      const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
      if (this.full_map && this.skipMapCreation) {
        let gmElement = await this.waitForGmStyleElement(".gm-style");
        gmElement.classList.add("hide-labels");
        this.createClassicMarkers();
      } else {
        this.createAdvancedMarkers(AdvancedMarkerElement);
      }
    });
  }
  createClassicMarkers() {
    this.barrioLabels.forEach(({ id, position, name }) => {
      const priceTag = document.createElement("div");
      priceTag.className = " uppercase max-w-[125px] text-gray-500 visible_over_zoom_15 markerLabel_break_words markerLabel bg-gray-200   p-1 bg-opacity-50";
      priceTag.textContent = name;
      if (name) {
        const marker = new google.maps.Marker({
          map: globalThis.gmap,
          position,
          icon: {
            path: 1,
            scale: 5,
            strokeWeight: 2,
            strokeColor: "rgba(200,200,200,0)"
          },
          label: this.getNameLabel(name, priceTag.className)
        });
        this.barrioMarkers.set(String(id), marker);
      }
    });
  }
  createAdvancedMarkers(constructor) {
    console.warn(this.customElementsMap);
    this.barrioLabels.forEach(async ({ id, position, name }) => {
      const priceTag = document.createElement("div");
      priceTag.className = " uppercase max-w-[125px] visible_over_zoom_15 text-gray-500 markerLabel_break_words markerLabel bg-gray-50   p-1 bg-opacity-10";
      priceTag.textContent = name;
      priceTag.style.backgroundColor = "rgba(190,190,190,0.2)";
      const marker = new constructor({
        map: null,
        position,
        content: priceTag,
        title: name
      });
      this.barrioMarkers.set(String(id), marker);
    });
  }
  get markerArray() {
    return this.barrioMarkers ? Array.from(this.barrioMarkers.values()) : [];
  }
  async waitForGoogleMapsLoaded(attempt = 0) {
    let gmaps = globalThis.google && globalThis.google.maps;
    if (gmaps) {
      console.timerInfo("importing core and maps at attempt " + attempt);
      return gmaps.importLibrary("core").then(() => Promise.all([
        gmaps.importLibrary("maps"),
        gmaps.importLibrary("marker")
      ]));
    }
    if (attempt > 19) {
      return gmaps;
    }
    return waitFor2(300).then(() => {
      console.timerInfo("google maps not found. Attempt " + attempt);
      return this.waitForGoogleMapsLoaded(attempt + 1);
    });
  }
  init() {
  }
  setCodigoInterno(codigo_interno) {
    this.codigo_interno = codigo_interno;
  }
  reloadSavedMaps(savedMaps) {
    this.savedMaps = savedMaps;
  }
  updateProperties(mapData) {
    let {
      filter_id,
      id,
      name,
      description,
      sharing_level,
      map_type,
      layer_object,
      user_id,
      map_status,
      feature_collection
    } = mapData || {};
    this.filter_id = filter_id;
    this.map_name = name;
    this.map_description = description;
    this.sharing_level = sharing_level;
    this.map_type = map_type;
    this.feature_collection = feature_collection || this.feature_collection;
    this.layer_object = id ? layer_object || this.PublicLayersObject : this.PublicLayersObject;
    if (map_status) {
      this.storedStatus = map_status;
    }
    this.id = id;
    this.user_id = user_id;
    if (!filter_id) {
      setTimeout(() => {
        this.filter_id = 157;
      }, 2e3);
    }
    return this;
  }
  get active_filter() {
    return this.filter_id;
  }
  set active_filter(filter_id) {
    if (filter_id !== this.filter_id) {
      console.zinfo("setting map filter id to " + filter_id);
      this.filter_id = filter_id;
    }
  }
  refreshSavedMaps() {
    return;
  }
  fetchPublicaciones() {
    module_default.store("negocios").next_page_url = "https://lacasadejuana.cl/api/publicaciones";
    module_default.store("negocios").complete = false;
    return this.$store.negocios.fetchAll().then((result) => {
      setTimeout(() => this.$store.negocios.total = this.$store.negocios.properties.length, 1e3);
      return result;
    });
  }
  get comunasOptions() {
    return Array.from(new Set(this.dealsWithCoords.map((d) => d.comuna)));
  }
  get dealsWithCoords() {
    return this.$store.negocios.properties.filter(
      ({ lat, lng, _extra_props }) => lat && lng && typeof lat === "number" && typeof lng === "number" || //@ts-ignore
      _extra_props?.lat && _extra_props?.lng && typeof _extra_props?.lat === "number" && typeof _extra_props?.lng === "number"
    );
  }
  get sharingLevelDescription() {
    return this.sharingLevels[this.map_sharing_level].description;
  }
  get dataLayers() {
    return this.layerSlugs.map(
      (slug_name) => globalThis.layerComponents[slug_name]
    );
  }
  get payload() {
    return {
      id: this.id,
      user_id: this.user_id || this.$store.user.id,
      last_modified_by: this.$store.user.id,
      filter_id: this.filter_id,
      name: this.map_name,
      description: this.map_description,
      sharing_level: this.map_sharing_level,
      layer_object: this.layer_object,
      map_status: this.storedStatus,
      feature_collection: this.feature_collection
    };
  }
  async saveLayer(slug_name, { layer_options }) {
    this.layer_object[slug_name].layer_options = layer_options;
  }
  get storedStatus() {
    const defaultMapStatus = {
      center: { lat: -33.415785, lng: -70.578539 },
      //mapTypeId: 'Grass',
      zoom: 13.1
    };
    const mapStatus = {
      ...defaultMapStatus
    };
    if (mapStatus.zoom)
      mapStatus.zoom = Number(Number(mapStatus.zoom).toFixed(1));
    if (mapStatus.center?.lat)
      mapStatus.center.lat = Number(
        Number(mapStatus.center.lat).toFixed(6)
      );
    if (mapStatus.center?.lng)
      mapStatus.center.lng = Number(
        Number(mapStatus.center.lng).toFixed(6)
      );
    return mapStatus;
  }
  set storedStatus(mapStatus) {
    mapStatus = mapStatus || {};
    mapStatus.mapTypeId = mapStatus.mapTypeId || "roadmap";
    if (mapStatus.zoom && mapStatus.center?.lat && mapStatus.center?.lng) {
      mapStatus.zoom = Number(Number(mapStatus.zoom).toFixed(1));
      mapStatus.center.lng = Number(
        Number(mapStatus.center.lng).toFixed(6)
      );
      mapStatus.center.lat = Number(
        Number(mapStatus.center.lat).toFixed(6)
      );
    }
  }
  pushLayer(options) {
    this.layer_array.push(options);
    this.layerSlugs.push(options.slug_name);
    return waitFor2(200 + Math.random() * 150);
  }
  async createLayers(mapFrameData) {
    let initialLength = this.layer_array.length;
    const promises = Object.entries(this.layer_object).filter(([slug_name, layer]) => !layer.disabled).map(([slug_name, layer_options]) => {
      return this.pushLayer({ slug_name, name: layer_options.name || slug_name, ...layer_options });
    });
    return Promise.all(promises).then(() => {
      if (initialLength === 0) {
        this.processEventListeners("layers_added", this);
      }
    });
  }
  set $store($store2) {
    this._$store = $store2;
  }
  get $store() {
    return this._$store;
  }
};
var createPublicMapStore = ($store2) => {
  return new PublicMapStore($store2);
};

// src/js/property_map/index.ts
var PublicMapComponents = {
  PublicLayerDeals,
  PublicLayerGeoJson,
  PublicLayerBarriosDataLayer,
  PublicMapFrameData,
  PublicLayerBarriosWebGL,
  PublicLayerBarrios: PublicLayerBarriosDataLayer
};
var property_map_default = PublicMapComponents;
export {
  PublicLayerDeals,
  PublicLayerGeoJson,
  PublicMapComponents,
  PublicMapFrameData,
  createPublicMapStore,
  property_map_default as default
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)

tom-select/dist/js/tom-select.complete.js:
  (*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) *)
  (*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) *)

@googlemaps/js-api-loader/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/

"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_lacasadejuana_negocios_panel"] = self["webpackChunk_lacasadejuana_negocios_panel"] || []).push([["node_modules_tw-elements_dist_js_chart_es_js"],{

/***/ "./node_modules/tw-elements/dist/js/chart.es.js":
/*!******************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/chart.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ye),\n/* harmony export */   B: () => (/* binding */ Me),\n/* harmony export */   P: () => (/* binding */ ve),\n/* harmony export */   a: () => (/* binding */ K),\n/* harmony export */   b: () => (/* binding */ D),\n/* harmony export */   c: () => (/* binding */ I),\n/* harmony export */   d: () => (/* binding */ O),\n/* harmony export */   e: () => (/* binding */ E),\n/* harmony export */   f: () => (/* binding */ Yc),\n/* harmony export */   i: () => (/* binding */ T),\n/* harmony export */   m: () => (/* binding */ ne),\n/* harmony export */   r: () => (/* binding */ Zt),\n/* harmony export */   t: () => (/* binding */ $),\n/* harmony export */   v: () => (/* binding */ C)\n/* harmony export */ });\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction ct() {\n}\nconst _o = function() {\n  let i = 0;\n  return function() {\n    return i++;\n  };\n}();\nfunction T(i) {\n  return i === null || typeof i > \"u\";\n}\nfunction z(i) {\n  if (Array.isArray && Array.isArray(i))\n    return !0;\n  const t = Object.prototype.toString.call(i);\n  return t.slice(0, 7) === \"[object\" && t.slice(-6) === \"Array]\";\n}\nfunction D(i) {\n  return i !== null && Object.prototype.toString.call(i) === \"[object Object]\";\n}\nconst N = (i) => (typeof i == \"number\" || i instanceof Number) && isFinite(+i);\nfunction Q(i, t) {\n  return N(i) ? i : t;\n}\nfunction C(i, t) {\n  return typeof i > \"u\" ? t : i;\n}\nconst yo = (i, t) => typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 : i / t, an = (i, t) => typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 * t : +i;\nfunction I(i, t, e) {\n  if (i && typeof i.call == \"function\")\n    return i.apply(e, t);\n}\nfunction E(i, t, e, s) {\n  let n, o, r;\n  if (z(i))\n    if (o = i.length, s)\n      for (n = o - 1; n >= 0; n--)\n        t.call(e, i[n], n);\n    else\n      for (n = 0; n < o; n++)\n        t.call(e, i[n], n);\n  else if (D(i))\n    for (r = Object.keys(i), o = r.length, n = 0; n < o; n++)\n      t.call(e, i[r[n]], r[n]);\n}\nfunction ze(i, t) {\n  let e, s, n, o;\n  if (!i || !t || i.length !== t.length)\n    return !1;\n  for (e = 0, s = i.length; e < s; ++e)\n    if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index)\n      return !1;\n  return !0;\n}\nfunction Be(i) {\n  if (z(i))\n    return i.map(Be);\n  if (D(i)) {\n    const t = /* @__PURE__ */ Object.create(null), e = Object.keys(i), s = e.length;\n    let n = 0;\n    for (; n < s; ++n)\n      t[e[n]] = Be(i[e[n]]);\n    return t;\n  }\n  return i;\n}\nfunction ln(i) {\n  return [\"__proto__\", \"prototype\", \"constructor\"].indexOf(i) === -1;\n}\nfunction vo(i, t, e, s) {\n  if (!ln(i))\n    return;\n  const n = t[i], o = e[i];\n  D(n) && D(o) ? ne(n, o, s) : t[i] = Be(o);\n}\nfunction ne(i, t, e) {\n  const s = z(t) ? t : [t], n = s.length;\n  if (!D(i))\n    return i;\n  e = e || {};\n  const o = e.merger || vo;\n  for (let r = 0; r < n; ++r) {\n    if (t = s[r], !D(t))\n      continue;\n    const a = Object.keys(t);\n    for (let l = 0, c = a.length; l < c; ++l)\n      o(a[l], i, t, e);\n  }\n  return i;\n}\nfunction Qt(i, t) {\n  return ne(i, t, { merger: Mo });\n}\nfunction Mo(i, t, e) {\n  if (!ln(i))\n    return;\n  const s = t[i], n = e[i];\n  D(s) && D(n) ? Qt(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = Be(n));\n}\nconst Xi = {\n  \"\": (i) => i,\n  x: (i) => i.x,\n  y: (i) => i.y\n};\nfunction _t(i, t) {\n  return (Xi[t] || (Xi[t] = ko(t)))(i);\n}\nfunction ko(i) {\n  const t = wo(i);\n  return (e) => {\n    for (const s of t) {\n      if (s === \"\")\n        break;\n      e = e && e[s];\n    }\n    return e;\n  };\n}\nfunction wo(i) {\n  const t = i.split(\".\"), e = [];\n  let s = \"\";\n  for (const n of t)\n    s += n, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (e.push(s), s = \"\");\n  return e;\n}\nfunction Oi(i) {\n  return i.charAt(0).toUpperCase() + i.slice(1);\n}\nconst et = (i) => typeof i < \"u\", yt = (i) => typeof i == \"function\", Ui = (i, t) => {\n  if (i.size !== t.size)\n    return !1;\n  for (const e of i)\n    if (!t.has(e))\n      return !1;\n  return !0;\n};\nfunction So(i) {\n  return i.type === \"mouseup\" || i.type === \"click\" || i.type === \"contextmenu\";\n}\nconst B = Math.PI, F = 2 * B, Po = F + B, Ve = Number.POSITIVE_INFINITY, Co = B / 180, V = B / 2, $t = B / 4, Ki = B * 2 / 3, tt = Math.log10, lt = Math.sign;\nfunction qi(i) {\n  const t = Math.round(i);\n  i = te(i, t, i / 1e3) ? t : i;\n  const e = Math.pow(10, Math.floor(tt(i))), s = i / e;\n  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;\n}\nfunction Do(i) {\n  const t = [], e = Math.sqrt(i);\n  let s;\n  for (s = 1; s < e; s++)\n    i % s === 0 && (t.push(s), t.push(i / s));\n  return e === (e | 0) && t.push(e), t.sort((n, o) => n - o).pop(), t;\n}\nfunction Bt(i) {\n  return !isNaN(parseFloat(i)) && isFinite(i);\n}\nfunction te(i, t, e) {\n  return Math.abs(i - t) < e;\n}\nfunction Oo(i, t) {\n  const e = Math.round(i);\n  return e - t <= i && e + t >= i;\n}\nfunction cn(i, t, e) {\n  let s, n, o;\n  for (s = 0, n = i.length; s < n; s++)\n    o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));\n}\nfunction nt(i) {\n  return i * (B / 180);\n}\nfunction Ai(i) {\n  return i * (180 / B);\n}\nfunction Gi(i) {\n  if (!N(i))\n    return;\n  let t = 1, e = 0;\n  for (; Math.round(i * t) / t !== i; )\n    t *= 10, e++;\n  return e;\n}\nfunction hn(i, t) {\n  const e = t.x - i.x, s = t.y - i.y, n = Math.sqrt(e * e + s * s);\n  let o = Math.atan2(s, e);\n  return o < -0.5 * B && (o += F), {\n    angle: o,\n    distance: n\n  };\n}\nfunction bi(i, t) {\n  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));\n}\nfunction Ao(i, t) {\n  return (i - t + Po) % F - B;\n}\nfunction Z(i) {\n  return (i % F + F) % F;\n}\nfunction oe(i, t, e, s) {\n  const n = Z(i), o = Z(t), r = Z(e), a = Z(o - n), l = Z(r - n), c = Z(n - o), h = Z(n - r);\n  return n === o || n === r || s && o === r || a > l && c < h;\n}\nfunction Y(i, t, e) {\n  return Math.max(t, Math.min(e, i));\n}\nfunction To(i) {\n  return Y(i, -32768, 32767);\n}\nfunction ut(i, t, e, s = 1e-6) {\n  return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;\n}\nfunction Ti(i, t, e) {\n  e = e || ((r) => i[r] < t);\n  let s = i.length - 1, n = 0, o;\n  for (; s - n > 1; )\n    o = n + s >> 1, e(o) ? n = o : s = o;\n  return { lo: n, hi: s };\n}\nconst ft = (i, t, e, s) => Ti(i, e, s ? (n) => i[n][t] <= e : (n) => i[n][t] < e), Lo = (i, t, e) => Ti(i, e, (s) => i[s][t] >= e);\nfunction Ro(i, t, e) {\n  let s = 0, n = i.length;\n  for (; s < n && i[s] < t; )\n    s++;\n  for (; n > s && i[n - 1] > e; )\n    n--;\n  return s > 0 || n < i.length ? i.slice(s, n) : i;\n}\nconst dn = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\nfunction Eo(i, t) {\n  if (i._chartjs) {\n    i._chartjs.listeners.push(t);\n    return;\n  }\n  Object.defineProperty(i, \"_chartjs\", {\n    configurable: !0,\n    enumerable: !1,\n    value: {\n      listeners: [t]\n    }\n  }), dn.forEach((e) => {\n    const s = \"_onData\" + Oi(e), n = i[e];\n    Object.defineProperty(i, e, {\n      configurable: !0,\n      enumerable: !1,\n      value(...o) {\n        const r = n.apply(this, o);\n        return i._chartjs.listeners.forEach((a) => {\n          typeof a[s] == \"function\" && a[s](...o);\n        }), r;\n      }\n    });\n  });\n}\nfunction Zi(i, t) {\n  const e = i._chartjs;\n  if (!e)\n    return;\n  const s = e.listeners, n = s.indexOf(t);\n  n !== -1 && s.splice(n, 1), !(s.length > 0) && (dn.forEach((o) => {\n    delete i[o];\n  }), delete i._chartjs);\n}\nfunction un(i) {\n  const t = /* @__PURE__ */ new Set();\n  let e, s;\n  for (e = 0, s = i.length; e < s; ++e)\n    t.add(i[e]);\n  return t.size === s ? i : Array.from(t);\n}\nconst fn = function() {\n  return typeof window > \"u\" ? function(i) {\n    return i();\n  } : window.requestAnimationFrame;\n}();\nfunction gn(i, t, e) {\n  const s = e || ((r) => Array.prototype.slice.call(r));\n  let n = !1, o = [];\n  return function(...r) {\n    o = s(r), n || (n = !0, fn.call(window, () => {\n      n = !1, i.apply(t, o);\n    }));\n  };\n}\nfunction Fo(i, t) {\n  let e;\n  return function(...s) {\n    return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;\n  };\n}\nconst Li = (i) => i === \"start\" ? \"left\" : i === \"end\" ? \"right\" : \"center\", U = (i, t, e) => i === \"start\" ? t : i === \"end\" ? e : (t + e) / 2, Io = (i, t, e, s) => i === (s ? \"left\" : \"right\") ? e : i === \"center\" ? (t + e) / 2 : t;\nfunction pn(i, t, e) {\n  const s = t.length;\n  let n = 0, o = s;\n  if (i._sorted) {\n    const { iScale: r, _parsed: a } = i, l = r.axis, { min: c, max: h, minDefined: d, maxDefined: u } = r.getUserBounds();\n    d && (n = Y(\n      Math.min(\n        ft(a, r.axis, c).lo,\n        e ? s : ft(t, l, r.getPixelForValue(c)).lo\n      ),\n      0,\n      s - 1\n    )), u ? o = Y(\n      Math.max(\n        ft(a, r.axis, h, !0).hi + 1,\n        e ? 0 : ft(t, l, r.getPixelForValue(h), !0).hi + 1\n      ),\n      n,\n      s\n    ) - n : o = s - n;\n  }\n  return { start: n, count: o };\n}\nfunction mn(i) {\n  const { xScale: t, yScale: e, _scaleRanges: s } = i, n = {\n    xmin: t.min,\n    xmax: t.max,\n    ymin: e.min,\n    ymax: e.max\n  };\n  if (!s)\n    return i._scaleRanges = n, !0;\n  const o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;\n  return Object.assign(s, n), o;\n}\nconst we = (i) => i === 0 || i === 1, Ji = (i, t, e) => -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * F / e)), Qi = (i, t, e) => Math.pow(2, -10 * i) * Math.sin((i - t) * F / e) + 1, ee = {\n  linear: (i) => i,\n  easeInQuad: (i) => i * i,\n  easeOutQuad: (i) => -i * (i - 2),\n  easeInOutQuad: (i) => (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1),\n  easeInCubic: (i) => i * i * i,\n  easeOutCubic: (i) => (i -= 1) * i * i + 1,\n  easeInOutCubic: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2),\n  easeInQuart: (i) => i * i * i * i,\n  easeOutQuart: (i) => -((i -= 1) * i * i * i - 1),\n  easeInOutQuart: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2),\n  easeInQuint: (i) => i * i * i * i * i,\n  easeOutQuint: (i) => (i -= 1) * i * i * i * i + 1,\n  easeInOutQuint: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2),\n  easeInSine: (i) => -Math.cos(i * V) + 1,\n  easeOutSine: (i) => Math.sin(i * V),\n  easeInOutSine: (i) => -0.5 * (Math.cos(B * i) - 1),\n  easeInExpo: (i) => i === 0 ? 0 : Math.pow(2, 10 * (i - 1)),\n  easeOutExpo: (i) => i === 1 ? 1 : -Math.pow(2, -10 * i) + 1,\n  easeInOutExpo: (i) => we(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2),\n  easeInCirc: (i) => i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1),\n  easeOutCirc: (i) => Math.sqrt(1 - (i -= 1) * i),\n  easeInOutCirc: (i) => (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1),\n  easeInElastic: (i) => we(i) ? i : Ji(i, 0.075, 0.3),\n  easeOutElastic: (i) => we(i) ? i : Qi(i, 0.075, 0.3),\n  easeInOutElastic(i) {\n    return we(i) ? i : i < 0.5 ? 0.5 * Ji(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * Qi(i * 2 - 1, 0.1125, 0.45);\n  },\n  easeInBack(i) {\n    return i * i * ((1.70158 + 1) * i - 1.70158);\n  },\n  easeOutBack(i) {\n    return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;\n  },\n  easeInOutBack(i) {\n    let t = 1.70158;\n    return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);\n  },\n  easeInBounce: (i) => 1 - ee.easeOutBounce(1 - i),\n  easeOutBounce(i) {\n    return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;\n  },\n  easeInOutBounce: (i) => i < 0.5 ? ee.easeInBounce(i * 2) * 0.5 : ee.easeOutBounce(i * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction he(i) {\n  return i + 0.5 | 0;\n}\nconst mt = (i, t, e) => Math.max(Math.min(i, e), t);\nfunction Gt(i) {\n  return mt(he(i * 2.55), 0, 255);\n}\nfunction xt(i) {\n  return mt(he(i * 255), 0, 255);\n}\nfunction dt(i) {\n  return mt(he(i / 2.55) / 100, 0, 1);\n}\nfunction ts(i) {\n  return mt(he(i * 100), 0, 100);\n}\nconst J = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, xi = [...\"0123456789ABCDEF\"], zo = (i) => xi[i & 15], Bo = (i) => xi[(i & 240) >> 4] + xi[i & 15], Se = (i) => (i & 240) >> 4 === (i & 15), Vo = (i) => Se(i.r) && Se(i.g) && Se(i.b) && Se(i.a);\nfunction Wo(i) {\n  var t = i.length, e;\n  return i[0] === \"#\" && (t === 4 || t === 5 ? e = {\n    r: 255 & J[i[1]] * 17,\n    g: 255 & J[i[2]] * 17,\n    b: 255 & J[i[3]] * 17,\n    a: t === 5 ? J[i[4]] * 17 : 255\n  } : (t === 7 || t === 9) && (e = {\n    r: J[i[1]] << 4 | J[i[2]],\n    g: J[i[3]] << 4 | J[i[4]],\n    b: J[i[5]] << 4 | J[i[6]],\n    a: t === 9 ? J[i[7]] << 4 | J[i[8]] : 255\n  })), e;\n}\nconst No = (i, t) => i < 255 ? t(i) : \"\";\nfunction Ho(i) {\n  var t = Vo(i) ? zo : Bo;\n  return i ? \"#\" + t(i.r) + t(i.g) + t(i.b) + No(i.a, t) : void 0;\n}\nconst jo = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction bn(i, t, e) {\n  const s = t * Math.min(e, 1 - e), n = (o, r = (o + i / 30) % 12) => e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);\n  return [n(0), n(8), n(4)];\n}\nfunction $o(i, t, e) {\n  const s = (n, o = (n + i / 60) % 6) => e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);\n  return [s(5), s(3), s(1)];\n}\nfunction Yo(i, t, e) {\n  const s = bn(i, 1, 0.5);\n  let n;\n  for (t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++)\n    s[n] *= 1 - t - e, s[n] += t;\n  return s;\n}\nfunction Xo(i, t, e, s, n) {\n  return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;\n}\nfunction Ri(i) {\n  const e = i.r / 255, s = i.g / 255, n = i.b / 255, o = Math.max(e, s, n), r = Math.min(e, s, n), a = (o + r) / 2;\n  let l, c, h;\n  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = Xo(e, s, n, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];\n}\nfunction Ei(i, t, e, s) {\n  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(xt);\n}\nfunction Fi(i, t, e) {\n  return Ei(bn, i, t, e);\n}\nfunction Uo(i, t, e) {\n  return Ei(Yo, i, t, e);\n}\nfunction Ko(i, t, e) {\n  return Ei($o, i, t, e);\n}\nfunction xn(i) {\n  return (i % 360 + 360) % 360;\n}\nfunction qo(i) {\n  const t = jo.exec(i);\n  let e = 255, s;\n  if (!t)\n    return;\n  t[5] !== s && (e = t[6] ? Gt(+t[5]) : xt(+t[5]));\n  const n = xn(+t[2]), o = +t[3] / 100, r = +t[4] / 100;\n  return t[1] === \"hwb\" ? s = Uo(n, o, r) : t[1] === \"hsv\" ? s = Ko(n, o, r) : s = Fi(n, o, r), {\n    r: s[0],\n    g: s[1],\n    b: s[2],\n    a: e\n  };\n}\nfunction Go(i, t) {\n  var e = Ri(i);\n  e[0] = xn(e[0] + t), e = Fi(e), i.r = e[0], i.g = e[1], i.b = e[2];\n}\nfunction Zo(i) {\n  if (!i)\n    return;\n  const t = Ri(i), e = t[0], s = ts(t[1]), n = ts(t[2]);\n  return i.a < 255 ? `hsla(${e}, ${s}%, ${n}%, ${dt(i.a)})` : `hsl(${e}, ${s}%, ${n}%)`;\n}\nconst es = {\n  x: \"dark\",\n  Z: \"light\",\n  Y: \"re\",\n  X: \"blu\",\n  W: \"gr\",\n  V: \"medium\",\n  U: \"slate\",\n  A: \"ee\",\n  T: \"ol\",\n  S: \"or\",\n  B: \"ra\",\n  C: \"lateg\",\n  D: \"ights\",\n  R: \"in\",\n  Q: \"turquois\",\n  E: \"hi\",\n  P: \"ro\",\n  O: \"al\",\n  N: \"le\",\n  M: \"de\",\n  L: \"yello\",\n  F: \"en\",\n  K: \"ch\",\n  G: \"arks\",\n  H: \"ea\",\n  I: \"ightg\",\n  J: \"wh\"\n}, is = {\n  OiceXe: \"f0f8ff\",\n  antiquewEte: \"faebd7\",\n  aqua: \"ffff\",\n  aquamarRe: \"7fffd4\",\n  azuY: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"0\",\n  blanKedOmond: \"ffebcd\",\n  Xe: \"ff\",\n  XeviTet: \"8a2be2\",\n  bPwn: \"a52a2a\",\n  burlywood: \"deb887\",\n  caMtXe: \"5f9ea0\",\n  KartYuse: \"7fff00\",\n  KocTate: \"d2691e\",\n  cSO: \"ff7f50\",\n  cSnflowerXe: \"6495ed\",\n  cSnsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"ffff\",\n  xXe: \"8b\",\n  xcyan: \"8b8b\",\n  xgTMnPd: \"b8860b\",\n  xWay: \"a9a9a9\",\n  xgYF: \"6400\",\n  xgYy: \"a9a9a9\",\n  xkhaki: \"bdb76b\",\n  xmagFta: \"8b008b\",\n  xTivegYF: \"556b2f\",\n  xSange: \"ff8c00\",\n  xScEd: \"9932cc\",\n  xYd: \"8b0000\",\n  xsOmon: \"e9967a\",\n  xsHgYF: \"8fbc8f\",\n  xUXe: \"483d8b\",\n  xUWay: \"2f4f4f\",\n  xUgYy: \"2f4f4f\",\n  xQe: \"ced1\",\n  xviTet: \"9400d3\",\n  dAppRk: \"ff1493\",\n  dApskyXe: \"bfff\",\n  dimWay: \"696969\",\n  dimgYy: \"696969\",\n  dodgerXe: \"1e90ff\",\n  fiYbrick: \"b22222\",\n  flSOwEte: \"fffaf0\",\n  foYstWAn: \"228b22\",\n  fuKsia: \"ff00ff\",\n  gaRsbSo: \"dcdcdc\",\n  ghostwEte: \"f8f8ff\",\n  gTd: \"ffd700\",\n  gTMnPd: \"daa520\",\n  Way: \"808080\",\n  gYF: \"8000\",\n  gYFLw: \"adff2f\",\n  gYy: \"808080\",\n  honeyMw: \"f0fff0\",\n  hotpRk: \"ff69b4\",\n  RdianYd: \"cd5c5c\",\n  Rdigo: \"4b0082\",\n  ivSy: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavFMr: \"e6e6fa\",\n  lavFMrXsh: \"fff0f5\",\n  lawngYF: \"7cfc00\",\n  NmoncEffon: \"fffacd\",\n  ZXe: \"add8e6\",\n  ZcSO: \"f08080\",\n  Zcyan: \"e0ffff\",\n  ZgTMnPdLw: \"fafad2\",\n  ZWay: \"d3d3d3\",\n  ZgYF: \"90ee90\",\n  ZgYy: \"d3d3d3\",\n  ZpRk: \"ffb6c1\",\n  ZsOmon: \"ffa07a\",\n  ZsHgYF: \"20b2aa\",\n  ZskyXe: \"87cefa\",\n  ZUWay: \"778899\",\n  ZUgYy: \"778899\",\n  ZstAlXe: \"b0c4de\",\n  ZLw: \"ffffe0\",\n  lime: \"ff00\",\n  limegYF: \"32cd32\",\n  lRF: \"faf0e6\",\n  magFta: \"ff00ff\",\n  maPon: \"800000\",\n  VaquamarRe: \"66cdaa\",\n  VXe: \"cd\",\n  VScEd: \"ba55d3\",\n  VpurpN: \"9370db\",\n  VsHgYF: \"3cb371\",\n  VUXe: \"7b68ee\",\n  VsprRggYF: \"fa9a\",\n  VQe: \"48d1cc\",\n  VviTetYd: \"c71585\",\n  midnightXe: \"191970\",\n  mRtcYam: \"f5fffa\",\n  mistyPse: \"ffe4e1\",\n  moccasR: \"ffe4b5\",\n  navajowEte: \"ffdead\",\n  navy: \"80\",\n  Tdlace: \"fdf5e6\",\n  Tive: \"808000\",\n  TivedBb: \"6b8e23\",\n  Sange: \"ffa500\",\n  SangeYd: \"ff4500\",\n  ScEd: \"da70d6\",\n  pOegTMnPd: \"eee8aa\",\n  pOegYF: \"98fb98\",\n  pOeQe: \"afeeee\",\n  pOeviTetYd: \"db7093\",\n  papayawEp: \"ffefd5\",\n  pHKpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pRk: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powMrXe: \"b0e0e6\",\n  purpN: \"800080\",\n  YbeccapurpN: \"663399\",\n  Yd: \"ff0000\",\n  Psybrown: \"bc8f8f\",\n  PyOXe: \"4169e1\",\n  saddNbPwn: \"8b4513\",\n  sOmon: \"fa8072\",\n  sandybPwn: \"f4a460\",\n  sHgYF: \"2e8b57\",\n  sHshell: \"fff5ee\",\n  siFna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyXe: \"87ceeb\",\n  UXe: \"6a5acd\",\n  UWay: \"708090\",\n  UgYy: \"708090\",\n  snow: \"fffafa\",\n  sprRggYF: \"ff7f\",\n  stAlXe: \"4682b4\",\n  tan: \"d2b48c\",\n  teO: \"8080\",\n  tEstN: \"d8bfd8\",\n  tomato: \"ff6347\",\n  Qe: \"40e0d0\",\n  viTet: \"ee82ee\",\n  JHt: \"f5deb3\",\n  wEte: \"ffffff\",\n  wEtesmoke: \"f5f5f5\",\n  Lw: \"ffff00\",\n  LwgYF: \"9acd32\"\n};\nfunction Jo() {\n  const i = {}, t = Object.keys(is), e = Object.keys(es);\n  let s, n, o, r, a;\n  for (s = 0; s < t.length; s++) {\n    for (r = a = t[s], n = 0; n < e.length; n++)\n      o = e[n], a = a.replace(o, es[o]);\n    o = parseInt(is[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];\n  }\n  return i;\n}\nlet Pe;\nfunction Qo(i) {\n  Pe || (Pe = Jo(), Pe.transparent = [0, 0, 0, 0]);\n  const t = Pe[i.toLowerCase()];\n  return t && {\n    r: t[0],\n    g: t[1],\n    b: t[2],\n    a: t.length === 4 ? t[3] : 255\n  };\n}\nconst tr = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction er(i) {\n  const t = tr.exec(i);\n  let e = 255, s, n, o;\n  if (t) {\n    if (t[7] !== s) {\n      const r = +t[7];\n      e = t[8] ? Gt(r) : mt(r * 255, 0, 255);\n    }\n    return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? Gt(s) : mt(s, 0, 255)), n = 255 & (t[4] ? Gt(n) : mt(n, 0, 255)), o = 255 & (t[6] ? Gt(o) : mt(o, 0, 255)), {\n      r: s,\n      g: n,\n      b: o,\n      a: e\n    };\n  }\n}\nfunction ir(i) {\n  return i && (i.a < 255 ? `rgba(${i.r}, ${i.g}, ${i.b}, ${dt(i.a)})` : `rgb(${i.r}, ${i.g}, ${i.b})`);\n}\nconst ni = (i) => i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055, Ft = (i) => i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);\nfunction sr(i, t, e) {\n  const s = Ft(dt(i.r)), n = Ft(dt(i.g)), o = Ft(dt(i.b));\n  return {\n    r: xt(ni(s + e * (Ft(dt(t.r)) - s))),\n    g: xt(ni(n + e * (Ft(dt(t.g)) - n))),\n    b: xt(ni(o + e * (Ft(dt(t.b)) - o))),\n    a: i.a + e * (t.a - i.a)\n  };\n}\nfunction Ce(i, t, e) {\n  if (i) {\n    let s = Ri(i);\n    s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Fi(s), i.r = s[0], i.g = s[1], i.b = s[2];\n  }\n}\nfunction _n(i, t) {\n  return i && Object.assign(t || {}, i);\n}\nfunction ss(i) {\n  var t = { r: 0, g: 0, b: 0, a: 255 };\n  return Array.isArray(i) ? i.length >= 3 && (t = { r: i[0], g: i[1], b: i[2], a: 255 }, i.length > 3 && (t.a = xt(i[3]))) : (t = _n(i, { r: 0, g: 0, b: 0, a: 1 }), t.a = xt(t.a)), t;\n}\nfunction nr(i) {\n  return i.charAt(0) === \"r\" ? er(i) : qo(i);\n}\nclass We {\n  constructor(t) {\n    if (t instanceof We)\n      return t;\n    const e = typeof t;\n    let s;\n    e === \"object\" ? s = ss(t) : e === \"string\" && (s = Wo(t) || Qo(t) || nr(t)), this._rgb = s, this._valid = !!s;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var t = _n(this._rgb);\n    return t && (t.a = dt(t.a)), t;\n  }\n  set rgb(t) {\n    this._rgb = ss(t);\n  }\n  rgbString() {\n    return this._valid ? ir(this._rgb) : void 0;\n  }\n  hexString() {\n    return this._valid ? Ho(this._rgb) : void 0;\n  }\n  hslString() {\n    return this._valid ? Zo(this._rgb) : void 0;\n  }\n  mix(t, e) {\n    if (t) {\n      const s = this.rgb, n = t.rgb;\n      let o;\n      const r = e === o ? 0.5 : e, a = 2 * r - 1, l = s.a - n.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;\n      o = 1 - c, s.r = 255 & c * s.r + o * n.r + 0.5, s.g = 255 & c * s.g + o * n.g + 0.5, s.b = 255 & c * s.b + o * n.b + 0.5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;\n    }\n    return this;\n  }\n  interpolate(t, e) {\n    return t && (this._rgb = sr(this._rgb, t._rgb, e)), this;\n  }\n  clone() {\n    return new We(this.rgb);\n  }\n  alpha(t) {\n    return this._rgb.a = xt(t), this;\n  }\n  clearer(t) {\n    const e = this._rgb;\n    return e.a *= 1 - t, this;\n  }\n  greyscale() {\n    const t = this._rgb, e = he(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);\n    return t.r = t.g = t.b = e, this;\n  }\n  opaquer(t) {\n    const e = this._rgb;\n    return e.a *= 1 + t, this;\n  }\n  negate() {\n    const t = this._rgb;\n    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n  }\n  lighten(t) {\n    return Ce(this._rgb, 2, t), this;\n  }\n  darken(t) {\n    return Ce(this._rgb, 2, -t), this;\n  }\n  saturate(t) {\n    return Ce(this._rgb, 1, t), this;\n  }\n  desaturate(t) {\n    return Ce(this._rgb, 1, -t), this;\n  }\n  rotate(t) {\n    return Go(this._rgb, t), this;\n  }\n}\nfunction yn(i) {\n  return new We(i);\n}\nfunction vn(i) {\n  if (i && typeof i == \"object\") {\n    const t = i.toString();\n    return t === \"[object CanvasPattern]\" || t === \"[object CanvasGradient]\";\n  }\n  return !1;\n}\nfunction ns(i) {\n  return vn(i) ? i : yn(i);\n}\nfunction oi(i) {\n  return vn(i) ? i : yn(i).saturate(0.5).darken(0.1).hexString();\n}\nconst At = /* @__PURE__ */ Object.create(null), _i = /* @__PURE__ */ Object.create(null);\nfunction ie(i, t) {\n  if (!t)\n    return i;\n  const e = t.split(\".\");\n  for (let s = 0, n = e.length; s < n; ++s) {\n    const o = e[s];\n    i = i[o] || (i[o] = /* @__PURE__ */ Object.create(null));\n  }\n  return i;\n}\nfunction ri(i, t, e) {\n  return typeof t == \"string\" ? ne(ie(i, t), e) : ne(ie(i, \"\"), t);\n}\nclass or {\n  constructor(t) {\n    this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (e) => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n      \"mousemove\",\n      \"mouseout\",\n      \"click\",\n      \"touchstart\",\n      \"touchmove\"\n    ], this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: \"normal\",\n      lineHeight: 1.2,\n      weight: null\n    }, this.hover = {}, this.hoverBackgroundColor = (e, s) => oi(s.backgroundColor), this.hoverBorderColor = (e, s) => oi(s.borderColor), this.hoverColor = (e, s) => oi(s.color), this.indexAxis = \"x\", this.interaction = {\n      mode: \"nearest\",\n      intersect: !0,\n      includeInvisible: !1\n    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);\n  }\n  set(t, e) {\n    return ri(this, t, e);\n  }\n  get(t) {\n    return ie(this, t);\n  }\n  describe(t, e) {\n    return ri(_i, t, e);\n  }\n  override(t, e) {\n    return ri(At, t, e);\n  }\n  route(t, e, s, n) {\n    const o = ie(this, t), r = ie(this, s), a = \"_\" + e;\n    Object.defineProperties(o, {\n      [a]: {\n        value: o[e],\n        writable: !0\n      },\n      [e]: {\n        enumerable: !0,\n        get() {\n          const l = this[a], c = r[n];\n          return D(l) ? Object.assign({}, c, l) : C(l, c);\n        },\n        set(l) {\n          this[a] = l;\n        }\n      }\n    });\n  }\n}\nvar O = new or({\n  _scriptable: (i) => !i.startsWith(\"on\"),\n  _indexable: (i) => i !== \"events\",\n  hover: {\n    _fallback: \"interaction\"\n  },\n  interaction: {\n    _scriptable: !1,\n    _indexable: !1\n  }\n});\nfunction rr(i) {\n  return !i || T(i.size) || T(i.family) ? null : (i.style ? i.style + \" \" : \"\") + (i.weight ? i.weight + \" \" : \"\") + i.size + \"px \" + i.family;\n}\nfunction Ne(i, t, e, s, n) {\n  let o = t[n];\n  return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;\n}\nfunction ar(i, t, e, s) {\n  s = s || {};\n  let n = s.data = s.data || {}, o = s.garbageCollect = s.garbageCollect || [];\n  s.font !== t && (n = s.data = {}, o = s.garbageCollect = [], s.font = t), i.save(), i.font = t;\n  let r = 0;\n  const a = e.length;\n  let l, c, h, d, u;\n  for (l = 0; l < a; l++)\n    if (d = e[l], d != null && z(d) !== !0)\n      r = Ne(i, n, o, r, d);\n    else if (z(d))\n      for (c = 0, h = d.length; c < h; c++)\n        u = d[c], u != null && !z(u) && (r = Ne(i, n, o, r, u));\n  i.restore();\n  const f = o.length / 2;\n  if (f > e.length) {\n    for (l = 0; l < f; l++)\n      delete n[o[l]];\n    o.splice(0, f);\n  }\n  return r;\n}\nfunction wt(i, t, e) {\n  const s = i.currentDevicePixelRatio, n = e !== 0 ? Math.max(e / 2, 0.5) : 0;\n  return Math.round((t - n) * s) / s + n;\n}\nfunction os(i, t) {\n  t = t || i.getContext(\"2d\"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore();\n}\nfunction yi(i, t, e, s) {\n  Mn(i, t, e, s, null);\n}\nfunction Mn(i, t, e, s, n) {\n  let o, r, a, l, c, h;\n  const d = t.pointStyle, u = t.rotation, f = t.radius;\n  let g = (u || 0) * Co;\n  if (d && typeof d == \"object\" && (o = d.toString(), o === \"[object HTMLImageElement]\" || o === \"[object HTMLCanvasElement]\")) {\n    i.save(), i.translate(e, s), i.rotate(g), i.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), i.restore();\n    return;\n  }\n  if (!(isNaN(f) || f <= 0)) {\n    switch (i.beginPath(), d) {\n      default:\n        n ? i.ellipse(e, s, n / 2, f, 0, 0, F) : i.arc(e, s, f, 0, F), i.closePath();\n        break;\n      case \"triangle\":\n        i.moveTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), i.closePath();\n        break;\n      case \"rectRounded\":\n        c = f * 0.516, l = f - c, r = Math.cos(g + $t) * l, a = Math.sin(g + $t) * l, i.arc(e - r, s - a, c, g - B, g - V), i.arc(e + a, s - r, c, g - V, g), i.arc(e + r, s + a, c, g, g + V), i.arc(e - a, s + r, c, g + V, g + B), i.closePath();\n        break;\n      case \"rect\":\n        if (!u) {\n          l = Math.SQRT1_2 * f, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);\n          break;\n        }\n        g += $t;\n      case \"rectRot\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + a, s - r), i.lineTo(e + r, s + a), i.lineTo(e - a, s + r), i.closePath();\n        break;\n      case \"crossRot\":\n        g += $t;\n      case \"cross\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n        break;\n      case \"star\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r), g += $t, r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n        break;\n      case \"line\":\n        r = n ? n / 2 : Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);\n        break;\n      case \"dash\":\n        i.moveTo(e, s), i.lineTo(e + Math.cos(g) * f, s + Math.sin(g) * f);\n        break;\n    }\n    i.fill(), t.borderWidth > 0 && i.stroke();\n  }\n}\nfunction re(i, t, e) {\n  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;\n}\nfunction Xe(i, t) {\n  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();\n}\nfunction Ue(i) {\n  i.restore();\n}\nfunction lr(i, t, e, s, n) {\n  if (!t)\n    return i.lineTo(e.x, e.y);\n  if (n === \"middle\") {\n    const o = (t.x + e.x) / 2;\n    i.lineTo(o, t.y), i.lineTo(o, e.y);\n  } else\n    n === \"after\" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);\n  i.lineTo(e.x, e.y);\n}\nfunction cr(i, t, e, s) {\n  if (!t)\n    return i.lineTo(e.x, e.y);\n  i.bezierCurveTo(\n    s ? t.cp1x : t.cp2x,\n    s ? t.cp1y : t.cp2y,\n    s ? e.cp2x : e.cp1x,\n    s ? e.cp2y : e.cp1y,\n    e.x,\n    e.y\n  );\n}\nfunction Tt(i, t, e, s, n, o = {}) {\n  const r = z(t) ? t : [t], a = o.strokeWidth > 0 && o.strokeColor !== \"\";\n  let l, c;\n  for (i.save(), i.font = n.string, hr(i, o), l = 0; l < r.length; ++l)\n    c = r[l], a && (o.strokeColor && (i.strokeStyle = o.strokeColor), T(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), dr(i, e, s, c, o), s += n.lineHeight;\n  i.restore();\n}\nfunction hr(i, t) {\n  t.translation && i.translate(t.translation[0], t.translation[1]), T(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);\n}\nfunction dr(i, t, e, s, n) {\n  if (n.strikethrough || n.underline) {\n    const o = i.measureText(s), r = t - o.actualBoundingBoxLeft, a = t + o.actualBoundingBoxRight, l = e - o.actualBoundingBoxAscent, c = e + o.actualBoundingBoxDescent, h = n.strikethrough ? (l + c) / 2 : c;\n    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();\n  }\n}\nfunction ae(i, t) {\n  const { x: e, y: s, w: n, h: o, radius: r } = t;\n  i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, -V, B, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, B, V, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, V, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -V, !0), i.lineTo(e + r.topLeft, s);\n}\nconst ur = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/), fr = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction gr(i, t) {\n  const e = (\"\" + i).match(ur);\n  if (!e || e[1] === \"normal\")\n    return t * 1.2;\n  switch (i = +e[2], e[3]) {\n    case \"px\":\n      return i;\n    case \"%\":\n      i /= 100;\n      break;\n  }\n  return t * i;\n}\nconst pr = (i) => +i || 0;\nfunction Ii(i, t) {\n  const e = {}, s = D(t), n = s ? Object.keys(t) : t, o = D(i) ? s ? (r) => C(i[r], i[t[r]]) : (r) => i[r] : () => i;\n  for (const r of n)\n    e[r] = pr(o(r));\n  return e;\n}\nfunction kn(i) {\n  return Ii(i, { top: \"y\", right: \"x\", bottom: \"y\", left: \"x\" });\n}\nfunction Dt(i) {\n  return Ii(i, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n}\nfunction K(i) {\n  const t = kn(i);\n  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;\n}\nfunction $(i, t) {\n  i = i || {}, t = t || O.font;\n  let e = C(i.size, t.size);\n  typeof e == \"string\" && (e = parseInt(e, 10));\n  let s = C(i.style, t.style);\n  s && !(\"\" + s).match(fr) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = \"\");\n  const n = {\n    family: C(i.family, t.family),\n    lineHeight: gr(C(i.lineHeight, t.lineHeight), e),\n    size: e,\n    style: s,\n    weight: C(i.weight, t.weight),\n    string: \"\"\n  };\n  return n.string = rr(n), n;\n}\nfunction Zt(i, t, e, s) {\n  let n = !0, o, r, a;\n  for (o = 0, r = i.length; o < r; ++o)\n    if (a = i[o], a !== void 0 && (t !== void 0 && typeof a == \"function\" && (a = a(t), n = !1), e !== void 0 && z(a) && (a = a[e % a.length], n = !1), a !== void 0))\n      return s && !n && (s.cacheable = !1), a;\n}\nfunction mr(i, t, e) {\n  const { min: s, max: n } = i, o = an(t, (n - s) / 2), r = (a, l) => e && a === 0 ? 0 : a + l;\n  return {\n    min: r(s, -Math.abs(o)),\n    max: r(n, o)\n  };\n}\nfunction vt(i, t) {\n  return Object.assign(Object.create(i), t);\n}\nfunction zi(i, t = [\"\"], e = i, s, n = () => i[0]) {\n  et(s) || (s = Cn(\"_fallback\", i));\n  const o = {\n    [Symbol.toStringTag]: \"Object\",\n    _cacheable: !0,\n    _scopes: i,\n    _rootScopes: e,\n    _fallback: s,\n    _getTarget: n,\n    override: (r) => zi([r, ...i], t, e, s)\n  };\n  return new Proxy(o, {\n    deleteProperty(r, a) {\n      return delete r[a], delete r._keys, delete i[0][a], !0;\n    },\n    get(r, a) {\n      return Sn(\n        r,\n        a,\n        () => wr(a, t, i, r)\n      );\n    },\n    getOwnPropertyDescriptor(r, a) {\n      return Reflect.getOwnPropertyDescriptor(r._scopes[0], a);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(i[0]);\n    },\n    has(r, a) {\n      return as(r).includes(a);\n    },\n    ownKeys(r) {\n      return as(r);\n    },\n    set(r, a, l) {\n      const c = r._storage || (r._storage = n());\n      return r[a] = c[a] = l, delete r._keys, !0;\n    }\n  });\n}\nfunction Vt(i, t, e, s) {\n  const n = {\n    _cacheable: !1,\n    _proxy: i,\n    _context: t,\n    _subProxy: e,\n    _stack: /* @__PURE__ */ new Set(),\n    _descriptors: wn(i, s),\n    setContext: (o) => Vt(i, o, e, s),\n    override: (o) => Vt(i.override(o), t, e, s)\n  };\n  return new Proxy(n, {\n    deleteProperty(o, r) {\n      return delete o[r], delete i[r], !0;\n    },\n    get(o, r, a) {\n      return Sn(\n        o,\n        r,\n        () => xr(o, r, a)\n      );\n    },\n    getOwnPropertyDescriptor(o, r) {\n      return o._descriptors.allKeys ? Reflect.has(i, r) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(i);\n    },\n    has(o, r) {\n      return Reflect.has(i, r);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(i);\n    },\n    set(o, r, a) {\n      return i[r] = a, delete o[r], !0;\n    }\n  });\n}\nfunction wn(i, t = { scriptable: !0, indexable: !0 }) {\n  const { _scriptable: e = t.scriptable, _indexable: s = t.indexable, _allKeys: n = t.allKeys } = i;\n  return {\n    allKeys: n,\n    scriptable: e,\n    indexable: s,\n    isScriptable: yt(e) ? e : () => e,\n    isIndexable: yt(s) ? s : () => s\n  };\n}\nconst br = (i, t) => i ? i + Oi(t) : t, Bi = (i, t) => D(t) && i !== \"adapters\" && (Object.getPrototypeOf(t) === null || t.constructor === Object);\nfunction Sn(i, t, e) {\n  if (Object.prototype.hasOwnProperty.call(i, t))\n    return i[t];\n  const s = e();\n  return i[t] = s, s;\n}\nfunction xr(i, t, e) {\n  const { _proxy: s, _context: n, _subProxy: o, _descriptors: r } = i;\n  let a = s[t];\n  return yt(a) && r.isScriptable(t) && (a = _r(t, a, i, e)), z(a) && a.length && (a = yr(t, a, i, r.isIndexable)), Bi(t, a) && (a = Vt(a, n, o && o[t], r)), a;\n}\nfunction _r(i, t, e, s) {\n  const { _proxy: n, _context: o, _subProxy: r, _stack: a } = e;\n  if (a.has(i))\n    throw new Error(\"Recursion detected: \" + Array.from(a).join(\"->\") + \"->\" + i);\n  return a.add(i), t = t(o, r || s), a.delete(i), Bi(i, t) && (t = Vi(n._scopes, n, i, t)), t;\n}\nfunction yr(i, t, e, s) {\n  const { _proxy: n, _context: o, _subProxy: r, _descriptors: a } = e;\n  if (et(o.index) && s(i))\n    t = t[o.index % t.length];\n  else if (D(t[0])) {\n    const l = t, c = n._scopes.filter((h) => h !== l);\n    t = [];\n    for (const h of l) {\n      const d = Vi(c, n, i, h);\n      t.push(Vt(d, o, r && r[i], a));\n    }\n  }\n  return t;\n}\nfunction Pn(i, t, e) {\n  return yt(i) ? i(t, e) : i;\n}\nconst vr = (i, t) => i === !0 ? t : typeof i == \"string\" ? _t(t, i) : void 0;\nfunction Mr(i, t, e, s, n) {\n  for (const o of t) {\n    const r = vr(e, o);\n    if (r) {\n      i.add(r);\n      const a = Pn(r._fallback, e, n);\n      if (et(a) && a !== e && a !== s)\n        return a;\n    } else if (r === !1 && et(s) && e !== s)\n      return null;\n  }\n  return !1;\n}\nfunction Vi(i, t, e, s) {\n  const n = t._rootScopes, o = Pn(t._fallback, e, s), r = [...i, ...n], a = /* @__PURE__ */ new Set();\n  a.add(s);\n  let l = rs(a, r, e, o || e, s);\n  return l === null || et(o) && o !== e && (l = rs(a, r, o, l, s), l === null) ? !1 : zi(\n    Array.from(a),\n    [\"\"],\n    n,\n    o,\n    () => kr(t, e, s)\n  );\n}\nfunction rs(i, t, e, s, n) {\n  for (; e; )\n    e = Mr(i, t, e, s, n);\n  return e;\n}\nfunction kr(i, t, e) {\n  const s = i._getTarget();\n  t in s || (s[t] = {});\n  const n = s[t];\n  return z(n) && D(e) ? e : n;\n}\nfunction wr(i, t, e, s) {\n  let n;\n  for (const o of t)\n    if (n = Cn(br(o, i), e), et(n))\n      return Bi(i, n) ? Vi(e, s, i, n) : n;\n}\nfunction Cn(i, t) {\n  for (const e of t) {\n    if (!e)\n      continue;\n    const s = e[i];\n    if (et(s))\n      return s;\n  }\n}\nfunction as(i) {\n  let t = i._keys;\n  return t || (t = i._keys = Sr(i._scopes)), t;\n}\nfunction Sr(i) {\n  const t = /* @__PURE__ */ new Set();\n  for (const e of i)\n    for (const s of Object.keys(e).filter((n) => !n.startsWith(\"_\")))\n      t.add(s);\n  return Array.from(t);\n}\nfunction Dn(i, t, e, s) {\n  const { iScale: n } = i, { key: o = \"r\" } = this._parsing, r = new Array(s);\n  let a, l, c, h;\n  for (a = 0, l = s; a < l; ++a)\n    c = a + e, h = t[c], r[a] = {\n      r: n.parse(_t(h, o), c)\n    };\n  return r;\n}\nconst Pr = Number.EPSILON || 1e-14, Wt = (i, t) => t < i.length && !i[t].skip && i[t], On = (i) => i === \"x\" ? \"y\" : \"x\";\nfunction Cr(i, t, e, s) {\n  const n = i.skip ? t : i, o = t, r = e.skip ? t : e, a = bi(o, n), l = bi(r, o);\n  let c = a / (a + l), h = l / (a + l);\n  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;\n  const d = s * c, u = s * h;\n  return {\n    previous: {\n      x: o.x - d * (r.x - n.x),\n      y: o.y - d * (r.y - n.y)\n    },\n    next: {\n      x: o.x + u * (r.x - n.x),\n      y: o.y + u * (r.y - n.y)\n    }\n  };\n}\nfunction Dr(i, t, e) {\n  const s = i.length;\n  let n, o, r, a, l, c = Wt(i, 0);\n  for (let h = 0; h < s - 1; ++h)\n    if (l = c, c = Wt(i, h + 1), !(!l || !c)) {\n      if (te(t[h], 0, Pr)) {\n        e[h] = e[h + 1] = 0;\n        continue;\n      }\n      n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);\n    }\n}\nfunction Or(i, t, e = \"x\") {\n  const s = On(e), n = i.length;\n  let o, r, a, l = Wt(i, 0);\n  for (let c = 0; c < n; ++c) {\n    if (r = a, a = l, l = Wt(i, c + 1), !a)\n      continue;\n    const h = a[e], d = a[s];\n    r && (o = (h - r[e]) / 3, a[`cp1${e}`] = h - o, a[`cp1${s}`] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[`cp2${e}`] = h + o, a[`cp2${s}`] = d + o * t[c]);\n  }\n}\nfunction Ar(i, t = \"x\") {\n  const e = On(t), s = i.length, n = Array(s).fill(0), o = Array(s);\n  let r, a, l, c = Wt(i, 0);\n  for (r = 0; r < s; ++r)\n    if (a = l, l = c, c = Wt(i, r + 1), !!l) {\n      if (c) {\n        const h = c[t] - l[t];\n        n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;\n      }\n      o[r] = a ? c ? lt(n[r - 1]) !== lt(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];\n    }\n  Dr(i, n, o), Or(i, o, t);\n}\nfunction De(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n}\nfunction Tr(i, t) {\n  let e, s, n, o, r, a = re(i[0], t);\n  for (e = 0, s = i.length; e < s; ++e)\n    r = o, o = a, a = e < s - 1 && re(i[e + 1], t), o && (n = i[e], r && (n.cp1x = De(n.cp1x, t.left, t.right), n.cp1y = De(n.cp1y, t.top, t.bottom)), a && (n.cp2x = De(n.cp2x, t.left, t.right), n.cp2y = De(n.cp2y, t.top, t.bottom)));\n}\nfunction Lr(i, t, e, s, n) {\n  let o, r, a, l;\n  if (t.spanGaps && (i = i.filter((c) => !c.skip)), t.cubicInterpolationMode === \"monotone\")\n    Ar(i, n);\n  else {\n    let c = s ? i[i.length - 1] : i[0];\n    for (o = 0, r = i.length; o < r; ++o)\n      a = i[o], l = Cr(\n        c,\n        a,\n        i[Math.min(o + 1, r - (s ? 0 : 1)) % r],\n        t.tension\n      ), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;\n  }\n  t.capBezierPoints && Tr(i, e);\n}\nfunction An() {\n  return typeof window < \"u\" && typeof document < \"u\";\n}\nfunction Wi(i) {\n  let t = i.parentNode;\n  return t && t.toString() === \"[object ShadowRoot]\" && (t = t.host), t;\n}\nfunction He(i, t, e) {\n  let s;\n  return typeof i == \"string\" ? (s = parseInt(i, 10), i.indexOf(\"%\") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;\n}\nconst Ke = (i) => window.getComputedStyle(i, null);\nfunction Rr(i, t) {\n  return Ke(i).getPropertyValue(t);\n}\nconst Er = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction Ot(i, t, e) {\n  const s = {};\n  e = e ? \"-\" + e : \"\";\n  for (let n = 0; n < 4; n++) {\n    const o = Er[n];\n    s[o] = parseFloat(i[t + \"-\" + o + e]) || 0;\n  }\n  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n}\nconst Fr = (i, t, e) => (i > 0 || t > 0) && (!e || !e.shadowRoot);\nfunction Ir(i, t) {\n  const e = i.touches, s = e && e.length ? e[0] : i, { offsetX: n, offsetY: o } = s;\n  let r = !1, a, l;\n  if (Fr(n, o, i.target))\n    a = n, l = o;\n  else {\n    const c = t.getBoundingClientRect();\n    a = s.clientX - c.left, l = s.clientY - c.top, r = !0;\n  }\n  return { x: a, y: l, box: r };\n}\nfunction Pt(i, t) {\n  if (\"native\" in i)\n    return i;\n  const { canvas: e, currentDevicePixelRatio: s } = t, n = Ke(e), o = n.boxSizing === \"border-box\", r = Ot(n, \"padding\"), a = Ot(n, \"border\", \"width\"), { x: l, y: c, box: h } = Ir(i, e), d = r.left + (h && a.left), u = r.top + (h && a.top);\n  let { width: f, height: g } = t;\n  return o && (f -= r.width + a.width, g -= r.height + a.height), {\n    x: Math.round((l - d) / f * e.width / s),\n    y: Math.round((c - u) / g * e.height / s)\n  };\n}\nfunction zr(i, t, e) {\n  let s, n;\n  if (t === void 0 || e === void 0) {\n    const o = Wi(i);\n    if (!o)\n      t = i.clientWidth, e = i.clientHeight;\n    else {\n      const r = o.getBoundingClientRect(), a = Ke(o), l = Ot(a, \"border\", \"width\"), c = Ot(a, \"padding\");\n      t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = He(a.maxWidth, o, \"clientWidth\"), n = He(a.maxHeight, o, \"clientHeight\");\n    }\n  }\n  return {\n    width: t,\n    height: e,\n    maxWidth: s || Ve,\n    maxHeight: n || Ve\n  };\n}\nconst ai = (i) => Math.round(i * 10) / 10;\nfunction Br(i, t, e, s) {\n  const n = Ke(i), o = Ot(n, \"margin\"), r = He(n.maxWidth, i, \"clientWidth\") || Ve, a = He(n.maxHeight, i, \"clientHeight\") || Ve, l = zr(i, t, e);\n  let { width: c, height: h } = l;\n  if (n.boxSizing === \"content-box\") {\n    const d = Ot(n, \"border\", \"width\"), u = Ot(n, \"padding\");\n    c -= u.width + d.width, h -= u.height + d.height;\n  }\n  return c = Math.max(0, c - o.width), h = Math.max(0, s ? Math.floor(c / s) : h - o.height), c = ai(Math.min(c, r, l.maxWidth)), h = ai(Math.min(h, a, l.maxHeight)), c && !h && (h = ai(c / 2)), {\n    width: c,\n    height: h\n  };\n}\nfunction ls(i, t, e) {\n  const s = t || 1, n = Math.floor(i.height * s), o = Math.floor(i.width * s);\n  i.height = n / s, i.width = o / s;\n  const r = i.canvas;\n  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = `${i.height}px`, r.style.width = `${i.width}px`), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;\n}\nconst Vr = function() {\n  let i = !1;\n  try {\n    const t = {\n      get passive() {\n        return i = !0, !1;\n      }\n    };\n    window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t);\n  } catch {\n  }\n  return i;\n}();\nfunction cs(i, t) {\n  const e = Rr(i, t), s = e && e.match(/^(\\d+)(\\.\\d+)?px$/);\n  return s ? +s[1] : void 0;\n}\nfunction Ct(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: i.y + e * (t.y - i.y)\n  };\n}\nfunction Wr(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: s === \"middle\" ? e < 0.5 ? i.y : t.y : s === \"after\" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y\n  };\n}\nfunction Nr(i, t, e, s) {\n  const n = { x: i.cp2x, y: i.cp2y }, o = { x: t.cp1x, y: t.cp1y }, r = Ct(i, n, e), a = Ct(n, o, e), l = Ct(o, t, e), c = Ct(r, a, e), h = Ct(a, l, e);\n  return Ct(c, h, e);\n}\nconst hs = /* @__PURE__ */ new Map();\nfunction Hr(i, t) {\n  t = t || {};\n  const e = i + JSON.stringify(t);\n  let s = hs.get(e);\n  return s || (s = new Intl.NumberFormat(i, t), hs.set(e, s)), s;\n}\nfunction de(i, t, e) {\n  return Hr(t, e).format(i);\n}\nconst jr = function(i, t) {\n  return {\n    x(e) {\n      return i + i + t - e;\n    },\n    setWidth(e) {\n      t = e;\n    },\n    textAlign(e) {\n      return e === \"center\" ? e : e === \"right\" ? \"left\" : \"right\";\n    },\n    xPlus(e, s) {\n      return e - s;\n    },\n    leftForLtr(e, s) {\n      return e - s;\n    }\n  };\n}, $r = function() {\n  return {\n    x(i) {\n      return i;\n    },\n    setWidth(i) {\n    },\n    textAlign(i) {\n      return i;\n    },\n    xPlus(i, t) {\n      return i + t;\n    },\n    leftForLtr(i, t) {\n      return i;\n    }\n  };\n};\nfunction zt(i, t, e) {\n  return i ? jr(t, e) : $r();\n}\nfunction Tn(i, t) {\n  let e, s;\n  (t === \"ltr\" || t === \"rtl\") && (e = i.canvas.style, s = [\n    e.getPropertyValue(\"direction\"),\n    e.getPropertyPriority(\"direction\")\n  ], e.setProperty(\"direction\", t, \"important\"), i.prevTextDirection = s);\n}\nfunction Ln(i, t) {\n  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty(\"direction\", t[0], t[1]));\n}\nfunction Rn(i) {\n  return i === \"angle\" ? {\n    between: oe,\n    compare: Ao,\n    normalize: Z\n  } : {\n    between: ut,\n    compare: (t, e) => t - e,\n    normalize: (t) => t\n  };\n}\nfunction ds({ start: i, end: t, count: e, loop: s, style: n }) {\n  return {\n    start: i % e,\n    end: t % e,\n    loop: s && (t - i + 1) % e === 0,\n    style: n\n  };\n}\nfunction Yr(i, t, e) {\n  const { property: s, start: n, end: o } = e, { between: r, normalize: a } = Rn(s), l = t.length;\n  let { start: c, end: h, loop: d } = i, u, f;\n  if (d) {\n    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u)\n      c--, h--;\n    c %= l, h %= l;\n  }\n  return h < c && (h += l), { start: c, end: h, loop: d, style: i.style };\n}\nfunction En(i, t, e) {\n  if (!e)\n    return [i];\n  const { property: s, start: n, end: o } = e, r = t.length, { compare: a, between: l, normalize: c } = Rn(s), { start: h, end: d, loop: u, style: f } = Yr(i, t, e), g = [];\n  let p = !1, m = null, b, x, v;\n  const y = () => l(n, v, b) && a(n, v) !== 0, _ = () => a(o, b) === 0 || l(o, v, b), M = () => p || y(), k = () => !p || _();\n  for (let S = h, w = h; S <= d; ++S)\n    x = t[S % r], !x.skip && (b = c(x[s]), b !== v && (p = l(b, n, o), m === null && M() && (m = a(b, n) === 0 ? S : w), m !== null && k() && (g.push(ds({ start: m, end: S, loop: u, count: r, style: f })), m = null), w = S, v = b));\n  return m !== null && g.push(ds({ start: m, end: d, loop: u, count: r, style: f })), g;\n}\nfunction Fn(i, t) {\n  const e = [], s = i.segments;\n  for (let n = 0; n < s.length; n++) {\n    const o = En(s[n], i.points, t);\n    o.length && e.push(...o);\n  }\n  return e;\n}\nfunction Xr(i, t, e, s) {\n  let n = 0, o = t - 1;\n  if (e && !s)\n    for (; n < t && !i[n].skip; )\n      n++;\n  for (; n < t && i[n].skip; )\n    n++;\n  for (n %= t, e && (o += n); o > n && i[o % t].skip; )\n    o--;\n  return o %= t, { start: n, end: o };\n}\nfunction Ur(i, t, e, s) {\n  const n = i.length, o = [];\n  let r = t, a = i[t], l;\n  for (l = t + 1; l <= e; ++l) {\n    const c = i[l % n];\n    c.skip || c.stop ? a.skip || (s = !1, o.push({ start: t % n, end: (l - 1) % n, loop: s }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;\n  }\n  return r !== null && o.push({ start: t % n, end: r % n, loop: s }), o;\n}\nfunction Kr(i, t) {\n  const e = i.points, s = i.options.spanGaps, n = e.length;\n  if (!n)\n    return [];\n  const o = !!i._loop, { start: r, end: a } = Xr(e, n, o, s);\n  if (s === !0)\n    return us(i, [{ start: r, end: a, loop: o }], e, t);\n  const l = a < r ? a + n : a, c = !!i._fullLoop && r === 0 && a === n - 1;\n  return us(i, Ur(e, r, l, c), e, t);\n}\nfunction us(i, t, e, s) {\n  return !s || !s.setContext || !e ? t : qr(i, t, e, s);\n}\nfunction qr(i, t, e, s) {\n  const n = i._chart.getContext(), o = fs(i.options), { _datasetIndex: r, options: { spanGaps: a } } = i, l = e.length, c = [];\n  let h = o, d = t[0].start, u = d;\n  function f(g, p, m, b) {\n    const x = a ? -1 : 1;\n    if (g !== p) {\n      for (g += l; e[g % l].skip; )\n        g -= x;\n      for (; e[p % l].skip; )\n        p += x;\n      g % l !== p % l && (c.push({ start: g % l, end: p % l, loop: m, style: b }), h = b, d = p % l);\n    }\n  }\n  for (const g of t) {\n    d = a ? d : g.start;\n    let p = e[d % l], m;\n    for (u = d + 1; u <= g.end; u++) {\n      const b = e[u % l];\n      m = fs(s.setContext(vt(n, {\n        type: \"segment\",\n        p0: p,\n        p1: b,\n        p0DataIndex: (u - 1) % l,\n        p1DataIndex: u % l,\n        datasetIndex: r\n      }))), Gr(m, h) && f(d, u - 1, g.loop, h), p = b, h = m;\n    }\n    d < u - 1 && f(d, u - 1, g.loop, h);\n  }\n  return c;\n}\nfunction fs(i) {\n  return {\n    backgroundColor: i.backgroundColor,\n    borderCapStyle: i.borderCapStyle,\n    borderDash: i.borderDash,\n    borderDashOffset: i.borderDashOffset,\n    borderJoinStyle: i.borderJoinStyle,\n    borderWidth: i.borderWidth,\n    borderColor: i.borderColor\n  };\n}\nfunction Gr(i, t) {\n  return t && JSON.stringify(i) !== JSON.stringify(t);\n}\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nclass Zr {\n  constructor() {\n    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;\n  }\n  _notify(t, e, s, n) {\n    const o = e.listeners[n], r = e.duration;\n    o.forEach((a) => a({\n      chart: t,\n      initial: e.initial,\n      numSteps: r,\n      currentStep: Math.min(s - e.start, r)\n    }));\n  }\n  _refresh() {\n    this._request || (this._running = !0, this._request = fn.call(window, () => {\n      this._update(), this._request = null, this._running && this._refresh();\n    }));\n  }\n  _update(t = Date.now()) {\n    let e = 0;\n    this._charts.forEach((s, n) => {\n      if (!s.running || !s.items.length)\n        return;\n      const o = s.items;\n      let r = o.length - 1, a = !1, l;\n      for (; r >= 0; --r)\n        l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());\n      a && (n.draw(), this._notify(n, s, t, \"progress\")), o.length || (s.running = !1, this._notify(n, s, t, \"complete\"), s.initial = !1), e += o.length;\n    }), this._lastDate = t, e === 0 && (this._running = !1);\n  }\n  _getAnims(t) {\n    const e = this._charts;\n    let s = e.get(t);\n    return s || (s = {\n      running: !1,\n      initial: !0,\n      items: [],\n      listeners: {\n        complete: [],\n        progress: []\n      }\n    }, e.set(t, s)), s;\n  }\n  listen(t, e, s) {\n    this._getAnims(t).listeners[e].push(s);\n  }\n  add(t, e) {\n    !e || !e.length || this._getAnims(t).items.push(...e);\n  }\n  has(t) {\n    return this._getAnims(t).items.length > 0;\n  }\n  start(t) {\n    const e = this._charts.get(t);\n    e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((s, n) => Math.max(s, n._duration), 0), this._refresh());\n  }\n  running(t) {\n    if (!this._running)\n      return !1;\n    const e = this._charts.get(t);\n    return !(!e || !e.running || !e.items.length);\n  }\n  stop(t) {\n    const e = this._charts.get(t);\n    if (!e || !e.items.length)\n      return;\n    const s = e.items;\n    let n = s.length - 1;\n    for (; n >= 0; --n)\n      s[n].cancel();\n    e.items = [], this._notify(t, e, Date.now(), \"complete\");\n  }\n  remove(t) {\n    return this._charts.delete(t);\n  }\n}\nvar at = new Zr();\nconst gs = \"transparent\", Jr = {\n  boolean(i, t, e) {\n    return e > 0.5 ? t : i;\n  },\n  color(i, t, e) {\n    const s = ns(i || gs), n = s.valid && ns(t || gs);\n    return n && n.valid ? n.mix(s, e).hexString() : t;\n  },\n  number(i, t, e) {\n    return i + (t - i) * e;\n  }\n};\nclass In {\n  constructor(t, e, s, n) {\n    const o = e[s];\n    n = Zt([t.to, n, o, t.from]);\n    const r = Zt([t.from, o, n]);\n    this._active = !0, this._fn = t.fn || Jr[t.type || typeof r], this._easing = ee[t.easing] || ee.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;\n  }\n  active() {\n    return this._active;\n  }\n  update(t, e, s) {\n    if (this._active) {\n      this._notify(!1);\n      const n = this._target[this._prop], o = s - this._start, r = this._duration - o;\n      this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Zt([t.to, e, n, t.from]), this._from = Zt([t.from, n, e]);\n    }\n  }\n  cancel() {\n    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n  }\n  tick(t) {\n    const e = t - this._start, s = this._duration, n = this._prop, o = this._from, r = this._loop, a = this._to;\n    let l;\n    if (this._active = o !== a && (r || e < s), !this._active) {\n      this._target[n] = a, this._notify(!0);\n      return;\n    }\n    if (e < 0) {\n      this._target[n] = o;\n      return;\n    }\n    l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);\n  }\n  wait() {\n    const t = this._promises || (this._promises = []);\n    return new Promise((e, s) => {\n      t.push({ res: e, rej: s });\n    });\n  }\n  _notify(t) {\n    const e = t ? \"res\" : \"rej\", s = this._promises || [];\n    for (let n = 0; n < s.length; n++)\n      s[n][e]();\n  }\n}\nconst Qr = [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"], ta = [\"color\", \"borderColor\", \"backgroundColor\"];\nO.set(\"animation\", {\n  delay: void 0,\n  duration: 1e3,\n  easing: \"easeOutQuart\",\n  fn: void 0,\n  from: void 0,\n  loop: void 0,\n  to: void 0,\n  type: void 0\n});\nconst ea = Object.keys(O.animation);\nO.describe(\"animation\", {\n  _fallback: !1,\n  _indexable: !1,\n  _scriptable: (i) => i !== \"onProgress\" && i !== \"onComplete\" && i !== \"fn\"\n});\nO.set(\"animations\", {\n  colors: {\n    type: \"color\",\n    properties: ta\n  },\n  numbers: {\n    type: \"number\",\n    properties: Qr\n  }\n});\nO.describe(\"animations\", {\n  _fallback: \"animation\"\n});\nO.set(\"transitions\", {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: \"transparent\"\n      },\n      visible: {\n        type: \"boolean\",\n        duration: 0\n      }\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: \"transparent\"\n      },\n      visible: {\n        type: \"boolean\",\n        easing: \"linear\",\n        fn: (i) => i | 0\n      }\n    }\n  }\n});\nclass Ni {\n  constructor(t, e) {\n    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);\n  }\n  configure(t) {\n    if (!D(t))\n      return;\n    const e = this._properties;\n    Object.getOwnPropertyNames(t).forEach((s) => {\n      const n = t[s];\n      if (!D(n))\n        return;\n      const o = {};\n      for (const r of ea)\n        o[r] = n[r];\n      (z(n.properties) && n.properties || [s]).forEach((r) => {\n        (r === s || !e.has(r)) && e.set(r, o);\n      });\n    });\n  }\n  _animateOptions(t, e) {\n    const s = e.options, n = sa(t, s);\n    if (!n)\n      return [];\n    const o = this._createAnimations(n, s);\n    return s.$shared && ia(t.options.$animations, s).then(() => {\n      t.options = s;\n    }, () => {\n    }), o;\n  }\n  _createAnimations(t, e) {\n    const s = this._properties, n = [], o = t.$animations || (t.$animations = {}), r = Object.keys(e), a = Date.now();\n    let l;\n    for (l = r.length - 1; l >= 0; --l) {\n      const c = r[l];\n      if (c.charAt(0) === \"$\")\n        continue;\n      if (c === \"options\") {\n        n.push(...this._animateOptions(t, e));\n        continue;\n      }\n      const h = e[c];\n      let d = o[c];\n      const u = s.get(c);\n      if (d)\n        if (u && d.active()) {\n          d.update(u, h, a);\n          continue;\n        } else\n          d.cancel();\n      if (!u || !u.duration) {\n        t[c] = h;\n        continue;\n      }\n      o[c] = d = new In(u, t, c, h), n.push(d);\n    }\n    return n;\n  }\n  update(t, e) {\n    if (this._properties.size === 0) {\n      Object.assign(t, e);\n      return;\n    }\n    const s = this._createAnimations(t, e);\n    if (s.length)\n      return at.add(this._chart, s), !0;\n  }\n}\nfunction ia(i, t) {\n  const e = [], s = Object.keys(t);\n  for (let n = 0; n < s.length; n++) {\n    const o = i[s[n]];\n    o && o.active() && e.push(o.wait());\n  }\n  return Promise.all(e);\n}\nfunction sa(i, t) {\n  if (!t)\n    return;\n  let e = i.options;\n  if (!e) {\n    i.options = t;\n    return;\n  }\n  return e.$shared && (i.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e;\n}\nfunction ps(i, t) {\n  const e = i && i.options || {}, s = e.reverse, n = e.min === void 0 ? t : 0, o = e.max === void 0 ? t : 0;\n  return {\n    start: s ? o : n,\n    end: s ? n : o\n  };\n}\nfunction na(i, t, e) {\n  if (e === !1)\n    return !1;\n  const s = ps(i, e), n = ps(t, e);\n  return {\n    top: n.end,\n    right: s.end,\n    bottom: n.start,\n    left: s.start\n  };\n}\nfunction oa(i) {\n  let t, e, s, n;\n  return D(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {\n    top: t,\n    right: e,\n    bottom: s,\n    left: n,\n    disabled: i === !1\n  };\n}\nfunction zn(i, t) {\n  const e = [], s = i._getSortedDatasetMetas(t);\n  let n, o;\n  for (n = 0, o = s.length; n < o; ++n)\n    e.push(s[n].index);\n  return e;\n}\nfunction ms(i, t, e, s = {}) {\n  const n = i.keys, o = s.mode === \"single\";\n  let r, a, l, c;\n  if (t !== null) {\n    for (r = 0, a = n.length; r < a; ++r) {\n      if (l = +n[r], l === e) {\n        if (s.all)\n          continue;\n        break;\n      }\n      c = i.values[l], N(c) && (o || t === 0 || lt(t) === lt(c)) && (t += c);\n    }\n    return t;\n  }\n}\nfunction ra(i) {\n  const t = Object.keys(i), e = new Array(t.length);\n  let s, n, o;\n  for (s = 0, n = t.length; s < n; ++s)\n    o = t[s], e[s] = {\n      x: o,\n      y: i[o]\n    };\n  return e;\n}\nfunction bs(i, t) {\n  const e = i && i.options.stacked;\n  return e || e === void 0 && t.stack !== void 0;\n}\nfunction aa(i, t, e) {\n  return `${i.id}.${t.id}.${e.stack || e.type}`;\n}\nfunction la(i) {\n  const { min: t, max: e, minDefined: s, maxDefined: n } = i.getUserBounds();\n  return {\n    min: s ? t : Number.NEGATIVE_INFINITY,\n    max: n ? e : Number.POSITIVE_INFINITY\n  };\n}\nfunction ca(i, t, e) {\n  const s = i[t] || (i[t] = {});\n  return s[e] || (s[e] = {});\n}\nfunction xs(i, t, e, s) {\n  for (const n of t.getMatchingVisibleMetas(s).reverse()) {\n    const o = i[n.index];\n    if (e && o > 0 || !e && o < 0)\n      return n.index;\n  }\n  return null;\n}\nfunction _s(i, t) {\n  const { chart: e, _cachedMeta: s } = i, n = e._stacks || (e._stacks = {}), { iScale: o, vScale: r, index: a } = s, l = o.axis, c = r.axis, h = aa(o, r, s), d = t.length;\n  let u;\n  for (let f = 0; f < d; ++f) {\n    const g = t[f], { [l]: p, [c]: m } = g, b = g._stacks || (g._stacks = {});\n    u = b[c] = ca(n, h, p), u[a] = m, u._top = xs(u, r, !0, s.type), u._bottom = xs(u, r, !1, s.type);\n  }\n}\nfunction li(i, t) {\n  const e = i.scales;\n  return Object.keys(e).filter((s) => e[s].axis === t).shift();\n}\nfunction ha(i, t) {\n  return vt(\n    i,\n    {\n      active: !1,\n      dataset: void 0,\n      datasetIndex: t,\n      index: t,\n      mode: \"default\",\n      type: \"dataset\"\n    }\n  );\n}\nfunction da(i, t, e) {\n  return vt(i, {\n    active: !1,\n    dataIndex: t,\n    parsed: void 0,\n    raw: void 0,\n    element: e,\n    index: t,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction Yt(i, t) {\n  const e = i.controller.index, s = i.vScale && i.vScale.axis;\n  if (s) {\n    t = t || i._parsed;\n    for (const n of t) {\n      const o = n._stacks;\n      if (!o || o[s] === void 0 || o[s][e] === void 0)\n        return;\n      delete o[s][e];\n    }\n  }\n}\nconst ci = (i) => i === \"reset\" || i === \"none\", ys = (i, t) => t ? i : Object.assign({}, i), ua = (i, t, e) => i && !t.hidden && t._stacked && { keys: zn(e, !0), values: null };\nclass it {\n  constructor(t, e) {\n    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();\n  }\n  initialize() {\n    const t = this._cachedMeta;\n    this.configure(), this.linkScales(), t._stacked = bs(t.vScale, t), this.addElements();\n  }\n  updateIndex(t) {\n    this.index !== t && Yt(this._cachedMeta), this.index = t;\n  }\n  linkScales() {\n    const t = this.chart, e = this._cachedMeta, s = this.getDataset(), n = (d, u, f, g) => d === \"x\" ? u : d === \"r\" ? g : f, o = e.xAxisID = C(s.xAxisID, li(t, \"x\")), r = e.yAxisID = C(s.yAxisID, li(t, \"y\")), a = e.rAxisID = C(s.rAxisID, li(t, \"r\")), l = e.indexAxis, c = e.iAxisID = n(l, o, r, a), h = e.vAxisID = n(l, r, o, a);\n    e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(t) {\n    return this.chart.scales[t];\n  }\n  _getOtherScale(t) {\n    const e = this._cachedMeta;\n    return t === e.iScale ? e.vScale : e.iScale;\n  }\n  reset() {\n    this._update(\"reset\");\n  }\n  _destroy() {\n    const t = this._cachedMeta;\n    this._data && Zi(this._data, this), t._stacked && Yt(t);\n  }\n  _dataCheck() {\n    const t = this.getDataset(), e = t.data || (t.data = []), s = this._data;\n    if (D(e))\n      this._data = ra(e);\n    else if (s !== e) {\n      if (s) {\n        Zi(s, this);\n        const n = this._cachedMeta;\n        Yt(n), n._parsed = [];\n      }\n      e && Object.isExtensible(e) && Eo(e, this), this._syncList = [], this._data = e;\n    }\n  }\n  addElements() {\n    const t = this._cachedMeta;\n    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());\n  }\n  buildOrUpdateElements(t) {\n    const e = this._cachedMeta, s = this.getDataset();\n    let n = !1;\n    this._dataCheck();\n    const o = e._stacked;\n    e._stacked = bs(e.vScale, e), e.stack !== s.stack && (n = !0, Yt(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && _s(this, e._parsed);\n  }\n  configure() {\n    const t = this.chart.config, e = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), e, !0);\n    this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n  }\n  parse(t, e) {\n    const { _cachedMeta: s, _data: n } = this, { iScale: o, _stacked: r } = s, a = o.axis;\n    let l = t === 0 && e === n.length ? !0 : s._sorted, c = t > 0 && s._parsed[t - 1], h, d, u;\n    if (this._parsing === !1)\n      s._parsed = n, s._sorted = !0, u = n;\n    else {\n      z(n[t]) ? u = this.parseArrayData(s, n, t, e) : D(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);\n      const f = () => d[a] === null || c && d[a] < c[a];\n      for (h = 0; h < e; ++h)\n        s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);\n      s._sorted = l;\n    }\n    r && _s(this, u);\n  }\n  parsePrimitiveData(t, e, s, n) {\n    const { iScale: o, vScale: r } = t, a = o.axis, l = r.axis, c = o.getLabels(), h = o === r, d = new Array(n);\n    let u, f, g;\n    for (u = 0, f = n; u < f; ++u)\n      g = u + s, d[u] = {\n        [a]: h || o.parse(c[g], g),\n        [l]: r.parse(e[g], g)\n      };\n    return d;\n  }\n  parseArrayData(t, e, s, n) {\n    const { xScale: o, yScale: r } = t, a = new Array(n);\n    let l, c, h, d;\n    for (l = 0, c = n; l < c; ++l)\n      h = l + s, d = e[h], a[l] = {\n        x: o.parse(d[0], h),\n        y: r.parse(d[1], h)\n      };\n    return a;\n  }\n  parseObjectData(t, e, s, n) {\n    const { xScale: o, yScale: r } = t, { xAxisKey: a = \"x\", yAxisKey: l = \"y\" } = this._parsing, c = new Array(n);\n    let h, d, u, f;\n    for (h = 0, d = n; h < d; ++h)\n      u = h + s, f = e[u], c[h] = {\n        x: o.parse(_t(f, a), u),\n        y: r.parse(_t(f, l), u)\n      };\n    return c;\n  }\n  getParsed(t) {\n    return this._cachedMeta._parsed[t];\n  }\n  getDataElement(t) {\n    return this._cachedMeta.data[t];\n  }\n  applyStack(t, e, s) {\n    const n = this.chart, o = this._cachedMeta, r = e[t.axis], a = {\n      keys: zn(n, !0),\n      values: e._stacks[t.axis]\n    };\n    return ms(a, r, o.index, { mode: s });\n  }\n  updateRangeFromParsed(t, e, s, n) {\n    const o = s[e.axis];\n    let r = o === null ? NaN : o;\n    const a = n && s._stacks[e.axis];\n    n && a && (n.values = a, r = ms(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);\n  }\n  getMinMax(t, e) {\n    const s = this._cachedMeta, n = s._parsed, o = s._sorted && t === s.iScale, r = n.length, a = this._getOtherScale(t), l = ua(e, s, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h, max: d } = la(a);\n    let u, f;\n    function g() {\n      f = n[u];\n      const p = f[a.axis];\n      return !N(f[t.axis]) || h > p || d < p;\n    }\n    for (u = 0; u < r && !(!g() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u)\n      ;\n    if (o) {\n      for (u = r - 1; u >= 0; --u)\n        if (!g()) {\n          this.updateRangeFromParsed(c, t, f, l);\n          break;\n        }\n    }\n    return c;\n  }\n  getAllParsedValues(t) {\n    const e = this._cachedMeta._parsed, s = [];\n    let n, o, r;\n    for (n = 0, o = e.length; n < o; ++n)\n      r = e[n][t.axis], N(r) && s.push(r);\n    return s;\n  }\n  getMaxOverflow() {\n    return !1;\n  }\n  getLabelAndValue(t) {\n    const e = this._cachedMeta, s = e.iScale, n = e.vScale, o = this.getParsed(t);\n    return {\n      label: s ? \"\" + s.getLabelForValue(o[s.axis]) : \"\",\n      value: n ? \"\" + n.getLabelForValue(o[n.axis]) : \"\"\n    };\n  }\n  _update(t) {\n    const e = this._cachedMeta;\n    this.update(t || \"default\"), e._clip = oa(C(this.options.clip, na(e.xScale, e.yScale, this.getMaxOverflow())));\n  }\n  update(t) {\n  }\n  draw() {\n    const t = this._ctx, e = this.chart, s = this._cachedMeta, n = s.data || [], o = e.chartArea, r = [], a = this._drawStart || 0, l = this._drawCount || n.length - a, c = this.options.drawActiveElementsOnTop;\n    let h;\n    for (s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {\n      const d = n[h];\n      d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));\n    }\n    for (h = 0; h < r.length; ++h)\n      r[h].draw(t, o);\n  }\n  getStyle(t, e) {\n    const s = e ? \"active\" : \"default\";\n    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);\n  }\n  getContext(t, e, s) {\n    const n = this.getDataset();\n    let o;\n    if (t >= 0 && t < this._cachedMeta.data.length) {\n      const r = this._cachedMeta.data[t];\n      o = r.$context || (r.$context = da(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;\n    } else\n      o = this.$context || (this.$context = ha(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;\n    return o.active = !!e, o.mode = s, o;\n  }\n  resolveDatasetElementOptions(t) {\n    return this._resolveElementOptions(this.datasetElementType.id, t);\n  }\n  resolveDataElementOptions(t, e) {\n    return this._resolveElementOptions(this.dataElementType.id, e, t);\n  }\n  _resolveElementOptions(t, e = \"default\", s) {\n    const n = e === \"active\", o = this._cachedDataOpts, r = t + \"-\" + e, a = o[r], l = this.enableOptionSharing && et(s);\n    if (a)\n      return ys(a, l);\n    const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), d = n ? [`${t}Hover`, \"hover\", t, \"\"] : [t, \"\"], u = c.getOptionScopes(this.getDataset(), h), f = Object.keys(O.elements[t]), g = () => this.getContext(s, n), p = c.resolveNamedOptions(u, f, g, d);\n    return p.$shared && (p.$shared = l, o[r] = Object.freeze(ys(p, l))), p;\n  }\n  _resolveAnimations(t, e, s) {\n    const n = this.chart, o = this._cachedDataOpts, r = `animation-${e}`, a = o[r];\n    if (a)\n      return a;\n    let l;\n    if (n.options.animation !== !1) {\n      const h = this.chart.config, d = h.datasetAnimationScopeKeys(this._type, e), u = h.getOptionScopes(this.getDataset(), d);\n      l = h.createResolver(u, this.getContext(t, s, e));\n    }\n    const c = new Ni(n, l && l.animations);\n    return l && l._cacheable && (o[r] = Object.freeze(c)), c;\n  }\n  getSharedOptions(t) {\n    if (t.$shared)\n      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n  }\n  includeOptions(t, e) {\n    return !e || ci(t) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(t, e) {\n    const s = this.resolveDataElementOptions(t, e), n = this._sharedOptions, o = this.getSharedOptions(s), r = this.includeOptions(e, o) || o !== n;\n    return this.updateSharedOptions(o, e, s), { sharedOptions: o, includeOptions: r };\n  }\n  updateElement(t, e, s, n) {\n    ci(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);\n  }\n  updateSharedOptions(t, e, s) {\n    t && !ci(e) && this._resolveAnimations(void 0, e).update(t, s);\n  }\n  _setStyle(t, e, s, n) {\n    t.active = n;\n    const o = this.getStyle(e, n);\n    this._resolveAnimations(e, s, n).update(t, {\n      options: !n && this.getSharedOptions(o) || o\n    });\n  }\n  removeHoverStyle(t, e, s) {\n    this._setStyle(t, s, \"active\", !1);\n  }\n  setHoverStyle(t, e, s) {\n    this._setStyle(t, s, \"active\", !0);\n  }\n  _removeDatasetHoverStyle() {\n    const t = this._cachedMeta.dataset;\n    t && this._setStyle(t, void 0, \"active\", !1);\n  }\n  _setDatasetHoverStyle() {\n    const t = this._cachedMeta.dataset;\n    t && this._setStyle(t, void 0, \"active\", !0);\n  }\n  _resyncElements(t) {\n    const e = this._data, s = this._cachedMeta.data;\n    for (const [a, l, c] of this._syncList)\n      this[a](l, c);\n    this._syncList = [];\n    const n = s.length, o = e.length, r = Math.min(o, n);\n    r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);\n  }\n  _insertElements(t, e, s = !0) {\n    const n = this._cachedMeta, o = n.data, r = t + e;\n    let a;\n    const l = (c) => {\n      for (c.length += e, a = c.length - 1; a >= r; a--)\n        c[a] = c[a - e];\n    };\n    for (l(o), a = t; a < r; ++a)\n      o[a] = new this.dataElementType();\n    this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, \"reset\");\n  }\n  updateElements(t, e, s, n) {\n  }\n  _removeElements(t, e) {\n    const s = this._cachedMeta;\n    if (this._parsing) {\n      const n = s._parsed.splice(t, e);\n      s._stacked && Yt(s, n);\n    }\n    s.data.splice(t, e);\n  }\n  _sync(t) {\n    if (this._parsing)\n      this._syncList.push(t);\n    else {\n      const [e, s, n] = t;\n      this[e](s, n);\n    }\n    this.chart._dataChanges.push([this.index, ...t]);\n  }\n  _onDataPush() {\n    const t = arguments.length;\n    this._sync([\"_insertElements\", this.getDataset().data.length - t, t]);\n  }\n  _onDataPop() {\n    this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync([\"_removeElements\", 0, 1]);\n  }\n  _onDataSplice(t, e) {\n    e && this._sync([\"_removeElements\", t, e]);\n    const s = arguments.length - 2;\n    s && this._sync([\"_insertElements\", t, s]);\n  }\n  _onDataUnshift() {\n    this._sync([\"_insertElements\", 0, arguments.length]);\n  }\n}\nit.defaults = {};\nit.prototype.datasetElementType = null;\nit.prototype.dataElementType = null;\nfunction fa(i, t) {\n  if (!i._cache.$bar) {\n    const e = i.getMatchingVisibleMetas(t);\n    let s = [];\n    for (let n = 0, o = e.length; n < o; n++)\n      s = s.concat(e[n].controller.getAllParsedValues(i));\n    i._cache.$bar = un(s.sort((n, o) => n - o));\n  }\n  return i._cache.$bar;\n}\nfunction ga(i) {\n  const t = i.iScale, e = fa(t, i.type);\n  let s = t._length, n, o, r, a;\n  const l = () => {\n    r === 32767 || r === -32768 || (et(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);\n  };\n  for (n = 0, o = e.length; n < o; ++n)\n    r = t.getPixelForValue(e[n]), l();\n  for (a = void 0, n = 0, o = t.ticks.length; n < o; ++n)\n    r = t.getPixelForTick(n), l();\n  return s;\n}\nfunction pa(i, t, e, s) {\n  const n = e.barThickness;\n  let o, r;\n  return T(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {\n    chunk: o / s,\n    ratio: r,\n    start: t.pixels[i] - o / 2\n  };\n}\nfunction ma(i, t, e, s) {\n  const n = t.pixels, o = n[i];\n  let r = i > 0 ? n[i - 1] : null, a = i < n.length - 1 ? n[i + 1] : null;\n  const l = e.categoryPercentage;\n  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);\n  const c = o - (o - Math.min(r, a)) / 2 * l;\n  return {\n    chunk: Math.abs(a - r) / 2 * l / s,\n    ratio: e.barPercentage,\n    start: c\n  };\n}\nfunction ba(i, t, e, s) {\n  const n = e.parse(i[0], s), o = e.parse(i[1], s), r = Math.min(n, o), a = Math.max(n, o);\n  let l = r, c = a;\n  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {\n    barStart: l,\n    barEnd: c,\n    start: n,\n    end: o,\n    min: r,\n    max: a\n  };\n}\nfunction Bn(i, t, e, s) {\n  return z(i) ? ba(i, t, e, s) : t[e.axis] = e.parse(i, s), t;\n}\nfunction vs(i, t, e, s) {\n  const n = i.iScale, o = i.vScale, r = n.getLabels(), a = n === o, l = [];\n  let c, h, d, u;\n  for (c = e, h = e + s; c < h; ++c)\n    u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(Bn(u, d, o, c));\n  return l;\n}\nfunction hi(i) {\n  return i && i.barStart !== void 0 && i.barEnd !== void 0;\n}\nfunction xa(i, t, e) {\n  return i !== 0 ? lt(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);\n}\nfunction _a(i) {\n  let t, e, s, n, o;\n  return i.horizontal ? (t = i.base > i.x, e = \"left\", s = \"right\") : (t = i.base < i.y, e = \"bottom\", s = \"top\"), t ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), { start: e, end: s, reverse: t, top: n, bottom: o };\n}\nfunction ya(i, t, e, s) {\n  let n = t.borderSkipped;\n  const o = {};\n  if (!n) {\n    i.borderSkipped = o;\n    return;\n  }\n  if (n === !0) {\n    i.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 };\n    return;\n  }\n  const { start: r, end: a, reverse: l, top: c, bottom: h } = _a(i);\n  n === \"middle\" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[Ms(h, r, a, l)] = !0, n = c)), o[Ms(n, r, a, l)] = !0, i.borderSkipped = o;\n}\nfunction Ms(i, t, e, s) {\n  return s ? (i = va(i, t, e), i = ks(i, e, t)) : i = ks(i, t, e), i;\n}\nfunction va(i, t, e) {\n  return i === t ? e : i === e ? t : i;\n}\nfunction ks(i, t, e) {\n  return i === \"start\" ? t : i === \"end\" ? e : i;\n}\nfunction Ma(i, { inflateAmount: t }, e) {\n  i.inflateAmount = t === \"auto\" ? e === 1 ? 0.33 : 0 : t;\n}\nclass ue extends it {\n  parsePrimitiveData(t, e, s, n) {\n    return vs(t, e, s, n);\n  }\n  parseArrayData(t, e, s, n) {\n    return vs(t, e, s, n);\n  }\n  parseObjectData(t, e, s, n) {\n    const { iScale: o, vScale: r } = t, { xAxisKey: a = \"x\", yAxisKey: l = \"y\" } = this._parsing, c = o.axis === \"x\" ? a : l, h = r.axis === \"x\" ? a : l, d = [];\n    let u, f, g, p;\n    for (u = s, f = s + n; u < f; ++u)\n      p = e[u], g = {}, g[o.axis] = o.parse(_t(p, c), u), d.push(Bn(_t(p, h), g, r, u));\n    return d;\n  }\n  updateRangeFromParsed(t, e, s, n) {\n    super.updateRangeFromParsed(t, e, s, n);\n    const o = s._custom;\n    o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(t) {\n    const e = this._cachedMeta, { iScale: s, vScale: n } = e, o = this.getParsed(t), r = o._custom, a = hi(r) ? \"[\" + r.start + \", \" + r.end + \"]\" : \"\" + n.getLabelForValue(o[n.axis]);\n    return {\n      label: \"\" + s.getLabelForValue(o[s.axis]),\n      value: a\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = !0, super.initialize();\n    const t = this._cachedMeta;\n    t.stack = this.getDataset().stack;\n  }\n  update(t) {\n    const e = this._cachedMeta;\n    this.updateElements(e.data, 0, e.data.length, t);\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", { index: r, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), h = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n    for (let f = e; f < e + s; f++) {\n      const g = this.getParsed(f), p = o || T(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, h), b = (g._stacks || {})[a.axis], x = {\n        horizontal: c,\n        base: p.base,\n        enableBorderRadius: !b || hi(g._custom) || r === b._top || r === b._bottom,\n        x: c ? p.head : m.center,\n        y: c ? m.center : p.head,\n        height: c ? m.size : Math.abs(p.size),\n        width: c ? Math.abs(p.size) : m.size\n      };\n      u && (x.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n      const v = x.options || t[f].options;\n      ya(x, v, b, r), Ma(x, v, h.ratio), this.updateElement(t[f], f, x, n);\n    }\n  }\n  _getStacks(t, e) {\n    const { iScale: s } = this._cachedMeta, n = s.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), o = s.options.stacked, r = [], a = (l) => {\n      const c = l.controller.getParsed(e), h = c && c[l.vScale.axis];\n      if (T(h) || isNaN(h))\n        return !0;\n    };\n    for (const l of n)\n      if (!(e !== void 0 && a(l)) && ((o === !1 || r.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && r.push(l.stack), l.index === t))\n        break;\n    return r.length || r.push(void 0), r;\n  }\n  _getStackCount(t) {\n    return this._getStacks(void 0, t).length;\n  }\n  _getStackIndex(t, e, s) {\n    const n = this._getStacks(t, s), o = e !== void 0 ? n.indexOf(e) : -1;\n    return o === -1 ? n.length - 1 : o;\n  }\n  _getRuler() {\n    const t = this.options, e = this._cachedMeta, s = e.iScale, n = [];\n    let o, r;\n    for (o = 0, r = e.data.length; o < r; ++o)\n      n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));\n    const a = t.barThickness;\n    return {\n      min: a || ga(e),\n      pixels: n,\n      start: s._startPixel,\n      end: s._endPixel,\n      stackCount: this._getStackCount(),\n      scale: s,\n      grouped: t.grouped,\n      ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n    };\n  }\n  _calculateBarValuePixels(t) {\n    const { _cachedMeta: { vScale: e, _stacked: s }, options: { base: n, minBarLength: o } } = this, r = n || 0, a = this.getParsed(t), l = a._custom, c = hi(l);\n    let h = a[e.axis], d = 0, u = s ? this.applyStack(e, a, s) : h, f, g;\n    u !== h && (d = u - h, u = h), c && (h = l.barStart, u = l.barEnd - l.barStart, h !== 0 && lt(h) !== lt(l.barEnd) && (d = 0), d += h);\n    const p = !T(n) && !c ? n : d;\n    let m = e.getPixelForValue(p);\n    if (this.chart.getDataVisibility(t) ? f = e.getPixelForValue(d + u) : f = m, g = f - m, Math.abs(g) < o) {\n      g = xa(g, e, r) * o, h === r && (m -= g / 2);\n      const b = e.getPixelForDecimal(0), x = e.getPixelForDecimal(1), v = Math.min(b, x), y = Math.max(b, x);\n      m = Math.max(Math.min(m, y), v), f = m + g;\n    }\n    if (m === e.getPixelForValue(r)) {\n      const b = lt(g) * e.getLineWidthForValue(r) / 2;\n      m += b, g -= b;\n    }\n    return {\n      size: g,\n      base: m,\n      head: f,\n      center: f + g / 2\n    };\n  }\n  _calculateBarIndexPixels(t, e) {\n    const s = e.scale, n = this.options, o = n.skipNull, r = C(n.maxBarThickness, 1 / 0);\n    let a, l;\n    if (e.grouped) {\n      const c = o ? this._getStackCount(t) : e.stackCount, h = n.barThickness === \"flex\" ? ma(t, e, n, c) : pa(t, e, n, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n      a = h.start + h.chunk * d + h.chunk / 2, l = Math.min(r, h.chunk * h.ratio);\n    } else\n      a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);\n    return {\n      base: a - l / 2,\n      head: a + l / 2,\n      center: a,\n      size: l\n    };\n  }\n  draw() {\n    const t = this._cachedMeta, e = t.vScale, s = t.data, n = s.length;\n    let o = 0;\n    for (; o < n; ++o)\n      this.getParsed(o)[e.axis] !== null && s[o].draw(this._ctx);\n  }\n}\nue.id = \"bar\";\nue.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"bar\",\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: !0,\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n    }\n  }\n};\nue.overrides = {\n  scales: {\n    _index_: {\n      type: \"category\",\n      offset: !0,\n      grid: {\n        offset: !0\n      }\n    },\n    _value_: {\n      type: \"linear\",\n      beginAtZero: !0\n    }\n  }\n};\nclass fe extends it {\n  initialize() {\n    this.enableOptionSharing = !0, super.initialize();\n  }\n  parsePrimitiveData(t, e, s, n) {\n    const o = super.parsePrimitiveData(t, e, s, n);\n    for (let r = 0; r < o.length; r++)\n      o[r]._custom = this.resolveDataElementOptions(r + s).radius;\n    return o;\n  }\n  parseArrayData(t, e, s, n) {\n    const o = super.parseArrayData(t, e, s, n);\n    for (let r = 0; r < o.length; r++) {\n      const a = e[s + r];\n      o[r]._custom = C(a[2], this.resolveDataElementOptions(r + s).radius);\n    }\n    return o;\n  }\n  parseObjectData(t, e, s, n) {\n    const o = super.parseObjectData(t, e, s, n);\n    for (let r = 0; r < o.length; r++) {\n      const a = e[s + r];\n      o[r]._custom = C(a && a.r && +a.r, this.resolveDataElementOptions(r + s).radius);\n    }\n    return o;\n  }\n  getMaxOverflow() {\n    const t = this._cachedMeta.data;\n    let e = 0;\n    for (let s = t.length - 1; s >= 0; --s)\n      e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2);\n    return e > 0 && e;\n  }\n  getLabelAndValue(t) {\n    const e = this._cachedMeta, { xScale: s, yScale: n } = e, o = this.getParsed(t), r = s.getLabelForValue(o.x), a = n.getLabelForValue(o.y), l = o._custom;\n    return {\n      label: e.label,\n      value: \"(\" + r + \", \" + a + (l ? \", \" + l : \"\") + \")\"\n    };\n  }\n  update(t) {\n    const e = this._cachedMeta.data;\n    this.updateElements(e, 0, e.length, t);\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", { iScale: r, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, n), h = r.axis, d = a.axis;\n    for (let u = e; u < e + s; u++) {\n      const f = t[u], g = !o && this.getParsed(u), p = {}, m = p[h] = o ? r.getPixelForDecimal(0.5) : r.getPixelForValue(g[h]), b = p[d] = o ? a.getBasePixel() : a.getPixelForValue(g[d]);\n      p.skip = isNaN(m) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(u, f.active ? \"active\" : n), o && (p.options.radius = 0)), this.updateElement(f, u, p, n);\n    }\n  }\n  resolveDataElementOptions(t, e) {\n    const s = this.getParsed(t);\n    let n = super.resolveDataElementOptions(t, e);\n    n.$shared && (n = Object.assign({}, n, { $shared: !1 }));\n    const o = n.radius;\n    return e !== \"active\" && (n.radius = 0), n.radius += C(s && s._custom, o), n;\n  }\n}\nfe.id = \"bubble\";\nfe.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"borderWidth\", \"radius\"]\n    }\n  }\n};\nfe.overrides = {\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return \"\";\n        }\n      }\n    }\n  }\n};\nfunction ka(i, t, e) {\n  let s = 1, n = 1, o = 0, r = 0;\n  if (t < F) {\n    const a = i, l = a + t, c = Math.cos(a), h = Math.sin(a), d = Math.cos(l), u = Math.sin(l), f = (v, y, _) => oe(v, a, l, !0) ? 1 : Math.max(y, y * e, _, _ * e), g = (v, y, _) => oe(v, a, l, !0) ? -1 : Math.min(y, y * e, _, _ * e), p = f(0, c, d), m = f(V, h, u), b = g(B, c, d), x = g(B + V, h, u);\n    s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, r = -(m + x) / 2;\n  }\n  return { ratioX: s, ratioY: n, offsetX: o, offsetY: r };\n}\nclass Lt extends it {\n  constructor(t, e) {\n    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n  }\n  linkScales() {\n  }\n  parse(t, e) {\n    const s = this.getDataset().data, n = this._cachedMeta;\n    if (this._parsing === !1)\n      n._parsed = s;\n    else {\n      let o = (l) => +s[l];\n      if (D(s[t])) {\n        const { key: l = \"value\" } = this._parsing;\n        o = (c) => +_t(s[c], l);\n      }\n      let r, a;\n      for (r = t, a = t + e; r < a; ++r)\n        n._parsed[r] = o(r);\n    }\n  }\n  _getRotation() {\n    return nt(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return nt(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let t = F, e = -F;\n    for (let s = 0; s < this.chart.data.datasets.length; ++s)\n      if (this.chart.isDatasetVisible(s)) {\n        const n = this.chart.getDatasetMeta(s).controller, o = n._getRotation(), r = n._getCircumference();\n        t = Math.min(t, o), e = Math.max(e, o + r);\n      }\n    return {\n      rotation: t,\n      circumference: e - t\n    };\n  }\n  update(t) {\n    const e = this.chart, { chartArea: s } = e, n = this._cachedMeta, o = n.data, r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(s.width, s.height) - r) / 2, 0), l = Math.min(yo(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = ka(d, h, l), m = (s.width - r) / u, b = (s.height - r) / f, x = Math.max(Math.min(m, b) / 2, 0), v = an(this.options.radius, x), y = Math.max(v * l, 0), _ = (v - y) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = g * v, this.offsetY = p * v, n.total = this.calculateTotal(), this.outerRadius = v - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, t);\n  }\n  _circumference(t, e) {\n    const s = this.options, n = this._cachedMeta, o = this._getCircumference();\n    return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / F);\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", r = this.chart, a = r.chartArea, c = r.options.animation, h = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, u = o && c.animateScale, f = u ? 0 : this.innerRadius, g = u ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: m } = this._getSharedOptions(e, n);\n    let b = this._getRotation(), x;\n    for (x = 0; x < e; ++x)\n      b += this._circumference(x, o);\n    for (x = e; x < e + s; ++x) {\n      const v = this._circumference(x, o), y = t[x], _ = {\n        x: h + this.offsetX,\n        y: d + this.offsetY,\n        startAngle: b,\n        endAngle: b + v,\n        circumference: v,\n        outerRadius: g,\n        innerRadius: f\n      };\n      m && (_.options = p || this.resolveDataElementOptions(x, y.active ? \"active\" : n)), b += v, this.updateElement(y, x, _, n);\n    }\n  }\n  calculateTotal() {\n    const t = this._cachedMeta, e = t.data;\n    let s = 0, n;\n    for (n = 0; n < e.length; n++) {\n      const o = t._parsed[n];\n      o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));\n    }\n    return s;\n  }\n  calculateCircumference(t) {\n    const e = this._cachedMeta.total;\n    return e > 0 && !isNaN(t) ? F * (Math.abs(t) / e) : 0;\n  }\n  getLabelAndValue(t) {\n    const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = de(e._parsed[t], s.options.locale);\n    return {\n      label: n[t] || \"\",\n      value: o\n    };\n  }\n  getMaxBorderWidth(t) {\n    let e = 0;\n    const s = this.chart;\n    let n, o, r, a, l;\n    if (!t) {\n      for (n = 0, o = s.data.datasets.length; n < o; ++n)\n        if (s.isDatasetVisible(n)) {\n          r = s.getDatasetMeta(n), t = r.data, a = r.controller;\n          break;\n        }\n    }\n    if (!t)\n      return 0;\n    for (n = 0, o = t.length; n < o; ++n)\n      l = a.resolveDataElementOptions(n), l.borderAlign !== \"inner\" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));\n    return e;\n  }\n  getMaxOffset(t) {\n    let e = 0;\n    for (let s = 0, n = t.length; s < n; ++s) {\n      const o = this.resolveDataElementOptions(s);\n      e = Math.max(e, o.offset || 0, o.hoverOffset || 0);\n    }\n    return e;\n  }\n  _getRingWeightOffset(t) {\n    let e = 0;\n    for (let s = 0; s < t; ++s)\n      this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));\n    return e;\n  }\n  _getRingWeight(t) {\n    return Math.max(C(this.chart.data.datasets[t].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nLt.id = \"doughnut\";\nLt.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !1\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n    }\n  },\n  cutout: \"50%\",\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\",\n  spacing: 0,\n  indexAxis: \"r\"\n};\nLt.descriptors = {\n  _scriptable: (i) => i !== \"spacing\",\n  _indexable: (i) => i !== \"spacing\"\n};\nLt.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(i) {\n          const t = i.data;\n          if (t.labels.length && t.datasets.length) {\n            const { labels: { pointStyle: e } } = i.legend.options;\n            return t.labels.map((s, n) => {\n              const r = i.getDatasetMeta(0).controller.getStyle(n);\n              return {\n                text: s,\n                fillStyle: r.backgroundColor,\n                strokeStyle: r.borderColor,\n                lineWidth: r.borderWidth,\n                pointStyle: e,\n                hidden: !i.getDataVisibility(n),\n                index: n\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(i, t, e) {\n        e.chart.toggleDataVisibility(t.index), e.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return \"\";\n        },\n        label(i) {\n          let t = i.label;\n          const e = \": \" + i.formattedValue;\n          return z(t) ? (t = t.slice(), t[0] += e) : t += e, t;\n        }\n      }\n    }\n  }\n};\nclass ge extends it {\n  initialize() {\n    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n  }\n  update(t) {\n    const e = this._cachedMeta, { dataset: s, data: n = [], _dataset: o } = e, r = this.chart._animationsDisabled;\n    let { start: a, count: l } = pn(e, n, r);\n    this._drawStart = a, this._drawCount = l, mn(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;\n    const c = this.resolveDatasetElementOptions(t);\n    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {\n      animated: !r,\n      options: c\n    }, t), this.updateElements(n, a, l, t);\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: d } = this._getSharedOptions(e, n), u = r.axis, f = a.axis, { spanGaps: g, segment: p } = this.options, m = Bt(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || n === \"none\";\n    let x = e > 0 && this.getParsed(e - 1);\n    for (let v = e; v < e + s; ++v) {\n      const y = t[v], _ = this.getParsed(v), M = b ? y : {}, k = T(_[f]), S = M[u] = r.getPixelForValue(_[u], v), w = M[f] = o || k ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, _, l) : _[f], v);\n      M.skip = isNaN(S) || isNaN(w) || k, M.stop = v > 0 && Math.abs(_[u] - x[u]) > m, p && (M.parsed = _, M.raw = c.data[v]), d && (M.options = h || this.resolveDataElementOptions(v, y.active ? \"active\" : n)), b || this.updateElement(y, v, M, n), x = _;\n    }\n  }\n  getMaxOverflow() {\n    const t = this._cachedMeta, e = t.dataset, s = e.options && e.options.borderWidth || 0, n = t.data || [];\n    if (!n.length)\n      return s;\n    const o = n[0].size(this.resolveDataElementOptions(0)), r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));\n    return Math.max(s, o, r) / 2;\n  }\n  draw() {\n    const t = this._cachedMeta;\n    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n  }\n}\nge.id = \"line\";\nge.defaults = {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  showLine: !0,\n  spanGaps: !1\n};\nge.overrides = {\n  scales: {\n    _index_: {\n      type: \"category\"\n    },\n    _value_: {\n      type: \"linear\"\n    }\n  }\n};\nclass pe extends it {\n  constructor(t, e) {\n    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n  }\n  getLabelAndValue(t) {\n    const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = de(e._parsed[t].r, s.options.locale);\n    return {\n      label: n[t] || \"\",\n      value: o\n    };\n  }\n  parseObjectData(t, e, s, n) {\n    return Dn.bind(this)(t, e, s, n);\n  }\n  update(t) {\n    const e = this._cachedMeta.data;\n    this._updateRadius(), this.updateElements(e, 0, e.length, t);\n  }\n  getMinMax() {\n    const t = this._cachedMeta, e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };\n    return t.data.forEach((s, n) => {\n      const o = this.getParsed(n).r;\n      !isNaN(o) && this.chart.getDataVisibility(n) && (o < e.min && (e.min = o), o > e.max && (e.max = o));\n    }), e;\n  }\n  _updateRadius() {\n    const t = this.chart, e = t.chartArea, s = t.options, n = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(n / 2, 0), r = Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0), a = (o - r) / t.getVisibleDatasetCount();\n    this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", r = this.chart, l = r.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - 0.5 * B;\n    let f = u, g;\n    const p = 360 / this.countVisibleElements();\n    for (g = 0; g < e; ++g)\n      f += this._computeAngle(g, n, p);\n    for (g = e; g < e + s; g++) {\n      const m = t[g];\n      let b = f, x = f + this._computeAngle(g, n, p), v = r.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;\n      f = x, o && (l.animateScale && (v = 0), l.animateRotate && (b = x = u));\n      const y = {\n        x: h,\n        y: d,\n        innerRadius: 0,\n        outerRadius: v,\n        startAngle: b,\n        endAngle: x,\n        options: this.resolveDataElementOptions(g, m.active ? \"active\" : n)\n      };\n      this.updateElement(m, g, y, n);\n    }\n  }\n  countVisibleElements() {\n    const t = this._cachedMeta;\n    let e = 0;\n    return t.data.forEach((s, n) => {\n      !isNaN(this.getParsed(n).r) && this.chart.getDataVisibility(n) && e++;\n    }), e;\n  }\n  _computeAngle(t, e, s) {\n    return this.chart.getDataVisibility(t) ? nt(this.resolveDataElementOptions(t, e).angle || s) : 0;\n  }\n}\npe.id = \"polarArea\";\npe.defaults = {\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !0\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"]\n    }\n  },\n  indexAxis: \"r\",\n  startAngle: 0\n};\npe.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(i) {\n          const t = i.data;\n          if (t.labels.length && t.datasets.length) {\n            const { labels: { pointStyle: e } } = i.legend.options;\n            return t.labels.map((s, n) => {\n              const r = i.getDatasetMeta(0).controller.getStyle(n);\n              return {\n                text: s,\n                fillStyle: r.backgroundColor,\n                strokeStyle: r.borderColor,\n                lineWidth: r.borderWidth,\n                pointStyle: e,\n                hidden: !i.getDataVisibility(n),\n                index: n\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(i, t, e) {\n        e.chart.toggleDataVisibility(t.index), e.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return \"\";\n        },\n        label(i) {\n          return i.chart.data.labels[i.dataIndex] + \": \" + i.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: \"radialLinear\",\n      angleLines: {\n        display: !1\n      },\n      beginAtZero: !0,\n      grid: {\n        circular: !0\n      },\n      pointLabels: {\n        display: !1\n      },\n      startAngle: 0\n    }\n  }\n};\nclass qe extends Lt {\n}\nqe.id = \"pie\";\nqe.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\"\n};\nclass me extends it {\n  getLabelAndValue(t) {\n    const e = this._cachedMeta.vScale, s = this.getParsed(t);\n    return {\n      label: e.getLabels()[t],\n      value: \"\" + e.getLabelForValue(s[e.axis])\n    };\n  }\n  parseObjectData(t, e, s, n) {\n    return Dn.bind(this)(t, e, s, n);\n  }\n  update(t) {\n    const e = this._cachedMeta, s = e.dataset, n = e.data || [], o = e.iScale.getLabels();\n    if (s.points = n, t !== \"resize\") {\n      const r = this.resolveDatasetElementOptions(t);\n      this.options.showLine || (r.borderWidth = 0);\n      const a = {\n        _loop: !0,\n        _fullLoop: o.length === n.length,\n        options: r\n      };\n      this.updateElement(s, void 0, a, t);\n    }\n    this.updateElements(n, 0, n.length, t);\n  }\n  updateElements(t, e, s, n) {\n    const o = this._cachedMeta.rScale, r = n === \"reset\";\n    for (let a = e; a < e + s; a++) {\n      const l = t[a], c = this.resolveDataElementOptions(a, l.active ? \"active\" : n), h = o.getPointPositionForValue(a, this.getParsed(a).r), d = r ? o.xCenter : h.x, u = r ? o.yCenter : h.y, f = {\n        x: d,\n        y: u,\n        angle: h.angle,\n        skip: isNaN(d) || isNaN(u),\n        options: c\n      };\n      this.updateElement(l, a, f, n);\n    }\n  }\n}\nme.id = \"radar\";\nme.defaults = {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  indexAxis: \"r\",\n  showLine: !0,\n  elements: {\n    line: {\n      fill: \"start\"\n    }\n  }\n};\nme.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: \"radialLinear\"\n    }\n  }\n};\nclass st {\n  constructor() {\n    this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;\n  }\n  tooltipPosition(t) {\n    const { x: e, y: s } = this.getProps([\"x\", \"y\"], t);\n    return { x: e, y: s };\n  }\n  hasValue() {\n    return Bt(this.x) && Bt(this.y);\n  }\n  getProps(t, e) {\n    const s = this.$animations;\n    if (!e || !s)\n      return this;\n    const n = {};\n    return t.forEach((o) => {\n      n[o] = s[o] && s[o].active() ? s[o]._to : this[o];\n    }), n;\n  }\n}\nst.defaults = {};\nst.defaultRoutes = void 0;\nconst Vn = {\n  values(i) {\n    return z(i) ? i : \"\" + i;\n  },\n  numeric(i, t, e) {\n    if (i === 0)\n      return \"0\";\n    const s = this.chart.options.locale;\n    let n, o = i;\n    if (e.length > 1) {\n      const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));\n      (c < 1e-4 || c > 1e15) && (n = \"scientific\"), o = wa(i, e);\n    }\n    const r = tt(Math.abs(o)), a = Math.max(Math.min(-1 * Math.floor(r), 20), 0), l = { notation: n, minimumFractionDigits: a, maximumFractionDigits: a };\n    return Object.assign(l, this.options.ticks.format), de(i, s, l);\n  },\n  logarithmic(i, t, e) {\n    if (i === 0)\n      return \"0\";\n    const s = i / Math.pow(10, Math.floor(tt(i)));\n    return s === 1 || s === 2 || s === 5 ? Vn.numeric.call(this, i, t, e) : \"\";\n  }\n};\nfunction wa(i, t) {\n  let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;\n  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;\n}\nvar be = { formatters: Vn };\nO.set(\"scale\", {\n  display: !0,\n  offset: !1,\n  reverse: !1,\n  beginAtZero: !1,\n  bounds: \"ticks\",\n  grace: 0,\n  grid: {\n    display: !0,\n    lineWidth: 1,\n    drawBorder: !0,\n    drawOnChartArea: !0,\n    drawTicks: !0,\n    tickLength: 8,\n    tickWidth: (i, t) => t.lineWidth,\n    tickColor: (i, t) => t.color,\n    offset: !1,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderWidth: 1\n  },\n  title: {\n    display: !1,\n    text: \"\",\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: !1,\n    textStrokeWidth: 0,\n    textStrokeColor: \"\",\n    padding: 3,\n    display: !0,\n    autoSkip: !0,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: be.formatters.values,\n    minor: {},\n    major: {},\n    align: \"center\",\n    crossAlign: \"near\",\n    showLabelBackdrop: !1,\n    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n    backdropPadding: 2\n  }\n});\nO.route(\"scale.ticks\", \"color\", \"\", \"color\");\nO.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\nO.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\");\nO.route(\"scale.title\", \"color\", \"\", \"color\");\nO.describe(\"scale\", {\n  _fallback: !1,\n  _scriptable: (i) => !i.startsWith(\"before\") && !i.startsWith(\"after\") && i !== \"callback\" && i !== \"parser\",\n  _indexable: (i) => i !== \"borderDash\" && i !== \"tickBorderDash\"\n});\nO.describe(\"scales\", {\n  _fallback: \"scale\"\n});\nO.describe(\"scale.ticks\", {\n  _scriptable: (i) => i !== \"backdropPadding\" && i !== \"callback\",\n  _indexable: (i) => i !== \"backdropPadding\"\n});\nfunction Sa(i, t) {\n  const e = i.options.ticks, s = e.maxTicksLimit || Pa(i), n = e.major.enabled ? Da(t) : [], o = n.length, r = n[0], a = n[o - 1], l = [];\n  if (o > s)\n    return Oa(t, l, n, o / s), l;\n  const c = Ca(n, t, s);\n  if (o > 0) {\n    let h, d;\n    const u = o > 1 ? Math.round((a - r) / (o - 1)) : null;\n    for (Oe(t, l, c, T(u) ? 0 : r - u, r), h = 0, d = o - 1; h < d; h++)\n      Oe(t, l, c, n[h], n[h + 1]);\n    return Oe(t, l, c, a, T(u) ? t.length : a + u), l;\n  }\n  return Oe(t, l, c), l;\n}\nfunction Pa(i) {\n  const t = i.options.offset, e = i._tickSize(), s = i._length / e + (t ? 0 : 1), n = i._maxLength / e;\n  return Math.floor(Math.min(s, n));\n}\nfunction Ca(i, t, e) {\n  const s = Aa(i), n = t.length / e;\n  if (!s)\n    return Math.max(n, 1);\n  const o = Do(s);\n  for (let r = 0, a = o.length - 1; r < a; r++) {\n    const l = o[r];\n    if (l > n)\n      return l;\n  }\n  return Math.max(n, 1);\n}\nfunction Da(i) {\n  const t = [];\n  let e, s;\n  for (e = 0, s = i.length; e < s; e++)\n    i[e].major && t.push(e);\n  return t;\n}\nfunction Oa(i, t, e, s) {\n  let n = 0, o = e[0], r;\n  for (s = Math.ceil(s), r = 0; r < i.length; r++)\n    r === o && (t.push(i[r]), n++, o = e[n * s]);\n}\nfunction Oe(i, t, e, s, n) {\n  const o = C(s, 0), r = Math.min(C(n, i.length), i.length);\n  let a = 0, l, c, h;\n  for (e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0; )\n    a++, h = Math.round(o + a * e);\n  for (c = Math.max(o, 0); c < r; c++)\n    c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));\n}\nfunction Aa(i) {\n  const t = i.length;\n  let e, s;\n  if (t < 2)\n    return !1;\n  for (s = i[0], e = 1; e < t; ++e)\n    if (i[e] - i[e - 1] !== s)\n      return !1;\n  return s;\n}\nconst Ta = (i) => i === \"left\" ? \"right\" : i === \"right\" ? \"left\" : i, ws = (i, t, e) => t === \"top\" || t === \"left\" ? i[t] + e : i[t] - e;\nfunction Ss(i, t) {\n  const e = [], s = i.length / t, n = i.length;\n  let o = 0;\n  for (; o < n; o += s)\n    e.push(i[Math.floor(o)]);\n  return e;\n}\nfunction La(i, t, e) {\n  const s = i.ticks.length, n = Math.min(t, s - 1), o = i._startPixel, r = i._endPixel, a = 1e-6;\n  let l = i.getPixelForTick(n), c;\n  if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a)))\n    return l;\n}\nfunction Ra(i, t) {\n  E(i, (e) => {\n    const s = e.gc, n = s.length / 2;\n    let o;\n    if (n > t) {\n      for (o = 0; o < n; ++o)\n        delete e.data[s[o]];\n      s.splice(0, n);\n    }\n  });\n}\nfunction Xt(i) {\n  return i.drawTicks ? i.tickLength : 0;\n}\nfunction Ps(i, t) {\n  if (!i.display)\n    return 0;\n  const e = $(i.font, t), s = K(i.padding);\n  return (z(i.text) ? i.text.length : 1) * e.lineHeight + s.height;\n}\nfunction Ea(i, t) {\n  return vt(i, {\n    scale: t,\n    type: \"scale\"\n  });\n}\nfunction Fa(i, t, e) {\n  return vt(i, {\n    tick: e,\n    index: t,\n    type: \"tick\"\n  });\n}\nfunction Ia(i, t, e) {\n  let s = Li(i);\n  return (e && t !== \"right\" || !e && t === \"right\") && (s = Ta(s)), s;\n}\nfunction za(i, t, e, s) {\n  const { top: n, left: o, bottom: r, right: a, chart: l } = i, { chartArea: c, scales: h } = l;\n  let d = 0, u, f, g;\n  const p = r - n, m = a - o;\n  if (i.isHorizontal()) {\n    if (f = U(s, o, a), D(e)) {\n      const b = Object.keys(e)[0], x = e[b];\n      g = h[b].getPixelForValue(x) + p - t;\n    } else\n      e === \"center\" ? g = (c.bottom + c.top) / 2 + p - t : g = ws(i, e, t);\n    u = a - o;\n  } else {\n    if (D(e)) {\n      const b = Object.keys(e)[0], x = e[b];\n      f = h[b].getPixelForValue(x) - m + t;\n    } else\n      e === \"center\" ? f = (c.left + c.right) / 2 - m + t : f = ws(i, e, t);\n    g = U(s, r, n), d = e === \"left\" ? -V : V;\n  }\n  return { titleX: f, titleY: g, maxWidth: u, rotation: d };\n}\nclass Mt extends st {\n  constructor(t) {\n    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n  }\n  init(t) {\n    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n  }\n  parse(t, e) {\n    return t;\n  }\n  getUserBounds() {\n    let { _userMin: t, _userMax: e, _suggestedMin: s, _suggestedMax: n } = this;\n    return t = Q(t, Number.POSITIVE_INFINITY), e = Q(e, Number.NEGATIVE_INFINITY), s = Q(s, Number.POSITIVE_INFINITY), n = Q(n, Number.NEGATIVE_INFINITY), {\n      min: Q(t, s),\n      max: Q(e, n),\n      minDefined: N(t),\n      maxDefined: N(e)\n    };\n  }\n  getMinMax(t) {\n    let { min: e, max: s, minDefined: n, maxDefined: o } = this.getUserBounds(), r;\n    if (n && o)\n      return { min: e, max: s };\n    const a = this.getMatchingVisibleMetas();\n    for (let l = 0, c = a.length; l < c; ++l)\n      r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));\n    return e = o && e > s ? s : e, s = n && e > s ? e : s, {\n      min: Q(e, Q(s, e)),\n      max: Q(s, Q(e, s))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const t = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {}, this._dataLimitsCached = !1;\n  }\n  beforeUpdate() {\n    I(this.options.beforeUpdate, [this]);\n  }\n  update(t, e, s) {\n    const { beginAtZero: n, grace: o, ticks: r } = this.options, a = r.sampleSize;\n    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = mr(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n    const l = a < this.ticks.length;\n    this._convertTicksToLabels(l ? Ss(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === \"auto\") && (this.ticks = Sa(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n  }\n  configure() {\n    let t = this.options.reverse, e, s;\n    this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    I(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    I(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    I(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(t) {\n    this.chart.notifyPlugins(t, this.getContext()), I(this.options[t], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks(\"beforeDataLimits\");\n  }\n  determineDataLimits() {\n  }\n  afterDataLimits() {\n    this._callHooks(\"afterDataLimits\");\n  }\n  beforeBuildTicks() {\n    this._callHooks(\"beforeBuildTicks\");\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks(\"afterBuildTicks\");\n  }\n  beforeTickToLabelConversion() {\n    I(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(t) {\n    const e = this.options.ticks;\n    let s, n, o;\n    for (s = 0, n = t.length; s < n; s++)\n      o = t[s], o.label = I(e.callback, [o.value, s, t], this);\n  }\n  afterTickToLabelConversion() {\n    I(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    I(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const t = this.options, e = t.ticks, s = this.ticks.length, n = e.minRotation || 0, o = e.maxRotation;\n    let r = n, a, l, c;\n    if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {\n      this.labelRotation = n;\n      return;\n    }\n    const h = this._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = Y(this.chart.width - d, 0, this.maxWidth);\n    a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - Xt(t.grid) - e.padding - Ps(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Ai(Math.min(\n      Math.asin(Y((h.highest.height + 6) / a, -1, 1)),\n      Math.asin(Y(l / c, -1, 1)) - Math.asin(Y(u / c, -1, 1))\n    )), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;\n  }\n  afterCalculateLabelRotation() {\n    I(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {\n  }\n  beforeFit() {\n    I(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const t = {\n      width: 0,\n      height: 0\n    }, { chart: e, options: { ticks: s, title: n, grid: o } } = this, r = this._isVisible(), a = this.isHorizontal();\n    if (r) {\n      const l = Ps(n, e.options.font);\n      if (a ? (t.width = this.maxWidth, t.height = Xt(o) + l) : (t.height = this.maxHeight, t.width = Xt(o) + l), s.display && this.ticks.length) {\n        const { first: c, last: h, widest: d, highest: u } = this._getLabelSizes(), f = s.padding * 2, g = nt(this.labelRotation), p = Math.cos(g), m = Math.sin(g);\n        if (a) {\n          const b = s.mirror ? 0 : m * d.width + p * u.height;\n          t.height = Math.min(this.maxHeight, t.height + b + f);\n        } else {\n          const b = s.mirror ? 0 : p * d.width + m * u.height;\n          t.width = Math.min(this.maxWidth, t.width + b + f);\n        }\n        this._calculatePadding(c, h, m, p);\n      }\n    }\n    this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n  }\n  _calculatePadding(t, e, s, n) {\n    const { ticks: { align: o, padding: r }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== \"top\" && this.axis === \"x\";\n    if (this.isHorizontal()) {\n      const h = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let u = 0, f = 0;\n      l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === \"start\" ? f = e.width : o === \"end\" ? u = t.width : o !== \"inner\" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);\n    } else {\n      let h = e.height / 2, d = t.height / 2;\n      o === \"start\" ? (h = 0, d = t.height) : o === \"end\" && (h = e.height, d = 0), this.paddingTop = h + r, this.paddingBottom = d + r;\n    }\n  }\n  _handleMargins() {\n    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n  }\n  afterFit() {\n    I(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const { axis: t, position: e } = this.options;\n    return e === \"top\" || e === \"bottom\" || t === \"x\";\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(t) {\n    this.beforeTickToLabelConversion(), this.generateTickLabels(t);\n    let e, s;\n    for (e = 0, s = t.length; e < s; e++)\n      T(t[e].label) && (t.splice(e, 1), s--, e--);\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let t = this._labelSizes;\n    if (!t) {\n      const e = this.options.ticks.sampleSize;\n      let s = this.ticks;\n      e < s.length && (s = Ss(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length);\n    }\n    return t;\n  }\n  _computeLabelSizes(t, e) {\n    const { ctx: s, _longestTextCache: n } = this, o = [], r = [];\n    let a = 0, l = 0, c, h, d, u, f, g, p, m, b, x, v;\n    for (c = 0; c < e; ++c) {\n      if (u = t[c].label, f = this._resolveTickFontOptions(c), s.font = g = f.string, p = n[g] = n[g] || { data: {}, gc: [] }, m = f.lineHeight, b = x = 0, !T(u) && !z(u))\n        b = Ne(s, p.data, p.gc, b, u), x = m;\n      else if (z(u))\n        for (h = 0, d = u.length; h < d; ++h)\n          v = u[h], !T(v) && !z(v) && (b = Ne(s, p.data, p.gc, b, v), x += m);\n      o.push(b), r.push(x), a = Math.max(b, a), l = Math.max(x, l);\n    }\n    Ra(n, e);\n    const y = o.indexOf(a), _ = r.indexOf(l), M = (k) => ({ width: o[k] || 0, height: r[k] || 0 });\n    return {\n      first: M(0),\n      last: M(e - 1),\n      widest: M(y),\n      highest: M(_),\n      widths: o,\n      heights: r\n    };\n  }\n  getLabelForValue(t) {\n    return t;\n  }\n  getPixelForValue(t, e) {\n    return NaN;\n  }\n  getValueForPixel(t) {\n  }\n  getPixelForTick(t) {\n    const e = this.ticks;\n    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n  }\n  getPixelForDecimal(t) {\n    this._reversePixels && (t = 1 - t);\n    const e = this._startPixel + t * this._length;\n    return To(this._alignToPixels ? wt(this.chart, e, 0) : e);\n  }\n  getDecimalForPixel(t) {\n    const e = (t - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - e : e;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const { min: t, max: e } = this;\n    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n  }\n  getContext(t) {\n    const e = this.ticks || [];\n    if (t >= 0 && t < e.length) {\n      const s = e[t];\n      return s.$context || (s.$context = Fa(this.getContext(), t, s));\n    }\n    return this.$context || (this.$context = Ea(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const t = this.options.ticks, e = nt(this.labelRotation), s = Math.abs(Math.cos(e)), n = Math.abs(Math.sin(e)), o = this._getLabelSizes(), r = t.autoSkipPadding || 0, a = o ? o.widest.width + r : 0, l = o ? o.highest.height + r : 0;\n    return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;\n  }\n  _isVisible() {\n    const t = this.options.display;\n    return t !== \"auto\" ? !!t : this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(t) {\n    const e = this.axis, s = this.chart, n = this.options, { grid: o, position: r } = n, a = o.offset, l = this.isHorizontal(), h = this.ticks.length + (a ? 1 : 0), d = Xt(o), u = [], f = o.setContext(this.getContext()), g = f.drawBorder ? f.borderWidth : 0, p = g / 2, m = function(P) {\n      return wt(s, P, g);\n    };\n    let b, x, v, y, _, M, k, S, w, L, R, A;\n    if (r === \"top\")\n      b = m(this.bottom), M = this.bottom - d, S = b - p, L = m(t.top) + p, A = t.bottom;\n    else if (r === \"bottom\")\n      b = m(this.top), L = t.top, A = m(t.bottom) - p, M = b + p, S = this.top + d;\n    else if (r === \"left\")\n      b = m(this.right), _ = this.right - d, k = b - p, w = m(t.left) + p, R = t.right;\n    else if (r === \"right\")\n      b = m(this.left), w = t.left, R = m(t.right) - p, _ = b + p, k = this.left + d;\n    else if (e === \"x\") {\n      if (r === \"center\")\n        b = m((t.top + t.bottom) / 2 + 0.5);\n      else if (D(r)) {\n        const P = Object.keys(r)[0], j = r[P];\n        b = m(this.chart.scales[P].getPixelForValue(j));\n      }\n      L = t.top, A = t.bottom, M = b + p, S = M + d;\n    } else if (e === \"y\") {\n      if (r === \"center\")\n        b = m((t.left + t.right) / 2);\n      else if (D(r)) {\n        const P = Object.keys(r)[0], j = r[P];\n        b = m(this.chart.scales[P].getPixelForValue(j));\n      }\n      _ = b - p, k = _ - d, w = t.left, R = t.right;\n    }\n    const H = C(n.ticks.maxTicksLimit, h), q = Math.max(1, Math.ceil(h / H));\n    for (x = 0; x < h; x += q) {\n      const P = o.setContext(this.getContext(x)), j = P.lineWidth, W = P.color, kt = P.borderDash || [], ti = P.borderDashOffset, Rt = P.tickWidth, ke = P.tickColor, Et = P.tickBorderDash || [], jt = P.tickBorderDashOffset;\n      v = La(this, x, a), v !== void 0 && (y = wt(s, v, j), l ? _ = k = w = R = y : M = S = L = A = y, u.push({\n        tx1: _,\n        ty1: M,\n        tx2: k,\n        ty2: S,\n        x1: w,\n        y1: L,\n        x2: R,\n        y2: A,\n        width: j,\n        color: W,\n        borderDash: kt,\n        borderDashOffset: ti,\n        tickWidth: Rt,\n        tickColor: ke,\n        tickBorderDash: Et,\n        tickBorderDashOffset: jt\n      }));\n    }\n    return this._ticksLength = h, this._borderValue = b, u;\n  }\n  _computeLabelItems(t) {\n    const e = this.axis, s = this.options, { position: n, ticks: o } = s, r = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = o, u = Xt(s.grid), f = u + h, g = d ? -h : f, p = -nt(this.labelRotation), m = [];\n    let b, x, v, y, _, M, k, S, w, L, R, A, H = \"middle\";\n    if (n === \"top\")\n      M = this.bottom - g, k = this._getXAxisLabelAlignment();\n    else if (n === \"bottom\")\n      M = this.top + g, k = this._getXAxisLabelAlignment();\n    else if (n === \"left\") {\n      const P = this._getYAxisLabelAlignment(u);\n      k = P.textAlign, _ = P.x;\n    } else if (n === \"right\") {\n      const P = this._getYAxisLabelAlignment(u);\n      k = P.textAlign, _ = P.x;\n    } else if (e === \"x\") {\n      if (n === \"center\")\n        M = (t.top + t.bottom) / 2 + f;\n      else if (D(n)) {\n        const P = Object.keys(n)[0], j = n[P];\n        M = this.chart.scales[P].getPixelForValue(j) + f;\n      }\n      k = this._getXAxisLabelAlignment();\n    } else if (e === \"y\") {\n      if (n === \"center\")\n        _ = (t.left + t.right) / 2 - f;\n      else if (D(n)) {\n        const P = Object.keys(n)[0], j = n[P];\n        _ = this.chart.scales[P].getPixelForValue(j);\n      }\n      k = this._getYAxisLabelAlignment(u).textAlign;\n    }\n    e === \"y\" && (l === \"start\" ? H = \"top\" : l === \"end\" && (H = \"bottom\"));\n    const q = this._getLabelSizes();\n    for (b = 0, x = a.length; b < x; ++b) {\n      v = a[b], y = v.label;\n      const P = o.setContext(this.getContext(b));\n      S = this.getPixelForTick(b) + o.labelOffset, w = this._resolveTickFontOptions(b), L = w.lineHeight, R = z(y) ? y.length : 1;\n      const j = R / 2, W = P.color, kt = P.textStrokeColor, ti = P.textStrokeWidth;\n      let Rt = k;\n      r ? (_ = S, k === \"inner\" && (b === x - 1 ? Rt = this.options.reverse ? \"left\" : \"right\" : b === 0 ? Rt = this.options.reverse ? \"right\" : \"left\" : Rt = \"center\"), n === \"top\" ? c === \"near\" || p !== 0 ? A = -R * L + L / 2 : c === \"center\" ? A = -q.highest.height / 2 - j * L + L : A = -q.highest.height + L / 2 : c === \"near\" || p !== 0 ? A = L / 2 : c === \"center\" ? A = q.highest.height / 2 - j * L : A = q.highest.height - R * L, d && (A *= -1)) : (M = S, A = (1 - R) * L / 2);\n      let ke;\n      if (P.showLabelBackdrop) {\n        const Et = K(P.backdropPadding), jt = q.heights[b], ei = q.widths[b];\n        let ii = M + A - Et.top, si = _ - Et.left;\n        switch (H) {\n          case \"middle\":\n            ii -= jt / 2;\n            break;\n          case \"bottom\":\n            ii -= jt;\n            break;\n        }\n        switch (k) {\n          case \"center\":\n            si -= ei / 2;\n            break;\n          case \"right\":\n            si -= ei;\n            break;\n        }\n        ke = {\n          left: si,\n          top: ii,\n          width: ei + Et.width,\n          height: jt + Et.height,\n          color: P.backdropColor\n        };\n      }\n      m.push({\n        rotation: p,\n        label: y,\n        font: w,\n        color: W,\n        strokeColor: kt,\n        strokeWidth: ti,\n        textOffset: A,\n        textAlign: Rt,\n        textBaseline: H,\n        translation: [_, M],\n        backdrop: ke\n      });\n    }\n    return m;\n  }\n  _getXAxisLabelAlignment() {\n    const { position: t, ticks: e } = this.options;\n    if (-nt(this.labelRotation))\n      return t === \"top\" ? \"left\" : \"right\";\n    let n = \"center\";\n    return e.align === \"start\" ? n = \"left\" : e.align === \"end\" ? n = \"right\" : e.align === \"inner\" && (n = \"inner\"), n;\n  }\n  _getYAxisLabelAlignment(t) {\n    const { position: e, ticks: { crossAlign: s, mirror: n, padding: o } } = this.options, r = this._getLabelSizes(), a = t + o, l = r.widest.width;\n    let c, h;\n    return e === \"left\" ? n ? (h = this.right + o, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h += l)) : (h = this.right - a, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h = this.left)) : e === \"right\" ? n ? (h = this.left + o, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h -= l)) : (h = this.left + a, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h = this.right)) : c = \"right\", { textAlign: c, x: h };\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror)\n      return;\n    const t = this.chart, e = this.options.position;\n    if (e === \"left\" || e === \"right\")\n      return { top: 0, left: this.left, bottom: t.height, right: this.right };\n    if (e === \"top\" || e === \"bottom\")\n      return { top: this.top, left: 0, bottom: this.bottom, right: t.width };\n  }\n  drawBackground() {\n    const { ctx: t, options: { backgroundColor: e }, left: s, top: n, width: o, height: r } = this;\n    e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());\n  }\n  getLineWidthForValue(t) {\n    const e = this.options.grid;\n    if (!this._isVisible() || !e.display)\n      return 0;\n    const n = this.ticks.findIndex((o) => o.value === t);\n    return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;\n  }\n  drawGrid(t) {\n    const e = this.options.grid, s = this.ctx, n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n    let o, r;\n    const a = (l, c, h) => {\n      !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());\n    };\n    if (e.display)\n      for (o = 0, r = n.length; o < r; ++o) {\n        const l = n[o];\n        e.drawOnChartArea && a(\n          { x: l.x1, y: l.y1 },\n          { x: l.x2, y: l.y2 },\n          l\n        ), e.drawTicks && a(\n          { x: l.tx1, y: l.ty1 },\n          { x: l.tx2, y: l.ty2 },\n          {\n            color: l.tickColor,\n            width: l.tickWidth,\n            borderDash: l.tickBorderDash,\n            borderDashOffset: l.tickBorderDashOffset\n          }\n        );\n      }\n  }\n  drawBorder() {\n    const { chart: t, ctx: e, options: { grid: s } } = this, n = s.setContext(this.getContext()), o = s.drawBorder ? n.borderWidth : 0;\n    if (!o)\n      return;\n    const r = s.setContext(this.getContext(0)).lineWidth, a = this._borderValue;\n    let l, c, h, d;\n    this.isHorizontal() ? (l = wt(t, this.left, o) - o / 2, c = wt(t, this.right, r) + r / 2, h = d = a) : (h = wt(t, this.top, o) - o / 2, d = wt(t, this.bottom, r) + r / 2, l = c = a), e.save(), e.lineWidth = n.borderWidth, e.strokeStyle = n.borderColor, e.beginPath(), e.moveTo(l, h), e.lineTo(c, d), e.stroke(), e.restore();\n  }\n  drawLabels(t) {\n    if (!this.options.ticks.display)\n      return;\n    const s = this.ctx, n = this._computeLabelArea();\n    n && Xe(s, n);\n    const o = this._labelItems || (this._labelItems = this._computeLabelItems(t));\n    let r, a;\n    for (r = 0, a = o.length; r < a; ++r) {\n      const l = o[r], c = l.font, h = l.label;\n      l.backdrop && (s.fillStyle = l.backdrop.color, s.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height));\n      let d = l.textOffset;\n      Tt(s, h, 0, d, c, l);\n    }\n    n && Ue(s);\n  }\n  drawTitle() {\n    const { ctx: t, options: { position: e, title: s, reverse: n } } = this;\n    if (!s.display)\n      return;\n    const o = $(s.font), r = K(s.padding), a = s.align;\n    let l = o.lineHeight / 2;\n    e === \"bottom\" || e === \"center\" || D(e) ? (l += r.bottom, z(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;\n    const { titleX: c, titleY: h, maxWidth: d, rotation: u } = za(this, l, e, a);\n    Tt(t, s.text, 0, 0, o, {\n      color: s.color,\n      maxWidth: d,\n      rotation: u,\n      textAlign: Ia(a, e, n),\n      textBaseline: \"middle\",\n      translation: [c, h]\n    });\n  }\n  draw(t) {\n    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n  }\n  _layers() {\n    const t = this.options, e = t.ticks && t.ticks.z || 0, s = C(t.grid && t.grid.z, -1);\n    return !this._isVisible() || this.draw !== Mt.prototype.draw ? [{\n      z: e,\n      draw: (n) => {\n        this.draw(n);\n      }\n    }] : [{\n      z: s,\n      draw: (n) => {\n        this.drawBackground(), this.drawGrid(n), this.drawTitle();\n      }\n    }, {\n      z: s + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: e,\n      draw: (n) => {\n        this.drawLabels(n);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(t) {\n    const e = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + \"AxisID\", n = [];\n    let o, r;\n    for (o = 0, r = e.length; o < r; ++o) {\n      const a = e[o];\n      a[s] === this.id && (!t || a.type === t) && n.push(a);\n    }\n    return n;\n  }\n  _resolveTickFontOptions(t) {\n    const e = this.options.ticks.setContext(this.getContext(t));\n    return $(e.font);\n  }\n  _maxDigits() {\n    const t = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / t;\n  }\n}\nclass Ae {\n  constructor(t, e, s) {\n    this.type = t, this.scope = e, this.override = s, this.items = /* @__PURE__ */ Object.create(null);\n  }\n  isForType(t) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n  }\n  register(t) {\n    const e = Object.getPrototypeOf(t);\n    let s;\n    Wa(e) && (s = this.register(e));\n    const n = this.items, o = t.id, r = this.scope + \".\" + o;\n    if (!o)\n      throw new Error(\"class does not have id: \" + t);\n    return o in n || (n[o] = t, Ba(t, r, s), this.override && O.override(t.id, t.overrides)), r;\n  }\n  get(t) {\n    return this.items[t];\n  }\n  unregister(t) {\n    const e = this.items, s = t.id, n = this.scope;\n    s in e && delete e[s], n && s in O[n] && (delete O[n][s], this.override && delete At[s]);\n  }\n}\nfunction Ba(i, t, e) {\n  const s = ne(/* @__PURE__ */ Object.create(null), [\n    e ? O.get(e) : {},\n    O.get(t),\n    i.defaults\n  ]);\n  O.set(t, s), i.defaultRoutes && Va(t, i.defaultRoutes), i.descriptors && O.describe(t, i.descriptors);\n}\nfunction Va(i, t) {\n  Object.keys(t).forEach((e) => {\n    const s = e.split(\".\"), n = s.pop(), o = [i].concat(s).join(\".\"), r = t[e].split(\".\"), a = r.pop(), l = r.join(\".\");\n    O.route(o, n, l, a);\n  });\n}\nfunction Wa(i) {\n  return \"id\" in i && \"defaults\" in i;\n}\nclass Na {\n  constructor() {\n    this.controllers = new Ae(it, \"datasets\", !0), this.elements = new Ae(st, \"elements\"), this.plugins = new Ae(Object, \"plugins\"), this.scales = new Ae(Mt, \"scales\"), this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...t) {\n    this._each(\"register\", t);\n  }\n  remove(...t) {\n    this._each(\"unregister\", t);\n  }\n  addControllers(...t) {\n    this._each(\"register\", t, this.controllers);\n  }\n  addElements(...t) {\n    this._each(\"register\", t, this.elements);\n  }\n  addPlugins(...t) {\n    this._each(\"register\", t, this.plugins);\n  }\n  addScales(...t) {\n    this._each(\"register\", t, this.scales);\n  }\n  getController(t) {\n    return this._get(t, this.controllers, \"controller\");\n  }\n  getElement(t) {\n    return this._get(t, this.elements, \"element\");\n  }\n  getPlugin(t) {\n    return this._get(t, this.plugins, \"plugin\");\n  }\n  getScale(t) {\n    return this._get(t, this.scales, \"scale\");\n  }\n  removeControllers(...t) {\n    this._each(\"unregister\", t, this.controllers);\n  }\n  removeElements(...t) {\n    this._each(\"unregister\", t, this.elements);\n  }\n  removePlugins(...t) {\n    this._each(\"unregister\", t, this.plugins);\n  }\n  removeScales(...t) {\n    this._each(\"unregister\", t, this.scales);\n  }\n  _each(t, e, s) {\n    [...e].forEach((n) => {\n      const o = s || this._getRegistryForType(n);\n      s || o.isForType(n) || o === this.plugins && n.id ? this._exec(t, o, n) : E(n, (r) => {\n        const a = s || this._getRegistryForType(r);\n        this._exec(t, a, r);\n      });\n    });\n  }\n  _exec(t, e, s) {\n    const n = Oi(t);\n    I(s[\"before\" + n], [], s), e[t](s), I(s[\"after\" + n], [], s);\n  }\n  _getRegistryForType(t) {\n    for (let e = 0; e < this._typedRegistries.length; e++) {\n      const s = this._typedRegistries[e];\n      if (s.isForType(t))\n        return s;\n    }\n    return this.plugins;\n  }\n  _get(t, e, s) {\n    const n = e.get(t);\n    if (n === void 0)\n      throw new Error('\"' + t + '\" is not a registered ' + s + \".\");\n    return n;\n  }\n}\nvar ot = new Na();\nclass xe extends it {\n  update(t) {\n    const e = this._cachedMeta, { data: s = [] } = e, n = this.chart._animationsDisabled;\n    let { start: o, count: r } = pn(e, s, n);\n    if (this._drawStart = o, this._drawCount = r, mn(e) && (o = 0, r = s.length), this.options.showLine) {\n      const { dataset: a, _dataset: l } = e;\n      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;\n      const c = this.resolveDatasetElementOptions(t);\n      c.segment = this.options.segment, this.updateElement(a, void 0, {\n        animated: !n,\n        options: c\n      }, t);\n    }\n    this.updateElements(s, o, r, t);\n  }\n  addElements() {\n    const { showLine: t } = this.options;\n    !this.datasetElementType && t && (this.datasetElementType = ot.getElement(\"line\")), super.addElements();\n  }\n  updateElements(t, e, s, n) {\n    const o = n === \"reset\", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(h), u = this.includeOptions(n, d), f = r.axis, g = a.axis, { spanGaps: p, segment: m } = this.options, b = Bt(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || n === \"none\";\n    let v = e > 0 && this.getParsed(e - 1);\n    for (let y = e; y < e + s; ++y) {\n      const _ = t[y], M = this.getParsed(y), k = x ? _ : {}, S = T(M[g]), w = k[f] = r.getPixelForValue(M[f], y), L = k[g] = o || S ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[g], y);\n      k.skip = isNaN(w) || isNaN(L) || S, k.stop = y > 0 && Math.abs(M[f] - v[f]) > b, m && (k.parsed = M, k.raw = c.data[y]), u && (k.options = d || this.resolveDataElementOptions(y, _.active ? \"active\" : n)), x || this.updateElement(_, y, k, n), v = M;\n    }\n    this.updateSharedOptions(d, n, h);\n  }\n  getMaxOverflow() {\n    const t = this._cachedMeta, e = t.data || [];\n    if (!this.options.showLine) {\n      let a = 0;\n      for (let l = e.length - 1; l >= 0; --l)\n        a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);\n      return a > 0 && a;\n    }\n    const s = t.dataset, n = s.options && s.options.borderWidth || 0;\n    if (!e.length)\n      return n;\n    const o = e[0].size(this.resolveDataElementOptions(0)), r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n    return Math.max(n, o, r) / 2;\n  }\n}\nxe.id = \"scatter\";\nxe.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  showLine: !1,\n  fill: !1\n};\nxe.overrides = {\n  interaction: {\n    mode: \"point\"\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return \"\";\n        },\n        label(i) {\n          return \"(\" + i.label + \", \" + i.formattedValue + \")\";\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  }\n};\nvar Wn = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  BarController: ue,\n  BubbleController: fe,\n  DoughnutController: Lt,\n  LineController: ge,\n  PolarAreaController: pe,\n  PieController: qe,\n  RadarController: me,\n  ScatterController: xe\n});\nfunction St() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nclass vi {\n  constructor(t) {\n    this.options = t || {};\n  }\n  init(t) {\n  }\n  formats() {\n    return St();\n  }\n  parse(t, e) {\n    return St();\n  }\n  format(t, e) {\n    return St();\n  }\n  add(t, e, s) {\n    return St();\n  }\n  diff(t, e, s) {\n    return St();\n  }\n  startOf(t, e, s) {\n    return St();\n  }\n  endOf(t, e) {\n    return St();\n  }\n}\nvi.override = function(i) {\n  Object.assign(vi.prototype, i);\n};\nvar Nn = {\n  _date: vi\n};\nfunction Ha(i, t, e, s) {\n  const { controller: n, data: o, _sorted: r } = i, a = n._cachedMeta.iScale;\n  if (a && t === a.axis && t !== \"r\" && r && o.length) {\n    const l = a._reversePixels ? Lo : ft;\n    if (s) {\n      if (n._sharedOptions) {\n        const c = o[0], h = typeof c.getRange == \"function\" && c.getRange(t);\n        if (h) {\n          const d = l(o, t, e - h), u = l(o, t, e + h);\n          return { lo: d.lo, hi: u.hi };\n        }\n      }\n    } else\n      return l(o, t, e);\n  }\n  return { lo: 0, hi: o.length - 1 };\n}\nfunction _e(i, t, e, s, n) {\n  const o = i.getSortedVisibleDatasetMetas(), r = e[t];\n  for (let a = 0, l = o.length; a < l; ++a) {\n    const { index: c, data: h } = o[a], { lo: d, hi: u } = Ha(o[a], t, r, n);\n    for (let f = d; f <= u; ++f) {\n      const g = h[f];\n      g.skip || s(g, c, f);\n    }\n  }\n}\nfunction ja(i) {\n  const t = i.indexOf(\"x\") !== -1, e = i.indexOf(\"y\") !== -1;\n  return function(s, n) {\n    const o = t ? Math.abs(s.x - n.x) : 0, r = e ? Math.abs(s.y - n.y) : 0;\n    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n  };\n}\nfunction di(i, t, e, s, n) {\n  const o = [];\n  return !n && !i.isPointInArea(t) || _e(i, e, t, function(a, l, c) {\n    !n && !re(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({ element: a, datasetIndex: l, index: c });\n  }, !0), o;\n}\nfunction $a(i, t, e, s) {\n  let n = [];\n  function o(r, a, l) {\n    const { startAngle: c, endAngle: h } = r.getProps([\"startAngle\", \"endAngle\"], s), { angle: d } = hn(r, { x: t.x, y: t.y });\n    oe(d, c, h) && n.push({ element: r, datasetIndex: a, index: l });\n  }\n  return _e(i, e, t, o), n;\n}\nfunction Ya(i, t, e, s, n, o) {\n  let r = [];\n  const a = ja(e);\n  let l = Number.POSITIVE_INFINITY;\n  function c(h, d, u) {\n    const f = h.inRange(t.x, t.y, n);\n    if (s && !f)\n      return;\n    const g = h.getCenterPoint(n);\n    if (!(!!o || i.isPointInArea(g)) && !f)\n      return;\n    const m = a(t, g);\n    m < l ? (r = [{ element: h, datasetIndex: d, index: u }], l = m) : m === l && r.push({ element: h, datasetIndex: d, index: u });\n  }\n  return _e(i, e, t, c), r;\n}\nfunction ui(i, t, e, s, n, o) {\n  return !o && !i.isPointInArea(t) ? [] : e === \"r\" && !s ? $a(i, t, e, n) : Ya(i, t, e, s, n, o);\n}\nfunction Cs(i, t, e, s, n) {\n  const o = [], r = e === \"x\" ? \"inXRange\" : \"inYRange\";\n  let a = !1;\n  return _e(i, e, t, (l, c, h) => {\n    l[r](t[e], n) && (o.push({ element: l, datasetIndex: c, index: h }), a = a || l.inRange(t.x, t.y, n));\n  }), s && !a ? [] : o;\n}\nvar Hn = {\n  evaluateInteractionItems: _e,\n  modes: {\n    index(i, t, e, s) {\n      const n = Pt(t, i), o = e.axis || \"x\", r = e.includeInvisible || !1, a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r), l = [];\n      return a.length ? (i.getSortedVisibleDatasetMetas().forEach((c) => {\n        const h = a[0].index, d = c.data[h];\n        d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: h });\n      }), l) : [];\n    },\n    dataset(i, t, e, s) {\n      const n = Pt(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n      let a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r);\n      if (a.length > 0) {\n        const l = a[0].datasetIndex, c = i.getDatasetMeta(l).data;\n        a = [];\n        for (let h = 0; h < c.length; ++h)\n          a.push({ element: c[h], datasetIndex: l, index: h });\n      }\n      return a;\n    },\n    point(i, t, e, s) {\n      const n = Pt(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n      return di(i, n, o, s, r);\n    },\n    nearest(i, t, e, s) {\n      const n = Pt(t, i), o = e.axis || \"xy\", r = e.includeInvisible || !1;\n      return ui(i, n, o, e.intersect, s, r);\n    },\n    x(i, t, e, s) {\n      const n = Pt(t, i);\n      return Cs(i, n, \"x\", e.intersect, s);\n    },\n    y(i, t, e, s) {\n      const n = Pt(t, i);\n      return Cs(i, n, \"y\", e.intersect, s);\n    }\n  }\n};\nconst jn = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction Ut(i, t) {\n  return i.filter((e) => e.pos === t);\n}\nfunction Ds(i, t) {\n  return i.filter((e) => jn.indexOf(e.pos) === -1 && e.box.axis === t);\n}\nfunction Kt(i, t) {\n  return i.sort((e, s) => {\n    const n = t ? s : e, o = t ? e : s;\n    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;\n  });\n}\nfunction Xa(i) {\n  const t = [];\n  let e, s, n, o, r, a;\n  for (e = 0, s = (i || []).length; e < s; ++e)\n    n = i[e], { position: o, options: { stack: r, stackWeight: a = 1 } } = n, t.push({\n      index: e,\n      box: n,\n      pos: o,\n      horizontal: n.isHorizontal(),\n      weight: n.weight,\n      stack: r && o + r,\n      stackWeight: a\n    });\n  return t;\n}\nfunction Ua(i) {\n  const t = {};\n  for (const e of i) {\n    const { stack: s, pos: n, stackWeight: o } = e;\n    if (!s || !jn.includes(n))\n      continue;\n    const r = t[s] || (t[s] = { count: 0, placed: 0, weight: 0, size: 0 });\n    r.count++, r.weight += o;\n  }\n  return t;\n}\nfunction Ka(i, t) {\n  const e = Ua(i), { vBoxMaxWidth: s, hBoxMaxHeight: n } = t;\n  let o, r, a;\n  for (o = 0, r = i.length; o < r; ++o) {\n    a = i[o];\n    const { fullSize: l } = a.box, c = e[a.stack], h = c && a.stackWeight / c.weight;\n    a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);\n  }\n  return e;\n}\nfunction qa(i) {\n  const t = Xa(i), e = Kt(t.filter((c) => c.box.fullSize), !0), s = Kt(Ut(t, \"left\"), !0), n = Kt(Ut(t, \"right\")), o = Kt(Ut(t, \"top\"), !0), r = Kt(Ut(t, \"bottom\")), a = Ds(t, \"x\"), l = Ds(t, \"y\");\n  return {\n    fullSize: e,\n    leftAndTop: s.concat(o),\n    rightAndBottom: n.concat(l).concat(r).concat(a),\n    chartArea: Ut(t, \"chartArea\"),\n    vertical: s.concat(n).concat(l),\n    horizontal: o.concat(r).concat(a)\n  };\n}\nfunction Os(i, t, e, s) {\n  return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);\n}\nfunction $n(i, t) {\n  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);\n}\nfunction Ga(i, t, e, s) {\n  const { pos: n, box: o } = e, r = i.maxPadding;\n  if (!D(n)) {\n    e.size && (i[n] -= e.size);\n    const d = s[e.stack] || { size: 0, count: 1 };\n    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;\n  }\n  o.getPadding && $n(r, o.getPadding());\n  const a = Math.max(0, t.outerWidth - Os(r, i, \"left\", \"right\")), l = Math.max(0, t.outerHeight - Os(r, i, \"top\", \"bottom\")), c = a !== i.w, h = l !== i.h;\n  return i.w = a, i.h = l, e.horizontal ? { same: c, other: h } : { same: h, other: c };\n}\nfunction Za(i) {\n  const t = i.maxPadding;\n  function e(s) {\n    const n = Math.max(t[s] - i[s], 0);\n    return i[s] += n, n;\n  }\n  i.y += e(\"top\"), i.x += e(\"left\"), e(\"right\"), e(\"bottom\");\n}\nfunction Ja(i, t) {\n  const e = t.maxPadding;\n  function s(n) {\n    const o = { left: 0, top: 0, right: 0, bottom: 0 };\n    return n.forEach((r) => {\n      o[r] = Math.max(t[r], e[r]);\n    }), o;\n  }\n  return s(i ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n}\nfunction Jt(i, t, e, s) {\n  const n = [];\n  let o, r, a, l, c, h;\n  for (o = 0, r = i.length, c = 0; o < r; ++o) {\n    a = i[o], l = a.box, l.update(\n      a.width || t.w,\n      a.height || t.h,\n      Ja(a.horizontal, t)\n    );\n    const { same: d, other: u } = Ga(t, e, a, s);\n    c |= d && n.length, h = h || u, l.fullSize || n.push(a);\n  }\n  return c && Jt(n, t, e, s) || h;\n}\nfunction Te(i, t, e, s, n) {\n  i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;\n}\nfunction As(i, t, e, s) {\n  const n = e.padding;\n  let { x: o, y: r } = t;\n  for (const a of i) {\n    const l = a.box, c = s[a.stack] || { count: 1, placed: 0, weight: 1 }, h = a.stackWeight / c.weight || 1;\n    if (a.horizontal) {\n      const d = t.w * h, u = c.size || l.height;\n      et(c.start) && (r = c.start), l.fullSize ? Te(l, n.left, r, e.outerWidth - n.right - n.left, u) : Te(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;\n    } else {\n      const d = t.h * h, u = c.size || l.width;\n      et(c.start) && (o = c.start), l.fullSize ? Te(l, o, n.top, u, e.outerHeight - n.bottom - n.top) : Te(l, o, t.top + c.placed, u, d), c.start = o, c.placed += d, o = l.right;\n    }\n  }\n  t.x = o, t.y = r;\n}\nO.set(\"layout\", {\n  autoPadding: !0,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar X = {\n  addBox(i, t) {\n    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || \"top\", t.weight = t.weight || 0, t._layers = t._layers || function() {\n      return [{\n        z: 0,\n        draw(e) {\n          t.draw(e);\n        }\n      }];\n    }, i.boxes.push(t);\n  },\n  removeBox(i, t) {\n    const e = i.boxes ? i.boxes.indexOf(t) : -1;\n    e !== -1 && i.boxes.splice(e, 1);\n  },\n  configure(i, t, e) {\n    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;\n  },\n  update(i, t, e, s) {\n    if (!i)\n      return;\n    const n = K(i.options.layout.padding), o = Math.max(t - n.width, 0), r = Math.max(e - n.height, 0), a = qa(i.boxes), l = a.vertical, c = a.horizontal;\n    E(i.boxes, (p) => {\n      typeof p.beforeLayout == \"function\" && p.beforeLayout();\n    });\n    const h = l.reduce((p, m) => m.box.options && m.box.options.display === !1 ? p : p + 1, 0) || 1, d = Object.freeze({\n      outerWidth: t,\n      outerHeight: e,\n      padding: n,\n      availableWidth: o,\n      availableHeight: r,\n      vBoxMaxWidth: o / 2 / h,\n      hBoxMaxHeight: r / 2\n    }), u = Object.assign({}, n);\n    $n(u, K(s));\n    const f = Object.assign({\n      maxPadding: u,\n      w: o,\n      h: r,\n      x: n.left,\n      y: n.top\n    }, n), g = Ka(l.concat(c), d);\n    Jt(a.fullSize, f, d, g), Jt(l, f, d, g), Jt(c, f, d, g) && Jt(l, f, d, g), Za(f), As(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, As(a.rightAndBottom, f, d, g), i.chartArea = {\n      left: f.left,\n      top: f.top,\n      right: f.left + f.w,\n      bottom: f.top + f.h,\n      height: f.h,\n      width: f.w\n    }, E(a.chartArea, (p) => {\n      const m = p.box;\n      Object.assign(m, i.chartArea), m.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 });\n    });\n  }\n};\nclass Hi {\n  acquireContext(t, e) {\n  }\n  releaseContext(t) {\n    return !1;\n  }\n  addEventListener(t, e, s) {\n  }\n  removeEventListener(t, e, s) {\n  }\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(t, e, s, n) {\n    return e = Math.max(0, e || t.width), s = s || t.height, {\n      width: e,\n      height: Math.max(0, n ? Math.floor(e / n) : s)\n    };\n  }\n  isAttached(t) {\n    return !0;\n  }\n  updateConfig(t) {\n  }\n}\nclass Yn extends Hi {\n  acquireContext(t) {\n    return t && t.getContext && t.getContext(\"2d\") || null;\n  }\n  updateConfig(t) {\n    t.options.animation = !1;\n  }\n}\nconst Ie = \"$chartjs\", Qa = {\n  touchstart: \"mousedown\",\n  touchmove: \"mousemove\",\n  touchend: \"mouseup\",\n  pointerenter: \"mouseenter\",\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointerleave: \"mouseout\",\n  pointerout: \"mouseout\"\n}, Ts = (i) => i === null || i === \"\";\nfunction tl(i, t) {\n  const e = i.style, s = i.getAttribute(\"height\"), n = i.getAttribute(\"width\");\n  if (i[Ie] = {\n    initial: {\n      height: s,\n      width: n,\n      style: {\n        display: e.display,\n        height: e.height,\n        width: e.width\n      }\n    }\n  }, e.display = e.display || \"block\", e.boxSizing = e.boxSizing || \"border-box\", Ts(n)) {\n    const o = cs(i, \"width\");\n    o !== void 0 && (i.width = o);\n  }\n  if (Ts(s))\n    if (i.style.height === \"\")\n      i.height = i.width / (t || 2);\n    else {\n      const o = cs(i, \"height\");\n      o !== void 0 && (i.height = o);\n    }\n  return i;\n}\nconst Xn = Vr ? { passive: !0 } : !1;\nfunction el(i, t, e) {\n  i.addEventListener(t, e, Xn);\n}\nfunction il(i, t, e) {\n  i.canvas.removeEventListener(t, e, Xn);\n}\nfunction sl(i, t) {\n  const e = Qa[i.type] || i.type, { x: s, y: n } = Pt(i, t);\n  return {\n    type: e,\n    chart: t,\n    native: i,\n    x: s !== void 0 ? s : null,\n    y: n !== void 0 ? n : null\n  };\n}\nfunction je(i, t) {\n  for (const e of i)\n    if (e === t || e.contains(t))\n      return !0;\n}\nfunction nl(i, t, e) {\n  const s = i.canvas, n = new MutationObserver((o) => {\n    let r = !1;\n    for (const a of o)\n      r = r || je(a.addedNodes, s), r = r && !je(a.removedNodes, s);\n    r && e();\n  });\n  return n.observe(document, { childList: !0, subtree: !0 }), n;\n}\nfunction ol(i, t, e) {\n  const s = i.canvas, n = new MutationObserver((o) => {\n    let r = !1;\n    for (const a of o)\n      r = r || je(a.removedNodes, s), r = r && !je(a.addedNodes, s);\n    r && e();\n  });\n  return n.observe(document, { childList: !0, subtree: !0 }), n;\n}\nconst le = /* @__PURE__ */ new Map();\nlet Ls = 0;\nfunction Un() {\n  const i = window.devicePixelRatio;\n  i !== Ls && (Ls = i, le.forEach((t, e) => {\n    e.currentDevicePixelRatio !== i && t();\n  }));\n}\nfunction rl(i, t) {\n  le.size || window.addEventListener(\"resize\", Un), le.set(i, t);\n}\nfunction al(i) {\n  le.delete(i), le.size || window.removeEventListener(\"resize\", Un);\n}\nfunction ll(i, t, e) {\n  const s = i.canvas, n = s && Wi(s);\n  if (!n)\n    return;\n  const o = gn((a, l) => {\n    const c = n.clientWidth;\n    e(a, l), c < n.clientWidth && e();\n  }, window), r = new ResizeObserver((a) => {\n    const l = a[0], c = l.contentRect.width, h = l.contentRect.height;\n    c === 0 && h === 0 || o(c, h);\n  });\n  return r.observe(n), rl(i, o), r;\n}\nfunction fi(i, t, e) {\n  e && e.disconnect(), t === \"resize\" && al(i);\n}\nfunction cl(i, t, e) {\n  const s = i.canvas, n = gn((o) => {\n    i.ctx !== null && e(sl(o, i));\n  }, i, (o) => {\n    const r = o[0];\n    return [r, r.offsetX, r.offsetY];\n  });\n  return el(s, t, n), n;\n}\nclass Kn extends Hi {\n  acquireContext(t, e) {\n    const s = t && t.getContext && t.getContext(\"2d\");\n    return s && s.canvas === t ? (tl(t, e), s) : null;\n  }\n  releaseContext(t) {\n    const e = t.canvas;\n    if (!e[Ie])\n      return !1;\n    const s = e[Ie].initial;\n    [\"height\", \"width\"].forEach((o) => {\n      const r = s[o];\n      T(r) ? e.removeAttribute(o) : e.setAttribute(o, r);\n    });\n    const n = s.style || {};\n    return Object.keys(n).forEach((o) => {\n      e.style[o] = n[o];\n    }), e.width = e.width, delete e[Ie], !0;\n  }\n  addEventListener(t, e, s) {\n    this.removeEventListener(t, e);\n    const n = t.$proxies || (t.$proxies = {}), r = {\n      attach: nl,\n      detach: ol,\n      resize: ll\n    }[e] || cl;\n    n[e] = r(t, e, s);\n  }\n  removeEventListener(t, e) {\n    const s = t.$proxies || (t.$proxies = {}), n = s[e];\n    if (!n)\n      return;\n    ({\n      attach: fi,\n      detach: fi,\n      resize: fi\n    }[e] || il)(t, e, n), s[e] = void 0;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(t, e, s, n) {\n    return Br(t, e, s, n);\n  }\n  isAttached(t) {\n    const e = Wi(t);\n    return !!(e && e.isConnected);\n  }\n}\nfunction qn(i) {\n  return !An() || typeof OffscreenCanvas < \"u\" && i instanceof OffscreenCanvas ? Yn : Kn;\n}\nclass hl {\n  constructor() {\n    this._init = [];\n  }\n  notify(t, e, s, n) {\n    e === \"beforeInit\" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n    const o = n ? this._descriptors(t).filter(n) : this._descriptors(t), r = this._notify(o, t, e, s);\n    return e === \"afterDestroy\" && (this._notify(o, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), r;\n  }\n  _notify(t, e, s, n) {\n    n = n || {};\n    for (const o of t) {\n      const r = o.plugin, a = r[s], l = [e, n, o.options];\n      if (I(a, l, r) === !1 && n.cancelable)\n        return !1;\n    }\n    return !0;\n  }\n  invalidate() {\n    T(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n  }\n  _descriptors(t) {\n    if (this._cache)\n      return this._cache;\n    const e = this._cache = this._createDescriptors(t);\n    return this._notifyStateChanges(t), e;\n  }\n  _createDescriptors(t, e) {\n    const s = t && t.config, n = C(s.options && s.options.plugins, {}), o = dl(s);\n    return n === !1 && !e ? [] : fl(t, o, n, e);\n  }\n  _notifyStateChanges(t) {\n    const e = this._oldCache || [], s = this._cache, n = (o, r) => o.filter((a) => !r.some((l) => a.plugin.id === l.plugin.id));\n    this._notify(n(e, s), t, \"stop\"), this._notify(n(s, e), t, \"start\");\n  }\n}\nfunction dl(i) {\n  const t = {}, e = [], s = Object.keys(ot.plugins.items);\n  for (let o = 0; o < s.length; o++)\n    e.push(ot.getPlugin(s[o]));\n  const n = i.plugins || [];\n  for (let o = 0; o < n.length; o++) {\n    const r = n[o];\n    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);\n  }\n  return { plugins: e, localIds: t };\n}\nfunction ul(i, t) {\n  return !t && i === !1 ? null : i === !0 ? {} : i;\n}\nfunction fl(i, { plugins: t, localIds: e }, s, n) {\n  const o = [], r = i.getContext();\n  for (const a of t) {\n    const l = a.id, c = ul(s[l], n);\n    c !== null && o.push({\n      plugin: a,\n      options: gl(i.config, { plugin: a, local: e[l] }, c, r)\n    });\n  }\n  return o;\n}\nfunction gl(i, { plugin: t, local: e }, s, n) {\n  const o = i.pluginScopeKeys(t), r = i.getOptionScopes(s, o);\n  return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [\"\"], {\n    scriptable: !1,\n    indexable: !1,\n    allKeys: !0\n  });\n}\nfunction Mi(i, t) {\n  const e = O.datasets[i] || {};\n  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || \"x\";\n}\nfunction pl(i, t) {\n  let e = i;\n  return i === \"_index_\" ? e = t : i === \"_value_\" && (e = t === \"x\" ? \"y\" : \"x\"), e;\n}\nfunction ml(i, t) {\n  return i === t ? \"_index_\" : \"_value_\";\n}\nfunction bl(i) {\n  if (i === \"top\" || i === \"bottom\")\n    return \"x\";\n  if (i === \"left\" || i === \"right\")\n    return \"y\";\n}\nfunction ki(i, t) {\n  return i === \"x\" || i === \"y\" ? i : t.axis || bl(t.position) || i.charAt(0).toLowerCase();\n}\nfunction xl(i, t) {\n  const e = At[i.type] || { scales: {} }, s = t.scales || {}, n = Mi(i.type, t), o = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);\n  return Object.keys(s).forEach((a) => {\n    const l = s[a];\n    if (!D(l))\n      return console.error(`Invalid scale configuration for scale: ${a}`);\n    if (l._proxy)\n      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);\n    const c = ki(a, l), h = ml(c, n), d = e.scales || {};\n    o[c] = o[c] || a, r[a] = Qt(/* @__PURE__ */ Object.create(null), [{ axis: c }, l, d[c], d[h]]);\n  }), i.data.datasets.forEach((a) => {\n    const l = a.type || i.type, c = a.indexAxis || Mi(l, t), d = (At[l] || {}).scales || {};\n    Object.keys(d).forEach((u) => {\n      const f = pl(u, c), g = a[f + \"AxisID\"] || o[f] || f;\n      r[g] = r[g] || /* @__PURE__ */ Object.create(null), Qt(r[g], [{ axis: f }, s[g], d[u]]);\n    });\n  }), Object.keys(r).forEach((a) => {\n    const l = r[a];\n    Qt(l, [O.scales[l.type], O.scale]);\n  }), r;\n}\nfunction Gn(i) {\n  const t = i.options || (i.options = {});\n  t.plugins = C(t.plugins, {}), t.scales = xl(i, t);\n}\nfunction Zn(i) {\n  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;\n}\nfunction _l(i) {\n  return i = i || {}, i.data = Zn(i.data), Gn(i), i;\n}\nconst Rs = /* @__PURE__ */ new Map(), Jn = /* @__PURE__ */ new Set();\nfunction Le(i, t) {\n  let e = Rs.get(i);\n  return e || (e = t(), Rs.set(i, e), Jn.add(e)), e;\n}\nconst qt = (i, t, e) => {\n  const s = _t(t, e);\n  s !== void 0 && i.add(s);\n};\nclass yl {\n  constructor(t) {\n    this._config = _l(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(t) {\n    this._config.type = t;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(t) {\n    this._config.data = Zn(t);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(t) {\n    this._config.options = t;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const t = this._config;\n    this.clearCache(), Gn(t);\n  }\n  clearCache() {\n    this._scopeCache.clear(), this._resolverCache.clear();\n  }\n  datasetScopeKeys(t) {\n    return Le(\n      t,\n      () => [[\n        `datasets.${t}`,\n        \"\"\n      ]]\n    );\n  }\n  datasetAnimationScopeKeys(t, e) {\n    return Le(\n      `${t}.transition.${e}`,\n      () => [\n        [\n          `datasets.${t}.transitions.${e}`,\n          `transitions.${e}`\n        ],\n        [\n          `datasets.${t}`,\n          \"\"\n        ]\n      ]\n    );\n  }\n  datasetElementScopeKeys(t, e) {\n    return Le(\n      `${t}-${e}`,\n      () => [[\n        `datasets.${t}.elements.${e}`,\n        `datasets.${t}`,\n        `elements.${e}`,\n        \"\"\n      ]]\n    );\n  }\n  pluginScopeKeys(t) {\n    const e = t.id, s = this.type;\n    return Le(\n      `${s}-plugin-${e}`,\n      () => [[\n        `plugins.${e}`,\n        ...t.additionalOptionScopes || []\n      ]]\n    );\n  }\n  _cachedScopes(t, e) {\n    const s = this._scopeCache;\n    let n = s.get(t);\n    return (!n || e) && (n = /* @__PURE__ */ new Map(), s.set(t, n)), n;\n  }\n  getOptionScopes(t, e, s) {\n    const { options: n, type: o } = this, r = this._cachedScopes(t, s), a = r.get(e);\n    if (a)\n      return a;\n    const l = /* @__PURE__ */ new Set();\n    e.forEach((h) => {\n      t && (l.add(t), h.forEach((d) => qt(l, t, d))), h.forEach((d) => qt(l, n, d)), h.forEach((d) => qt(l, At[o] || {}, d)), h.forEach((d) => qt(l, O, d)), h.forEach((d) => qt(l, _i, d));\n    });\n    const c = Array.from(l);\n    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Jn.has(e) && r.set(e, c), c;\n  }\n  chartOptionScopes() {\n    const { options: t, type: e } = this;\n    return [\n      t,\n      At[e] || {},\n      O.datasets[e] || {},\n      { type: e },\n      O,\n      _i\n    ];\n  }\n  resolveNamedOptions(t, e, s, n = [\"\"]) {\n    const o = { $shared: !0 }, { resolver: r, subPrefixes: a } = Es(this._resolverCache, t, n);\n    let l = r;\n    if (Ml(r, e)) {\n      o.$shared = !1, s = yt(s) ? s() : s;\n      const c = this.createResolver(t, s, a);\n      l = Vt(r, s, c);\n    }\n    for (const c of e)\n      o[c] = l[c];\n    return o;\n  }\n  createResolver(t, e, s = [\"\"], n) {\n    const { resolver: o } = Es(this._resolverCache, t, s);\n    return D(e) ? Vt(o, e, void 0, n) : o;\n  }\n}\nfunction Es(i, t, e) {\n  let s = i.get(t);\n  s || (s = /* @__PURE__ */ new Map(), i.set(t, s));\n  const n = e.join();\n  let o = s.get(n);\n  return o || (o = {\n    resolver: zi(t, e),\n    subPrefixes: e.filter((a) => !a.toLowerCase().includes(\"hover\"))\n  }, s.set(n, o)), o;\n}\nconst vl = (i) => D(i) && Object.getOwnPropertyNames(i).reduce((t, e) => t || yt(i[e]), !1);\nfunction Ml(i, t) {\n  const { isScriptable: e, isIndexable: s } = wn(i);\n  for (const n of t) {\n    const o = e(n), r = s(n), a = (r || o) && i[n];\n    if (o && (yt(a) || vl(a)) || r && z(a))\n      return !0;\n  }\n  return !1;\n}\nvar kl = \"3.9.1\";\nconst wl = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction Fs(i, t) {\n  return i === \"top\" || i === \"bottom\" || wl.indexOf(i) === -1 && t === \"x\";\n}\nfunction Is(i, t) {\n  return function(e, s) {\n    return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];\n  };\n}\nfunction zs(i) {\n  const t = i.chart, e = t.options.animation;\n  t.notifyPlugins(\"afterRender\"), I(e && e.onComplete, [i], t);\n}\nfunction Sl(i) {\n  const t = i.chart, e = t.options.animation;\n  I(e && e.onProgress, [i], t);\n}\nfunction Qn(i) {\n  return An() && typeof i == \"string\" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;\n}\nconst $e = {}, to = (i) => {\n  const t = Qn(i);\n  return Object.values($e).filter((e) => e.canvas === t).pop();\n};\nfunction Pl(i, t, e) {\n  const s = Object.keys(i);\n  for (const n of s) {\n    const o = +n;\n    if (o >= t) {\n      const r = i[n];\n      delete i[n], (e > 0 || o > t) && (i[o + e] = r);\n    }\n  }\n}\nfunction Cl(i, t, e, s) {\n  return !e || i.type === \"mouseout\" ? null : s ? t : i;\n}\nclass ji {\n  constructor(t, e) {\n    const s = this.config = new yl(e), n = Qn(t), o = to(n);\n    if (o)\n      throw new Error(\n        \"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\"\n      );\n    const r = s.createResolver(s.chartOptionScopes(), this.getContext());\n    this.platform = new (s.platform || qn(n))(), this.platform.updateConfig(s);\n    const a = this.platform.acquireContext(n, r.aspectRatio), l = a && a.canvas, c = l && l.height, h = l && l.width;\n    if (this.id = _o(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new hl(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Fo((d) => this.update(d), r.resizeDelay || 0), this._dataChanges = [], $e[this.id] = this, !a || !l) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    at.listen(this, \"complete\", zs), at.listen(this, \"progress\", Sl), this._initialize(), this.attached && this.update();\n  }\n  get aspectRatio() {\n    const { options: { aspectRatio: t, maintainAspectRatio: e }, width: s, height: n, _aspectRatio: o } = this;\n    return T(t) ? e && o ? o : n ? s / n : null : t;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(t) {\n    this.config.data = t;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(t) {\n    this.config.options = t;\n  }\n  _initialize() {\n    return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ls(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n  }\n  clear() {\n    return os(this.canvas, this.ctx), this;\n  }\n  stop() {\n    return at.stop(this), this;\n  }\n  resize(t, e) {\n    at.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e);\n  }\n  _resize(t, e) {\n    const s = this.options, n = this.canvas, o = s.maintainAspectRatio && this.aspectRatio, r = this.platform.getMaximumSize(n, t, e, o), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? \"resize\" : \"attach\";\n    this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, ls(this, a, !0) && (this.notifyPlugins(\"resize\", { size: r }), I(s.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());\n  }\n  ensureScalesHaveIDs() {\n    const e = this.options.scales || {};\n    E(e, (s, n) => {\n      s.id = n;\n    });\n  }\n  buildOrUpdateScales() {\n    const t = this.options, e = t.scales, s = this.scales, n = Object.keys(s).reduce((r, a) => (r[a] = !1, r), {});\n    let o = [];\n    e && (o = o.concat(\n      Object.keys(e).map((r) => {\n        const a = e[r], l = ki(r, a), c = l === \"r\", h = l === \"x\";\n        return {\n          options: a,\n          dposition: c ? \"chartArea\" : h ? \"bottom\" : \"left\",\n          dtype: c ? \"radialLinear\" : h ? \"category\" : \"linear\"\n        };\n      })\n    )), E(o, (r) => {\n      const a = r.options, l = a.id, c = ki(l, a), h = C(a.type, r.dtype);\n      (a.position === void 0 || Fs(a.position, c) !== Fs(r.dposition)) && (a.position = r.dposition), n[l] = !0;\n      let d = null;\n      if (l in s && s[l].type === h)\n        d = s[l];\n      else {\n        const u = ot.getScale(h);\n        d = new u({\n          id: l,\n          type: h,\n          ctx: this.ctx,\n          chart: this\n        }), s[d.id] = d;\n      }\n      d.init(a, t);\n    }), E(n, (r, a) => {\n      r || delete s[a];\n    }), E(s, (r) => {\n      X.configure(this, r, r.options), X.addBox(this, r);\n    });\n  }\n  _updateMetasets() {\n    const t = this._metasets, e = this.data.datasets.length, s = t.length;\n    if (t.sort((n, o) => n.index - o.index), s > e) {\n      for (let n = e; n < s; ++n)\n        this._destroyDatasetMeta(n);\n      t.splice(e, s - e);\n    }\n    this._sortedMetasets = t.slice(0).sort(Is(\"order\", \"index\"));\n  }\n  _removeUnreferencedMetasets() {\n    const { _metasets: t, data: { datasets: e } } = this;\n    t.length > e.length && delete this._stacks, t.forEach((s, n) => {\n      e.filter((o) => o === s._dataset).length === 0 && this._destroyDatasetMeta(n);\n    });\n  }\n  buildOrUpdateControllers() {\n    const t = [], e = this.data.datasets;\n    let s, n;\n    for (this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++) {\n      const o = e[s];\n      let r = this.getDatasetMeta(s);\n      const a = o.type || this.config.type;\n      if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || Mi(a, this.options), r.order = o.order || 0, r.index = s, r.label = \"\" + o.label, r.visible = this.isDatasetVisible(s), r.controller)\n        r.controller.updateIndex(s), r.controller.linkScales();\n      else {\n        const l = ot.getController(a), { datasetElementType: c, dataElementType: h } = O.datasets[a];\n        Object.assign(l.prototype, {\n          dataElementType: ot.getElement(h),\n          datasetElementType: c && ot.getElement(c)\n        }), r.controller = new l(this, s), t.push(r.controller);\n      }\n    }\n    return this._updateMetasets(), t;\n  }\n  _resetElements() {\n    E(this.data.datasets, (t, e) => {\n      this.getDatasetMeta(e).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements(), this.notifyPlugins(\"reset\");\n  }\n  update(t) {\n    const e = this.config;\n    e.update();\n    const s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), n = this._animationsDisabled = !s.animation;\n    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins(\"beforeUpdate\", { mode: t, cancelable: !0 }) === !1)\n      return;\n    const o = this.buildOrUpdateControllers();\n    this.notifyPlugins(\"beforeElementsUpdate\");\n    let r = 0;\n    for (let c = 0, h = this.data.datasets.length; c < h; c++) {\n      const { controller: d } = this.getDatasetMeta(c), u = !n && o.indexOf(d) === -1;\n      d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);\n    }\n    r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || E(o, (c) => {\n      c.reset();\n    }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", { mode: t }), this._layers.sort(Is(\"z\", \"_idx\"));\n    const { _active: a, _lastEvent: l } = this;\n    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n  }\n  _updateScales() {\n    E(this.scales, (t) => {\n      X.removeBox(this, t);\n    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const t = this.options, e = new Set(Object.keys(this._listeners)), s = new Set(t.events);\n    (!Ui(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());\n  }\n  _updateHiddenIndices() {\n    const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n    for (const { method: s, start: n, count: o } of e) {\n      const r = s === \"_removeElements\" ? -o : o;\n      Pl(t, n, r);\n    }\n  }\n  _getUniformDataChanges() {\n    const t = this._dataChanges;\n    if (!t || !t.length)\n      return;\n    this._dataChanges = [];\n    const e = this.data.datasets.length, s = (o) => new Set(\n      t.filter((r) => r[0] === o).map((r, a) => a + \",\" + r.splice(1).join(\",\"))\n    ), n = s(0);\n    for (let o = 1; o < e; o++)\n      if (!Ui(n, s(o)))\n        return;\n    return Array.from(n).map((o) => o.split(\",\")).map((o) => ({ method: o[1], start: +o[2], count: +o[3] }));\n  }\n  _updateLayout(t) {\n    if (this.notifyPlugins(\"beforeLayout\", { cancelable: !0 }) === !1)\n      return;\n    X.update(this, this.width, this.height, t);\n    const e = this.chartArea, s = e.width <= 0 || e.height <= 0;\n    this._layers = [], E(this.boxes, (n) => {\n      s && n.position === \"chartArea\" || (n.configure && n.configure(), this._layers.push(...n._layers()));\n    }, this), this._layers.forEach((n, o) => {\n      n._idx = o;\n    }), this.notifyPlugins(\"afterLayout\");\n  }\n  _updateDatasets(t) {\n    if (this.notifyPlugins(\"beforeDatasetsUpdate\", { mode: t, cancelable: !0 }) !== !1) {\n      for (let e = 0, s = this.data.datasets.length; e < s; ++e)\n        this.getDatasetMeta(e).controller.configure();\n      for (let e = 0, s = this.data.datasets.length; e < s; ++e)\n        this._updateDataset(e, yt(t) ? t({ datasetIndex: e }) : t);\n      this.notifyPlugins(\"afterDatasetsUpdate\", { mode: t });\n    }\n  }\n  _updateDataset(t, e) {\n    const s = this.getDatasetMeta(t), n = { meta: s, index: t, mode: e, cancelable: !0 };\n    this.notifyPlugins(\"beforeDatasetUpdate\", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", n));\n  }\n  render() {\n    this.notifyPlugins(\"beforeRender\", { cancelable: !0 }) !== !1 && (at.has(this) ? this.attached && !at.running(this) && at.start(this) : (this.draw(), zs({ chart: this })));\n  }\n  draw() {\n    let t;\n    if (this._resizeBeforeDraw) {\n      const { width: s, height: n } = this._resizeBeforeDraw;\n      this._resize(s, n), this._resizeBeforeDraw = null;\n    }\n    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins(\"beforeDraw\", { cancelable: !0 }) === !1)\n      return;\n    const e = this._layers;\n    for (t = 0; t < e.length && e[t].z <= 0; ++t)\n      e[t].draw(this.chartArea);\n    for (this._drawDatasets(); t < e.length; ++t)\n      e[t].draw(this.chartArea);\n    this.notifyPlugins(\"afterDraw\");\n  }\n  _getSortedDatasetMetas(t) {\n    const e = this._sortedMetasets, s = [];\n    let n, o;\n    for (n = 0, o = e.length; n < o; ++n) {\n      const r = e[n];\n      (!t || r.visible) && s.push(r);\n    }\n    return s;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(!0);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins(\"beforeDatasetsDraw\", { cancelable: !0 }) === !1)\n      return;\n    const t = this.getSortedVisibleDatasetMetas();\n    for (let e = t.length - 1; e >= 0; --e)\n      this._drawDataset(t[e]);\n    this.notifyPlugins(\"afterDatasetsDraw\");\n  }\n  _drawDataset(t) {\n    const e = this.ctx, s = t._clip, n = !s.disabled, o = this.chartArea, r = {\n      meta: t,\n      index: t.index,\n      cancelable: !0\n    };\n    this.notifyPlugins(\"beforeDatasetDraw\", r) !== !1 && (n && Xe(e, {\n      left: s.left === !1 ? 0 : o.left - s.left,\n      right: s.right === !1 ? this.width : o.right + s.right,\n      top: s.top === !1 ? 0 : o.top - s.top,\n      bottom: s.bottom === !1 ? this.height : o.bottom + s.bottom\n    }), t.controller.draw(), n && Ue(e), r.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", r));\n  }\n  isPointInArea(t) {\n    return re(t, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(t, e, s, n) {\n    const o = Hn.modes[e];\n    return typeof o == \"function\" ? o(this, t, s, n) : [];\n  }\n  getDatasetMeta(t) {\n    const e = this.data.datasets[t], s = this._metasets;\n    let n = s.filter((o) => o && o._dataset === e).pop();\n    return n || (n = {\n      type: null,\n      data: [],\n      dataset: null,\n      controller: null,\n      hidden: null,\n      xAxisID: null,\n      yAxisID: null,\n      order: e && e.order || 0,\n      index: t,\n      _dataset: e,\n      _parsed: [],\n      _sorted: !1\n    }, s.push(n)), n;\n  }\n  getContext() {\n    return this.$context || (this.$context = vt(null, { chart: this, type: \"chart\" }));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(t) {\n    const e = this.data.datasets[t];\n    if (!e)\n      return !1;\n    const s = this.getDatasetMeta(t);\n    return typeof s.hidden == \"boolean\" ? !s.hidden : !e.hidden;\n  }\n  setDatasetVisibility(t, e) {\n    const s = this.getDatasetMeta(t);\n    s.hidden = !e;\n  }\n  toggleDataVisibility(t) {\n    this._hiddenIndices[t] = !this._hiddenIndices[t];\n  }\n  getDataVisibility(t) {\n    return !this._hiddenIndices[t];\n  }\n  _updateVisibility(t, e, s) {\n    const n = s ? \"show\" : \"hide\", o = this.getDatasetMeta(t), r = o.controller._resolveAnimations(void 0, n);\n    et(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, { visible: s }), this.update((a) => a.datasetIndex === t ? n : void 0));\n  }\n  hide(t, e) {\n    this._updateVisibility(t, e, !1);\n  }\n  show(t, e) {\n    this._updateVisibility(t, e, !0);\n  }\n  _destroyDatasetMeta(t) {\n    const e = this._metasets[t];\n    e && e.controller && e.controller._destroy(), delete this._metasets[t];\n  }\n  _stop() {\n    let t, e;\n    for (this.stop(), at.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)\n      this._destroyDatasetMeta(t);\n  }\n  destroy() {\n    this.notifyPlugins(\"beforeDestroy\");\n    const { canvas: t, ctx: e } = this;\n    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), os(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins(\"destroy\"), delete $e[this.id], this.notifyPlugins(\"afterDestroy\");\n  }\n  toBase64Image(...t) {\n    return this.canvas.toDataURL(...t);\n  }\n  bindEvents() {\n    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n  }\n  bindUserEvents() {\n    const t = this._listeners, e = this.platform, s = (o, r) => {\n      e.addEventListener(this, o, r), t[o] = r;\n    }, n = (o, r, a) => {\n      o.offsetX = r, o.offsetY = a, this._eventHandler(o);\n    };\n    E(this.options.events, (o) => s(o, n));\n  }\n  bindResponsiveEvents() {\n    this._responsiveListeners || (this._responsiveListeners = {});\n    const t = this._responsiveListeners, e = this.platform, s = (l, c) => {\n      e.addEventListener(this, l, c), t[l] = c;\n    }, n = (l, c) => {\n      t[l] && (e.removeEventListener(this, l, c), delete t[l]);\n    }, o = (l, c) => {\n      this.canvas && this.resize(l, c);\n    };\n    let r;\n    const a = () => {\n      n(\"attach\", a), this.attached = !0, this.resize(), s(\"resize\", o), s(\"detach\", r);\n    };\n    r = () => {\n      this.attached = !1, n(\"resize\", o), this._stop(), this._resize(0, 0), s(\"attach\", a);\n    }, e.isAttached(this.canvas) ? a() : r();\n  }\n  unbindEvents() {\n    E(this._listeners, (t, e) => {\n      this.platform.removeEventListener(this, e, t);\n    }), this._listeners = {}, E(this._responsiveListeners, (t, e) => {\n      this.platform.removeEventListener(this, e, t);\n    }), this._responsiveListeners = void 0;\n  }\n  updateHoverStyle(t, e, s) {\n    const n = s ? \"set\" : \"remove\";\n    let o, r, a, l;\n    for (e === \"dataset\" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller[\"_\" + n + \"DatasetHoverStyle\"]()), a = 0, l = t.length; a < l; ++a) {\n      r = t[a];\n      const c = r && this.getDatasetMeta(r.datasetIndex).controller;\n      c && c[n + \"HoverStyle\"](r.element, r.datasetIndex, r.index);\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(t) {\n    const e = this._active || [], s = t.map(({ datasetIndex: o, index: r }) => {\n      const a = this.getDatasetMeta(o);\n      if (!a)\n        throw new Error(\"No dataset found at index \" + o);\n      return {\n        datasetIndex: o,\n        element: a.data[r],\n        index: r\n      };\n    });\n    !ze(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));\n  }\n  notifyPlugins(t, e, s) {\n    return this._plugins.notify(this, t, e, s);\n  }\n  _updateHoverStyles(t, e, s) {\n    const n = this.options.hover, o = (l, c) => l.filter((h) => !c.some((d) => h.datasetIndex === d.datasetIndex && h.index === d.index)), r = o(e, t), a = s ? t : o(t, e);\n    r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);\n  }\n  _eventHandler(t, e) {\n    const s = {\n      event: t,\n      replay: e,\n      cancelable: !0,\n      inChartArea: this.isPointInArea(t)\n    }, n = (r) => (r.options.events || this.options.events).includes(t.native.type);\n    if (this.notifyPlugins(\"beforeEvent\", s, n) === !1)\n      return;\n    const o = this._handleEvent(t, e, s.inChartArea);\n    return s.cancelable = !1, this.notifyPlugins(\"afterEvent\", s, n), (o || s.changed) && this.render(), this;\n  }\n  _handleEvent(t, e, s) {\n    const { _active: n = [], options: o } = this, r = e, a = this._getActiveElements(t, n, s, r), l = So(t), c = Cl(t, this._lastEvent, s, l);\n    s && (this._lastEvent = null, I(o.onHover, [t, a, this], this), l && I(o.onClick, [t, a, this], this));\n    const h = !ze(a, n);\n    return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;\n  }\n  _getActiveElements(t, e, s, n) {\n    if (t.type === \"mouseout\")\n      return [];\n    if (!s)\n      return e;\n    const o = this.options.hover;\n    return this.getElementsAtEventForMode(t, o.mode, o, n);\n  }\n}\nconst Bs = () => E(ji.instances, (i) => i._plugins.invalidate()), pt = !0;\nObject.defineProperties(ji, {\n  defaults: {\n    enumerable: pt,\n    value: O\n  },\n  instances: {\n    enumerable: pt,\n    value: $e\n  },\n  overrides: {\n    enumerable: pt,\n    value: At\n  },\n  registry: {\n    enumerable: pt,\n    value: ot\n  },\n  version: {\n    enumerable: pt,\n    value: kl\n  },\n  getChart: {\n    enumerable: pt,\n    value: to\n  },\n  register: {\n    enumerable: pt,\n    value: (...i) => {\n      ot.add(...i), Bs();\n    }\n  },\n  unregister: {\n    enumerable: pt,\n    value: (...i) => {\n      ot.remove(...i), Bs();\n    }\n  }\n});\nfunction eo(i, t, e) {\n  const { startAngle: s, pixelMargin: n, x: o, y: r, outerRadius: a, innerRadius: l } = t;\n  let c = n / a;\n  i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + V, s - V), i.closePath(), i.clip();\n}\nfunction Dl(i) {\n  return Ii(i, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction Ol(i, t, e, s) {\n  const n = Dl(i.options.borderRadius), o = (e - t) / 2, r = Math.min(o, s * t / 2), a = (l) => {\n    const c = (e - Math.min(o, l)) * s / 2;\n    return Y(l, 0, Math.min(o, c));\n  };\n  return {\n    outerStart: a(n.outerStart),\n    outerEnd: a(n.outerEnd),\n    innerStart: Y(n.innerStart, 0, r),\n    innerEnd: Y(n.innerEnd, 0, r)\n  };\n}\nfunction It(i, t, e, s) {\n  return {\n    x: e + i * Math.cos(t),\n    y: s + i * Math.sin(t)\n  };\n}\nfunction wi(i, t, e, s, n, o) {\n  const { x: r, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = t, d = Math.max(t.outerRadius + s + e - c, 0), u = h > 0 ? h + s + e + c : 0;\n  let f = 0;\n  const g = n - l;\n  if (s) {\n    const P = h > 0 ? h - s : 0, j = d > 0 ? d - s : 0, W = (P + j) / 2, kt = W !== 0 ? g * W / (W + s) : g;\n    f = (g - kt) / 2;\n  }\n  const p = Math.max(1e-3, g * d - e / B) / d, m = (g - p) / 2, b = l + m + f, x = n - m - f, { outerStart: v, outerEnd: y, innerStart: _, innerEnd: M } = Ol(t, u, d, x - b), k = d - v, S = d - y, w = b + v / k, L = x - y / S, R = u + _, A = u + M, H = b + _ / R, q = x - M / A;\n  if (i.beginPath(), o) {\n    if (i.arc(r, a, d, w, L), y > 0) {\n      const W = It(S, L, r, a);\n      i.arc(W.x, W.y, y, L, x + V);\n    }\n    const P = It(A, x, r, a);\n    if (i.lineTo(P.x, P.y), M > 0) {\n      const W = It(A, q, r, a);\n      i.arc(W.x, W.y, M, x + V, q + Math.PI);\n    }\n    if (i.arc(r, a, u, x - M / u, b + _ / u, !0), _ > 0) {\n      const W = It(R, H, r, a);\n      i.arc(W.x, W.y, _, H + Math.PI, b - V);\n    }\n    const j = It(k, b, r, a);\n    if (i.lineTo(j.x, j.y), v > 0) {\n      const W = It(k, w, r, a);\n      i.arc(W.x, W.y, v, b - V, w);\n    }\n  } else {\n    i.moveTo(r, a);\n    const P = Math.cos(w) * d + r, j = Math.sin(w) * d + a;\n    i.lineTo(P, j);\n    const W = Math.cos(L) * d + r, kt = Math.sin(L) * d + a;\n    i.lineTo(W, kt);\n  }\n  i.closePath();\n}\nfunction Al(i, t, e, s, n) {\n  const { fullCircles: o, startAngle: r, circumference: a } = t;\n  let l = t.endAngle;\n  if (o) {\n    wi(i, t, e, s, r + F, n);\n    for (let c = 0; c < o; ++c)\n      i.fill();\n    isNaN(a) || (l = r + a % F, a % F === 0 && (l += F));\n  }\n  return wi(i, t, e, s, l, n), i.fill(), l;\n}\nfunction Tl(i, t, e) {\n  const { x: s, y: n, startAngle: o, pixelMargin: r, fullCircles: a } = t, l = Math.max(t.outerRadius - r, 0), c = t.innerRadius + r;\n  let h;\n  for (e && eo(i, t, o + F), i.beginPath(), i.arc(s, n, c, o + F, o, !0), h = 0; h < a; ++h)\n    i.stroke();\n  for (i.beginPath(), i.arc(s, n, l, o, o + F), h = 0; h < a; ++h)\n    i.stroke();\n}\nfunction Ll(i, t, e, s, n, o) {\n  const { options: r } = t, { borderWidth: a, borderJoinStyle: l } = r, c = r.borderAlign === \"inner\";\n  a && (c ? (i.lineWidth = a * 2, i.lineJoin = l || \"round\") : (i.lineWidth = a, i.lineJoin = l || \"bevel\"), t.fullCircles && Tl(i, t, c), c && eo(i, t, n), wi(i, t, e, s, n, o), i.stroke());\n}\nclass ye extends st {\n  constructor(t) {\n    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n  }\n  inRange(t, e, s) {\n    const n = this.getProps([\"x\", \"y\"], s), { angle: o, distance: r } = hn(n, { x: t, y: e }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: h, circumference: d } = this.getProps([\n      \"startAngle\",\n      \"endAngle\",\n      \"innerRadius\",\n      \"outerRadius\",\n      \"circumference\"\n    ], s), u = this.options.spacing / 2, g = C(d, l - a) >= F || oe(o, a, l), p = ut(r, c + u, h + u);\n    return g && p;\n  }\n  getCenterPoint(t) {\n    const { x: e, y: s, startAngle: n, endAngle: o, innerRadius: r, outerRadius: a } = this.getProps([\n      \"x\",\n      \"y\",\n      \"startAngle\",\n      \"endAngle\",\n      \"innerRadius\",\n      \"outerRadius\",\n      \"circumference\"\n    ], t), { offset: l, spacing: c } = this.options, h = (n + o) / 2, d = (r + a + c + l) / 2;\n    return {\n      x: e + Math.cos(h) * d,\n      y: s + Math.sin(h) * d\n    };\n  }\n  tooltipPosition(t) {\n    return this.getCenterPoint(t);\n  }\n  draw(t) {\n    const { options: e, circumference: s } = this, n = (e.offset || 0) / 2, o = (e.spacing || 0) / 2, r = e.circular;\n    if (this.pixelMargin = e.borderAlign === \"inner\" ? 0.33 : 0, this.fullCircles = s > F ? Math.floor(s / F) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0)\n      return;\n    t.save();\n    let a = 0;\n    if (n) {\n      a = n / 2;\n      const c = (this.startAngle + this.endAngle) / 2;\n      t.translate(Math.cos(c) * a, Math.sin(c) * a), this.circumference >= B && (a = n);\n    }\n    t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;\n    const l = Al(t, this, a, o, r);\n    Ll(t, this, a, o, l, r), t.restore();\n  }\n}\nye.id = \"arc\";\nye.defaults = {\n  borderAlign: \"center\",\n  borderColor: \"#fff\",\n  borderJoinStyle: void 0,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: void 0,\n  circular: !0\n};\nye.defaultRoutes = {\n  backgroundColor: \"backgroundColor\"\n};\nfunction io(i, t, e = t) {\n  i.lineCap = C(e.borderCapStyle, t.borderCapStyle), i.setLineDash(C(e.borderDash, t.borderDash)), i.lineDashOffset = C(e.borderDashOffset, t.borderDashOffset), i.lineJoin = C(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = C(e.borderWidth, t.borderWidth), i.strokeStyle = C(e.borderColor, t.borderColor);\n}\nfunction Rl(i, t, e) {\n  i.lineTo(e.x, e.y);\n}\nfunction El(i) {\n  return i.stepped ? lr : i.tension || i.cubicInterpolationMode === \"monotone\" ? cr : Rl;\n}\nfunction so(i, t, e = {}) {\n  const s = i.length, { start: n = 0, end: o = s - 1 } = e, { start: r, end: a } = t, l = Math.max(n, r), c = Math.min(o, a), h = n < r && o < r || n > a && o > a;\n  return {\n    count: s,\n    start: l,\n    loop: t.loop,\n    ilen: c < l && !h ? s + c - l : c - l\n  };\n}\nfunction Fl(i, t, e, s) {\n  const { points: n, options: o } = t, { count: r, start: a, loop: l, ilen: c } = so(n, e, s), h = El(o);\n  let { move: d = !0, reverse: u } = s || {}, f, g, p;\n  for (f = 0; f <= c; ++f)\n    g = n[(a + (u ? c - f : f)) % r], !g.skip && (d ? (i.moveTo(g.x, g.y), d = !1) : h(i, p, g, u, o.stepped), p = g);\n  return l && (g = n[(a + (u ? c : 0)) % r], h(i, p, g, u, o.stepped)), !!l;\n}\nfunction Il(i, t, e, s) {\n  const n = t.points, { count: o, start: r, ilen: a } = so(n, e, s), { move: l = !0, reverse: c } = s || {};\n  let h = 0, d = 0, u, f, g, p, m, b;\n  const x = (y) => (r + (c ? a - y : y)) % o, v = () => {\n    p !== m && (i.lineTo(h, m), i.lineTo(h, p), i.lineTo(h, b));\n  };\n  for (l && (f = n[x(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {\n    if (f = n[x(u)], f.skip)\n      continue;\n    const y = f.x, _ = f.y, M = y | 0;\n    M === g ? (_ < p ? p = _ : _ > m && (m = _), h = (d * h + y) / ++d) : (v(), i.lineTo(y, _), g = M, d = 0, p = m = _), b = _;\n  }\n  v();\n}\nfunction Si(i) {\n  const t = i.options, e = t.borderDash && t.borderDash.length;\n  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== \"monotone\" && !t.stepped && !e ? Il : Fl;\n}\nfunction zl(i) {\n  return i.stepped ? Wr : i.tension || i.cubicInterpolationMode === \"monotone\" ? Nr : Ct;\n}\nfunction Bl(i, t, e, s) {\n  let n = t._path;\n  n || (n = t._path = new Path2D(), t.path(n, e, s) && n.closePath()), io(i, t.options), i.stroke(n);\n}\nfunction Vl(i, t, e, s) {\n  const { segments: n, options: o } = t, r = Si(t);\n  for (const a of n)\n    io(i, o, a.style), i.beginPath(), r(i, t, a, { start: e, end: e + s - 1 }) && i.closePath(), i.stroke();\n}\nconst Wl = typeof Path2D == \"function\";\nfunction Nl(i, t, e, s) {\n  Wl && !t.options.segment ? Bl(i, t, e, s) : Vl(i, t, e, s);\n}\nclass gt extends st {\n  constructor(t) {\n    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n  }\n  updateControlPoints(t, e) {\n    const s = this.options;\n    if ((s.tension || s.cubicInterpolationMode === \"monotone\") && !s.stepped && !this._pointsUpdated) {\n      const n = s.spanGaps ? this._loop : this._fullLoop;\n      Lr(this._points, s, t, n, e), this._pointsUpdated = !0;\n    }\n  }\n  set points(t) {\n    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = Kr(this, this.options.segment));\n  }\n  first() {\n    const t = this.segments, e = this.points;\n    return t.length && e[t[0].start];\n  }\n  last() {\n    const t = this.segments, e = this.points, s = t.length;\n    return s && e[t[s - 1].end];\n  }\n  interpolate(t, e) {\n    const s = this.options, n = t[e], o = this.points, r = Fn(this, { property: e, start: n, end: n });\n    if (!r.length)\n      return;\n    const a = [], l = zl(s);\n    let c, h;\n    for (c = 0, h = r.length; c < h; ++c) {\n      const { start: d, end: u } = r[c], f = o[d], g = o[u];\n      if (f === g) {\n        a.push(f);\n        continue;\n      }\n      const p = Math.abs((n - f[e]) / (g[e] - f[e])), m = l(f, g, p, s.stepped);\n      m[e] = t[e], a.push(m);\n    }\n    return a.length === 1 ? a[0] : a;\n  }\n  pathSegment(t, e, s) {\n    return Si(this)(t, this, e, s);\n  }\n  path(t, e, s) {\n    const n = this.segments, o = Si(this);\n    let r = this._loop;\n    e = e || 0, s = s || this.points.length - e;\n    for (const a of n)\n      r &= o(t, this, a, { start: e, end: e + s - 1 });\n    return !!r;\n  }\n  draw(t, e, s, n) {\n    const o = this.options || {};\n    (this.points || []).length && o.borderWidth && (t.save(), Nl(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n  }\n}\ngt.id = \"line\";\ngt.defaults = {\n  borderCapStyle: \"butt\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: \"miter\",\n  borderWidth: 3,\n  capBezierPoints: !0,\n  cubicInterpolationMode: \"default\",\n  fill: !1,\n  spanGaps: !1,\n  stepped: !1,\n  tension: 0\n};\ngt.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\ngt.descriptors = {\n  _scriptable: !0,\n  _indexable: (i) => i !== \"borderDash\" && i !== \"fill\"\n};\nfunction Vs(i, t, e, s) {\n  const n = i.options, { [e]: o } = i.getProps([e], s);\n  return Math.abs(t - o) < n.radius + n.hitRadius;\n}\nclass ve extends st {\n  constructor(t) {\n    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n  }\n  inRange(t, e, s) {\n    const n = this.options, { x: o, y: r } = this.getProps([\"x\", \"y\"], s);\n    return Math.pow(t - o, 2) + Math.pow(e - r, 2) < Math.pow(n.hitRadius + n.radius, 2);\n  }\n  inXRange(t, e) {\n    return Vs(this, t, \"x\", e);\n  }\n  inYRange(t, e) {\n    return Vs(this, t, \"y\", e);\n  }\n  getCenterPoint(t) {\n    const { x: e, y: s } = this.getProps([\"x\", \"y\"], t);\n    return { x: e, y: s };\n  }\n  size(t) {\n    t = t || this.options || {};\n    let e = t.radius || 0;\n    e = Math.max(e, e && t.hoverRadius || 0);\n    const s = e && t.borderWidth || 0;\n    return (e + s) * 2;\n  }\n  draw(t, e) {\n    const s = this.options;\n    this.skip || s.radius < 0.1 || !re(this, e, this.size(s) / 2) || (t.strokeStyle = s.borderColor, t.lineWidth = s.borderWidth, t.fillStyle = s.backgroundColor, yi(t, s, this.x, this.y));\n  }\n  getRange() {\n    const t = this.options || {};\n    return t.radius + t.hitRadius;\n  }\n}\nve.id = \"point\";\nve.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: \"circle\",\n  radius: 3,\n  rotation: 0\n};\nve.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\nfunction no(i, t) {\n  const { x: e, y: s, base: n, width: o, height: r } = i.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], t);\n  let a, l, c, h, d;\n  return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), { left: a, top: c, right: l, bottom: h };\n}\nfunction bt(i, t, e, s) {\n  return i ? 0 : Y(t, e, s);\n}\nfunction Hl(i, t, e) {\n  const s = i.options.borderWidth, n = i.borderSkipped, o = kn(s);\n  return {\n    t: bt(n.top, o.top, 0, e),\n    r: bt(n.right, o.right, 0, t),\n    b: bt(n.bottom, o.bottom, 0, e),\n    l: bt(n.left, o.left, 0, t)\n  };\n}\nfunction jl(i, t, e) {\n  const { enableBorderRadius: s } = i.getProps([\"enableBorderRadius\"]), n = i.options.borderRadius, o = Dt(n), r = Math.min(t, e), a = i.borderSkipped, l = s || D(n);\n  return {\n    topLeft: bt(!l || a.top || a.left, o.topLeft, 0, r),\n    topRight: bt(!l || a.top || a.right, o.topRight, 0, r),\n    bottomLeft: bt(!l || a.bottom || a.left, o.bottomLeft, 0, r),\n    bottomRight: bt(!l || a.bottom || a.right, o.bottomRight, 0, r)\n  };\n}\nfunction $l(i) {\n  const t = no(i), e = t.right - t.left, s = t.bottom - t.top, n = Hl(i, e / 2, s / 2), o = jl(i, e / 2, s / 2);\n  return {\n    outer: {\n      x: t.left,\n      y: t.top,\n      w: e,\n      h: s,\n      radius: o\n    },\n    inner: {\n      x: t.left + n.l,\n      y: t.top + n.t,\n      w: e - n.l - n.r,\n      h: s - n.t - n.b,\n      radius: {\n        topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),\n        topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),\n        bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),\n        bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))\n      }\n    }\n  };\n}\nfunction gi(i, t, e, s) {\n  const n = t === null, o = e === null, a = i && !(n && o) && no(i, s);\n  return a && (n || ut(t, a.left, a.right)) && (o || ut(e, a.top, a.bottom));\n}\nfunction Yl(i) {\n  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;\n}\nfunction Xl(i, t) {\n  i.rect(t.x, t.y, t.w, t.h);\n}\nfunction pi(i, t, e = {}) {\n  const s = i.x !== e.x ? -t : 0, n = i.y !== e.y ? -t : 0, o = (i.x + i.w !== e.x + e.w ? t : 0) - s, r = (i.y + i.h !== e.y + e.h ? t : 0) - n;\n  return {\n    x: i.x + s,\n    y: i.y + n,\n    w: i.w + o,\n    h: i.h + r,\n    radius: i.radius\n  };\n}\nclass Me extends st {\n  constructor(t) {\n    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n  }\n  draw(t) {\n    const { inflateAmount: e, options: { borderColor: s, backgroundColor: n } } = this, { inner: o, outer: r } = $l(this), a = Yl(r.radius) ? ae : Xl;\n    t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, pi(r, e, o)), t.clip(), a(t, pi(o, -e, r)), t.fillStyle = s, t.fill(\"evenodd\")), t.beginPath(), a(t, pi(o, e)), t.fillStyle = n, t.fill(), t.restore();\n  }\n  inRange(t, e, s) {\n    return gi(this, t, e, s);\n  }\n  inXRange(t, e) {\n    return gi(this, t, null, e);\n  }\n  inYRange(t, e) {\n    return gi(this, null, t, e);\n  }\n  getCenterPoint(t) {\n    const { x: e, y: s, base: n, horizontal: o } = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], t);\n    return {\n      x: o ? (e + n) / 2 : e,\n      y: o ? s : (s + n) / 2\n    };\n  }\n  getRange(t) {\n    return t === \"x\" ? this.width / 2 : this.height / 2;\n  }\n}\nMe.id = \"bar\";\nMe.defaults = {\n  borderSkipped: \"start\",\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: \"auto\",\n  pointStyle: void 0\n};\nMe.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\nvar oo = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ArcElement: ye,\n  LineElement: gt,\n  PointElement: ve,\n  BarElement: Me\n});\nfunction Ul(i, t, e, s, n) {\n  const o = n.samples || s;\n  if (o >= e)\n    return i.slice(t, t + e);\n  const r = [], a = (e - 2) / (o - 2);\n  let l = 0;\n  const c = t + e - 1;\n  let h = t, d, u, f, g, p;\n  for (r[l++] = i[h], d = 0; d < o - 2; d++) {\n    let m = 0, b = 0, x;\n    const v = Math.floor((d + 1) * a) + 1 + t, y = Math.min(Math.floor((d + 2) * a) + 1, e) + t, _ = y - v;\n    for (x = v; x < y; x++)\n      m += i[x].x, b += i[x].y;\n    m /= _, b /= _;\n    const M = Math.floor(d * a) + 1 + t, k = Math.min(Math.floor((d + 1) * a) + 1, e) + t, { x: S, y: w } = i[h];\n    for (f = g = -1, x = M; x < k; x++)\n      g = 0.5 * Math.abs(\n        (S - m) * (i[x].y - w) - (S - i[x].x) * (b - w)\n      ), g > f && (f = g, u = i[x], p = x);\n    r[l++] = u, h = p;\n  }\n  return r[l++] = i[c], r;\n}\nfunction Kl(i, t, e, s) {\n  let n = 0, o = 0, r, a, l, c, h, d, u, f, g, p;\n  const m = [], b = t + e - 1, x = i[t].x, y = i[b].x - x;\n  for (r = t; r < t + e; ++r) {\n    a = i[r], l = (a.x - x) / y * s, c = a.y;\n    const _ = l | 0;\n    if (_ === h)\n      c < g ? (g = c, d = r) : c > p && (p = c, u = r), n = (o * n + a.x) / ++o;\n    else {\n      const M = r - 1;\n      if (!T(d) && !T(u)) {\n        const k = Math.min(d, u), S = Math.max(d, u);\n        k !== f && k !== M && m.push({\n          ...i[k],\n          x: n\n        }), S !== f && S !== M && m.push({\n          ...i[S],\n          x: n\n        });\n      }\n      r > 0 && M !== f && m.push(i[M]), m.push(a), h = _, o = 0, g = p = c, d = u = f = r;\n    }\n  }\n  return m;\n}\nfunction ro(i) {\n  if (i._decimated) {\n    const t = i._data;\n    delete i._decimated, delete i._data, Object.defineProperty(i, \"data\", { value: t });\n  }\n}\nfunction Ws(i) {\n  i.data.datasets.forEach((t) => {\n    ro(t);\n  });\n}\nfunction ql(i, t) {\n  const e = t.length;\n  let s = 0, n;\n  const { iScale: o } = i, { min: r, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();\n  return l && (s = Y(ft(t, o.axis, r).lo, 0, e - 1)), c ? n = Y(ft(t, o.axis, a).hi + 1, s, e) - s : n = e - s, { start: s, count: n };\n}\nvar ao = {\n  id: \"decimation\",\n  defaults: {\n    algorithm: \"min-max\",\n    enabled: !1\n  },\n  beforeElementsUpdate: (i, t, e) => {\n    if (!e.enabled) {\n      Ws(i);\n      return;\n    }\n    const s = i.width;\n    i.data.datasets.forEach((n, o) => {\n      const { _data: r, indexAxis: a } = n, l = i.getDatasetMeta(o), c = r || n.data;\n      if (Zt([a, i.options.indexAxis]) === \"y\" || !l.controller.supportsDecimation)\n        return;\n      const h = i.scales[l.xAxisID];\n      if (h.type !== \"linear\" && h.type !== \"time\" || i.options.parsing)\n        return;\n      let { start: d, count: u } = ql(l, c);\n      const f = e.threshold || 4 * s;\n      if (u <= f) {\n        ro(n);\n        return;\n      }\n      T(r) && (n._data = c, delete n.data, Object.defineProperty(n, \"data\", {\n        configurable: !0,\n        enumerable: !0,\n        get: function() {\n          return this._decimated;\n        },\n        set: function(p) {\n          this._data = p;\n        }\n      }));\n      let g;\n      switch (e.algorithm) {\n        case \"lttb\":\n          g = Ul(c, d, u, s, e);\n          break;\n        case \"min-max\":\n          g = Kl(c, d, u, s);\n          break;\n        default:\n          throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);\n      }\n      n._decimated = g;\n    });\n  },\n  destroy(i) {\n    Ws(i);\n  }\n};\nfunction Gl(i, t, e) {\n  const s = i.segments, n = i.points, o = t.points, r = [];\n  for (const a of s) {\n    let { start: l, end: c } = a;\n    c = $i(l, c, n);\n    const h = Pi(e, n[l], n[c], a.loop);\n    if (!t.segments) {\n      r.push({\n        source: a,\n        target: h,\n        start: n[l],\n        end: n[c]\n      });\n      continue;\n    }\n    const d = Fn(t, h);\n    for (const u of d) {\n      const f = Pi(e, o[u.start], o[u.end], u.loop), g = En(a, n, f);\n      for (const p of g)\n        r.push({\n          source: p,\n          target: u,\n          start: {\n            [e]: Ns(h, f, \"start\", Math.max)\n          },\n          end: {\n            [e]: Ns(h, f, \"end\", Math.min)\n          }\n        });\n    }\n  }\n  return r;\n}\nfunction Pi(i, t, e, s) {\n  if (s)\n    return;\n  let n = t[i], o = e[i];\n  return i === \"angle\" && (n = Z(n), o = Z(o)), { property: i, start: n, end: o };\n}\nfunction Zl(i, t) {\n  const { x: e = null, y: s = null } = i || {}, n = t.points, o = [];\n  return t.segments.forEach(({ start: r, end: a }) => {\n    a = $i(r, a, n);\n    const l = n[r], c = n[a];\n    s !== null ? (o.push({ x: l.x, y: s }), o.push({ x: c.x, y: s })) : e !== null && (o.push({ x: e, y: l.y }), o.push({ x: e, y: c.y }));\n  }), o;\n}\nfunction $i(i, t, e) {\n  for (; t > i; t--) {\n    const s = e[t];\n    if (!isNaN(s.x) && !isNaN(s.y))\n      break;\n  }\n  return t;\n}\nfunction Ns(i, t, e, s) {\n  return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;\n}\nfunction lo(i, t) {\n  let e = [], s = !1;\n  return z(i) ? (s = !0, e = i) : e = Zl(i, t), e.length ? new gt({\n    points: e,\n    options: { tension: 0 },\n    _loop: s,\n    _fullLoop: s\n  }) : null;\n}\nfunction Hs(i) {\n  return i && i.fill !== !1;\n}\nfunction Jl(i, t, e) {\n  let n = i[t].fill;\n  const o = [t];\n  let r;\n  if (!e)\n    return n;\n  for (; n !== !1 && o.indexOf(n) === -1; ) {\n    if (!N(n))\n      return n;\n    if (r = i[n], !r)\n      return !1;\n    if (r.visible)\n      return n;\n    o.push(n), n = r.fill;\n  }\n  return !1;\n}\nfunction Ql(i, t, e) {\n  const s = sc(i);\n  if (D(s))\n    return isNaN(s.value) ? !1 : s;\n  let n = parseFloat(s);\n  return N(n) && Math.floor(n) === n ? tc(s[0], t, n, e) : [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(s) >= 0 && s;\n}\nfunction tc(i, t, e, s) {\n  return (i === \"-\" || i === \"+\") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;\n}\nfunction ec(i, t) {\n  let e = null;\n  return i === \"start\" ? e = t.bottom : i === \"end\" ? e = t.top : D(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;\n}\nfunction ic(i, t, e) {\n  let s;\n  return i === \"start\" ? s = e : i === \"end\" ? s = t.options.reverse ? t.min : t.max : D(i) ? s = i.value : s = t.getBaseValue(), s;\n}\nfunction sc(i) {\n  const t = i.options, e = t.fill;\n  let s = C(e && e.target, e);\n  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? \"origin\" : s;\n}\nfunction nc(i) {\n  const { scale: t, index: e, line: s } = i, n = [], o = s.segments, r = s.points, a = oc(t, e);\n  a.push(lo({ x: null, y: t.bottom }, s));\n  for (let l = 0; l < o.length; l++) {\n    const c = o[l];\n    for (let h = c.start; h <= c.end; h++)\n      rc(n, r[h], a);\n  }\n  return new gt({ points: n, options: {} });\n}\nfunction oc(i, t) {\n  const e = [], s = i.getMatchingVisibleMetas(\"line\");\n  for (let n = 0; n < s.length; n++) {\n    const o = s[n];\n    if (o.index === t)\n      break;\n    o.hidden || e.unshift(o.dataset);\n  }\n  return e;\n}\nfunction rc(i, t, e) {\n  const s = [];\n  for (let n = 0; n < e.length; n++) {\n    const o = e[n], { first: r, last: a, point: l } = ac(o, t, \"x\");\n    if (!(!l || r && a)) {\n      if (r)\n        s.unshift(l);\n      else if (i.push(l), !a)\n        break;\n    }\n  }\n  i.push(...s);\n}\nfunction ac(i, t, e) {\n  const s = i.interpolate(t, e);\n  if (!s)\n    return {};\n  const n = s[e], o = i.segments, r = i.points;\n  let a = !1, l = !1;\n  for (let c = 0; c < o.length; c++) {\n    const h = o[c], d = r[h.start][e], u = r[h.end][e];\n    if (ut(n, d, u)) {\n      a = n === d, l = n === u;\n      break;\n    }\n  }\n  return { first: a, last: l, point: s };\n}\nclass co {\n  constructor(t) {\n    this.x = t.x, this.y = t.y, this.radius = t.radius;\n  }\n  pathSegment(t, e, s) {\n    const { x: n, y: o, radius: r } = this;\n    return e = e || { start: 0, end: F }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;\n  }\n  interpolate(t) {\n    const { x: e, y: s, radius: n } = this, o = t.angle;\n    return {\n      x: e + Math.cos(o) * n,\n      y: s + Math.sin(o) * n,\n      angle: o\n    };\n  }\n}\nfunction lc(i) {\n  const { chart: t, fill: e, line: s } = i;\n  if (N(e))\n    return cc(t, e);\n  if (e === \"stack\")\n    return nc(i);\n  if (e === \"shape\")\n    return !0;\n  const n = hc(i);\n  return n instanceof co ? n : lo(n, s);\n}\nfunction cc(i, t) {\n  const e = i.getDatasetMeta(t);\n  return e && i.isDatasetVisible(t) ? e.dataset : null;\n}\nfunction hc(i) {\n  return (i.scale || {}).getPointPositionForValue ? uc(i) : dc(i);\n}\nfunction dc(i) {\n  const { scale: t = {}, fill: e } = i, s = ec(e, t);\n  if (N(s)) {\n    const n = t.isHorizontal();\n    return {\n      x: n ? s : null,\n      y: n ? null : s\n    };\n  }\n  return null;\n}\nfunction uc(i) {\n  const { scale: t, fill: e } = i, s = t.options, n = t.getLabels().length, o = s.reverse ? t.max : t.min, r = ic(e, t, o), a = [];\n  if (s.grid.circular) {\n    const l = t.getPointPositionForValue(0, o);\n    return new co({\n      x: l.x,\n      y: l.y,\n      radius: t.getDistanceFromCenterForValue(r)\n    });\n  }\n  for (let l = 0; l < n; ++l)\n    a.push(t.getPointPositionForValue(l, r));\n  return a;\n}\nfunction mi(i, t, e) {\n  const s = lc(t), { line: n, scale: o, axis: r } = t, a = n.options, l = a.fill, c = a.backgroundColor, { above: h = c, below: d = c } = l || {};\n  s && n.points.length && (Xe(i, e), fc(i, { line: n, target: s, above: h, below: d, area: e, scale: o, axis: r }), Ue(i));\n}\nfunction fc(i, t) {\n  const { line: e, target: s, above: n, below: o, area: r, scale: a } = t, l = e._loop ? \"angle\" : t.axis;\n  i.save(), l === \"x\" && o !== n && (js(i, s, r.top), $s(i, { line: e, target: s, color: n, scale: a, property: l }), i.restore(), i.save(), js(i, s, r.bottom)), $s(i, { line: e, target: s, color: o, scale: a, property: l }), i.restore();\n}\nfunction js(i, t, e) {\n  const { segments: s, points: n } = t;\n  let o = !0, r = !1;\n  i.beginPath();\n  for (const a of s) {\n    const { start: l, end: c } = a, h = n[l], d = n[$i(l, c, n)];\n    o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, { move: r }), r ? i.closePath() : i.lineTo(d.x, e);\n  }\n  i.lineTo(t.first().x, e), i.closePath(), i.clip();\n}\nfunction $s(i, t) {\n  const { line: e, target: s, property: n, color: o, scale: r } = t, a = Gl(e, s, n);\n  for (const { source: l, target: c, start: h, end: d } of a) {\n    const { style: { backgroundColor: u = o } = {} } = l, f = s !== !0;\n    i.save(), i.fillStyle = u, gc(i, r, f && Pi(n, h, d)), i.beginPath();\n    const g = !!e.pathSegment(i, l);\n    let p;\n    if (f) {\n      g ? i.closePath() : Ys(i, s, d, n);\n      const m = !!s.pathSegment(i, c, { move: g, reverse: !0 });\n      p = g && m, p || Ys(i, s, h, n);\n    }\n    i.closePath(), i.fill(p ? \"evenodd\" : \"nonzero\"), i.restore();\n  }\n}\nfunction gc(i, t, e) {\n  const { top: s, bottom: n } = t.chart.chartArea, { property: o, start: r, end: a } = e || {};\n  o === \"x\" && (i.beginPath(), i.rect(r, s, a - r, n - s), i.clip());\n}\nfunction Ys(i, t, e, s) {\n  const n = t.interpolate(e, s);\n  n && i.lineTo(n.x, n.y);\n}\nvar ho = {\n  id: \"filler\",\n  afterDatasetsUpdate(i, t, e) {\n    const s = (i.data.datasets || []).length, n = [];\n    let o, r, a, l;\n    for (r = 0; r < s; ++r)\n      o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof gt && (l = {\n        visible: i.isDatasetVisible(r),\n        index: r,\n        fill: Ql(a, r, s),\n        chart: i,\n        axis: o.controller.options.indexAxis,\n        scale: o.vScale,\n        line: a\n      }), o.$filler = l, n.push(l);\n    for (r = 0; r < s; ++r)\n      l = n[r], !(!l || l.fill === !1) && (l.fill = Jl(n, r, e.propagate));\n  },\n  beforeDraw(i, t, e) {\n    const s = e.drawTime === \"beforeDraw\", n = i.getSortedVisibleDatasetMetas(), o = i.chartArea;\n    for (let r = n.length - 1; r >= 0; --r) {\n      const a = n[r].$filler;\n      a && (a.line.updateControlPoints(o, a.axis), s && a.fill && mi(i.ctx, a, o));\n    }\n  },\n  beforeDatasetsDraw(i, t, e) {\n    if (e.drawTime !== \"beforeDatasetsDraw\")\n      return;\n    const s = i.getSortedVisibleDatasetMetas();\n    for (let n = s.length - 1; n >= 0; --n) {\n      const o = s[n].$filler;\n      Hs(o) && mi(i.ctx, o, i.chartArea);\n    }\n  },\n  beforeDatasetDraw(i, t, e) {\n    const s = t.meta.$filler;\n    !Hs(s) || e.drawTime !== \"beforeDatasetDraw\" || mi(i.ctx, s, i.chartArea);\n  },\n  defaults: {\n    propagate: !0,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nconst Xs = (i, t) => {\n  let { boxHeight: e = t, boxWidth: s = t } = i;\n  return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {\n    boxWidth: s,\n    boxHeight: e,\n    itemHeight: Math.max(t, e)\n  };\n}, pc = (i, t) => i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;\nclass Us extends st {\n  constructor(t) {\n    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n  }\n  update(t, e, s) {\n    this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();\n  }\n  setDimensions() {\n    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n  }\n  buildLabels() {\n    const t = this.options.labels || {};\n    let e = I(t.generateLabels, [this.chart], this) || [];\n    t.filter && (e = e.filter((s) => t.filter(s, this.chart.data))), t.sort && (e = e.sort((s, n) => t.sort(s, n, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n  }\n  fit() {\n    const { options: t, ctx: e } = this;\n    if (!t.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const s = t.labels, n = $(s.font), o = n.size, r = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Xs(s, o);\n    let c, h;\n    e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, o, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n  }\n  _fitRows(t, e, s, n) {\n    const { ctx: o, maxWidth: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], h = n + a;\n    let d = t;\n    o.textAlign = \"left\", o.textBaseline = \"middle\";\n    let u = -1, f = -h;\n    return this.legendItems.forEach((g, p) => {\n      const m = s + e / 2 + o.measureText(g.text).width;\n      (p === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (p > 0 ? 0 : 1)] = 0, f += h, u++), l[p] = { left: 0, top: f, row: u, width: m, height: n }, c[c.length - 1] += m + a;\n    }), d;\n  }\n  _fitCols(t, e, s, n) {\n    const { ctx: o, maxHeight: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = r - t;\n    let d = a, u = 0, f = 0, g = 0, p = 0;\n    return this.legendItems.forEach((m, b) => {\n      const x = s + e / 2 + o.measureText(m.text).width;\n      b > 0 && f + n + 2 * a > h && (d += u + a, c.push({ width: u, height: f }), g += u + a, p++, u = f = 0), l[b] = { left: g, top: f, col: p, width: x, height: n }, u = Math.max(u, x), f += n + a;\n    }), d += u, c.push({ width: u, height: f }), d;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display)\n      return;\n    const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: s, labels: { padding: n }, rtl: o } } = this, r = zt(o, this.left, this.width);\n    if (this.isHorizontal()) {\n      let a = 0, l = U(s, this.left + n, this.right - this.lineWidths[a]);\n      for (const c of e)\n        a !== c.row && (a = c.row, l = U(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;\n    } else {\n      let a = 0, l = U(s, this.top + t + n, this.bottom - this.columnSizes[a].height);\n      for (const c of e)\n        c.col !== a && (a = c.col, l = U(s, this.top + t + n, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + n, c.left = r.leftForLtr(r.x(c.left), c.width), l += c.height + n;\n    }\n  }\n  isHorizontal() {\n    return this.options.position === \"top\" || this.options.position === \"bottom\";\n  }\n  draw() {\n    if (this.options.display) {\n      const t = this.ctx;\n      Xe(t, this), this._draw(), Ue(t);\n    }\n  }\n  _draw() {\n    const { options: t, columnSizes: e, lineWidths: s, ctx: n } = this, { align: o, labels: r } = t, a = O.color, l = zt(t.rtl, this.left, this.width), c = $(r.font), { color: h, padding: d } = r, u = c.size, f = u / 2;\n    let g;\n    this.drawTitle(), n.textAlign = l.textAlign(\"left\"), n.textBaseline = \"middle\", n.lineWidth = 0.5, n.font = c.string;\n    const { boxWidth: p, boxHeight: m, itemHeight: b } = Xs(r, u), x = function(k, S, w) {\n      if (isNaN(p) || p <= 0 || isNaN(m) || m < 0)\n        return;\n      n.save();\n      const L = C(w.lineWidth, 1);\n      if (n.fillStyle = C(w.fillStyle, a), n.lineCap = C(w.lineCap, \"butt\"), n.lineDashOffset = C(w.lineDashOffset, 0), n.lineJoin = C(w.lineJoin, \"miter\"), n.lineWidth = L, n.strokeStyle = C(w.strokeStyle, a), n.setLineDash(C(w.lineDash, [])), r.usePointStyle) {\n        const R = {\n          radius: m * Math.SQRT2 / 2,\n          pointStyle: w.pointStyle,\n          rotation: w.rotation,\n          borderWidth: L\n        }, A = l.xPlus(k, p / 2), H = S + f;\n        Mn(n, R, A, H, r.pointStyleWidth && p);\n      } else {\n        const R = S + Math.max((u - m) / 2, 0), A = l.leftForLtr(k, p), H = Dt(w.borderRadius);\n        n.beginPath(), Object.values(H).some((q) => q !== 0) ? ae(n, {\n          x: A,\n          y: R,\n          w: p,\n          h: m,\n          radius: H\n        }) : n.rect(A, R, p, m), n.fill(), L !== 0 && n.stroke();\n      }\n      n.restore();\n    }, v = function(k, S, w) {\n      Tt(n, w.text, k, S + b / 2, c, {\n        strikethrough: w.hidden,\n        textAlign: l.textAlign(w.textAlign)\n      });\n    }, y = this.isHorizontal(), _ = this._computeTitleHeight();\n    y ? g = {\n      x: U(o, this.left + d, this.right - s[0]),\n      y: this.top + d + _,\n      line: 0\n    } : g = {\n      x: this.left + d,\n      y: U(o, this.top + _ + d, this.bottom - e[0].height),\n      line: 0\n    }, Tn(this.ctx, t.textDirection);\n    const M = b + d;\n    this.legendItems.forEach((k, S) => {\n      n.strokeStyle = k.fontColor || h, n.fillStyle = k.fontColor || h;\n      const w = n.measureText(k.text).width, L = l.textAlign(k.textAlign || (k.textAlign = r.textAlign)), R = p + f + w;\n      let A = g.x, H = g.y;\n      l.setWidth(this.width), y ? S > 0 && A + R + d > this.right && (H = g.y += M, g.line++, A = g.x = U(o, this.left + d, this.right - s[g.line])) : S > 0 && H + M > this.bottom && (A = g.x = A + e[g.line].width + d, g.line++, H = g.y = U(o, this.top + _ + d, this.bottom - e[g.line].height));\n      const q = l.x(A);\n      x(q, H, k), A = Io(L, A + p + f, y ? A + R : this.right, t.rtl), v(l.x(A), H, k), y ? g.x += R + d : g.y += M;\n    }), Ln(this.ctx, t.textDirection);\n  }\n  drawTitle() {\n    const t = this.options, e = t.title, s = $(e.font), n = K(e.padding);\n    if (!e.display)\n      return;\n    const o = zt(t.rtl, this.left, this.width), r = this.ctx, a = e.position, l = s.size / 2, c = n.top + l;\n    let h, d = this.left, u = this.width;\n    if (this.isHorizontal())\n      u = Math.max(...this.lineWidths), h = this.top + c, d = U(t.align, d, this.right - u);\n    else {\n      const g = this.columnSizes.reduce((p, m) => Math.max(p, m.height), 0);\n      h = c + U(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());\n    }\n    const f = U(a, d, d + u);\n    r.textAlign = o.textAlign(Li(a)), r.textBaseline = \"middle\", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, Tt(r, e.text, f, h, s);\n  }\n  _computeTitleHeight() {\n    const t = this.options.title, e = $(t.font), s = K(t.padding);\n    return t.display ? e.lineHeight + s.height : 0;\n  }\n  _getLegendItemAt(t, e) {\n    let s, n, o;\n    if (ut(t, this.left, this.right) && ut(e, this.top, this.bottom)) {\n      for (o = this.legendHitBoxes, s = 0; s < o.length; ++s)\n        if (n = o[s], ut(t, n.left, n.left + n.width) && ut(e, n.top, n.top + n.height))\n          return this.legendItems[s];\n    }\n    return null;\n  }\n  handleEvent(t) {\n    const e = this.options;\n    if (!mc(t.type, e))\n      return;\n    const s = this._getLegendItemAt(t.x, t.y);\n    if (t.type === \"mousemove\" || t.type === \"mouseout\") {\n      const n = this._hoveredItem, o = pc(n, s);\n      n && !o && I(e.onLeave, [t, n, this], this), this._hoveredItem = s, s && !o && I(e.onHover, [t, s, this], this);\n    } else\n      s && I(e.onClick, [t, s, this], this);\n  }\n}\nfunction mc(i, t) {\n  return !!((i === \"mousemove\" || i === \"mouseout\") && (t.onHover || t.onLeave) || t.onClick && (i === \"click\" || i === \"mouseup\"));\n}\nvar uo = {\n  id: \"legend\",\n  _element: Us,\n  start(i, t, e) {\n    const s = i.legend = new Us({ ctx: i.ctx, options: e, chart: i });\n    X.configure(i, s, e), X.addBox(i, s);\n  },\n  stop(i) {\n    X.removeBox(i, i.legend), delete i.legend;\n  },\n  beforeUpdate(i, t, e) {\n    const s = i.legend;\n    X.configure(i, s, e), s.options = e;\n  },\n  afterUpdate(i) {\n    const t = i.legend;\n    t.buildLabels(), t.adjustHitBoxes();\n  },\n  afterEvent(i, t) {\n    t.replay || i.legend.handleEvent(t.event);\n  },\n  defaults: {\n    display: !0,\n    position: \"top\",\n    align: \"center\",\n    fullSize: !0,\n    reverse: !1,\n    weight: 1e3,\n    onClick(i, t, e) {\n      const s = t.datasetIndex, n = e.chart;\n      n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (i) => i.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(i) {\n        const t = i.data.datasets, { labels: { usePointStyle: e, pointStyle: s, textAlign: n, color: o } } = i.legend.options;\n        return i._getSortedDatasetMetas().map((r) => {\n          const a = r.controller.getStyle(e ? 0 : void 0), l = K(a.borderWidth);\n          return {\n            text: t[r.index].label,\n            fillStyle: a.backgroundColor,\n            fontColor: o,\n            hidden: !r.visible,\n            lineCap: a.borderCapStyle,\n            lineDash: a.borderDash,\n            lineDashOffset: a.borderDashOffset,\n            lineJoin: a.borderJoinStyle,\n            lineWidth: (l.width + l.height) / 4,\n            strokeStyle: a.borderColor,\n            pointStyle: s || a.pointStyle,\n            rotation: a.rotation,\n            textAlign: n || a.textAlign,\n            borderRadius: 0,\n            datasetIndex: r.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (i) => i.chart.options.color,\n      display: !1,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: (i) => !i.startsWith(\"on\"),\n    labels: {\n      _scriptable: (i) => ![\"generateLabels\", \"filter\", \"sort\"].includes(i)\n    }\n  }\n};\nclass Yi extends st {\n  constructor(t) {\n    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n  }\n  update(t, e) {\n    const s = this.options;\n    if (this.left = 0, this.top = 0, !s.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = t, this.height = this.bottom = e;\n    const n = z(s.text) ? s.text.length : 1;\n    this._padding = K(s.padding);\n    const o = n * $(s.font).lineHeight + this._padding.height;\n    this.isHorizontal() ? this.height = o : this.width = o;\n  }\n  isHorizontal() {\n    const t = this.options.position;\n    return t === \"top\" || t === \"bottom\";\n  }\n  _drawArgs(t) {\n    const { top: e, left: s, bottom: n, right: o, options: r } = this, a = r.align;\n    let l = 0, c, h, d;\n    return this.isHorizontal() ? (h = U(a, s, o), d = e + t, c = o - s) : (r.position === \"left\" ? (h = s + t, d = U(a, n, e), l = B * -0.5) : (h = o - t, d = U(a, e, n), l = B * 0.5), c = n - e), { titleX: h, titleY: d, maxWidth: c, rotation: l };\n  }\n  draw() {\n    const t = this.ctx, e = this.options;\n    if (!e.display)\n      return;\n    const s = $(e.font), o = s.lineHeight / 2 + this._padding.top, { titleX: r, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);\n    Tt(t, e.text, 0, 0, s, {\n      color: e.color,\n      maxWidth: l,\n      rotation: c,\n      textAlign: Li(e.align),\n      textBaseline: \"middle\",\n      translation: [r, a]\n    });\n  }\n}\nfunction bc(i, t) {\n  const e = new Yi({\n    ctx: i.ctx,\n    options: t,\n    chart: i\n  });\n  X.configure(i, e, t), X.addBox(i, e), i.titleBlock = e;\n}\nvar fo = {\n  id: \"title\",\n  _element: Yi,\n  start(i, t, e) {\n    bc(i, e);\n  },\n  stop(i) {\n    const t = i.titleBlock;\n    X.removeBox(i, t), delete i.titleBlock;\n  },\n  beforeUpdate(i, t, e) {\n    const s = i.titleBlock;\n    X.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: !0,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2e3\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nconst Re = /* @__PURE__ */ new WeakMap();\nvar go = {\n  id: \"subtitle\",\n  start(i, t, e) {\n    const s = new Yi({\n      ctx: i.ctx,\n      options: e,\n      chart: i\n    });\n    X.configure(i, s, e), X.addBox(i, s), Re.set(i, s);\n  },\n  stop(i) {\n    X.removeBox(i, Re.get(i)), Re.delete(i);\n  },\n  beforeUpdate(i, t, e) {\n    const s = Re.get(i);\n    X.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"normal\"\n    },\n    fullSize: !0,\n    padding: 0,\n    position: \"top\",\n    text: \"\",\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nconst se = {\n  average(i) {\n    if (!i.length)\n      return !1;\n    let t, e, s = 0, n = 0, o = 0;\n    for (t = 0, e = i.length; t < e; ++t) {\n      const r = i[t].element;\n      if (r && r.hasValue()) {\n        const a = r.tooltipPosition();\n        s += a.x, n += a.y, ++o;\n      }\n    }\n    return {\n      x: s / o,\n      y: n / o\n    };\n  },\n  nearest(i, t) {\n    if (!i.length)\n      return !1;\n    let e = t.x, s = t.y, n = Number.POSITIVE_INFINITY, o, r, a;\n    for (o = 0, r = i.length; o < r; ++o) {\n      const l = i[o].element;\n      if (l && l.hasValue()) {\n        const c = l.getCenterPoint(), h = bi(t, c);\n        h < n && (n = h, a = l);\n      }\n    }\n    if (a) {\n      const l = a.tooltipPosition();\n      e = l.x, s = l.y;\n    }\n    return {\n      x: e,\n      y: s\n    };\n  }\n};\nfunction rt(i, t) {\n  return t && (z(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;\n}\nfunction ht(i) {\n  return (typeof i == \"string\" || i instanceof String) && i.indexOf(`\n`) > -1 ? i.split(`\n`) : i;\n}\nfunction xc(i, t) {\n  const { element: e, datasetIndex: s, index: n } = t, o = i.getDatasetMeta(s).controller, { label: r, value: a } = o.getLabelAndValue(n);\n  return {\n    chart: i,\n    label: r,\n    parsed: o.getParsed(n),\n    raw: i.data.datasets[s].data[n],\n    formattedValue: a,\n    dataset: o.getDataset(),\n    dataIndex: n,\n    datasetIndex: s,\n    element: e\n  };\n}\nfunction Ks(i, t) {\n  const e = i.chart.ctx, { body: s, footer: n, title: o } = i, { boxWidth: r, boxHeight: a } = t, l = $(t.bodyFont), c = $(t.titleFont), h = $(t.footerFont), d = o.length, u = n.length, f = s.length, g = K(t.padding);\n  let p = g.height, m = 0, b = s.reduce((y, _) => y + _.before.length + _.lines.length + _.after.length, 0);\n  if (b += i.beforeBody.length + i.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {\n    const y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;\n    p += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;\n  }\n  u && (p += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);\n  let x = 0;\n  const v = function(y) {\n    m = Math.max(m, e.measureText(y).width + x);\n  };\n  return e.save(), e.font = c.string, E(i.title, v), e.font = l.string, E(i.beforeBody.concat(i.afterBody), v), x = t.displayColors ? r + 2 + t.boxPadding : 0, E(s, (y) => {\n    E(y.before, v), E(y.lines, v), E(y.after, v);\n  }), x = 0, e.font = h.string, E(i.footer, v), e.restore(), m += g.width, { width: m, height: p };\n}\nfunction _c(i, t) {\n  const { y: e, height: s } = t;\n  return e < s / 2 ? \"top\" : e > i.height - s / 2 ? \"bottom\" : \"center\";\n}\nfunction yc(i, t, e, s) {\n  const { x: n, width: o } = s, r = e.caretSize + e.caretPadding;\n  if (i === \"left\" && n + o + r > t.width || i === \"right\" && n - o - r < 0)\n    return !0;\n}\nfunction vc(i, t, e, s) {\n  const { x: n, width: o } = e, { width: r, chartArea: { left: a, right: l } } = i;\n  let c = \"center\";\n  return s === \"center\" ? c = n <= (a + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? c = \"left\" : n >= r - o / 2 && (c = \"right\"), yc(c, i, t, e) && (c = \"center\"), c;\n}\nfunction qs(i, t, e) {\n  const s = e.yAlign || t.yAlign || _c(i, e);\n  return {\n    xAlign: e.xAlign || t.xAlign || vc(i, t, e, s),\n    yAlign: s\n  };\n}\nfunction Mc(i, t) {\n  let { x: e, width: s } = i;\n  return t === \"right\" ? e -= s : t === \"center\" && (e -= s / 2), e;\n}\nfunction kc(i, t, e) {\n  let { y: s, height: n } = i;\n  return t === \"top\" ? s += e : t === \"bottom\" ? s -= n + e : s -= n / 2, s;\n}\nfunction Gs(i, t, e, s) {\n  const { caretSize: n, caretPadding: o, cornerRadius: r } = i, { xAlign: a, yAlign: l } = e, c = n + o, { topLeft: h, topRight: d, bottomLeft: u, bottomRight: f } = Dt(r);\n  let g = Mc(t, a);\n  const p = kc(t, l, c);\n  return l === \"center\" ? a === \"left\" ? g += c : a === \"right\" && (g -= c) : a === \"left\" ? g -= Math.max(h, u) + n : a === \"right\" && (g += Math.max(d, f) + n), {\n    x: Y(g, 0, s.width - t.width),\n    y: Y(p, 0, s.height - t.height)\n  };\n}\nfunction Ee(i, t, e) {\n  const s = K(e.padding);\n  return t === \"center\" ? i.x + i.width / 2 : t === \"right\" ? i.x + i.width - s.right : i.x + s.left;\n}\nfunction Zs(i) {\n  return rt([], ht(i));\n}\nfunction wc(i, t, e) {\n  return vt(i, {\n    tooltip: t,\n    tooltipItems: e,\n    type: \"tooltip\"\n  });\n}\nfunction Js(i, t) {\n  const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;\n  return e ? i.override(e) : i;\n}\nclass Ci extends st {\n  constructor(t) {\n    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n  }\n  initialize(t) {\n    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n  }\n  _resolveAnimations() {\n    const t = this._cachedAnimations;\n    if (t)\n      return t;\n    const e = this.chart, s = this.options.setContext(this.getContext()), n = s.enabled && e.options.animation && s.animations, o = new Ni(this.chart, n);\n    return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;\n  }\n  getContext() {\n    return this.$context || (this.$context = wc(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(t, e) {\n    const { callbacks: s } = e, n = s.beforeTitle.apply(this, [t]), o = s.title.apply(this, [t]), r = s.afterTitle.apply(this, [t]);\n    let a = [];\n    return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;\n  }\n  getBeforeBody(t, e) {\n    return Zs(e.callbacks.beforeBody.apply(this, [t]));\n  }\n  getBody(t, e) {\n    const { callbacks: s } = e, n = [];\n    return E(t, (o) => {\n      const r = {\n        before: [],\n        lines: [],\n        after: []\n      }, a = Js(s, o);\n      rt(r.before, ht(a.beforeLabel.call(this, o))), rt(r.lines, a.label.call(this, o)), rt(r.after, ht(a.afterLabel.call(this, o))), n.push(r);\n    }), n;\n  }\n  getAfterBody(t, e) {\n    return Zs(e.callbacks.afterBody.apply(this, [t]));\n  }\n  getFooter(t, e) {\n    const { callbacks: s } = e, n = s.beforeFooter.apply(this, [t]), o = s.footer.apply(this, [t]), r = s.afterFooter.apply(this, [t]);\n    let a = [];\n    return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;\n  }\n  _createItems(t) {\n    const e = this._active, s = this.chart.data, n = [], o = [], r = [];\n    let a = [], l, c;\n    for (l = 0, c = e.length; l < c; ++l)\n      a.push(xc(this.chart, e[l]));\n    return t.filter && (a = a.filter((h, d, u) => t.filter(h, d, u, s))), t.itemSort && (a = a.sort((h, d) => t.itemSort(h, d, s))), E(a, (h) => {\n      const d = Js(t.callbacks, h);\n      n.push(d.labelColor.call(this, h)), o.push(d.labelPointStyle.call(this, h)), r.push(d.labelTextColor.call(this, h));\n    }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;\n  }\n  update(t, e) {\n    const s = this.options.setContext(this.getContext()), n = this._active;\n    let o, r = [];\n    if (!n.length)\n      this.opacity !== 0 && (o = {\n        opacity: 0\n      });\n    else {\n      const a = se[s.position].call(this, n, this._eventPosition);\n      r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);\n      const l = this._size = Ks(this, s), c = Object.assign({}, a, l), h = qs(this.chart, s, c), d = Gs(s, c, h, this.chart);\n      this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {\n        opacity: 1,\n        x: d.x,\n        y: d.y,\n        width: l.width,\n        height: l.height,\n        caretX: a.x,\n        caretY: a.y\n      };\n    }\n    this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, { chart: this.chart, tooltip: this, replay: e });\n  }\n  drawCaret(t, e, s, n) {\n    const o = this.getCaretPosition(t, s, n);\n    e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);\n  }\n  getCaretPosition(t, e, s) {\n    const { xAlign: n, yAlign: o } = this, { caretSize: r, cornerRadius: a } = s, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: d } = Dt(a), { x: u, y: f } = t, { width: g, height: p } = e;\n    let m, b, x, v, y, _;\n    return o === \"center\" ? (y = f + p / 2, n === \"left\" ? (m = u, b = m - r, v = y + r, _ = y - r) : (m = u + g, b = m + r, v = y - r, _ = y + r), x = m) : (n === \"left\" ? b = u + Math.max(l, h) + r : n === \"right\" ? b = u + g - Math.max(c, d) - r : b = this.caretX, o === \"top\" ? (v = f, y = v - r, m = b - r, x = b + r) : (v = f + p, y = v + r, m = b + r, x = b - r), _ = v), { x1: m, x2: b, x3: x, y1: v, y2: y, y3: _ };\n  }\n  drawTitle(t, e, s) {\n    const n = this.title, o = n.length;\n    let r, a, l;\n    if (o) {\n      const c = zt(s.rtl, this.x, this.width);\n      for (t.x = Ee(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = \"middle\", r = $(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l)\n        e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);\n    }\n  }\n  _drawColorBox(t, e, s, n, o) {\n    const r = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: c, boxPadding: h } = o, d = $(o.bodyFont), u = Ee(this, \"left\", o), f = n.x(u), g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, p = e.y + g;\n    if (o.usePointStyle) {\n      const m = {\n        radius: Math.min(c, l) / 2,\n        pointStyle: a.pointStyle,\n        rotation: a.rotation,\n        borderWidth: 1\n      }, b = n.leftForLtr(f, c) + c / 2, x = p + l / 2;\n      t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, yi(t, m, b, x), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, yi(t, m, b, x);\n    } else {\n      t.lineWidth = D(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;\n      const m = n.leftForLtr(f, c - h), b = n.leftForLtr(n.xPlus(f, 1), c - h - 2), x = Dt(r.borderRadius);\n      Object.values(x).some((v) => v !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ae(t, {\n        x: m,\n        y: p,\n        w: c,\n        h: l,\n        radius: x\n      }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), ae(t, {\n        x: b,\n        y: p + 1,\n        w: c - 2,\n        h: l - 2,\n        radius: x\n      }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, p, c, l), t.strokeRect(m, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(b, p + 1, c - 2, l - 2));\n    }\n    t.fillStyle = this.labelTextColors[s];\n  }\n  drawBody(t, e, s) {\n    const { body: n } = this, { bodySpacing: o, bodyAlign: r, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: h } = s, d = $(s.bodyFont);\n    let u = d.lineHeight, f = 0;\n    const g = zt(s.rtl, this.x, this.width), p = function(S) {\n      e.fillText(S, g.x(t.x + f), t.y + u / 2), t.y += u + o;\n    }, m = g.textAlign(r);\n    let b, x, v, y, _, M, k;\n    for (e.textAlign = r, e.textBaseline = \"middle\", e.font = d.string, t.x = Ee(this, m, s), e.fillStyle = s.bodyColor, E(this.beforeBody, p), f = a && m !== \"right\" ? r === \"center\" ? c / 2 + h : c + 2 + h : 0, y = 0, M = n.length; y < M; ++y) {\n      for (b = n[y], x = this.labelTextColors[y], e.fillStyle = x, E(b.before, p), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, g, s), u = Math.max(d.lineHeight, l)), _ = 0, k = v.length; _ < k; ++_)\n        p(v[_]), u = d.lineHeight;\n      E(b.after, p);\n    }\n    f = 0, u = d.lineHeight, E(this.afterBody, p), t.y -= o;\n  }\n  drawFooter(t, e, s) {\n    const n = this.footer, o = n.length;\n    let r, a;\n    if (o) {\n      const l = zt(s.rtl, this.x, this.width);\n      for (t.x = Ee(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = \"middle\", r = $(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a)\n        e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;\n    }\n  }\n  drawBackground(t, e, s, n) {\n    const { xAlign: o, yAlign: r } = this, { x: a, y: l } = t, { width: c, height: h } = s, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: g } = Dt(n.cornerRadius);\n    e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === \"top\" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === \"center\" && o === \"right\" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - g), e.quadraticCurveTo(a + c, l + h, a + c - g, l + h), r === \"bottom\" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === \"center\" && o === \"left\" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();\n  }\n  _updateAnimationTarget(t) {\n    const e = this.chart, s = this.$animations, n = s && s.x, o = s && s.y;\n    if (n || o) {\n      const r = se[t.position].call(this, this._active, this._eventPosition);\n      if (!r)\n        return;\n      const a = this._size = Ks(this, t), l = Object.assign({}, r, this._size), c = qs(e, t, l), h = Gs(t, l, c, e);\n      (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(t) {\n    const e = this.options.setContext(this.getContext());\n    let s = this.opacity;\n    if (!s)\n      return;\n    this._updateAnimationTarget(e);\n    const n = {\n      width: this.width,\n      height: this.height\n    }, o = {\n      x: this.x,\n      y: this.y\n    };\n    s = Math.abs(s) < 1e-3 ? 0 : s;\n    const r = K(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Tn(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), Ln(t, e.textDirection), t.restore());\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(t, e) {\n    const s = this._active, n = t.map(({ datasetIndex: a, index: l }) => {\n      const c = this.chart.getDatasetMeta(a);\n      if (!c)\n        throw new Error(\"Cannot find a dataset at index \" + a);\n      return {\n        datasetIndex: a,\n        element: c.data[l],\n        index: l\n      };\n    }), o = !ze(s, n), r = this._positionChanged(n, e);\n    (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n  }\n  handleEvent(t, e, s = !0) {\n    if (e && this._ignoreReplayEvents)\n      return !1;\n    this._ignoreReplayEvents = !1;\n    const n = this.options, o = this._active || [], r = this._getActiveElements(t, o, e, s), a = this._positionChanged(r, t), l = e || !ze(r, o) || a;\n    return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {\n      x: t.x,\n      y: t.y\n    }, this.update(!0, e))), l;\n  }\n  _getActiveElements(t, e, s, n) {\n    const o = this.options;\n    if (t.type === \"mouseout\")\n      return [];\n    if (!n)\n      return e;\n    const r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);\n    return o.reverse && r.reverse(), r;\n  }\n  _positionChanged(t, e) {\n    const { caretX: s, caretY: n, options: o } = this, r = se[o.position].call(this, t, e);\n    return r !== !1 && (s !== r.x || n !== r.y);\n  }\n}\nCi.positioners = se;\nvar po = {\n  id: \"tooltip\",\n  _element: Ci,\n  positioners: se,\n  afterInit(i, t, e) {\n    e && (i.tooltip = new Ci({ chart: i, options: e }));\n  },\n  beforeUpdate(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  reset(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  afterDraw(i) {\n    const t = i.tooltip;\n    if (t && t._willRender()) {\n      const e = {\n        tooltip: t\n      };\n      if (i.notifyPlugins(\"beforeTooltipDraw\", e) === !1)\n        return;\n      t.draw(i.ctx), i.notifyPlugins(\"afterTooltipDraw\", e);\n    }\n  },\n  afterEvent(i, t) {\n    if (i.tooltip) {\n      const e = t.replay;\n      i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);\n    }\n  },\n  defaults: {\n    enabled: !0,\n    external: null,\n    position: \"average\",\n    backgroundColor: \"rgba(0,0,0,0.8)\",\n    titleColor: \"#fff\",\n    titleFont: {\n      weight: \"bold\"\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: \"left\",\n    bodyColor: \"#fff\",\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: \"left\",\n    footerColor: \"#fff\",\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: \"bold\"\n    },\n    footerAlign: \"left\",\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (i, t) => t.bodyFont.size,\n    boxWidth: (i, t) => t.bodyFont.size,\n    multiKeyBackground: \"#fff\",\n    displayColors: !0,\n    boxPadding: 0,\n    borderColor: \"rgba(0,0,0,0)\",\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: \"easeOutQuart\"\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n      },\n      opacity: {\n        easing: \"linear\",\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: ct,\n      title(i) {\n        if (i.length > 0) {\n          const t = i[0], e = t.chart.data.labels, s = e ? e.length : 0;\n          if (this && this.options && this.options.mode === \"dataset\")\n            return t.dataset.label || \"\";\n          if (t.label)\n            return t.label;\n          if (s > 0 && t.dataIndex < s)\n            return e[t.dataIndex];\n        }\n        return \"\";\n      },\n      afterTitle: ct,\n      beforeBody: ct,\n      beforeLabel: ct,\n      label(i) {\n        if (this && this.options && this.options.mode === \"dataset\")\n          return i.label + \": \" + i.formattedValue || i.formattedValue;\n        let t = i.dataset.label || \"\";\n        t && (t += \": \");\n        const e = i.formattedValue;\n        return T(e) || (t += e), t;\n      },\n      labelColor(i) {\n        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n        return {\n          borderColor: e.borderColor,\n          backgroundColor: e.backgroundColor,\n          borderWidth: e.borderWidth,\n          borderDash: e.borderDash,\n          borderDashOffset: e.borderDashOffset,\n          borderRadius: 0\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(i) {\n        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n        return {\n          pointStyle: e.pointStyle,\n          rotation: e.rotation\n        };\n      },\n      afterLabel: ct,\n      afterBody: ct,\n      beforeFooter: ct,\n      footer: ct,\n      afterFooter: ct\n    }\n  },\n  defaultRoutes: {\n    bodyFont: \"font\",\n    footerFont: \"font\",\n    titleFont: \"font\"\n  },\n  descriptors: {\n    _scriptable: (i) => i !== \"filter\" && i !== \"itemSort\" && i !== \"external\",\n    _indexable: !1,\n    callbacks: {\n      _scriptable: !1,\n      _indexable: !1\n    },\n    animation: {\n      _fallback: !1\n    },\n    animations: {\n      _fallback: \"animation\"\n    }\n  },\n  additionalOptionScopes: [\"interaction\"]\n}, mo = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  Decimation: ao,\n  Filler: ho,\n  Legend: uo,\n  SubTitle: go,\n  Title: fo,\n  Tooltip: po\n});\nconst Sc = (i, t, e, s) => (typeof t == \"string\" ? (e = i.push(t) - 1, s.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e);\nfunction Pc(i, t, e, s) {\n  const n = i.indexOf(t);\n  if (n === -1)\n    return Sc(i, t, e, s);\n  const o = i.lastIndexOf(t);\n  return n !== o ? e : n;\n}\nconst Cc = (i, t) => i === null ? null : Y(Math.round(i), 0, t);\nclass ce extends Mt {\n  constructor(t) {\n    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n  }\n  init(t) {\n    const e = this._addedLabels;\n    if (e.length) {\n      const s = this.getLabels();\n      for (const { index: n, label: o } of e)\n        s[n] === o && s.splice(n, 1);\n      this._addedLabels = [];\n    }\n    super.init(t);\n  }\n  parse(t, e) {\n    if (T(t))\n      return null;\n    const s = this.getLabels();\n    return e = isFinite(e) && s[e] === t ? e : Pc(s, t, C(e, t), this._addedLabels), Cc(e, s.length - 1);\n  }\n  determineDataLimits() {\n    const { minDefined: t, maxDefined: e } = this.getUserBounds();\n    let { min: s, max: n } = this.getMinMax(!0);\n    this.options.bounds === \"ticks\" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;\n  }\n  buildTicks() {\n    const t = this.min, e = this.max, s = this.options.offset, n = [];\n    let o = this.getLabels();\n    o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);\n    for (let r = t; r <= e; r++)\n      n.push({ value: r });\n    return n;\n  }\n  getLabelForValue(t) {\n    const e = this.getLabels();\n    return t >= 0 && t < e.length ? e[t] : t;\n  }\n  configure() {\n    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n  }\n  getPixelForValue(t) {\n    return typeof t != \"number\" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(t) {\n    const e = this.ticks;\n    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n  }\n  getValueForPixel(t) {\n    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nce.id = \"category\";\nce.defaults = {\n  ticks: {\n    callback: ce.prototype.getLabelForValue\n  }\n};\nfunction Dc(i, t) {\n  const e = [], { bounds: n, step: o, min: r, max: a, precision: l, count: c, maxTicks: h, maxDigits: d, includeBounds: u } = i, f = o || 1, g = h - 1, { min: p, max: m } = t, b = !T(r), x = !T(a), v = !T(c), y = (m - p) / (d + 1);\n  let _ = qi((m - p) / g / f) * f, M, k, S, w;\n  if (_ < 1e-14 && !b && !x)\n    return [{ value: p }, { value: m }];\n  w = Math.ceil(m / _) - Math.floor(p / _), w > g && (_ = qi(w * _ / g / f) * f), T(l) || (M = Math.pow(10, l), _ = Math.ceil(_ * M) / M), n === \"ticks\" ? (k = Math.floor(p / _) * _, S = Math.ceil(m / _) * _) : (k = p, S = m), b && x && o && Oo((a - r) / o, _ / 1e3) ? (w = Math.round(Math.min((a - r) / _, h)), _ = (a - r) / w, k = r, S = a) : v ? (k = b ? r : k, S = x ? a : S, w = c - 1, _ = (S - k) / w) : (w = (S - k) / _, te(w, Math.round(w), _ / 1e3) ? w = Math.round(w) : w = Math.ceil(w));\n  const L = Math.max(\n    Gi(_),\n    Gi(k)\n  );\n  M = Math.pow(10, T(l) ? L : l), k = Math.round(k * M) / M, S = Math.round(S * M) / M;\n  let R = 0;\n  for (b && (u && k !== r ? (e.push({ value: r }), k < r && R++, te(Math.round((k + R * _) * M) / M, r, Qs(r, y, i)) && R++) : k < r && R++); R < w; ++R)\n    e.push({ value: Math.round((k + R * _) * M) / M });\n  return x && u && S !== a ? e.length && te(e[e.length - 1].value, a, Qs(a, y, i)) ? e[e.length - 1].value = a : e.push({ value: a }) : (!x || S === a) && e.push({ value: S }), e;\n}\nfunction Qs(i, t, { horizontal: e, minRotation: s }) {\n  const n = nt(s), o = (e ? Math.sin(n) : Math.cos(n)) || 1e-3, r = 0.75 * t * (\"\" + i).length;\n  return Math.min(t / o, r);\n}\nclass Ye extends Mt {\n  constructor(t) {\n    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n  }\n  parse(t, e) {\n    return T(t) || (typeof t == \"number\" || t instanceof Number) && !isFinite(+t) ? null : +t;\n  }\n  handleTickRangeOptions() {\n    const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: s } = this.getUserBounds();\n    let { min: n, max: o } = this;\n    const r = (l) => n = e ? n : l, a = (l) => o = s ? o : l;\n    if (t) {\n      const l = lt(n), c = lt(o);\n      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);\n    }\n    if (n === o) {\n      let l = 1;\n      (o >= Number.MAX_SAFE_INTEGER || n <= Number.MIN_SAFE_INTEGER) && (l = Math.abs(o * 0.05)), a(o + l), t || r(n - l);\n    }\n    this.min = n, this.max = o;\n  }\n  getTickLimit() {\n    const t = this.options.ticks;\n    let { maxTicksLimit: e, stepSize: s } = t, n;\n    return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${n} ticks. Limiting to 1000.`), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const t = this.options, e = t.ticks;\n    let s = this.getTickLimit();\n    s = Math.max(2, s);\n    const n = {\n      maxTicks: s,\n      bounds: t.bounds,\n      min: t.min,\n      max: t.max,\n      precision: e.precision,\n      step: e.stepSize,\n      count: e.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: e.minRotation || 0,\n      includeBounds: e.includeBounds !== !1\n    }, o = this._range || this, r = Dc(n, o);\n    return t.bounds === \"ticks\" && cn(r, this, \"value\"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;\n  }\n  configure() {\n    const t = this.ticks;\n    let e = this.min, s = this.max;\n    if (super.configure(), this.options.offset && t.length) {\n      const n = (s - e) / Math.max(t.length - 1, 1) / 2;\n      e -= n, s += n;\n    }\n    this._startValue = e, this._endValue = s, this._valueRange = s - e;\n  }\n  getLabelForValue(t) {\n    return de(t, this.chart.options.locale, this.options.ticks.format);\n  }\n}\nclass Ge extends Ye {\n  determineDataLimits() {\n    const { min: t, max: e } = this.getMinMax(!0);\n    this.min = N(t) ? t : 0, this.max = N(e) ? e : 1, this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const t = this.isHorizontal(), e = t ? this.width : this.height, s = nt(this.options.ticks.minRotation), n = (t ? Math.sin(s) : Math.cos(s)) || 1e-3, o = this._resolveTickFontOptions(0);\n    return Math.ceil(e / Math.min(40, o.lineHeight / n));\n  }\n  getPixelForValue(t) {\n    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(t) {\n    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n  }\n}\nGe.id = \"linear\";\nGe.defaults = {\n  ticks: {\n    callback: be.formatters.numeric\n  }\n};\nfunction tn(i) {\n  return i / Math.pow(10, Math.floor(tt(i))) === 1;\n}\nfunction Oc(i, t) {\n  const e = Math.floor(tt(t.max)), s = Math.ceil(t.max / Math.pow(10, e)), n = [];\n  let o = Q(i.min, Math.pow(10, Math.floor(tt(t.min)))), r = Math.floor(tt(o)), a = Math.floor(o / Math.pow(10, r)), l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;\n  do\n    n.push({ value: o, major: tn(o) }), ++a, a === 10 && (a = 1, ++r, l = r >= 0 ? 1 : l), o = Math.round(a * Math.pow(10, r) * l) / l;\n  while (r < e || r === e && a < s);\n  const c = Q(i.max, o);\n  return n.push({ value: c, major: tn(o) }), n;\n}\nclass Ze extends Mt {\n  constructor(t) {\n    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n  }\n  parse(t, e) {\n    const s = Ye.prototype.parse.apply(this, [t, e]);\n    if (s === 0) {\n      this._zero = !0;\n      return;\n    }\n    return N(s) && s > 0 ? s : null;\n  }\n  determineDataLimits() {\n    const { min: t, max: e } = this.getMinMax(!0);\n    this.min = N(t) ? Math.max(0, t) : null, this.max = N(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const { minDefined: t, maxDefined: e } = this.getUserBounds();\n    let s = this.min, n = this.max;\n    const o = (l) => s = t ? s : l, r = (l) => n = e ? n : l, a = (l, c) => Math.pow(10, Math.floor(tt(l)) + c);\n    s === n && (s <= 0 ? (o(1), r(10)) : (o(a(s, -1)), r(a(n, 1)))), s <= 0 && o(a(n, -1)), n <= 0 && r(a(s, 1)), this._zero && this.min !== this._suggestedMin && s === a(this.min, 0) && o(a(s, -1)), this.min = s, this.max = n;\n  }\n  buildTicks() {\n    const t = this.options, e = {\n      min: this._userMin,\n      max: this._userMax\n    }, s = Oc(e, this);\n    return t.bounds === \"ticks\" && cn(s, this, \"value\"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;\n  }\n  getLabelForValue(t) {\n    return t === void 0 ? \"0\" : de(t, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const t = this.min;\n    super.configure(), this._startValue = tt(t), this._valueRange = tt(this.max) - tt(t);\n  }\n  getPixelForValue(t) {\n    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (tt(t) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(t) {\n    const e = this.getDecimalForPixel(t);\n    return Math.pow(10, this._startValue + e * this._valueRange);\n  }\n}\nZe.id = \"logarithmic\";\nZe.defaults = {\n  ticks: {\n    callback: be.formatters.logarithmic,\n    major: {\n      enabled: !0\n    }\n  }\n};\nfunction Di(i) {\n  const t = i.ticks;\n  if (t.display && i.display) {\n    const e = K(t.backdropPadding);\n    return C(t.font && t.font.size, O.font.size) + e.height;\n  }\n  return 0;\n}\nfunction Ac(i, t, e) {\n  return e = z(e) ? e : [e], {\n    w: ar(i, t.string, e),\n    h: e.length * t.lineHeight\n  };\n}\nfunction en(i, t, e, s, n) {\n  return i === s || i === n ? {\n    start: t - e / 2,\n    end: t + e / 2\n  } : i < s || i > n ? {\n    start: t - e,\n    end: t\n  } : {\n    start: t,\n    end: t + e\n  };\n}\nfunction Tc(i) {\n  const t = {\n    l: i.left + i._padding.left,\n    r: i.right - i._padding.right,\n    t: i.top + i._padding.top,\n    b: i.bottom - i._padding.bottom\n  }, e = Object.assign({}, t), s = [], n = [], o = i._pointLabels.length, r = i.options.pointLabels, a = r.centerPointLabels ? B / o : 0;\n  for (let l = 0; l < o; l++) {\n    const c = r.setContext(i.getPointLabelContext(l));\n    n[l] = c.padding;\n    const h = i.getPointPosition(l, i.drawingArea + n[l], a), d = $(c.font), u = Ac(i.ctx, d, i._pointLabels[l]);\n    s[l] = u;\n    const f = Z(i.getIndexAngle(l) + a), g = Math.round(Ai(f)), p = en(g, h.x, u.w, 0, 180), m = en(g, h.y, u.h, 90, 270);\n    Lc(e, t, f, p, m);\n  }\n  i.setCenterPoint(\n    t.l - e.l,\n    e.r - t.r,\n    t.t - e.t,\n    e.b - t.b\n  ), i._pointLabelItems = Rc(i, s, n);\n}\nfunction Lc(i, t, e, s, n) {\n  const o = Math.abs(Math.sin(e)), r = Math.abs(Math.cos(e));\n  let a = 0, l = 0;\n  s.start < t.l ? (a = (t.l - s.start) / o, i.l = Math.min(i.l, t.l - a)) : s.end > t.r && (a = (s.end - t.r) / o, i.r = Math.max(i.r, t.r + a)), n.start < t.t ? (l = (t.t - n.start) / r, i.t = Math.min(i.t, t.t - l)) : n.end > t.b && (l = (n.end - t.b) / r, i.b = Math.max(i.b, t.b + l));\n}\nfunction Rc(i, t, e) {\n  const s = [], n = i._pointLabels.length, o = i.options, r = Di(o) / 2, a = i.drawingArea, l = o.pointLabels.centerPointLabels ? B / n : 0;\n  for (let c = 0; c < n; c++) {\n    const h = i.getPointPosition(c, a + r + e[c], l), d = Math.round(Ai(Z(h.angle + V))), u = t[c], f = Ic(h.y, u.h, d), g = Ec(d), p = Fc(h.x, u.w, g);\n    s.push({\n      x: h.x,\n      y: f,\n      textAlign: g,\n      left: p,\n      top: f,\n      right: p + u.w,\n      bottom: f + u.h\n    });\n  }\n  return s;\n}\nfunction Ec(i) {\n  return i === 0 || i === 180 ? \"center\" : i < 180 ? \"left\" : \"right\";\n}\nfunction Fc(i, t, e) {\n  return e === \"right\" ? i -= t : e === \"center\" && (i -= t / 2), i;\n}\nfunction Ic(i, t, e) {\n  return e === 90 || e === 270 ? i -= t / 2 : (e > 270 || e < 90) && (i -= t), i;\n}\nfunction zc(i, t) {\n  const { ctx: e, options: { pointLabels: s } } = i;\n  for (let n = t - 1; n >= 0; n--) {\n    const o = s.setContext(i.getPointLabelContext(n)), r = $(o.font), { x: a, y: l, textAlign: c, left: h, top: d, right: u, bottom: f } = i._pointLabelItems[n], { backdropColor: g } = o;\n    if (!T(g)) {\n      const p = Dt(o.borderRadius), m = K(o.backdropPadding);\n      e.fillStyle = g;\n      const b = h - m.left, x = d - m.top, v = u - h + m.width, y = f - d + m.height;\n      Object.values(p).some((_) => _ !== 0) ? (e.beginPath(), ae(e, {\n        x: b,\n        y: x,\n        w: v,\n        h: y,\n        radius: p\n      }), e.fill()) : e.fillRect(b, x, v, y);\n    }\n    Tt(\n      e,\n      i._pointLabels[n],\n      a,\n      l + r.lineHeight / 2,\n      r,\n      {\n        color: o.color,\n        textAlign: c,\n        textBaseline: \"middle\"\n      }\n    );\n  }\n}\nfunction bo(i, t, e, s) {\n  const { ctx: n } = i;\n  if (e)\n    n.arc(i.xCenter, i.yCenter, t, 0, F);\n  else {\n    let o = i.getPointPosition(0, t);\n    n.moveTo(o.x, o.y);\n    for (let r = 1; r < s; r++)\n      o = i.getPointPosition(r, t), n.lineTo(o.x, o.y);\n  }\n}\nfunction Bc(i, t, e, s) {\n  const n = i.ctx, o = t.circular, { color: r, lineWidth: a } = t;\n  !o && !s || !r || !a || e < 0 || (n.save(), n.strokeStyle = r, n.lineWidth = a, n.setLineDash(t.borderDash), n.lineDashOffset = t.borderDashOffset, n.beginPath(), bo(i, e, o, s), n.closePath(), n.stroke(), n.restore());\n}\nfunction Vc(i, t, e) {\n  return vt(i, {\n    label: e,\n    index: t,\n    type: \"pointLabel\"\n  });\n}\nclass Nt extends Ye {\n  constructor(t) {\n    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const t = this._padding = K(Di(this.options) / 2), e = this.width = this.maxWidth - t.width, s = this.height = this.maxHeight - t.height;\n    this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s) / 2);\n  }\n  determineDataLimits() {\n    const { min: t, max: e } = this.getMinMax(!1);\n    this.min = N(t) && !isNaN(t) ? t : 0, this.max = N(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / Di(this.options));\n  }\n  generateTickLabels(t) {\n    Ye.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, s) => {\n      const n = I(this.options.pointLabels.callback, [e, s], this);\n      return n || n === 0 ? n : \"\";\n    }).filter((e, s) => this.chart.getDataVisibility(s));\n  }\n  fit() {\n    const t = this.options;\n    t.display && t.pointLabels.display ? Tc(this) : this.setCenterPoint(0, 0, 0, 0);\n  }\n  setCenterPoint(t, e, s, n) {\n    this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, n));\n  }\n  getIndexAngle(t) {\n    const e = F / (this._pointLabels.length || 1), s = this.options.startAngle || 0;\n    return Z(t * e + nt(s));\n  }\n  getDistanceFromCenterForValue(t) {\n    if (T(t))\n      return NaN;\n    const e = this.drawingArea / (this.max - this.min);\n    return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n  }\n  getValueForDistanceFromCenter(t) {\n    if (T(t))\n      return NaN;\n    const e = t / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - e : this.min + e;\n  }\n  getPointLabelContext(t) {\n    const e = this._pointLabels || [];\n    if (t >= 0 && t < e.length) {\n      const s = e[t];\n      return Vc(this.getContext(), t, s);\n    }\n  }\n  getPointPosition(t, e, s = 0) {\n    const n = this.getIndexAngle(t) - V + s;\n    return {\n      x: Math.cos(n) * e + this.xCenter,\n      y: Math.sin(n) * e + this.yCenter,\n      angle: n\n    };\n  }\n  getPointPositionForValue(t, e) {\n    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n  }\n  getBasePosition(t) {\n    return this.getPointPositionForValue(t || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(t) {\n    const { left: e, top: s, right: n, bottom: o } = this._pointLabelItems[t];\n    return {\n      left: e,\n      top: s,\n      right: n,\n      bottom: o\n    };\n  }\n  drawBackground() {\n    const { backgroundColor: t, grid: { circular: e } } = this.options;\n    if (t) {\n      const s = this.ctx;\n      s.save(), s.beginPath(), bo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore();\n    }\n  }\n  drawGrid() {\n    const t = this.ctx, e = this.options, { angleLines: s, grid: n } = e, o = this._pointLabels.length;\n    let r, a, l;\n    if (e.pointLabels.display && zc(this, o), n.display && this.ticks.forEach((c, h) => {\n      if (h !== 0) {\n        a = this.getDistanceFromCenterForValue(c.value);\n        const d = n.setContext(this.getContext(h - 1));\n        Bc(this, d, a, o);\n      }\n    }), s.display) {\n      for (t.save(), r = o - 1; r >= 0; r--) {\n        const c = s.setContext(this.getPointLabelContext(r)), { color: h, lineWidth: d } = c;\n        !d || !h || (t.lineWidth = d, t.strokeStyle = h, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(r, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n      }\n      t.restore();\n    }\n  }\n  drawBorder() {\n  }\n  drawLabels() {\n    const t = this.ctx, e = this.options, s = e.ticks;\n    if (!s.display)\n      return;\n    const n = this.getIndexAngle(0);\n    let o, r;\n    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((a, l) => {\n      if (l === 0 && !e.reverse)\n        return;\n      const c = s.setContext(this.getContext(l)), h = $(c.font);\n      if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {\n        t.font = h.string, r = t.measureText(a.label).width, t.fillStyle = c.backdropColor;\n        const d = K(c.backdropPadding);\n        t.fillRect(\n          -r / 2 - d.left,\n          -o - h.size / 2 - d.top,\n          r + d.width,\n          h.size + d.height\n        );\n      }\n      Tt(t, a.label, 0, -o, h, {\n        color: c.color\n      });\n    }), t.restore();\n  }\n  drawTitle() {\n  }\n}\nNt.id = \"radialLinear\";\nNt.defaults = {\n  display: !0,\n  animate: !0,\n  position: \"chartArea\",\n  angleLines: {\n    display: !0,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0\n  },\n  grid: {\n    circular: !1\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: !0,\n    callback: be.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: void 0,\n    backdropPadding: 2,\n    display: !0,\n    font: {\n      size: 10\n    },\n    callback(i) {\n      return i;\n    },\n    padding: 5,\n    centerPointLabels: !1\n  }\n};\nNt.defaultRoutes = {\n  \"angleLines.color\": \"borderColor\",\n  \"pointLabels.color\": \"color\",\n  \"ticks.color\": \"color\"\n};\nNt.descriptors = {\n  angleLines: {\n    _fallback: \"grid\"\n  }\n};\nconst Je = {\n  millisecond: { common: !0, size: 1, steps: 1e3 },\n  second: { common: !0, size: 1e3, steps: 60 },\n  minute: { common: !0, size: 6e4, steps: 60 },\n  hour: { common: !0, size: 36e5, steps: 24 },\n  day: { common: !0, size: 864e5, steps: 30 },\n  week: { common: !1, size: 6048e5, steps: 4 },\n  month: { common: !0, size: 2628e6, steps: 12 },\n  quarter: { common: !1, size: 7884e6, steps: 4 },\n  year: { common: !0, size: 3154e7 }\n}, G = Object.keys(Je);\nfunction Wc(i, t) {\n  return i - t;\n}\nfunction sn(i, t) {\n  if (T(t))\n    return null;\n  const e = i._adapter, { parser: s, round: n, isoWeekday: o } = i._parseOpts;\n  let r = t;\n  return typeof s == \"function\" && (r = s(r)), N(r) || (r = typeof s == \"string\" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === \"week\" && (Bt(o) || o === !0) ? e.startOf(r, \"isoWeek\", o) : e.startOf(r, n)), +r);\n}\nfunction nn(i, t, e, s) {\n  const n = G.length;\n  for (let o = G.indexOf(i); o < n - 1; ++o) {\n    const r = Je[G[o]], a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;\n    if (r.common && Math.ceil((e - t) / (a * r.size)) <= s)\n      return G[o];\n  }\n  return G[n - 1];\n}\nfunction Nc(i, t, e, s, n) {\n  for (let o = G.length - 1; o >= G.indexOf(e); o--) {\n    const r = G[o];\n    if (Je[r].common && i._adapter.diff(n, s, r) >= t - 1)\n      return r;\n  }\n  return G[e ? G.indexOf(e) : 0];\n}\nfunction Hc(i) {\n  for (let t = G.indexOf(i) + 1, e = G.length; t < e; ++t)\n    if (Je[G[t]].common)\n      return G[t];\n}\nfunction on(i, t, e) {\n  if (!e)\n    i[t] = !0;\n  else if (e.length) {\n    const { lo: s, hi: n } = Ti(e, t), o = e[s] >= t ? e[s] : e[n];\n    i[o] = !0;\n  }\n}\nfunction jc(i, t, e, s) {\n  const n = i._adapter, o = +n.startOf(t[0].value, s), r = t[t.length - 1].value;\n  let a, l;\n  for (a = o; a <= r; a = +n.add(a, 1, s))\n    l = e[a], l >= 0 && (t[l].major = !0);\n  return t;\n}\nfunction rn(i, t, e) {\n  const s = [], n = {}, o = t.length;\n  let r, a;\n  for (r = 0; r < o; ++r)\n    a = t[r], n[a] = r, s.push({\n      value: a,\n      major: !1\n    });\n  return o === 0 || !e ? s : jc(i, s, n, e);\n}\nclass Ht extends Mt {\n  constructor(t) {\n    super(t), this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n  }\n  init(t, e) {\n    const s = t.time || (t.time = {}), n = this._adapter = new Nn._date(t.adapters.date);\n    n.init(e), Qt(s.displayFormats, n.formats()), this._parseOpts = {\n      parser: s.parser,\n      round: s.round,\n      isoWeekday: s.isoWeekday\n    }, super.init(t), this._normalized = e.normalized;\n  }\n  parse(t, e) {\n    return t === void 0 ? null : sn(this, t);\n  }\n  beforeLayout() {\n    super.beforeLayout(), this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const t = this.options, e = this._adapter, s = t.time.unit || \"day\";\n    let { min: n, max: o, minDefined: r, maxDefined: a } = this.getUserBounds();\n    function l(c) {\n      !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));\n    }\n    (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") && l(this.getMinMax(!1))), n = N(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = N(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);\n  }\n  _getLabelBounds() {\n    const t = this.getLabelTimestamps();\n    let e = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;\n    return t.length && (e = t[0], s = t[t.length - 1]), { min: e, max: s };\n  }\n  buildTicks() {\n    const t = this.options, e = t.time, s = t.ticks, n = s.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n    t.bounds === \"ticks\" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);\n    const o = this.min, r = this.max, a = Ro(n, o, r);\n    return this._unit = e.unit || (s.autoSkip ? nn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Nc(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === \"year\" ? void 0 : Hc(this._unit), this.initOffsets(n), t.reverse && a.reverse(), rn(this, a, this._majorUnit);\n  }\n  afterAutoSkip() {\n    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));\n  }\n  initOffsets(t) {\n    let e = 0, s = 0, n, o;\n    this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);\n    const r = t.length < 3 ? 0.5 : 0.25;\n    e = Y(e, 0, r), s = Y(s, 0, r), this._offsets = { start: e, end: s, factor: 1 / (e + 1 + s) };\n  }\n  _generate() {\n    const t = this._adapter, e = this.min, s = this.max, n = this.options, o = n.time, r = o.unit || nn(o.minUnit, e, s, this._getLabelCapacity(e)), a = C(o.stepSize, 1), l = r === \"week\" ? o.isoWeekday : !1, c = Bt(l) || l === !0, h = {};\n    let d = e, u, f;\n    if (c && (d = +t.startOf(d, \"isoWeek\", l)), d = +t.startOf(d, c ? \"day\" : r), t.diff(s, e, r) > 1e5 * a)\n      throw new Error(e + \" and \" + s + \" are too far apart with stepSize of \" + a + \" \" + r);\n    const g = n.ticks.source === \"data\" && this.getDataTimestamps();\n    for (u = d, f = 0; u < s; u = +t.add(u, a, r), f++)\n      on(h, u, g);\n    return (u === s || n.bounds === \"ticks\" || f === 1) && on(h, u, g), Object.keys(h).sort((p, m) => p - m).map((p) => +p);\n  }\n  getLabelForValue(t) {\n    const e = this._adapter, s = this.options.time;\n    return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);\n  }\n  _tickFormatFunction(t, e, s, n) {\n    const o = this.options, r = o.time.displayFormats, a = this._unit, l = this._majorUnit, c = a && r[a], h = l && r[l], d = s[e], u = l && h && d && d.major, f = this._adapter.format(t, n || (u ? h : c)), g = o.ticks.callback;\n    return g ? I(g, [f, e, s], this) : f;\n  }\n  generateTickLabels(t) {\n    let e, s, n;\n    for (e = 0, s = t.length; e < s; ++e)\n      n = t[e], n.label = this._tickFormatFunction(n.value, e, t);\n  }\n  getDecimalForValue(t) {\n    return t === null ? NaN : (t - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(t) {\n    const e = this._offsets, s = this.getDecimalForValue(t);\n    return this.getPixelForDecimal((e.start + s) * e.factor);\n  }\n  getValueForPixel(t) {\n    const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;\n    return this.min + s * (this.max - this.min);\n  }\n  _getLabelSize(t) {\n    const e = this.options.ticks, s = this.ctx.measureText(t).width, n = nt(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(n), r = Math.sin(n), a = this._resolveTickFontOptions(0).size;\n    return {\n      w: s * o + a * r,\n      h: s * r + a * o\n    };\n  }\n  _getLabelCapacity(t) {\n    const e = this.options.time, s = e.displayFormats, n = s[e.unit] || s.millisecond, o = this._tickFormatFunction(t, 0, rn(this, [t], this._majorUnit), n), r = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;\n    return a > 0 ? a : 1;\n  }\n  getDataTimestamps() {\n    let t = this._cache.data || [], e, s;\n    if (t.length)\n      return t;\n    const n = this.getMatchingVisibleMetas();\n    if (this._normalized && n.length)\n      return this._cache.data = n[0].controller.getAllParsedValues(this);\n    for (e = 0, s = n.length; e < s; ++e)\n      t = t.concat(n[e].controller.getAllParsedValues(this));\n    return this._cache.data = this.normalize(t);\n  }\n  getLabelTimestamps() {\n    const t = this._cache.labels || [];\n    let e, s;\n    if (t.length)\n      return t;\n    const n = this.getLabels();\n    for (e = 0, s = n.length; e < s; ++e)\n      t.push(sn(this, n[e]));\n    return this._cache.labels = this._normalized ? t : this.normalize(t);\n  }\n  normalize(t) {\n    return un(t.sort(Wc));\n  }\n}\nHt.id = \"time\";\nHt.defaults = {\n  bounds: \"data\",\n  adapters: {},\n  time: {\n    parser: !1,\n    unit: !1,\n    round: !1,\n    isoWeekday: !1,\n    minUnit: \"millisecond\",\n    displayFormats: {}\n  },\n  ticks: {\n    source: \"auto\",\n    major: {\n      enabled: !1\n    }\n  }\n};\nfunction Fe(i, t, e) {\n  let s = 0, n = i.length - 1, o, r, a, l;\n  e ? (t >= i[s].pos && t <= i[n].pos && ({ lo: s, hi: n } = ft(i, \"pos\", t)), { pos: o, time: a } = i[s], { pos: r, time: l } = i[n]) : (t >= i[s].time && t <= i[n].time && ({ lo: s, hi: n } = ft(i, \"time\", t)), { time: o, pos: a } = i[s], { time: r, pos: l } = i[n]);\n  const c = r - o;\n  return c ? a + (l - a) * (t - o) / c : a;\n}\nclass Qe extends Ht {\n  constructor(t) {\n    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n  }\n  initOffsets() {\n    const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n    this._minPos = Fe(e, this.min), this._tableRange = Fe(e, this.max) - this._minPos, super.initOffsets(t);\n  }\n  buildLookupTable(t) {\n    const { min: e, max: s } = this, n = [], o = [];\n    let r, a, l, c, h;\n    for (r = 0, a = t.length; r < a; ++r)\n      c = t[r], c >= e && c <= s && n.push(c);\n    if (n.length < 2)\n      return [\n        { time: e, pos: 0 },\n        { time: s, pos: 1 }\n      ];\n    for (r = 0, a = n.length; r < a; ++r)\n      h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({ time: c, pos: r / (a - 1) });\n    return o;\n  }\n  _getTimestampsForTable() {\n    let t = this._cache.all || [];\n    if (t.length)\n      return t;\n    const e = this.getDataTimestamps(), s = this.getLabelTimestamps();\n    return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;\n  }\n  getDecimalForValue(t) {\n    return (Fe(this._table, t) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(t) {\n    const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;\n    return Fe(this._table, s * this._tableRange + this._minPos, !0);\n  }\n}\nQe.id = \"timeseries\";\nQe.defaults = Ht.defaults;\nvar xo = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  CategoryScale: ce,\n  LinearScale: Ge,\n  LogarithmicScale: Ze,\n  RadialLinearScale: Nt,\n  TimeScale: Ht,\n  TimeSeriesScale: Qe\n});\nconst $c = [\n  Wn,\n  oo,\n  mo,\n  xo\n], Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Animation: In,\n  Animations: Ni,\n  ArcElement: ye,\n  BarController: ue,\n  BarElement: Me,\n  BasePlatform: Hi,\n  BasicPlatform: Yn,\n  BubbleController: fe,\n  CategoryScale: ce,\n  Chart: ji,\n  DatasetController: it,\n  Decimation: ao,\n  DomPlatform: Kn,\n  DoughnutController: Lt,\n  Element: st,\n  Filler: ho,\n  Interaction: Hn,\n  Legend: uo,\n  LineController: ge,\n  LineElement: gt,\n  LinearScale: Ge,\n  LogarithmicScale: Ze,\n  PieController: qe,\n  PointElement: ve,\n  PolarAreaController: pe,\n  RadarController: me,\n  RadialLinearScale: Nt,\n  Scale: Mt,\n  ScatterController: xe,\n  SubTitle: go,\n  Ticks: be,\n  TimeScale: Ht,\n  TimeSeriesScale: Qe,\n  Title: fo,\n  Tooltip: po,\n  _adapters: Nn,\n  _detectPlatform: qn,\n  animator: at,\n  controllers: Wn,\n  defaults: O,\n  elements: oo,\n  layouts: X,\n  plugins: mo,\n  registerables: $c,\n  registry: ot,\n  scales: xo\n}, Symbol.toStringTag, { value: \"Module\" }));\n\n//# sourceMappingURL=chart.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy9jaGFydC5lcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0JBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGFjYXNhZGVqdWFuYS9uZWdvY2lvcy1wYW5lbC8uL25vZGVfbW9kdWxlcy90dy1lbGVtZW50cy9kaXN0L2pzL2NoYXJ0LmVzLmpzPzlhOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiBjdCgpIHtcbn1cbmNvbnN0IF9vID0gZnVuY3Rpb24oKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59KCk7XG5mdW5jdGlvbiBUKGkpIHtcbiAgcmV0dXJuIGkgPT09IG51bGwgfHwgdHlwZW9mIGkgPiBcInVcIjtcbn1cbmZ1bmN0aW9uIHooaSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGkpKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpKTtcbiAgcmV0dXJuIHQuc2xpY2UoMCwgNykgPT09IFwiW29iamVjdFwiICYmIHQuc2xpY2UoLTYpID09PSBcIkFycmF5XVwiO1xufVxuZnVuY3Rpb24gRChpKSB7XG4gIHJldHVybiBpICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmNvbnN0IE4gPSAoaSkgPT4gKHR5cGVvZiBpID09IFwibnVtYmVyXCIgfHwgaSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK2kpO1xuZnVuY3Rpb24gUShpLCB0KSB7XG4gIHJldHVybiBOKGkpID8gaSA6IHQ7XG59XG5mdW5jdGlvbiBDKGksIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID4gXCJ1XCIgPyB0IDogaTtcbn1cbmNvbnN0IHlvID0gKGksIHQpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgaS5lbmRzV2l0aChcIiVcIikgPyBwYXJzZUZsb2F0KGkpIC8gMTAwIDogaSAvIHQsIGFuID0gKGksIHQpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgaS5lbmRzV2l0aChcIiVcIikgPyBwYXJzZUZsb2F0KGkpIC8gMTAwICogdCA6ICtpO1xuZnVuY3Rpb24gSShpLCB0LCBlKSB7XG4gIGlmIChpICYmIHR5cGVvZiBpLmNhbGwgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBpLmFwcGx5KGUsIHQpO1xufVxuZnVuY3Rpb24gRShpLCB0LCBlLCBzKSB7XG4gIGxldCBuLCBvLCByO1xuICBpZiAoeihpKSlcbiAgICBpZiAobyA9IGkubGVuZ3RoLCBzKVxuICAgICAgZm9yIChuID0gbyAtIDE7IG4gPj0gMDsgbi0tKVxuICAgICAgICB0LmNhbGwoZSwgaVtuXSwgbik7XG4gICAgZWxzZVxuICAgICAgZm9yIChuID0gMDsgbiA8IG87IG4rKylcbiAgICAgICAgdC5jYWxsKGUsIGlbbl0sIG4pO1xuICBlbHNlIGlmIChEKGkpKVxuICAgIGZvciAociA9IE9iamVjdC5rZXlzKGkpLCBvID0gci5sZW5ndGgsIG4gPSAwOyBuIDwgbzsgbisrKVxuICAgICAgdC5jYWxsKGUsIGlbcltuXV0sIHJbbl0pO1xufVxuZnVuY3Rpb24gemUoaSwgdCkge1xuICBsZXQgZSwgcywgbiwgbztcbiAgaWYgKCFpIHx8ICF0IHx8IGkubGVuZ3RoICE9PSB0Lmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAoZSA9IDAsIHMgPSBpLmxlbmd0aDsgZSA8IHM7ICsrZSlcbiAgICBpZiAobiA9IGlbZV0sIG8gPSB0W2VdLCBuLmRhdGFzZXRJbmRleCAhPT0gby5kYXRhc2V0SW5kZXggfHwgbi5pbmRleCAhPT0gby5pbmRleClcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gQmUoaSkge1xuICBpZiAoeihpKSlcbiAgICByZXR1cm4gaS5tYXAoQmUpO1xuICBpZiAoRChpKSkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgZSA9IE9iamVjdC5rZXlzKGkpLCBzID0gZS5sZW5ndGg7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAoOyBuIDwgczsgKytuKVxuICAgICAgdFtlW25dXSA9IEJlKGlbZVtuXV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbG4oaSkge1xuICByZXR1cm4gW1wiX19wcm90b19fXCIsIFwicHJvdG90eXBlXCIsIFwiY29uc3RydWN0b3JcIl0uaW5kZXhPZihpKSA9PT0gLTE7XG59XG5mdW5jdGlvbiB2byhpLCB0LCBlLCBzKSB7XG4gIGlmICghbG4oaSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuID0gdFtpXSwgbyA9IGVbaV07XG4gIEQobikgJiYgRChvKSA/IG5lKG4sIG8sIHMpIDogdFtpXSA9IEJlKG8pO1xufVxuZnVuY3Rpb24gbmUoaSwgdCwgZSkge1xuICBjb25zdCBzID0geih0KSA/IHQgOiBbdF0sIG4gPSBzLmxlbmd0aDtcbiAgaWYgKCFEKGkpKVxuICAgIHJldHVybiBpO1xuICBlID0gZSB8fCB7fTtcbiAgY29uc3QgbyA9IGUubWVyZ2VyIHx8IHZvO1xuICBmb3IgKGxldCByID0gMDsgciA8IG47ICsrcikge1xuICAgIGlmICh0ID0gc1tyXSwgIUQodCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBhID0gT2JqZWN0LmtleXModCk7XG4gICAgZm9yIChsZXQgbCA9IDAsIGMgPSBhLmxlbmd0aDsgbCA8IGM7ICsrbClcbiAgICAgIG8oYVtsXSwgaSwgdCwgZSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBRdChpLCB0KSB7XG4gIHJldHVybiBuZShpLCB0LCB7IG1lcmdlcjogTW8gfSk7XG59XG5mdW5jdGlvbiBNbyhpLCB0LCBlKSB7XG4gIGlmICghbG4oaSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gdFtpXSwgbiA9IGVbaV07XG4gIEQocykgJiYgRChuKSA/IFF0KHMsIG4pIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGkpIHx8ICh0W2ldID0gQmUobikpO1xufVxuY29uc3QgWGkgPSB7XG4gIFwiXCI6IChpKSA9PiBpLFxuICB4OiAoaSkgPT4gaS54LFxuICB5OiAoaSkgPT4gaS55XG59O1xuZnVuY3Rpb24gX3QoaSwgdCkge1xuICByZXR1cm4gKFhpW3RdIHx8IChYaVt0XSA9IGtvKHQpKSkoaSk7XG59XG5mdW5jdGlvbiBrbyhpKSB7XG4gIGNvbnN0IHQgPSB3byhpKTtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgZm9yIChjb25zdCBzIG9mIHQpIHtcbiAgICAgIGlmIChzID09PSBcIlwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGUgPSBlICYmIGVbc107XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9O1xufVxuZnVuY3Rpb24gd28oaSkge1xuICBjb25zdCB0ID0gaS5zcGxpdChcIi5cIiksIGUgPSBbXTtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IG4gb2YgdClcbiAgICBzICs9IG4sIHMuZW5kc1dpdGgoXCJcXFxcXCIpID8gcyA9IHMuc2xpY2UoMCwgLTEpICsgXCIuXCIgOiAoZS5wdXNoKHMpLCBzID0gXCJcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gT2koaSkge1xuICByZXR1cm4gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XG59XG5jb25zdCBldCA9IChpKSA9PiB0eXBlb2YgaSA8IFwidVwiLCB5dCA9IChpKSA9PiB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIsIFVpID0gKGksIHQpID0+IHtcbiAgaWYgKGkuc2l6ZSAhPT0gdC5zaXplKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCBlIG9mIGkpXG4gICAgaWYgKCF0LmhhcyhlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufTtcbmZ1bmN0aW9uIFNvKGkpIHtcbiAgcmV0dXJuIGkudHlwZSA9PT0gXCJtb3VzZXVwXCIgfHwgaS50eXBlID09PSBcImNsaWNrXCIgfHwgaS50eXBlID09PSBcImNvbnRleHRtZW51XCI7XG59XG5jb25zdCBCID0gTWF0aC5QSSwgRiA9IDIgKiBCLCBQbyA9IEYgKyBCLCBWZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgQ28gPSBCIC8gMTgwLCBWID0gQiAvIDIsICR0ID0gQiAvIDQsIEtpID0gQiAqIDIgLyAzLCB0dCA9IE1hdGgubG9nMTAsIGx0ID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gcWkoaSkge1xuICBjb25zdCB0ID0gTWF0aC5yb3VuZChpKTtcbiAgaSA9IHRlKGksIHQsIGkgLyAxZTMpID8gdCA6IGk7XG4gIGNvbnN0IGUgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcih0dChpKSkpLCBzID0gaSAvIGU7XG4gIHJldHVybiAocyA8PSAxID8gMSA6IHMgPD0gMiA/IDIgOiBzIDw9IDUgPyA1IDogMTApICogZTtcbn1cbmZ1bmN0aW9uIERvKGkpIHtcbiAgY29uc3QgdCA9IFtdLCBlID0gTWF0aC5zcXJ0KGkpO1xuICBsZXQgcztcbiAgZm9yIChzID0gMTsgcyA8IGU7IHMrKylcbiAgICBpICUgcyA9PT0gMCAmJiAodC5wdXNoKHMpLCB0LnB1c2goaSAvIHMpKTtcbiAgcmV0dXJuIGUgPT09IChlIHwgMCkgJiYgdC5wdXNoKGUpLCB0LnNvcnQoKG4sIG8pID0+IG4gLSBvKS5wb3AoKSwgdDtcbn1cbmZ1bmN0aW9uIEJ0KGkpIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGkpKSAmJiBpc0Zpbml0ZShpKTtcbn1cbmZ1bmN0aW9uIHRlKGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGkgLSB0KSA8IGU7XG59XG5mdW5jdGlvbiBPbyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBNYXRoLnJvdW5kKGkpO1xuICByZXR1cm4gZSAtIHQgPD0gaSAmJiBlICsgdCA+PSBpO1xufVxuZnVuY3Rpb24gY24oaSwgdCwgZSkge1xuICBsZXQgcywgbiwgbztcbiAgZm9yIChzID0gMCwgbiA9IGkubGVuZ3RoOyBzIDwgbjsgcysrKVxuICAgIG8gPSBpW3NdW2VdLCBpc05hTihvKSB8fCAodC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgbyksIHQubWF4ID0gTWF0aC5tYXgodC5tYXgsIG8pKTtcbn1cbmZ1bmN0aW9uIG50KGkpIHtcbiAgcmV0dXJuIGkgKiAoQiAvIDE4MCk7XG59XG5mdW5jdGlvbiBBaShpKSB7XG4gIHJldHVybiBpICogKDE4MCAvIEIpO1xufVxuZnVuY3Rpb24gR2koaSkge1xuICBpZiAoIU4oaSkpXG4gICAgcmV0dXJuO1xuICBsZXQgdCA9IDEsIGUgPSAwO1xuICBmb3IgKDsgTWF0aC5yb3VuZChpICogdCkgLyB0ICE9PSBpOyApXG4gICAgdCAqPSAxMCwgZSsrO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGhuKGksIHQpIHtcbiAgY29uc3QgZSA9IHQueCAtIGkueCwgcyA9IHQueSAtIGkueSwgbiA9IE1hdGguc3FydChlICogZSArIHMgKiBzKTtcbiAgbGV0IG8gPSBNYXRoLmF0YW4yKHMsIGUpO1xuICByZXR1cm4gbyA8IC0wLjUgKiBCICYmIChvICs9IEYpLCB7XG4gICAgYW5nbGU6IG8sXG4gICAgZGlzdGFuY2U6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIGJpKGksIHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0LnggLSBpLngsIDIpICsgTWF0aC5wb3codC55IC0gaS55LCAyKSk7XG59XG5mdW5jdGlvbiBBbyhpLCB0KSB7XG4gIHJldHVybiAoaSAtIHQgKyBQbykgJSBGIC0gQjtcbn1cbmZ1bmN0aW9uIFooaSkge1xuICByZXR1cm4gKGkgJSBGICsgRikgJSBGO1xufVxuZnVuY3Rpb24gb2UoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gWihpKSwgbyA9IFoodCksIHIgPSBaKGUpLCBhID0gWihvIC0gbiksIGwgPSBaKHIgLSBuKSwgYyA9IFoobiAtIG8pLCBoID0gWihuIC0gcik7XG4gIHJldHVybiBuID09PSBvIHx8IG4gPT09IHIgfHwgcyAmJiBvID09PSByIHx8IGEgPiBsICYmIGMgPCBoO1xufVxuZnVuY3Rpb24gWShpLCB0LCBlKSB7XG4gIHJldHVybiBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBpKSk7XG59XG5mdW5jdGlvbiBUbyhpKSB7XG4gIHJldHVybiBZKGksIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gdXQoaSwgdCwgZSwgcyA9IDFlLTYpIHtcbiAgcmV0dXJuIGkgPj0gTWF0aC5taW4odCwgZSkgLSBzICYmIGkgPD0gTWF0aC5tYXgodCwgZSkgKyBzO1xufVxuZnVuY3Rpb24gVGkoaSwgdCwgZSkge1xuICBlID0gZSB8fCAoKHIpID0+IGlbcl0gPCB0KTtcbiAgbGV0IHMgPSBpLmxlbmd0aCAtIDEsIG4gPSAwLCBvO1xuICBmb3IgKDsgcyAtIG4gPiAxOyApXG4gICAgbyA9IG4gKyBzID4+IDEsIGUobykgPyBuID0gbyA6IHMgPSBvO1xuICByZXR1cm4geyBsbzogbiwgaGk6IHMgfTtcbn1cbmNvbnN0IGZ0ID0gKGksIHQsIGUsIHMpID0+IFRpKGksIGUsIHMgPyAobikgPT4gaVtuXVt0XSA8PSBlIDogKG4pID0+IGlbbl1bdF0gPCBlKSwgTG8gPSAoaSwgdCwgZSkgPT4gVGkoaSwgZSwgKHMpID0+IGlbc11bdF0gPj0gZSk7XG5mdW5jdGlvbiBSbyhpLCB0LCBlKSB7XG4gIGxldCBzID0gMCwgbiA9IGkubGVuZ3RoO1xuICBmb3IgKDsgcyA8IG4gJiYgaVtzXSA8IHQ7IClcbiAgICBzKys7XG4gIGZvciAoOyBuID4gcyAmJiBpW24gLSAxXSA+IGU7IClcbiAgICBuLS07XG4gIHJldHVybiBzID4gMCB8fCBuIDwgaS5sZW5ndGggPyBpLnNsaWNlKHMsIG4pIDogaTtcbn1cbmNvbnN0IGRuID0gW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwic3BsaWNlXCIsIFwidW5zaGlmdFwiXTtcbmZ1bmN0aW9uIEVvKGksIHQpIHtcbiAgaWYgKGkuX2NoYXJ0anMpIHtcbiAgICBpLl9jaGFydGpzLmxpc3RlbmVycy5wdXNoKHQpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfY2hhcnRqc1wiLCB7XG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbdF1cbiAgICB9XG4gIH0pLCBkbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgcyA9IFwiX29uRGF0YVwiICsgT2koZSksIG4gPSBpW2VdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBlLCB7XG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICB2YWx1ZSguLi5vKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuLmFwcGx5KHRoaXMsIG8pO1xuICAgICAgICByZXR1cm4gaS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICAgIHR5cGVvZiBhW3NdID09IFwiZnVuY3Rpb25cIiAmJiBhW3NdKC4uLm8pO1xuICAgICAgICB9KSwgcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBaaShpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLl9jaGFydGpzO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gZS5saXN0ZW5lcnMsIG4gPSBzLmluZGV4T2YodCk7XG4gIG4gIT09IC0xICYmIHMuc3BsaWNlKG4sIDEpLCAhKHMubGVuZ3RoID4gMCkgJiYgKGRuLmZvckVhY2goKG8pID0+IHtcbiAgICBkZWxldGUgaVtvXTtcbiAgfSksIGRlbGV0ZSBpLl9jaGFydGpzKTtcbn1cbmZ1bmN0aW9uIHVuKGkpIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBlLCBzO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgdC5hZGQoaVtlXSk7XG4gIHJldHVybiB0LnNpemUgPT09IHMgPyBpIDogQXJyYXkuZnJvbSh0KTtcbn1cbmNvbnN0IGZuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkoKTtcbiAgfSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCk7XG5mdW5jdGlvbiBnbihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBlIHx8ICgocikgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocikpO1xuICBsZXQgbiA9ICExLCBvID0gW107XG4gIHJldHVybiBmdW5jdGlvbiguLi5yKSB7XG4gICAgbyA9IHMociksIG4gfHwgKG4gPSAhMCwgZm4uY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIG4gPSAhMSwgaS5hcHBseSh0LCBvKTtcbiAgICB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiBGbyhpLCB0KSB7XG4gIGxldCBlO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucykge1xuICAgIHJldHVybiB0ID8gKGNsZWFyVGltZW91dChlKSwgZSA9IHNldFRpbWVvdXQoaSwgdCwgcykpIDogaS5hcHBseSh0aGlzLCBzKSwgdDtcbiAgfTtcbn1cbmNvbnN0IExpID0gKGkpID0+IGkgPT09IFwic3RhcnRcIiA/IFwibGVmdFwiIDogaSA9PT0gXCJlbmRcIiA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsIFUgPSAoaSwgdCwgZSkgPT4gaSA9PT0gXCJzdGFydFwiID8gdCA6IGkgPT09IFwiZW5kXCIgPyBlIDogKHQgKyBlKSAvIDIsIElvID0gKGksIHQsIGUsIHMpID0+IGkgPT09IChzID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpID8gZSA6IGkgPT09IFwiY2VudGVyXCIgPyAodCArIGUpIC8gMiA6IHQ7XG5mdW5jdGlvbiBwbihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSB0Lmxlbmd0aDtcbiAgbGV0IG4gPSAwLCBvID0gcztcbiAgaWYgKGkuX3NvcnRlZCkge1xuICAgIGNvbnN0IHsgaVNjYWxlOiByLCBfcGFyc2VkOiBhIH0gPSBpLCBsID0gci5heGlzLCB7IG1pbjogYywgbWF4OiBoLCBtaW5EZWZpbmVkOiBkLCBtYXhEZWZpbmVkOiB1IH0gPSByLmdldFVzZXJCb3VuZHMoKTtcbiAgICBkICYmIChuID0gWShcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBmdChhLCByLmF4aXMsIGMpLmxvLFxuICAgICAgICBlID8gcyA6IGZ0KHQsIGwsIHIuZ2V0UGl4ZWxGb3JWYWx1ZShjKSkubG9cbiAgICAgICksXG4gICAgICAwLFxuICAgICAgcyAtIDFcbiAgICApKSwgdSA/IG8gPSBZKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIGZ0KGEsIHIuYXhpcywgaCwgITApLmhpICsgMSxcbiAgICAgICAgZSA/IDAgOiBmdCh0LCBsLCByLmdldFBpeGVsRm9yVmFsdWUoaCksICEwKS5oaSArIDFcbiAgICAgICksXG4gICAgICBuLFxuICAgICAgc1xuICAgICkgLSBuIDogbyA9IHMgLSBuO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0OiBuLCBjb3VudDogbyB9O1xufVxuZnVuY3Rpb24gbW4oaSkge1xuICBjb25zdCB7IHhTY2FsZTogdCwgeVNjYWxlOiBlLCBfc2NhbGVSYW5nZXM6IHMgfSA9IGksIG4gPSB7XG4gICAgeG1pbjogdC5taW4sXG4gICAgeG1heDogdC5tYXgsXG4gICAgeW1pbjogZS5taW4sXG4gICAgeW1heDogZS5tYXhcbiAgfTtcbiAgaWYgKCFzKVxuICAgIHJldHVybiBpLl9zY2FsZVJhbmdlcyA9IG4sICEwO1xuICBjb25zdCBvID0gcy54bWluICE9PSB0Lm1pbiB8fCBzLnhtYXggIT09IHQubWF4IHx8IHMueW1pbiAhPT0gZS5taW4gfHwgcy55bWF4ICE9PSBlLm1heDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocywgbiksIG87XG59XG5jb25zdCB3ZSA9IChpKSA9PiBpID09PSAwIHx8IGkgPT09IDEsIEppID0gKGksIHQsIGUpID0+IC0oTWF0aC5wb3coMiwgMTAgKiAoaSAtPSAxKSkgKiBNYXRoLnNpbigoaSAtIHQpICogRiAvIGUpKSwgUWkgPSAoaSwgdCwgZSkgPT4gTWF0aC5wb3coMiwgLTEwICogaSkgKiBNYXRoLnNpbigoaSAtIHQpICogRiAvIGUpICsgMSwgZWUgPSB7XG4gIGxpbmVhcjogKGkpID0+IGksXG4gIGVhc2VJblF1YWQ6IChpKSA9PiBpICogaSxcbiAgZWFzZU91dFF1YWQ6IChpKSA9PiAtaSAqIChpIC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IChpKSA9PiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIGkgKiBpIDogLTAuNSAqICgtLWkgKiAoaSAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiAoaSkgPT4gaSAqIGkgKiBpLFxuICBlYXNlT3V0Q3ViaWM6IChpKSA9PiAoaSAtPSAxKSAqIGkgKiBpICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IChpKSA9PiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIGkgKiBpICogaSA6IDAuNSAqICgoaSAtPSAyKSAqIGkgKiBpICsgMiksXG4gIGVhc2VJblF1YXJ0OiAoaSkgPT4gaSAqIGkgKiBpICogaSxcbiAgZWFzZU91dFF1YXJ0OiAoaSkgPT4gLSgoaSAtPSAxKSAqIGkgKiBpICogaSAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogKGkpID0+IChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgKiBpICogaSA6IC0wLjUgKiAoKGkgLT0gMikgKiBpICogaSAqIGkgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IChpKSA9PiBpICogaSAqIGkgKiBpICogaSxcbiAgZWFzZU91dFF1aW50OiAoaSkgPT4gKGkgLT0gMSkgKiBpICogaSAqIGkgKiBpICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IChpKSA9PiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIGkgKiBpICogaSAqIGkgKiBpIDogMC41ICogKChpIC09IDIpICogaSAqIGkgKiBpICogaSArIDIpLFxuICBlYXNlSW5TaW5lOiAoaSkgPT4gLU1hdGguY29zKGkgKiBWKSArIDEsXG4gIGVhc2VPdXRTaW5lOiAoaSkgPT4gTWF0aC5zaW4oaSAqIFYpLFxuICBlYXNlSW5PdXRTaW5lOiAoaSkgPT4gLTAuNSAqIChNYXRoLmNvcyhCICogaSkgLSAxKSxcbiAgZWFzZUluRXhwbzogKGkpID0+IGkgPT09IDAgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAoaSAtIDEpKSxcbiAgZWFzZU91dEV4cG86IChpKSA9PiBpID09PSAxID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiBpKSArIDEsXG4gIGVhc2VJbk91dEV4cG86IChpKSA9PiB3ZShpKSA/IGkgOiBpIDwgMC41ID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAoaSAqIDIgLSAxKSkgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChpICogMiAtIDEpKSArIDIpLFxuICBlYXNlSW5DaXJjOiAoaSkgPT4gaSA+PSAxID8gaSA6IC0oTWF0aC5zcXJ0KDEgLSBpICogaSkgLSAxKSxcbiAgZWFzZU91dENpcmM6IChpKSA9PiBNYXRoLnNxcnQoMSAtIChpIC09IDEpICogaSksXG4gIGVhc2VJbk91dENpcmM6IChpKSA9PiAoaSAvPSAwLjUpIDwgMSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBpICogaSkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtIChpIC09IDIpICogaSkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogKGkpID0+IHdlKGkpID8gaSA6IEppKGksIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogKGkpID0+IHdlKGkpID8gaSA6IFFpKGksIDAuMDc1LCAwLjMpLFxuICBlYXNlSW5PdXRFbGFzdGljKGkpIHtcbiAgICByZXR1cm4gd2UoaSkgPyBpIDogaSA8IDAuNSA/IDAuNSAqIEppKGkgKiAyLCAwLjExMjUsIDAuNDUpIDogMC41ICsgMC41ICogUWkoaSAqIDIgLSAxLCAwLjExMjUsIDAuNDUpO1xuICB9LFxuICBlYXNlSW5CYWNrKGkpIHtcbiAgICByZXR1cm4gaSAqIGkgKiAoKDEuNzAxNTggKyAxKSAqIGkgLSAxLjcwMTU4KTtcbiAgfSxcbiAgZWFzZU91dEJhY2soaSkge1xuICAgIHJldHVybiAoaSAtPSAxKSAqIGkgKiAoKDEuNzAxNTggKyAxKSAqIGkgKyAxLjcwMTU4KSArIDE7XG4gIH0sXG4gIGVhc2VJbk91dEJhY2soaSkge1xuICAgIGxldCB0ID0gMS43MDE1ODtcbiAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiAoaSAqIGkgKiAoKCh0ICo9IDEuNTI1KSArIDEpICogaSAtIHQpKSA6IDAuNSAqICgoaSAtPSAyKSAqIGkgKiAoKCh0ICo9IDEuNTI1KSArIDEpICogaSArIHQpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogKGkpID0+IDEgLSBlZS5lYXNlT3V0Qm91bmNlKDEgLSBpKSxcbiAgZWFzZU91dEJvdW5jZShpKSB7XG4gICAgcmV0dXJuIGkgPCAxIC8gMi43NSA/IDcuNTYyNSAqIGkgKiBpIDogaSA8IDIgLyAyLjc1ID8gNy41NjI1ICogKGkgLT0gMS41IC8gMi43NSkgKiBpICsgMC43NSA6IGkgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKGkgLT0gMi4yNSAvIDIuNzUpICogaSArIDAuOTM3NSA6IDcuNTYyNSAqIChpIC09IDIuNjI1IC8gMi43NSkgKiBpICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogKGkpID0+IGkgPCAwLjUgPyBlZS5lYXNlSW5Cb3VuY2UoaSAqIDIpICogMC41IDogZWUuZWFzZU91dEJvdW5jZShpICogMiAtIDEpICogMC41ICsgMC41XG59O1xuLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjIuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIyIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiBoZShpKSB7XG4gIHJldHVybiBpICsgMC41IHwgMDtcbn1cbmNvbnN0IG10ID0gKGksIHQsIGUpID0+IE1hdGgubWF4KE1hdGgubWluKGksIGUpLCB0KTtcbmZ1bmN0aW9uIEd0KGkpIHtcbiAgcmV0dXJuIG10KGhlKGkgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIHh0KGkpIHtcbiAgcmV0dXJuIG10KGhlKGkgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gZHQoaSkge1xuICByZXR1cm4gbXQoaGUoaSAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIHRzKGkpIHtcbiAgcmV0dXJuIG10KGhlKGkgKiAxMDApLCAwLCAxMDApO1xufVxuY29uc3QgSiA9IHsgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNSB9LCB4aSA9IFsuLi5cIjAxMjM0NTY3ODlBQkNERUZcIl0sIHpvID0gKGkpID0+IHhpW2kgJiAxNV0sIEJvID0gKGkpID0+IHhpWyhpICYgMjQwKSA+PiA0XSArIHhpW2kgJiAxNV0sIFNlID0gKGkpID0+IChpICYgMjQwKSA+PiA0ID09PSAoaSAmIDE1KSwgVm8gPSAoaSkgPT4gU2UoaS5yKSAmJiBTZShpLmcpICYmIFNlKGkuYikgJiYgU2UoaS5hKTtcbmZ1bmN0aW9uIFdvKGkpIHtcbiAgdmFyIHQgPSBpLmxlbmd0aCwgZTtcbiAgcmV0dXJuIGlbMF0gPT09IFwiI1wiICYmICh0ID09PSA0IHx8IHQgPT09IDUgPyBlID0ge1xuICAgIHI6IDI1NSAmIEpbaVsxXV0gKiAxNyxcbiAgICBnOiAyNTUgJiBKW2lbMl1dICogMTcsXG4gICAgYjogMjU1ICYgSltpWzNdXSAqIDE3LFxuICAgIGE6IHQgPT09IDUgPyBKW2lbNF1dICogMTcgOiAyNTVcbiAgfSA6ICh0ID09PSA3IHx8IHQgPT09IDkpICYmIChlID0ge1xuICAgIHI6IEpbaVsxXV0gPDwgNCB8IEpbaVsyXV0sXG4gICAgZzogSltpWzNdXSA8PCA0IHwgSltpWzRdXSxcbiAgICBiOiBKW2lbNV1dIDw8IDQgfCBKW2lbNl1dLFxuICAgIGE6IHQgPT09IDkgPyBKW2lbN11dIDw8IDQgfCBKW2lbOF1dIDogMjU1XG4gIH0pKSwgZTtcbn1cbmNvbnN0IE5vID0gKGksIHQpID0+IGkgPCAyNTUgPyB0KGkpIDogXCJcIjtcbmZ1bmN0aW9uIEhvKGkpIHtcbiAgdmFyIHQgPSBWbyhpKSA/IHpvIDogQm87XG4gIHJldHVybiBpID8gXCIjXCIgKyB0KGkucikgKyB0KGkuZykgKyB0KGkuYikgKyBObyhpLmEsIHQpIDogdm9pZCAwO1xufVxuY29uc3Qgam8gPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gYm4oaSwgdCwgZSkge1xuICBjb25zdCBzID0gdCAqIE1hdGgubWluKGUsIDEgLSBlKSwgbiA9IChvLCByID0gKG8gKyBpIC8gMzApICUgMTIpID0+IGUgLSBzICogTWF0aC5tYXgoTWF0aC5taW4ociAtIDMsIDkgLSByLCAxKSwgLTEpO1xuICByZXR1cm4gW24oMCksIG4oOCksIG4oNCldO1xufVxuZnVuY3Rpb24gJG8oaSwgdCwgZSkge1xuICBjb25zdCBzID0gKG4sIG8gPSAobiArIGkgLyA2MCkgJSA2KSA9PiBlIC0gZSAqIHQgKiBNYXRoLm1heChNYXRoLm1pbihvLCA0IC0gbywgMSksIDApO1xuICByZXR1cm4gW3MoNSksIHMoMyksIHMoMSldO1xufVxuZnVuY3Rpb24gWW8oaSwgdCwgZSkge1xuICBjb25zdCBzID0gYm4oaSwgMSwgMC41KTtcbiAgbGV0IG47XG4gIGZvciAodCArIGUgPiAxICYmIChuID0gMSAvICh0ICsgZSksIHQgKj0gbiwgZSAqPSBuKSwgbiA9IDA7IG4gPCAzOyBuKyspXG4gICAgc1tuXSAqPSAxIC0gdCAtIGUsIHNbbl0gKz0gdDtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBYbyhpLCB0LCBlLCBzLCBuKSB7XG4gIHJldHVybiBpID09PSBuID8gKHQgLSBlKSAvIHMgKyAodCA8IGUgPyA2IDogMCkgOiB0ID09PSBuID8gKGUgLSBpKSAvIHMgKyAyIDogKGkgLSB0KSAvIHMgKyA0O1xufVxuZnVuY3Rpb24gUmkoaSkge1xuICBjb25zdCBlID0gaS5yIC8gMjU1LCBzID0gaS5nIC8gMjU1LCBuID0gaS5iIC8gMjU1LCBvID0gTWF0aC5tYXgoZSwgcywgbiksIHIgPSBNYXRoLm1pbihlLCBzLCBuKSwgYSA9IChvICsgcikgLyAyO1xuICBsZXQgbCwgYywgaDtcbiAgcmV0dXJuIG8gIT09IHIgJiYgKGggPSBvIC0gciwgYyA9IGEgPiAwLjUgPyBoIC8gKDIgLSBvIC0gcikgOiBoIC8gKG8gKyByKSwgbCA9IFhvKGUsIHMsIG4sIGgsIG8pLCBsID0gbCAqIDYwICsgMC41KSwgW2wgfCAwLCBjIHx8IDAsIGFdO1xufVxuZnVuY3Rpb24gRWkoaSwgdCwgZSwgcykge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkodCkgPyBpKHRbMF0sIHRbMV0sIHRbMl0pIDogaSh0LCBlLCBzKSkubWFwKHh0KTtcbn1cbmZ1bmN0aW9uIEZpKGksIHQsIGUpIHtcbiAgcmV0dXJuIEVpKGJuLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIFVvKGksIHQsIGUpIHtcbiAgcmV0dXJuIEVpKFlvLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIEtvKGksIHQsIGUpIHtcbiAgcmV0dXJuIEVpKCRvLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIHhuKGkpIHtcbiAgcmV0dXJuIChpICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIHFvKGkpIHtcbiAgY29uc3QgdCA9IGpvLmV4ZWMoaSk7XG4gIGxldCBlID0gMjU1LCBzO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuO1xuICB0WzVdICE9PSBzICYmIChlID0gdFs2XSA/IEd0KCt0WzVdKSA6IHh0KCt0WzVdKSk7XG4gIGNvbnN0IG4gPSB4bigrdFsyXSksIG8gPSArdFszXSAvIDEwMCwgciA9ICt0WzRdIC8gMTAwO1xuICByZXR1cm4gdFsxXSA9PT0gXCJod2JcIiA/IHMgPSBVbyhuLCBvLCByKSA6IHRbMV0gPT09IFwiaHN2XCIgPyBzID0gS28obiwgbywgcikgOiBzID0gRmkobiwgbywgciksIHtcbiAgICByOiBzWzBdLFxuICAgIGc6IHNbMV0sXG4gICAgYjogc1syXSxcbiAgICBhOiBlXG4gIH07XG59XG5mdW5jdGlvbiBHbyhpLCB0KSB7XG4gIHZhciBlID0gUmkoaSk7XG4gIGVbMF0gPSB4bihlWzBdICsgdCksIGUgPSBGaShlKSwgaS5yID0gZVswXSwgaS5nID0gZVsxXSwgaS5iID0gZVsyXTtcbn1cbmZ1bmN0aW9uIFpvKGkpIHtcbiAgaWYgKCFpKVxuICAgIHJldHVybjtcbiAgY29uc3QgdCA9IFJpKGkpLCBlID0gdFswXSwgcyA9IHRzKHRbMV0pLCBuID0gdHModFsyXSk7XG4gIHJldHVybiBpLmEgPCAyNTUgPyBgaHNsYSgke2V9LCAke3N9JSwgJHtufSUsICR7ZHQoaS5hKX0pYCA6IGBoc2woJHtlfSwgJHtzfSUsICR7bn0lKWA7XG59XG5jb25zdCBlcyA9IHtcbiAgeDogXCJkYXJrXCIsXG4gIFo6IFwibGlnaHRcIixcbiAgWTogXCJyZVwiLFxuICBYOiBcImJsdVwiLFxuICBXOiBcImdyXCIsXG4gIFY6IFwibWVkaXVtXCIsXG4gIFU6IFwic2xhdGVcIixcbiAgQTogXCJlZVwiLFxuICBUOiBcIm9sXCIsXG4gIFM6IFwib3JcIixcbiAgQjogXCJyYVwiLFxuICBDOiBcImxhdGVnXCIsXG4gIEQ6IFwiaWdodHNcIixcbiAgUjogXCJpblwiLFxuICBROiBcInR1cnF1b2lzXCIsXG4gIEU6IFwiaGlcIixcbiAgUDogXCJyb1wiLFxuICBPOiBcImFsXCIsXG4gIE46IFwibGVcIixcbiAgTTogXCJkZVwiLFxuICBMOiBcInllbGxvXCIsXG4gIEY6IFwiZW5cIixcbiAgSzogXCJjaFwiLFxuICBHOiBcImFya3NcIixcbiAgSDogXCJlYVwiLFxuICBJOiBcImlnaHRnXCIsXG4gIEo6IFwid2hcIlxufSwgaXMgPSB7XG4gIE9pY2VYZTogXCJmMGY4ZmZcIixcbiAgYW50aXF1ZXdFdGU6IFwiZmFlYmQ3XCIsXG4gIGFxdWE6IFwiZmZmZlwiLFxuICBhcXVhbWFyUmU6IFwiN2ZmZmQ0XCIsXG4gIGF6dVk6IFwiZjBmZmZmXCIsXG4gIGJlaWdlOiBcImY1ZjVkY1wiLFxuICBiaXNxdWU6IFwiZmZlNGM0XCIsXG4gIGJsYWNrOiBcIjBcIixcbiAgYmxhbktlZE9tb25kOiBcImZmZWJjZFwiLFxuICBYZTogXCJmZlwiLFxuICBYZXZpVGV0OiBcIjhhMmJlMlwiLFxuICBiUHduOiBcImE1MmEyYVwiLFxuICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gIGNhTXRYZTogXCI1ZjllYTBcIixcbiAgS2FydFl1c2U6IFwiN2ZmZjAwXCIsXG4gIEtvY1RhdGU6IFwiZDI2OTFlXCIsXG4gIGNTTzogXCJmZjdmNTBcIixcbiAgY1NuZmxvd2VyWGU6IFwiNjQ5NWVkXCIsXG4gIGNTbnNpbGs6IFwiZmZmOGRjXCIsXG4gIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gIGN5YW46IFwiZmZmZlwiLFxuICB4WGU6IFwiOGJcIixcbiAgeGN5YW46IFwiOGI4YlwiLFxuICB4Z1RNblBkOiBcImI4ODYwYlwiLFxuICB4V2F5OiBcImE5YTlhOVwiLFxuICB4Z1lGOiBcIjY0MDBcIixcbiAgeGdZeTogXCJhOWE5YTlcIixcbiAgeGtoYWtpOiBcImJkYjc2YlwiLFxuICB4bWFnRnRhOiBcIjhiMDA4YlwiLFxuICB4VGl2ZWdZRjogXCI1NTZiMmZcIixcbiAgeFNhbmdlOiBcImZmOGMwMFwiLFxuICB4U2NFZDogXCI5OTMyY2NcIixcbiAgeFlkOiBcIjhiMDAwMFwiLFxuICB4c09tb246IFwiZTk5NjdhXCIsXG4gIHhzSGdZRjogXCI4ZmJjOGZcIixcbiAgeFVYZTogXCI0ODNkOGJcIixcbiAgeFVXYXk6IFwiMmY0ZjRmXCIsXG4gIHhVZ1l5OiBcIjJmNGY0ZlwiLFxuICB4UWU6IFwiY2VkMVwiLFxuICB4dmlUZXQ6IFwiOTQwMGQzXCIsXG4gIGRBcHBSazogXCJmZjE0OTNcIixcbiAgZEFwc2t5WGU6IFwiYmZmZlwiLFxuICBkaW1XYXk6IFwiNjk2OTY5XCIsXG4gIGRpbWdZeTogXCI2OTY5NjlcIixcbiAgZG9kZ2VyWGU6IFwiMWU5MGZmXCIsXG4gIGZpWWJyaWNrOiBcImIyMjIyMlwiLFxuICBmbFNPd0V0ZTogXCJmZmZhZjBcIixcbiAgZm9Zc3RXQW46IFwiMjI4YjIyXCIsXG4gIGZ1S3NpYTogXCJmZjAwZmZcIixcbiAgZ2FSc2JTbzogXCJkY2RjZGNcIixcbiAgZ2hvc3R3RXRlOiBcImY4ZjhmZlwiLFxuICBnVGQ6IFwiZmZkNzAwXCIsXG4gIGdUTW5QZDogXCJkYWE1MjBcIixcbiAgV2F5OiBcIjgwODA4MFwiLFxuICBnWUY6IFwiODAwMFwiLFxuICBnWUZMdzogXCJhZGZmMmZcIixcbiAgZ1l5OiBcIjgwODA4MFwiLFxuICBob25leU13OiBcImYwZmZmMFwiLFxuICBob3RwUms6IFwiZmY2OWI0XCIsXG4gIFJkaWFuWWQ6IFwiY2Q1YzVjXCIsXG4gIFJkaWdvOiBcIjRiMDA4MlwiLFxuICBpdlN5OiBcImZmZmZmMFwiLFxuICBraGFraTogXCJmMGU2OGNcIixcbiAgbGF2Rk1yOiBcImU2ZTZmYVwiLFxuICBsYXZGTXJYc2g6IFwiZmZmMGY1XCIsXG4gIGxhd25nWUY6IFwiN2NmYzAwXCIsXG4gIE5tb25jRWZmb246IFwiZmZmYWNkXCIsXG4gIFpYZTogXCJhZGQ4ZTZcIixcbiAgWmNTTzogXCJmMDgwODBcIixcbiAgWmN5YW46IFwiZTBmZmZmXCIsXG4gIFpnVE1uUGRMdzogXCJmYWZhZDJcIixcbiAgWldheTogXCJkM2QzZDNcIixcbiAgWmdZRjogXCI5MGVlOTBcIixcbiAgWmdZeTogXCJkM2QzZDNcIixcbiAgWnBSazogXCJmZmI2YzFcIixcbiAgWnNPbW9uOiBcImZmYTA3YVwiLFxuICBac0hnWUY6IFwiMjBiMmFhXCIsXG4gIFpza3lYZTogXCI4N2NlZmFcIixcbiAgWlVXYXk6IFwiNzc4ODk5XCIsXG4gIFpVZ1l5OiBcIjc3ODg5OVwiLFxuICBac3RBbFhlOiBcImIwYzRkZVwiLFxuICBaTHc6IFwiZmZmZmUwXCIsXG4gIGxpbWU6IFwiZmYwMFwiLFxuICBsaW1lZ1lGOiBcIjMyY2QzMlwiLFxuICBsUkY6IFwiZmFmMGU2XCIsXG4gIG1hZ0Z0YTogXCJmZjAwZmZcIixcbiAgbWFQb246IFwiODAwMDAwXCIsXG4gIFZhcXVhbWFyUmU6IFwiNjZjZGFhXCIsXG4gIFZYZTogXCJjZFwiLFxuICBWU2NFZDogXCJiYTU1ZDNcIixcbiAgVnB1cnBOOiBcIjkzNzBkYlwiLFxuICBWc0hnWUY6IFwiM2NiMzcxXCIsXG4gIFZVWGU6IFwiN2I2OGVlXCIsXG4gIFZzcHJSZ2dZRjogXCJmYTlhXCIsXG4gIFZRZTogXCI0OGQxY2NcIixcbiAgVnZpVGV0WWQ6IFwiYzcxNTg1XCIsXG4gIG1pZG5pZ2h0WGU6IFwiMTkxOTcwXCIsXG4gIG1SdGNZYW06IFwiZjVmZmZhXCIsXG4gIG1pc3R5UHNlOiBcImZmZTRlMVwiLFxuICBtb2NjYXNSOiBcImZmZTRiNVwiLFxuICBuYXZham93RXRlOiBcImZmZGVhZFwiLFxuICBuYXZ5OiBcIjgwXCIsXG4gIFRkbGFjZTogXCJmZGY1ZTZcIixcbiAgVGl2ZTogXCI4MDgwMDBcIixcbiAgVGl2ZWRCYjogXCI2YjhlMjNcIixcbiAgU2FuZ2U6IFwiZmZhNTAwXCIsXG4gIFNhbmdlWWQ6IFwiZmY0NTAwXCIsXG4gIFNjRWQ6IFwiZGE3MGQ2XCIsXG4gIHBPZWdUTW5QZDogXCJlZWU4YWFcIixcbiAgcE9lZ1lGOiBcIjk4ZmI5OFwiLFxuICBwT2VRZTogXCJhZmVlZWVcIixcbiAgcE9ldmlUZXRZZDogXCJkYjcwOTNcIixcbiAgcGFwYXlhd0VwOiBcImZmZWZkNVwiLFxuICBwSEtwdWZmOiBcImZmZGFiOVwiLFxuICBwZXJ1OiBcImNkODUzZlwiLFxuICBwUms6IFwiZmZjMGNiXCIsXG4gIHBsdW06IFwiZGRhMGRkXCIsXG4gIHBvd01yWGU6IFwiYjBlMGU2XCIsXG4gIHB1cnBOOiBcIjgwMDA4MFwiLFxuICBZYmVjY2FwdXJwTjogXCI2NjMzOTlcIixcbiAgWWQ6IFwiZmYwMDAwXCIsXG4gIFBzeWJyb3duOiBcImJjOGY4ZlwiLFxuICBQeU9YZTogXCI0MTY5ZTFcIixcbiAgc2FkZE5iUHduOiBcIjhiNDUxM1wiLFxuICBzT21vbjogXCJmYTgwNzJcIixcbiAgc2FuZHliUHduOiBcImY0YTQ2MFwiLFxuICBzSGdZRjogXCIyZThiNTdcIixcbiAgc0hzaGVsbDogXCJmZmY1ZWVcIixcbiAgc2lGbmE6IFwiYTA1MjJkXCIsXG4gIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgc2t5WGU6IFwiODdjZWViXCIsXG4gIFVYZTogXCI2YTVhY2RcIixcbiAgVVdheTogXCI3MDgwOTBcIixcbiAgVWdZeTogXCI3MDgwOTBcIixcbiAgc25vdzogXCJmZmZhZmFcIixcbiAgc3ByUmdnWUY6IFwiZmY3ZlwiLFxuICBzdEFsWGU6IFwiNDY4MmI0XCIsXG4gIHRhbjogXCJkMmI0OGNcIixcbiAgdGVPOiBcIjgwODBcIixcbiAgdEVzdE46IFwiZDhiZmQ4XCIsXG4gIHRvbWF0bzogXCJmZjYzNDdcIixcbiAgUWU6IFwiNDBlMGQwXCIsXG4gIHZpVGV0OiBcImVlODJlZVwiLFxuICBKSHQ6IFwiZjVkZWIzXCIsXG4gIHdFdGU6IFwiZmZmZmZmXCIsXG4gIHdFdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgTHc6IFwiZmZmZjAwXCIsXG4gIEx3Z1lGOiBcIjlhY2QzMlwiXG59O1xuZnVuY3Rpb24gSm8oKSB7XG4gIGNvbnN0IGkgPSB7fSwgdCA9IE9iamVjdC5rZXlzKGlzKSwgZSA9IE9iamVjdC5rZXlzKGVzKTtcbiAgbGV0IHMsIG4sIG8sIHIsIGE7XG4gIGZvciAocyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKSB7XG4gICAgZm9yIChyID0gYSA9IHRbc10sIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKylcbiAgICAgIG8gPSBlW25dLCBhID0gYS5yZXBsYWNlKG8sIGVzW29dKTtcbiAgICBvID0gcGFyc2VJbnQoaXNbcl0sIDE2KSwgaVthXSA9IFtvID4+IDE2ICYgMjU1LCBvID4+IDggJiAyNTUsIG8gJiAyNTVdO1xuICB9XG4gIHJldHVybiBpO1xufVxubGV0IFBlO1xuZnVuY3Rpb24gUW8oaSkge1xuICBQZSB8fCAoUGUgPSBKbygpLCBQZS50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHQgPSBQZVtpLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gdCAmJiB7XG4gICAgcjogdFswXSxcbiAgICBnOiB0WzFdLFxuICAgIGI6IHRbMl0sXG4gICAgYTogdC5sZW5ndGggPT09IDQgPyB0WzNdIDogMjU1XG4gIH07XG59XG5jb25zdCB0ciA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gZXIoaSkge1xuICBjb25zdCB0ID0gdHIuZXhlYyhpKTtcbiAgbGV0IGUgPSAyNTUsIHMsIG4sIG87XG4gIGlmICh0KSB7XG4gICAgaWYgKHRbN10gIT09IHMpIHtcbiAgICAgIGNvbnN0IHIgPSArdFs3XTtcbiAgICAgIGUgPSB0WzhdID8gR3QocikgOiBtdChyICogMjU1LCAwLCAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gcyA9ICt0WzFdLCBuID0gK3RbM10sIG8gPSArdFs1XSwgcyA9IDI1NSAmICh0WzJdID8gR3QocykgOiBtdChzLCAwLCAyNTUpKSwgbiA9IDI1NSAmICh0WzRdID8gR3QobikgOiBtdChuLCAwLCAyNTUpKSwgbyA9IDI1NSAmICh0WzZdID8gR3QobykgOiBtdChvLCAwLCAyNTUpKSwge1xuICAgICAgcjogcyxcbiAgICAgIGc6IG4sXG4gICAgICBiOiBvLFxuICAgICAgYTogZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlyKGkpIHtcbiAgcmV0dXJuIGkgJiYgKGkuYSA8IDI1NSA/IGByZ2JhKCR7aS5yfSwgJHtpLmd9LCAke2kuYn0sICR7ZHQoaS5hKX0pYCA6IGByZ2IoJHtpLnJ9LCAke2kuZ30sICR7aS5ifSlgKTtcbn1cbmNvbnN0IG5pID0gKGkpID0+IGkgPD0gMzEzMDhlLTcgPyBpICogMTIuOTIgOiBNYXRoLnBvdyhpLCAxIC8gMi40KSAqIDEuMDU1IC0gMC4wNTUsIEZ0ID0gKGkpID0+IGkgPD0gMC4wNDA0NSA/IGkgLyAxMi45MiA6IE1hdGgucG93KChpICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBzcihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBGdChkdChpLnIpKSwgbiA9IEZ0KGR0KGkuZykpLCBvID0gRnQoZHQoaS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogeHQobmkocyArIGUgKiAoRnQoZHQodC5yKSkgLSBzKSkpLFxuICAgIGc6IHh0KG5pKG4gKyBlICogKEZ0KGR0KHQuZykpIC0gbikpKSxcbiAgICBiOiB4dChuaShvICsgZSAqIChGdChkdCh0LmIpKSAtIG8pKSksXG4gICAgYTogaS5hICsgZSAqICh0LmEgLSBpLmEpXG4gIH07XG59XG5mdW5jdGlvbiBDZShpLCB0LCBlKSB7XG4gIGlmIChpKSB7XG4gICAgbGV0IHMgPSBSaShpKTtcbiAgICBzW3RdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc1t0XSArIHNbdF0gKiBlLCB0ID09PSAwID8gMzYwIDogMSkpLCBzID0gRmkocyksIGkuciA9IHNbMF0sIGkuZyA9IHNbMV0sIGkuYiA9IHNbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIF9uKGksIHQpIHtcbiAgcmV0dXJuIGkgJiYgT2JqZWN0LmFzc2lnbih0IHx8IHt9LCBpKTtcbn1cbmZ1bmN0aW9uIHNzKGkpIHtcbiAgdmFyIHQgPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NSB9O1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpKSA/IGkubGVuZ3RoID49IDMgJiYgKHQgPSB7IHI6IGlbMF0sIGc6IGlbMV0sIGI6IGlbMl0sIGE6IDI1NSB9LCBpLmxlbmd0aCA+IDMgJiYgKHQuYSA9IHh0KGlbM10pKSkgOiAodCA9IF9uKGksIHsgcjogMCwgZzogMCwgYjogMCwgYTogMSB9KSwgdC5hID0geHQodC5hKSksIHQ7XG59XG5mdW5jdGlvbiBucihpKSB7XG4gIHJldHVybiBpLmNoYXJBdCgwKSA9PT0gXCJyXCIgPyBlcihpKSA6IHFvKGkpO1xufVxuY2xhc3MgV2Uge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgaWYgKHQgaW5zdGFuY2VvZiBXZSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGUgPSB0eXBlb2YgdDtcbiAgICBsZXQgcztcbiAgICBlID09PSBcIm9iamVjdFwiID8gcyA9IHNzKHQpIDogZSA9PT0gXCJzdHJpbmdcIiAmJiAocyA9IFdvKHQpIHx8IFFvKHQpIHx8IG5yKHQpKSwgdGhpcy5fcmdiID0gcywgdGhpcy5fdmFsaWQgPSAhIXM7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB0ID0gX24odGhpcy5fcmdiKTtcbiAgICByZXR1cm4gdCAmJiAodC5hID0gZHQodC5hKSksIHQ7XG4gIH1cbiAgc2V0IHJnYih0KSB7XG4gICAgdGhpcy5fcmdiID0gc3ModCk7XG4gIH1cbiAgcmdiU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGlyKHRoaXMuX3JnYikgOiB2b2lkIDA7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IEhvKHRoaXMuX3JnYikgOiB2b2lkIDA7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IFpvKHRoaXMuX3JnYikgOiB2b2lkIDA7XG4gIH1cbiAgbWl4KHQsIGUpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMucmdiLCBuID0gdC5yZ2I7XG4gICAgICBsZXQgbztcbiAgICAgIGNvbnN0IHIgPSBlID09PSBvID8gMC41IDogZSwgYSA9IDIgKiByIC0gMSwgbCA9IHMuYSAtIG4uYSwgYyA9ICgoYSAqIGwgPT09IC0xID8gYSA6IChhICsgbCkgLyAoMSArIGEgKiBsKSkgKyAxKSAvIDI7XG4gICAgICBvID0gMSAtIGMsIHMuciA9IDI1NSAmIGMgKiBzLnIgKyBvICogbi5yICsgMC41LCBzLmcgPSAyNTUgJiBjICogcy5nICsgbyAqIG4uZyArIDAuNSwgcy5iID0gMjU1ICYgYyAqIHMuYiArIG8gKiBuLmIgKyAwLjUsIHMuYSA9IHIgKiBzLmEgKyAoMSAtIHIpICogbi5hLCB0aGlzLnJnYiA9IHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludGVycG9sYXRlKHQsIGUpIHtcbiAgICByZXR1cm4gdCAmJiAodGhpcy5fcmdiID0gc3IodGhpcy5fcmdiLCB0Ll9yZ2IsIGUpKSwgdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFdlKHRoaXMucmdiKTtcbiAgfVxuICBhbHBoYSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYi5hID0geHQodCksIHRoaXM7XG4gIH1cbiAgY2xlYXJlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3JnYjtcbiAgICByZXR1cm4gZS5hICo9IDEgLSB0LCB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fcmdiLCBlID0gaGUodC5yICogMC4zICsgdC5nICogMC41OSArIHQuYiAqIDAuMTEpO1xuICAgIHJldHVybiB0LnIgPSB0LmcgPSB0LmIgPSBlLCB0aGlzO1xuICB9XG4gIG9wYXF1ZXIodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9yZ2I7XG4gICAgcmV0dXJuIGUuYSAqPSAxICsgdCwgdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3JnYjtcbiAgICByZXR1cm4gdC5yID0gMjU1IC0gdC5yLCB0LmcgPSAyNTUgLSB0LmcsIHQuYiA9IDI1NSAtIHQuYiwgdGhpcztcbiAgfVxuICBsaWdodGVuKHQpIHtcbiAgICByZXR1cm4gQ2UodGhpcy5fcmdiLCAyLCB0KSwgdGhpcztcbiAgfVxuICBkYXJrZW4odCkge1xuICAgIHJldHVybiBDZSh0aGlzLl9yZ2IsIDIsIC10KSwgdGhpcztcbiAgfVxuICBzYXR1cmF0ZSh0KSB7XG4gICAgcmV0dXJuIENlKHRoaXMuX3JnYiwgMSwgdCksIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZSh0KSB7XG4gICAgcmV0dXJuIENlKHRoaXMuX3JnYiwgMSwgLXQpLCB0aGlzO1xuICB9XG4gIHJvdGF0ZSh0KSB7XG4gICAgcmV0dXJuIEdvKHRoaXMuX3JnYiwgdCksIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIHluKGkpIHtcbiAgcmV0dXJuIG5ldyBXZShpKTtcbn1cbmZ1bmN0aW9uIHZuKGkpIHtcbiAgaWYgKGkgJiYgdHlwZW9mIGkgPT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHQgPSBpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHQgPT09IFwiW29iamVjdCBDYW52YXNQYXR0ZXJuXVwiIHx8IHQgPT09IFwiW29iamVjdCBDYW52YXNHcmFkaWVudF1cIjtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBucyhpKSB7XG4gIHJldHVybiB2bihpKSA/IGkgOiB5bihpKTtcbn1cbmZ1bmN0aW9uIG9pKGkpIHtcbiAgcmV0dXJuIHZuKGkpID8gaSA6IHluKGkpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5jb25zdCBBdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBfaSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaWUoaSwgdCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIGk7XG4gIGNvbnN0IGUgPSB0LnNwbGl0KFwiLlwiKTtcbiAgZm9yIChsZXQgcyA9IDAsIG4gPSBlLmxlbmd0aDsgcyA8IG47ICsrcykge1xuICAgIGNvbnN0IG8gPSBlW3NdO1xuICAgIGkgPSBpW29dIHx8IChpW29dID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gcmkoaSwgdCwgZSkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IG5lKGllKGksIHQpLCBlKSA6IG5lKGllKGksIFwiXCIpLCB0KTtcbn1cbmNsYXNzIG9yIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdm9pZCAwLCB0aGlzLmJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLDAsMCwwLjEpXCIsIHRoaXMuYm9yZGVyQ29sb3IgPSBcInJnYmEoMCwwLDAsMC4xKVwiLCB0aGlzLmNvbG9yID0gXCIjNjY2XCIsIHRoaXMuZGF0YXNldHMgPSB7fSwgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGUpID0+IGUuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpLCB0aGlzLmVsZW1lbnRzID0ge30sIHRoaXMuZXZlbnRzID0gW1xuICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgIFwibW91c2VvdXRcIixcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgXCJ0b3VjaG1vdmVcIlxuICAgIF0sIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogXCJub3JtYWxcIixcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH0sIHRoaXMuaG92ZXIgPSB7fSwgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChlLCBzKSA9PiBvaShzLmJhY2tncm91bmRDb2xvciksIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChlLCBzKSA9PiBvaShzLmJvcmRlckNvbG9yKSwgdGhpcy5ob3ZlckNvbG9yID0gKGUsIHMpID0+IG9pKHMuY29sb3IpLCB0aGlzLmluZGV4QXhpcyA9IFwieFwiLCB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogXCJuZWFyZXN0XCIsXG4gICAgICBpbnRlcnNlY3Q6ICEwLFxuICAgICAgaW5jbHVkZUludmlzaWJsZTogITFcbiAgICB9LCB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSAhMCwgdGhpcy5vbkhvdmVyID0gbnVsbCwgdGhpcy5vbkNsaWNrID0gbnVsbCwgdGhpcy5wYXJzaW5nID0gITAsIHRoaXMucGx1Z2lucyA9IHt9LCB0aGlzLnJlc3BvbnNpdmUgPSAhMCwgdGhpcy5zY2FsZSA9IHZvaWQgMCwgdGhpcy5zY2FsZXMgPSB7fSwgdGhpcy5zaG93TGluZSA9ICEwLCB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gITAsIHRoaXMuZGVzY3JpYmUodCk7XG4gIH1cbiAgc2V0KHQsIGUpIHtcbiAgICByZXR1cm4gcmkodGhpcywgdCwgZSk7XG4gIH1cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gaWUodGhpcywgdCk7XG4gIH1cbiAgZGVzY3JpYmUodCwgZSkge1xuICAgIHJldHVybiByaShfaSwgdCwgZSk7XG4gIH1cbiAgb3ZlcnJpZGUodCwgZSkge1xuICAgIHJldHVybiByaShBdCwgdCwgZSk7XG4gIH1cbiAgcm91dGUodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBpZSh0aGlzLCB0KSwgciA9IGllKHRoaXMsIHMpLCBhID0gXCJfXCIgKyBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG8sIHtcbiAgICAgIFthXToge1xuICAgICAgICB2YWx1ZTogb1tlXSxcbiAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICB9LFxuICAgICAgW2VdOiB7XG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbCA9IHRoaXNbYV0sIGMgPSByW25dO1xuICAgICAgICAgIHJldHVybiBEKGwpID8gT2JqZWN0LmFzc2lnbih7fSwgYywgbCkgOiBDKGwsIGMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQobCkge1xuICAgICAgICAgIHRoaXNbYV0gPSBsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnZhciBPID0gbmV3IG9yKHtcbiAgX3NjcmlwdGFibGU6IChpKSA9PiAhaS5zdGFydHNXaXRoKFwib25cIiksXG4gIF9pbmRleGFibGU6IChpKSA9PiBpICE9PSBcImV2ZW50c1wiLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogXCJpbnRlcmFjdGlvblwiXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6ICExLFxuICAgIF9pbmRleGFibGU6ICExXG4gIH1cbn0pO1xuZnVuY3Rpb24gcnIoaSkge1xuICByZXR1cm4gIWkgfHwgVChpLnNpemUpIHx8IFQoaS5mYW1pbHkpID8gbnVsbCA6IChpLnN0eWxlID8gaS5zdHlsZSArIFwiIFwiIDogXCJcIikgKyAoaS53ZWlnaHQgPyBpLndlaWdodCArIFwiIFwiIDogXCJcIikgKyBpLnNpemUgKyBcInB4IFwiICsgaS5mYW1pbHk7XG59XG5mdW5jdGlvbiBOZShpLCB0LCBlLCBzLCBuKSB7XG4gIGxldCBvID0gdFtuXTtcbiAgcmV0dXJuIG8gfHwgKG8gPSB0W25dID0gaS5tZWFzdXJlVGV4dChuKS53aWR0aCwgZS5wdXNoKG4pKSwgbyA+IHMgJiYgKHMgPSBvKSwgcztcbn1cbmZ1bmN0aW9uIGFyKGksIHQsIGUsIHMpIHtcbiAgcyA9IHMgfHwge307XG4gIGxldCBuID0gcy5kYXRhID0gcy5kYXRhIHx8IHt9LCBvID0gcy5nYXJiYWdlQ29sbGVjdCA9IHMuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gIHMuZm9udCAhPT0gdCAmJiAobiA9IHMuZGF0YSA9IHt9LCBvID0gcy5nYXJiYWdlQ29sbGVjdCA9IFtdLCBzLmZvbnQgPSB0KSwgaS5zYXZlKCksIGkuZm9udCA9IHQ7XG4gIGxldCByID0gMDtcbiAgY29uc3QgYSA9IGUubGVuZ3RoO1xuICBsZXQgbCwgYywgaCwgZCwgdTtcbiAgZm9yIChsID0gMDsgbCA8IGE7IGwrKylcbiAgICBpZiAoZCA9IGVbbF0sIGQgIT0gbnVsbCAmJiB6KGQpICE9PSAhMClcbiAgICAgIHIgPSBOZShpLCBuLCBvLCByLCBkKTtcbiAgICBlbHNlIGlmICh6KGQpKVxuICAgICAgZm9yIChjID0gMCwgaCA9IGQubGVuZ3RoOyBjIDwgaDsgYysrKVxuICAgICAgICB1ID0gZFtjXSwgdSAhPSBudWxsICYmICF6KHUpICYmIChyID0gTmUoaSwgbiwgbywgciwgdSkpO1xuICBpLnJlc3RvcmUoKTtcbiAgY29uc3QgZiA9IG8ubGVuZ3RoIC8gMjtcbiAgaWYgKGYgPiBlLmxlbmd0aCkge1xuICAgIGZvciAobCA9IDA7IGwgPCBmOyBsKyspXG4gICAgICBkZWxldGUgbltvW2xdXTtcbiAgICBvLnNwbGljZSgwLCBmKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHd0KGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuY3VycmVudERldmljZVBpeGVsUmF0aW8sIG4gPSBlICE9PSAwID8gTWF0aC5tYXgoZSAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgodCAtIG4pICogcykgLyBzICsgbjtcbn1cbmZ1bmN0aW9uIG9zKGksIHQpIHtcbiAgdCA9IHQgfHwgaS5nZXRDb250ZXh0KFwiMmRcIiksIHQuc2F2ZSgpLCB0LnJlc2V0VHJhbnNmb3JtKCksIHQuY2xlYXJSZWN0KDAsIDAsIGkud2lkdGgsIGkuaGVpZ2h0KSwgdC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiB5aShpLCB0LCBlLCBzKSB7XG4gIE1uKGksIHQsIGUsIHMsIG51bGwpO1xufVxuZnVuY3Rpb24gTW4oaSwgdCwgZSwgcywgbikge1xuICBsZXQgbywgciwgYSwgbCwgYywgaDtcbiAgY29uc3QgZCA9IHQucG9pbnRTdHlsZSwgdSA9IHQucm90YXRpb24sIGYgPSB0LnJhZGl1cztcbiAgbGV0IGcgPSAodSB8fCAwKSAqIENvO1xuICBpZiAoZCAmJiB0eXBlb2YgZCA9PSBcIm9iamVjdFwiICYmIChvID0gZC50b1N0cmluZygpLCBvID09PSBcIltvYmplY3QgSFRNTEltYWdlRWxlbWVudF1cIiB8fCBvID09PSBcIltvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdXCIpKSB7XG4gICAgaS5zYXZlKCksIGkudHJhbnNsYXRlKGUsIHMpLCBpLnJvdGF0ZShnKSwgaS5kcmF3SW1hZ2UoZCwgLWQud2lkdGggLyAyLCAtZC5oZWlnaHQgLyAyLCBkLndpZHRoLCBkLmhlaWdodCksIGkucmVzdG9yZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShpc05hTihmKSB8fCBmIDw9IDApKSB7XG4gICAgc3dpdGNoIChpLmJlZ2luUGF0aCgpLCBkKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuID8gaS5lbGxpcHNlKGUsIHMsIG4gLyAyLCBmLCAwLCAwLCBGKSA6IGkuYXJjKGUsIHMsIGYsIDAsIEYpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICBpLm1vdmVUbyhlICsgTWF0aC5zaW4oZykgKiBmLCBzIC0gTWF0aC5jb3MoZykgKiBmKSwgZyArPSBLaSwgaS5saW5lVG8oZSArIE1hdGguc2luKGcpICogZiwgcyAtIE1hdGguY29zKGcpICogZiksIGcgKz0gS2ksIGkubGluZVRvKGUgKyBNYXRoLnNpbihnKSAqIGYsIHMgLSBNYXRoLmNvcyhnKSAqIGYpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWN0Um91bmRlZFwiOlxuICAgICAgICBjID0gZiAqIDAuNTE2LCBsID0gZiAtIGMsIHIgPSBNYXRoLmNvcyhnICsgJHQpICogbCwgYSA9IE1hdGguc2luKGcgKyAkdCkgKiBsLCBpLmFyYyhlIC0gciwgcyAtIGEsIGMsIGcgLSBCLCBnIC0gViksIGkuYXJjKGUgKyBhLCBzIC0gciwgYywgZyAtIFYsIGcpLCBpLmFyYyhlICsgciwgcyArIGEsIGMsIGcsIGcgKyBWKSwgaS5hcmMoZSAtIGEsIHMgKyByLCBjLCBnICsgViwgZyArIEIpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgIGlmICghdSkge1xuICAgICAgICAgIGwgPSBNYXRoLlNRUlQxXzIgKiBmLCBoID0gbiA/IG4gLyAyIDogbCwgaS5yZWN0KGUgLSBoLCBzIC0gbCwgMiAqIGgsIDIgKiBsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBnICs9ICR0O1xuICAgICAgY2FzZSBcInJlY3RSb3RcIjpcbiAgICAgICAgciA9IE1hdGguY29zKGcpICogZiwgYSA9IE1hdGguc2luKGcpICogZiwgaS5tb3ZlVG8oZSAtIHIsIHMgLSBhKSwgaS5saW5lVG8oZSArIGEsIHMgLSByKSwgaS5saW5lVG8oZSArIHIsIHMgKyBhKSwgaS5saW5lVG8oZSAtIGEsIHMgKyByKSwgaS5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3Jvc3NSb3RcIjpcbiAgICAgICAgZyArPSAkdDtcbiAgICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgICByID0gTWF0aC5jb3MoZykgKiBmLCBhID0gTWF0aC5zaW4oZykgKiBmLCBpLm1vdmVUbyhlIC0gciwgcyAtIGEpLCBpLmxpbmVUbyhlICsgciwgcyArIGEpLCBpLm1vdmVUbyhlICsgYSwgcyAtIHIpLCBpLmxpbmVUbyhlIC0gYSwgcyArIHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdGFyXCI6XG4gICAgICAgIHIgPSBNYXRoLmNvcyhnKSAqIGYsIGEgPSBNYXRoLnNpbihnKSAqIGYsIGkubW92ZVRvKGUgLSByLCBzIC0gYSksIGkubGluZVRvKGUgKyByLCBzICsgYSksIGkubW92ZVRvKGUgKyBhLCBzIC0gciksIGkubGluZVRvKGUgLSBhLCBzICsgciksIGcgKz0gJHQsIHIgPSBNYXRoLmNvcyhnKSAqIGYsIGEgPSBNYXRoLnNpbihnKSAqIGYsIGkubW92ZVRvKGUgLSByLCBzIC0gYSksIGkubGluZVRvKGUgKyByLCBzICsgYSksIGkubW92ZVRvKGUgKyBhLCBzIC0gciksIGkubGluZVRvKGUgLSBhLCBzICsgcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgciA9IG4gPyBuIC8gMiA6IE1hdGguY29zKGcpICogZiwgYSA9IE1hdGguc2luKGcpICogZiwgaS5tb3ZlVG8oZSAtIHIsIHMgLSBhKSwgaS5saW5lVG8oZSArIHIsIHMgKyBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGFzaFwiOlxuICAgICAgICBpLm1vdmVUbyhlLCBzKSwgaS5saW5lVG8oZSArIE1hdGguY29zKGcpICogZiwgcyArIE1hdGguc2luKGcpICogZik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpLmZpbGwoKSwgdC5ib3JkZXJXaWR0aCA+IDAgJiYgaS5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gcmUoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9IGUgfHwgMC41LCAhdCB8fCBpICYmIGkueCA+IHQubGVmdCAtIGUgJiYgaS54IDwgdC5yaWdodCArIGUgJiYgaS55ID4gdC50b3AgLSBlICYmIGkueSA8IHQuYm90dG9tICsgZTtcbn1cbmZ1bmN0aW9uIFhlKGksIHQpIHtcbiAgaS5zYXZlKCksIGkuYmVnaW5QYXRoKCksIGkucmVjdCh0LmxlZnQsIHQudG9wLCB0LnJpZ2h0IC0gdC5sZWZ0LCB0LmJvdHRvbSAtIHQudG9wKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiBVZShpKSB7XG4gIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gbHIoaSwgdCwgZSwgcywgbikge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIGkubGluZVRvKGUueCwgZS55KTtcbiAgaWYgKG4gPT09IFwibWlkZGxlXCIpIHtcbiAgICBjb25zdCBvID0gKHQueCArIGUueCkgLyAyO1xuICAgIGkubGluZVRvKG8sIHQueSksIGkubGluZVRvKG8sIGUueSk7XG4gIH0gZWxzZVxuICAgIG4gPT09IFwiYWZ0ZXJcIiAhPSAhIXMgPyBpLmxpbmVUbyh0LngsIGUueSkgOiBpLmxpbmVUbyhlLngsIHQueSk7XG4gIGkubGluZVRvKGUueCwgZS55KTtcbn1cbmZ1bmN0aW9uIGNyKGksIHQsIGUsIHMpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBpLmxpbmVUbyhlLngsIGUueSk7XG4gIGkuYmV6aWVyQ3VydmVUbyhcbiAgICBzID8gdC5jcDF4IDogdC5jcDJ4LFxuICAgIHMgPyB0LmNwMXkgOiB0LmNwMnksXG4gICAgcyA/IGUuY3AyeCA6IGUuY3AxeCxcbiAgICBzID8gZS5jcDJ5IDogZS5jcDF5LFxuICAgIGUueCxcbiAgICBlLnlcbiAgKTtcbn1cbmZ1bmN0aW9uIFR0KGksIHQsIGUsIHMsIG4sIG8gPSB7fSkge1xuICBjb25zdCByID0geih0KSA/IHQgOiBbdF0sIGEgPSBvLnN0cm9rZVdpZHRoID4gMCAmJiBvLnN0cm9rZUNvbG9yICE9PSBcIlwiO1xuICBsZXQgbCwgYztcbiAgZm9yIChpLnNhdmUoKSwgaS5mb250ID0gbi5zdHJpbmcsIGhyKGksIG8pLCBsID0gMDsgbCA8IHIubGVuZ3RoOyArK2wpXG4gICAgYyA9IHJbbF0sIGEgJiYgKG8uc3Ryb2tlQ29sb3IgJiYgKGkuc3Ryb2tlU3R5bGUgPSBvLnN0cm9rZUNvbG9yKSwgVChvLnN0cm9rZVdpZHRoKSB8fCAoaS5saW5lV2lkdGggPSBvLnN0cm9rZVdpZHRoKSwgaS5zdHJva2VUZXh0KGMsIGUsIHMsIG8ubWF4V2lkdGgpKSwgaS5maWxsVGV4dChjLCBlLCBzLCBvLm1heFdpZHRoKSwgZHIoaSwgZSwgcywgYywgbyksIHMgKz0gbi5saW5lSGVpZ2h0O1xuICBpLnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGhyKGksIHQpIHtcbiAgdC50cmFuc2xhdGlvbiAmJiBpLnRyYW5zbGF0ZSh0LnRyYW5zbGF0aW9uWzBdLCB0LnRyYW5zbGF0aW9uWzFdKSwgVCh0LnJvdGF0aW9uKSB8fCBpLnJvdGF0ZSh0LnJvdGF0aW9uKSwgdC5jb2xvciAmJiAoaS5maWxsU3R5bGUgPSB0LmNvbG9yKSwgdC50ZXh0QWxpZ24gJiYgKGkudGV4dEFsaWduID0gdC50ZXh0QWxpZ24pLCB0LnRleHRCYXNlbGluZSAmJiAoaS50ZXh0QmFzZWxpbmUgPSB0LnRleHRCYXNlbGluZSk7XG59XG5mdW5jdGlvbiBkcihpLCB0LCBlLCBzLCBuKSB7XG4gIGlmIChuLnN0cmlrZXRocm91Z2ggfHwgbi51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBvID0gaS5tZWFzdXJlVGV4dChzKSwgciA9IHQgLSBvLmFjdHVhbEJvdW5kaW5nQm94TGVmdCwgYSA9IHQgKyBvLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIGwgPSBlIC0gby5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCwgYyA9IGUgKyBvLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCwgaCA9IG4uc3RyaWtldGhyb3VnaCA/IChsICsgYykgLyAyIDogYztcbiAgICBpLnN0cm9rZVN0eWxlID0gaS5maWxsU3R5bGUsIGkuYmVnaW5QYXRoKCksIGkubGluZVdpZHRoID0gbi5kZWNvcmF0aW9uV2lkdGggfHwgMiwgaS5tb3ZlVG8ociwgaCksIGkubGluZVRvKGEsIGgpLCBpLnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZShpLCB0KSB7XG4gIGNvbnN0IHsgeDogZSwgeTogcywgdzogbiwgaDogbywgcmFkaXVzOiByIH0gPSB0O1xuICBpLmFyYyhlICsgci50b3BMZWZ0LCBzICsgci50b3BMZWZ0LCByLnRvcExlZnQsIC1WLCBCLCAhMCksIGkubGluZVRvKGUsIHMgKyBvIC0gci5ib3R0b21MZWZ0KSwgaS5hcmMoZSArIHIuYm90dG9tTGVmdCwgcyArIG8gLSByLmJvdHRvbUxlZnQsIHIuYm90dG9tTGVmdCwgQiwgViwgITApLCBpLmxpbmVUbyhlICsgbiAtIHIuYm90dG9tUmlnaHQsIHMgKyBvKSwgaS5hcmMoZSArIG4gLSByLmJvdHRvbVJpZ2h0LCBzICsgbyAtIHIuYm90dG9tUmlnaHQsIHIuYm90dG9tUmlnaHQsIFYsIDAsICEwKSwgaS5saW5lVG8oZSArIG4sIHMgKyByLnRvcFJpZ2h0KSwgaS5hcmMoZSArIG4gLSByLnRvcFJpZ2h0LCBzICsgci50b3BSaWdodCwgci50b3BSaWdodCwgMCwgLVYsICEwKSwgaS5saW5lVG8oZSArIHIudG9wTGVmdCwgcyk7XG59XG5jb25zdCB1ciA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pLCBmciA9IG5ldyBSZWdFeHAoL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC8pO1xuZnVuY3Rpb24gZ3IoaSwgdCkge1xuICBjb25zdCBlID0gKFwiXCIgKyBpKS5tYXRjaCh1cik7XG4gIGlmICghZSB8fCBlWzFdID09PSBcIm5vcm1hbFwiKVxuICAgIHJldHVybiB0ICogMS4yO1xuICBzd2l0Y2ggKGkgPSArZVsyXSwgZVszXSkge1xuICAgIGNhc2UgXCJweFwiOlxuICAgICAgcmV0dXJuIGk7XG4gICAgY2FzZSBcIiVcIjpcbiAgICAgIGkgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHQgKiBpO1xufVxuY29uc3QgcHIgPSAoaSkgPT4gK2kgfHwgMDtcbmZ1bmN0aW9uIElpKGksIHQpIHtcbiAgY29uc3QgZSA9IHt9LCBzID0gRCh0KSwgbiA9IHMgPyBPYmplY3Qua2V5cyh0KSA6IHQsIG8gPSBEKGkpID8gcyA/IChyKSA9PiBDKGlbcl0sIGlbdFtyXV0pIDogKHIpID0+IGlbcl0gOiAoKSA9PiBpO1xuICBmb3IgKGNvbnN0IHIgb2YgbilcbiAgICBlW3JdID0gcHIobyhyKSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24ga24oaSkge1xuICByZXR1cm4gSWkoaSwgeyB0b3A6IFwieVwiLCByaWdodDogXCJ4XCIsIGJvdHRvbTogXCJ5XCIsIGxlZnQ6IFwieFwiIH0pO1xufVxuZnVuY3Rpb24gRHQoaSkge1xuICByZXR1cm4gSWkoaSwgW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiLCBcImJvdHRvbVJpZ2h0XCJdKTtcbn1cbmZ1bmN0aW9uIEsoaSkge1xuICBjb25zdCB0ID0ga24oaSk7XG4gIHJldHVybiB0LndpZHRoID0gdC5sZWZ0ICsgdC5yaWdodCwgdC5oZWlnaHQgPSB0LnRvcCArIHQuYm90dG9tLCB0O1xufVxuZnVuY3Rpb24gJChpLCB0KSB7XG4gIGkgPSBpIHx8IHt9LCB0ID0gdCB8fCBPLmZvbnQ7XG4gIGxldCBlID0gQyhpLnNpemUsIHQuc2l6ZSk7XG4gIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgKGUgPSBwYXJzZUludChlLCAxMCkpO1xuICBsZXQgcyA9IEMoaS5zdHlsZSwgdC5zdHlsZSk7XG4gIHMgJiYgIShcIlwiICsgcykubWF0Y2goZnIpICYmIChjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHMgKyAnXCInKSwgcyA9IFwiXCIpO1xuICBjb25zdCBuID0ge1xuICAgIGZhbWlseTogQyhpLmZhbWlseSwgdC5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IGdyKEMoaS5saW5lSGVpZ2h0LCB0LmxpbmVIZWlnaHQpLCBlKSxcbiAgICBzaXplOiBlLFxuICAgIHN0eWxlOiBzLFxuICAgIHdlaWdodDogQyhpLndlaWdodCwgdC53ZWlnaHQpLFxuICAgIHN0cmluZzogXCJcIlxuICB9O1xuICByZXR1cm4gbi5zdHJpbmcgPSBycihuKSwgbjtcbn1cbmZ1bmN0aW9uIFp0KGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSAhMCwgbywgciwgYTtcbiAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKVxuICAgIGlmIChhID0gaVtvXSwgYSAhPT0gdm9pZCAwICYmICh0ICE9PSB2b2lkIDAgJiYgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiICYmIChhID0gYSh0KSwgbiA9ICExKSwgZSAhPT0gdm9pZCAwICYmIHooYSkgJiYgKGEgPSBhW2UgJSBhLmxlbmd0aF0sIG4gPSAhMSksIGEgIT09IHZvaWQgMCkpXG4gICAgICByZXR1cm4gcyAmJiAhbiAmJiAocy5jYWNoZWFibGUgPSAhMSksIGE7XG59XG5mdW5jdGlvbiBtcihpLCB0LCBlKSB7XG4gIGNvbnN0IHsgbWluOiBzLCBtYXg6IG4gfSA9IGksIG8gPSBhbih0LCAobiAtIHMpIC8gMiksIHIgPSAoYSwgbCkgPT4gZSAmJiBhID09PSAwID8gMCA6IGEgKyBsO1xuICByZXR1cm4ge1xuICAgIG1pbjogcihzLCAtTWF0aC5hYnMobykpLFxuICAgIG1heDogcihuLCBvKVxuICB9O1xufVxuZnVuY3Rpb24gdnQoaSwgdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGkpLCB0KTtcbn1cbmZ1bmN0aW9uIHppKGksIHQgPSBbXCJcIl0sIGUgPSBpLCBzLCBuID0gKCkgPT4gaVswXSkge1xuICBldChzKSB8fCAocyA9IENuKFwiX2ZhbGxiYWNrXCIsIGkpKTtcbiAgY29uc3QgbyA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJPYmplY3RcIixcbiAgICBfY2FjaGVhYmxlOiAhMCxcbiAgICBfc2NvcGVzOiBpLFxuICAgIF9yb290U2NvcGVzOiBlLFxuICAgIF9mYWxsYmFjazogcyxcbiAgICBfZ2V0VGFyZ2V0OiBuLFxuICAgIG92ZXJyaWRlOiAocikgPT4gemkoW3IsIC4uLmldLCB0LCBlLCBzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KG8sIHtcbiAgICBkZWxldGVQcm9wZXJ0eShyLCBhKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHJbYV0sIGRlbGV0ZSByLl9rZXlzLCBkZWxldGUgaVswXVthXSwgITA7XG4gICAgfSxcbiAgICBnZXQociwgYSkge1xuICAgICAgcmV0dXJuIFNuKFxuICAgICAgICByLFxuICAgICAgICBhLFxuICAgICAgICAoKSA9PiB3cihhLCB0LCBpLCByKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLCBhKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioci5fc2NvcGVzWzBdLCBhKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaVswXSk7XG4gICAgfSxcbiAgICBoYXMociwgYSkge1xuICAgICAgcmV0dXJuIGFzKHIpLmluY2x1ZGVzKGEpO1xuICAgIH0sXG4gICAgb3duS2V5cyhyKSB7XG4gICAgICByZXR1cm4gYXMocik7XG4gICAgfSxcbiAgICBzZXQociwgYSwgbCkge1xuICAgICAgY29uc3QgYyA9IHIuX3N0b3JhZ2UgfHwgKHIuX3N0b3JhZ2UgPSBuKCkpO1xuICAgICAgcmV0dXJuIHJbYV0gPSBjW2FdID0gbCwgZGVsZXRlIHIuX2tleXMsICEwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBWdChpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB7XG4gICAgX2NhY2hlYWJsZTogITEsXG4gICAgX3Byb3h5OiBpLFxuICAgIF9jb250ZXh0OiB0LFxuICAgIF9zdWJQcm94eTogZSxcbiAgICBfc3RhY2s6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiB3bihpLCBzKSxcbiAgICBzZXRDb250ZXh0OiAobykgPT4gVnQoaSwgbywgZSwgcyksXG4gICAgb3ZlcnJpZGU6IChvKSA9PiBWdChpLm92ZXJyaWRlKG8pLCB0LCBlLCBzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KG4sIHtcbiAgICBkZWxldGVQcm9wZXJ0eShvLCByKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIG9bcl0sIGRlbGV0ZSBpW3JdLCAhMDtcbiAgICB9LFxuICAgIGdldChvLCByLCBhKSB7XG4gICAgICByZXR1cm4gU24oXG4gICAgICAgIG8sXG4gICAgICAgIHIsXG4gICAgICAgICgpID0+IHhyKG8sIHIsIGEpXG4gICAgICApO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHIpIHtcbiAgICAgIHJldHVybiBvLl9kZXNjcmlwdG9ycy5hbGxLZXlzID8gUmVmbGVjdC5oYXMoaSwgcikgPyB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gOiB2b2lkIDAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLCByKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaSk7XG4gICAgfSxcbiAgICBoYXMobywgcikge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKGksIHIpO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMoaSk7XG4gICAgfSxcbiAgICBzZXQobywgciwgYSkge1xuICAgICAgcmV0dXJuIGlbcl0gPSBhLCBkZWxldGUgb1tyXSwgITA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHduKGksIHQgPSB7IHNjcmlwdGFibGU6ICEwLCBpbmRleGFibGU6ICEwIH0pIHtcbiAgY29uc3QgeyBfc2NyaXB0YWJsZTogZSA9IHQuc2NyaXB0YWJsZSwgX2luZGV4YWJsZTogcyA9IHQuaW5kZXhhYmxlLCBfYWxsS2V5czogbiA9IHQuYWxsS2V5cyB9ID0gaTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBuLFxuICAgIHNjcmlwdGFibGU6IGUsXG4gICAgaW5kZXhhYmxlOiBzLFxuICAgIGlzU2NyaXB0YWJsZTogeXQoZSkgPyBlIDogKCkgPT4gZSxcbiAgICBpc0luZGV4YWJsZTogeXQocykgPyBzIDogKCkgPT4gc1xuICB9O1xufVxuY29uc3QgYnIgPSAoaSwgdCkgPT4gaSA/IGkgKyBPaSh0KSA6IHQsIEJpID0gKGksIHQpID0+IEQodCkgJiYgaSAhPT0gXCJhZGFwdGVyc1wiICYmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkgPT09IG51bGwgfHwgdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbmZ1bmN0aW9uIFNuKGksIHQsIGUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCB0KSlcbiAgICByZXR1cm4gaVt0XTtcbiAgY29uc3QgcyA9IGUoKTtcbiAgcmV0dXJuIGlbdF0gPSBzLCBzO1xufVxuZnVuY3Rpb24geHIoaSwgdCwgZSkge1xuICBjb25zdCB7IF9wcm94eTogcywgX2NvbnRleHQ6IG4sIF9zdWJQcm94eTogbywgX2Rlc2NyaXB0b3JzOiByIH0gPSBpO1xuICBsZXQgYSA9IHNbdF07XG4gIHJldHVybiB5dChhKSAmJiByLmlzU2NyaXB0YWJsZSh0KSAmJiAoYSA9IF9yKHQsIGEsIGksIGUpKSwgeihhKSAmJiBhLmxlbmd0aCAmJiAoYSA9IHlyKHQsIGEsIGksIHIuaXNJbmRleGFibGUpKSwgQmkodCwgYSkgJiYgKGEgPSBWdChhLCBuLCBvICYmIG9bdF0sIHIpKSwgYTtcbn1cbmZ1bmN0aW9uIF9yKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBfcHJveHk6IG4sIF9jb250ZXh0OiBvLCBfc3ViUHJveHk6IHIsIF9zdGFjazogYSB9ID0gZTtcbiAgaWYgKGEuaGFzKGkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBkZXRlY3RlZDogXCIgKyBBcnJheS5mcm9tKGEpLmpvaW4oXCItPlwiKSArIFwiLT5cIiArIGkpO1xuICByZXR1cm4gYS5hZGQoaSksIHQgPSB0KG8sIHIgfHwgcyksIGEuZGVsZXRlKGkpLCBCaShpLCB0KSAmJiAodCA9IFZpKG4uX3Njb3BlcywgbiwgaSwgdCkpLCB0O1xufVxuZnVuY3Rpb24geXIoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IF9wcm94eTogbiwgX2NvbnRleHQ6IG8sIF9zdWJQcm94eTogciwgX2Rlc2NyaXB0b3JzOiBhIH0gPSBlO1xuICBpZiAoZXQoby5pbmRleCkgJiYgcyhpKSlcbiAgICB0ID0gdFtvLmluZGV4ICUgdC5sZW5ndGhdO1xuICBlbHNlIGlmIChEKHRbMF0pKSB7XG4gICAgY29uc3QgbCA9IHQsIGMgPSBuLl9zY29wZXMuZmlsdGVyKChoKSA9PiBoICE9PSBsKTtcbiAgICB0ID0gW107XG4gICAgZm9yIChjb25zdCBoIG9mIGwpIHtcbiAgICAgIGNvbnN0IGQgPSBWaShjLCBuLCBpLCBoKTtcbiAgICAgIHQucHVzaChWdChkLCBvLCByICYmIHJbaV0sIGEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBQbihpLCB0LCBlKSB7XG4gIHJldHVybiB5dChpKSA/IGkodCwgZSkgOiBpO1xufVxuY29uc3QgdnIgPSAoaSwgdCkgPT4gaSA9PT0gITAgPyB0IDogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IF90KHQsIGkpIDogdm9pZCAwO1xuZnVuY3Rpb24gTXIoaSwgdCwgZSwgcywgbikge1xuICBmb3IgKGNvbnN0IG8gb2YgdCkge1xuICAgIGNvbnN0IHIgPSB2cihlLCBvKTtcbiAgICBpZiAocikge1xuICAgICAgaS5hZGQocik7XG4gICAgICBjb25zdCBhID0gUG4oci5fZmFsbGJhY2ssIGUsIG4pO1xuICAgICAgaWYgKGV0KGEpICYmIGEgIT09IGUgJiYgYSAhPT0gcylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSBlbHNlIGlmIChyID09PSAhMSAmJiBldChzKSAmJiBlICE9PSBzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gVmkoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gdC5fcm9vdFNjb3BlcywgbyA9IFBuKHQuX2ZhbGxiYWNrLCBlLCBzKSwgciA9IFsuLi5pLCAuLi5uXSwgYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGEuYWRkKHMpO1xuICBsZXQgbCA9IHJzKGEsIHIsIGUsIG8gfHwgZSwgcyk7XG4gIHJldHVybiBsID09PSBudWxsIHx8IGV0KG8pICYmIG8gIT09IGUgJiYgKGwgPSBycyhhLCByLCBvLCBsLCBzKSwgbCA9PT0gbnVsbCkgPyAhMSA6IHppKFxuICAgIEFycmF5LmZyb20oYSksXG4gICAgW1wiXCJdLFxuICAgIG4sXG4gICAgbyxcbiAgICAoKSA9PiBrcih0LCBlLCBzKVxuICApO1xufVxuZnVuY3Rpb24gcnMoaSwgdCwgZSwgcywgbikge1xuICBmb3IgKDsgZTsgKVxuICAgIGUgPSBNcihpLCB0LCBlLCBzLCBuKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBrcihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLl9nZXRUYXJnZXQoKTtcbiAgdCBpbiBzIHx8IChzW3RdID0ge30pO1xuICBjb25zdCBuID0gc1t0XTtcbiAgcmV0dXJuIHoobikgJiYgRChlKSA/IGUgOiBuO1xufVxuZnVuY3Rpb24gd3IoaSwgdCwgZSwgcykge1xuICBsZXQgbjtcbiAgZm9yIChjb25zdCBvIG9mIHQpXG4gICAgaWYgKG4gPSBDbihicihvLCBpKSwgZSksIGV0KG4pKVxuICAgICAgcmV0dXJuIEJpKGksIG4pID8gVmkoZSwgcywgaSwgbikgOiBuO1xufVxuZnVuY3Rpb24gQ24oaSwgdCkge1xuICBmb3IgKGNvbnN0IGUgb2YgdCkge1xuICAgIGlmICghZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHMgPSBlW2ldO1xuICAgIGlmIChldChzKSlcbiAgICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBhcyhpKSB7XG4gIGxldCB0ID0gaS5fa2V5cztcbiAgcmV0dXJuIHQgfHwgKHQgPSBpLl9rZXlzID0gU3IoaS5fc2NvcGVzKSksIHQ7XG59XG5mdW5jdGlvbiBTcihpKSB7XG4gIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGUgb2YgaSlcbiAgICBmb3IgKGNvbnN0IHMgb2YgT2JqZWN0LmtleXMoZSkuZmlsdGVyKChuKSA9PiAhbi5zdGFydHNXaXRoKFwiX1wiKSkpXG4gICAgICB0LmFkZChzKTtcbiAgcmV0dXJuIEFycmF5LmZyb20odCk7XG59XG5mdW5jdGlvbiBEbihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgaVNjYWxlOiBuIH0gPSBpLCB7IGtleTogbyA9IFwiclwiIH0gPSB0aGlzLl9wYXJzaW5nLCByID0gbmV3IEFycmF5KHMpO1xuICBsZXQgYSwgbCwgYywgaDtcbiAgZm9yIChhID0gMCwgbCA9IHM7IGEgPCBsOyArK2EpXG4gICAgYyA9IGEgKyBlLCBoID0gdFtjXSwgclthXSA9IHtcbiAgICAgIHI6IG4ucGFyc2UoX3QoaCwgbyksIGMpXG4gICAgfTtcbiAgcmV0dXJuIHI7XG59XG5jb25zdCBQciA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0LCBXdCA9IChpLCB0KSA9PiB0IDwgaS5sZW5ndGggJiYgIWlbdF0uc2tpcCAmJiBpW3RdLCBPbiA9IChpKSA9PiBpID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG5mdW5jdGlvbiBDcihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBpLnNraXAgPyB0IDogaSwgbyA9IHQsIHIgPSBlLnNraXAgPyB0IDogZSwgYSA9IGJpKG8sIG4pLCBsID0gYmkociwgbyk7XG4gIGxldCBjID0gYSAvIChhICsgbCksIGggPSBsIC8gKGEgKyBsKTtcbiAgYyA9IGlzTmFOKGMpID8gMCA6IGMsIGggPSBpc05hTihoKSA/IDAgOiBoO1xuICBjb25zdCBkID0gcyAqIGMsIHUgPSBzICogaDtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogby54IC0gZCAqIChyLnggLSBuLngpLFxuICAgICAgeTogby55IC0gZCAqIChyLnkgLSBuLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBvLnggKyB1ICogKHIueCAtIG4ueCksXG4gICAgICB5OiBvLnkgKyB1ICogKHIueSAtIG4ueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBEcihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLmxlbmd0aDtcbiAgbGV0IG4sIG8sIHIsIGEsIGwsIGMgPSBXdChpLCAwKTtcbiAgZm9yIChsZXQgaCA9IDA7IGggPCBzIC0gMTsgKytoKVxuICAgIGlmIChsID0gYywgYyA9IFd0KGksIGggKyAxKSwgISghbCB8fCAhYykpIHtcbiAgICAgIGlmICh0ZSh0W2hdLCAwLCBQcikpIHtcbiAgICAgICAgZVtoXSA9IGVbaCArIDFdID0gMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuID0gZVtoXSAvIHRbaF0sIG8gPSBlW2ggKyAxXSAvIHRbaF0sIGEgPSBNYXRoLnBvdyhuLCAyKSArIE1hdGgucG93KG8sIDIpLCAhKGEgPD0gOSkgJiYgKHIgPSAzIC8gTWF0aC5zcXJ0KGEpLCBlW2hdID0gbiAqIHIgKiB0W2hdLCBlW2ggKyAxXSA9IG8gKiByICogdFtoXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gT3IoaSwgdCwgZSA9IFwieFwiKSB7XG4gIGNvbnN0IHMgPSBPbihlKSwgbiA9IGkubGVuZ3RoO1xuICBsZXQgbywgciwgYSwgbCA9IFd0KGksIDApO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IG47ICsrYykge1xuICAgIGlmIChyID0gYSwgYSA9IGwsIGwgPSBXdChpLCBjICsgMSksICFhKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgaCA9IGFbZV0sIGQgPSBhW3NdO1xuICAgIHIgJiYgKG8gPSAoaCAtIHJbZV0pIC8gMywgYVtgY3AxJHtlfWBdID0gaCAtIG8sIGFbYGNwMSR7c31gXSA9IGQgLSBvICogdFtjXSksIGwgJiYgKG8gPSAobFtlXSAtIGgpIC8gMywgYVtgY3AyJHtlfWBdID0gaCArIG8sIGFbYGNwMiR7c31gXSA9IGQgKyBvICogdFtjXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEFyKGksIHQgPSBcInhcIikge1xuICBjb25zdCBlID0gT24odCksIHMgPSBpLmxlbmd0aCwgbiA9IEFycmF5KHMpLmZpbGwoMCksIG8gPSBBcnJheShzKTtcbiAgbGV0IHIsIGEsIGwsIGMgPSBXdChpLCAwKTtcbiAgZm9yIChyID0gMDsgciA8IHM7ICsrcilcbiAgICBpZiAoYSA9IGwsIGwgPSBjLCBjID0gV3QoaSwgciArIDEpLCAhIWwpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGNvbnN0IGggPSBjW3RdIC0gbFt0XTtcbiAgICAgICAgbltyXSA9IGggIT09IDAgPyAoY1tlXSAtIGxbZV0pIC8gaCA6IDA7XG4gICAgICB9XG4gICAgICBvW3JdID0gYSA/IGMgPyBsdChuW3IgLSAxXSkgIT09IGx0KG5bcl0pID8gMCA6IChuW3IgLSAxXSArIG5bcl0pIC8gMiA6IG5bciAtIDFdIDogbltyXTtcbiAgICB9XG4gIERyKGksIG4sIG8pLCBPcihpLCBvLCB0KTtcbn1cbmZ1bmN0aW9uIERlKGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGksIGUpLCB0KTtcbn1cbmZ1bmN0aW9uIFRyKGksIHQpIHtcbiAgbGV0IGUsIHMsIG4sIG8sIHIsIGEgPSByZShpWzBdLCB0KTtcbiAgZm9yIChlID0gMCwgcyA9IGkubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgIHIgPSBvLCBvID0gYSwgYSA9IGUgPCBzIC0gMSAmJiByZShpW2UgKyAxXSwgdCksIG8gJiYgKG4gPSBpW2VdLCByICYmIChuLmNwMXggPSBEZShuLmNwMXgsIHQubGVmdCwgdC5yaWdodCksIG4uY3AxeSA9IERlKG4uY3AxeSwgdC50b3AsIHQuYm90dG9tKSksIGEgJiYgKG4uY3AyeCA9IERlKG4uY3AyeCwgdC5sZWZ0LCB0LnJpZ2h0KSwgbi5jcDJ5ID0gRGUobi5jcDJ5LCB0LnRvcCwgdC5ib3R0b20pKSk7XG59XG5mdW5jdGlvbiBMcihpLCB0LCBlLCBzLCBuKSB7XG4gIGxldCBvLCByLCBhLCBsO1xuICBpZiAodC5zcGFuR2FwcyAmJiAoaSA9IGkuZmlsdGVyKChjKSA9PiAhYy5za2lwKSksIHQuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gXCJtb25vdG9uZVwiKVxuICAgIEFyKGksIG4pO1xuICBlbHNlIHtcbiAgICBsZXQgYyA9IHMgPyBpW2kubGVuZ3RoIC0gMV0gOiBpWzBdO1xuICAgIGZvciAobyA9IDAsIHIgPSBpLmxlbmd0aDsgbyA8IHI7ICsrbylcbiAgICAgIGEgPSBpW29dLCBsID0gQ3IoXG4gICAgICAgIGMsXG4gICAgICAgIGEsXG4gICAgICAgIGlbTWF0aC5taW4obyArIDEsIHIgLSAocyA/IDAgOiAxKSkgJSByXSxcbiAgICAgICAgdC50ZW5zaW9uXG4gICAgICApLCBhLmNwMXggPSBsLnByZXZpb3VzLngsIGEuY3AxeSA9IGwucHJldmlvdXMueSwgYS5jcDJ4ID0gbC5uZXh0LngsIGEuY3AyeSA9IGwubmV4dC55LCBjID0gYTtcbiAgfVxuICB0LmNhcEJlemllclBvaW50cyAmJiBUcihpLCBlKTtcbn1cbmZ1bmN0aW9uIEFuKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiBkb2N1bWVudCA8IFwidVwiO1xufVxuZnVuY3Rpb24gV2koaSkge1xuICBsZXQgdCA9IGkucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHQgJiYgdC50b1N0cmluZygpID09PSBcIltvYmplY3QgU2hhZG93Um9vdF1cIiAmJiAodCA9IHQuaG9zdCksIHQ7XG59XG5mdW5jdGlvbiBIZShpLCB0LCBlKSB7XG4gIGxldCBzO1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IChzID0gcGFyc2VJbnQoaSwgMTApLCBpLmluZGV4T2YoXCIlXCIpICE9PSAtMSAmJiAocyA9IHMgLyAxMDAgKiB0LnBhcmVudE5vZGVbZV0pKSA6IHMgPSBpLCBzO1xufVxuY29uc3QgS2UgPSAoaSkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaSwgbnVsbCk7XG5mdW5jdGlvbiBScihpLCB0KSB7XG4gIHJldHVybiBLZShpKS5nZXRQcm9wZXJ0eVZhbHVlKHQpO1xufVxuY29uc3QgRXIgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG5mdW5jdGlvbiBPdChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZSA9IGUgPyBcIi1cIiArIGUgOiBcIlwiO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IDQ7IG4rKykge1xuICAgIGNvbnN0IG8gPSBFcltuXTtcbiAgICBzW29dID0gcGFyc2VGbG9hdChpW3QgKyBcIi1cIiArIG8gKyBlXSkgfHwgMDtcbiAgfVxuICByZXR1cm4gcy53aWR0aCA9IHMubGVmdCArIHMucmlnaHQsIHMuaGVpZ2h0ID0gcy50b3AgKyBzLmJvdHRvbSwgcztcbn1cbmNvbnN0IEZyID0gKGksIHQsIGUpID0+IChpID4gMCB8fCB0ID4gMCkgJiYgKCFlIHx8ICFlLnNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gSXIoaSwgdCkge1xuICBjb25zdCBlID0gaS50b3VjaGVzLCBzID0gZSAmJiBlLmxlbmd0aCA/IGVbMF0gOiBpLCB7IG9mZnNldFg6IG4sIG9mZnNldFk6IG8gfSA9IHM7XG4gIGxldCByID0gITEsIGEsIGw7XG4gIGlmIChGcihuLCBvLCBpLnRhcmdldCkpXG4gICAgYSA9IG4sIGwgPSBvO1xuICBlbHNlIHtcbiAgICBjb25zdCBjID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBhID0gcy5jbGllbnRYIC0gYy5sZWZ0LCBsID0gcy5jbGllbnRZIC0gYy50b3AsIHIgPSAhMDtcbiAgfVxuICByZXR1cm4geyB4OiBhLCB5OiBsLCBib3g6IHIgfTtcbn1cbmZ1bmN0aW9uIFB0KGksIHQpIHtcbiAgaWYgKFwibmF0aXZlXCIgaW4gaSlcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgeyBjYW52YXM6IGUsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvOiBzIH0gPSB0LCBuID0gS2UoZSksIG8gPSBuLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCIsIHIgPSBPdChuLCBcInBhZGRpbmdcIiksIGEgPSBPdChuLCBcImJvcmRlclwiLCBcIndpZHRoXCIpLCB7IHg6IGwsIHk6IGMsIGJveDogaCB9ID0gSXIoaSwgZSksIGQgPSByLmxlZnQgKyAoaCAmJiBhLmxlZnQpLCB1ID0gci50b3AgKyAoaCAmJiBhLnRvcCk7XG4gIGxldCB7IHdpZHRoOiBmLCBoZWlnaHQ6IGcgfSA9IHQ7XG4gIHJldHVybiBvICYmIChmIC09IHIud2lkdGggKyBhLndpZHRoLCBnIC09IHIuaGVpZ2h0ICsgYS5oZWlnaHQpLCB7XG4gICAgeDogTWF0aC5yb3VuZCgobCAtIGQpIC8gZiAqIGUud2lkdGggLyBzKSxcbiAgICB5OiBNYXRoLnJvdW5kKChjIC0gdSkgLyBnICogZS5oZWlnaHQgLyBzKVxuICB9O1xufVxuZnVuY3Rpb24genIoaSwgdCwgZSkge1xuICBsZXQgcywgbjtcbiAgaWYgKHQgPT09IHZvaWQgMCB8fCBlID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBvID0gV2koaSk7XG4gICAgaWYgKCFvKVxuICAgICAgdCA9IGkuY2xpZW50V2lkdGgsIGUgPSBpLmNsaWVudEhlaWdodDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHIgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhID0gS2UobyksIGwgPSBPdChhLCBcImJvcmRlclwiLCBcIndpZHRoXCIpLCBjID0gT3QoYSwgXCJwYWRkaW5nXCIpO1xuICAgICAgdCA9IHIud2lkdGggLSBjLndpZHRoIC0gbC53aWR0aCwgZSA9IHIuaGVpZ2h0IC0gYy5oZWlnaHQgLSBsLmhlaWdodCwgcyA9IEhlKGEubWF4V2lkdGgsIG8sIFwiY2xpZW50V2lkdGhcIiksIG4gPSBIZShhLm1heEhlaWdodCwgbywgXCJjbGllbnRIZWlnaHRcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHQsXG4gICAgaGVpZ2h0OiBlLFxuICAgIG1heFdpZHRoOiBzIHx8IFZlLFxuICAgIG1heEhlaWdodDogbiB8fCBWZVxuICB9O1xufVxuY29uc3QgYWkgPSAoaSkgPT4gTWF0aC5yb3VuZChpICogMTApIC8gMTA7XG5mdW5jdGlvbiBCcihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBLZShpKSwgbyA9IE90KG4sIFwibWFyZ2luXCIpLCByID0gSGUobi5tYXhXaWR0aCwgaSwgXCJjbGllbnRXaWR0aFwiKSB8fCBWZSwgYSA9IEhlKG4ubWF4SGVpZ2h0LCBpLCBcImNsaWVudEhlaWdodFwiKSB8fCBWZSwgbCA9IHpyKGksIHQsIGUpO1xuICBsZXQgeyB3aWR0aDogYywgaGVpZ2h0OiBoIH0gPSBsO1xuICBpZiAobi5ib3hTaXppbmcgPT09IFwiY29udGVudC1ib3hcIikge1xuICAgIGNvbnN0IGQgPSBPdChuLCBcImJvcmRlclwiLCBcIndpZHRoXCIpLCB1ID0gT3QobiwgXCJwYWRkaW5nXCIpO1xuICAgIGMgLT0gdS53aWR0aCArIGQud2lkdGgsIGggLT0gdS5oZWlnaHQgKyBkLmhlaWdodDtcbiAgfVxuICByZXR1cm4gYyA9IE1hdGgubWF4KDAsIGMgLSBvLndpZHRoKSwgaCA9IE1hdGgubWF4KDAsIHMgPyBNYXRoLmZsb29yKGMgLyBzKSA6IGggLSBvLmhlaWdodCksIGMgPSBhaShNYXRoLm1pbihjLCByLCBsLm1heFdpZHRoKSksIGggPSBhaShNYXRoLm1pbihoLCBhLCBsLm1heEhlaWdodCkpLCBjICYmICFoICYmIChoID0gYWkoYyAvIDIpKSwge1xuICAgIHdpZHRoOiBjLFxuICAgIGhlaWdodDogaFxuICB9O1xufVxuZnVuY3Rpb24gbHMoaSwgdCwgZSkge1xuICBjb25zdCBzID0gdCB8fCAxLCBuID0gTWF0aC5mbG9vcihpLmhlaWdodCAqIHMpLCBvID0gTWF0aC5mbG9vcihpLndpZHRoICogcyk7XG4gIGkuaGVpZ2h0ID0gbiAvIHMsIGkud2lkdGggPSBvIC8gcztcbiAgY29uc3QgciA9IGkuY2FudmFzO1xuICByZXR1cm4gci5zdHlsZSAmJiAoZSB8fCAhci5zdHlsZS5oZWlnaHQgJiYgIXIuc3R5bGUud2lkdGgpICYmIChyLnN0eWxlLmhlaWdodCA9IGAke2kuaGVpZ2h0fXB4YCwgci5zdHlsZS53aWR0aCA9IGAke2kud2lkdGh9cHhgKSwgaS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcyB8fCByLmhlaWdodCAhPT0gbiB8fCByLndpZHRoICE9PSBvID8gKGkuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBzLCByLmhlaWdodCA9IG4sIHIud2lkdGggPSBvLCBpLmN0eC5zZXRUcmFuc2Zvcm0ocywgMCwgMCwgcywgMCwgMCksICEwKSA6ICExO1xufVxuY29uc3QgVnIgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGkgPSAhMTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHJldHVybiBpID0gITAsICExO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIHQpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgdCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBpO1xufSgpO1xuZnVuY3Rpb24gY3MoaSwgdCkge1xuICBjb25zdCBlID0gUnIoaSwgdCksIHMgPSBlICYmIGUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBzID8gK3NbMV0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBDdChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiB7XG4gICAgeDogaS54ICsgZSAqICh0LnggLSBpLngpLFxuICAgIHk6IGkueSArIGUgKiAodC55IC0gaS55KVxuICB9O1xufVxuZnVuY3Rpb24gV3IoaSwgdCwgZSwgcykge1xuICByZXR1cm4ge1xuICAgIHg6IGkueCArIGUgKiAodC54IC0gaS54KSxcbiAgICB5OiBzID09PSBcIm1pZGRsZVwiID8gZSA8IDAuNSA/IGkueSA6IHQueSA6IHMgPT09IFwiYWZ0ZXJcIiA/IGUgPCAxID8gaS55IDogdC55IDogZSA+IDAgPyB0LnkgOiBpLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIE5yKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IHsgeDogaS5jcDJ4LCB5OiBpLmNwMnkgfSwgbyA9IHsgeDogdC5jcDF4LCB5OiB0LmNwMXkgfSwgciA9IEN0KGksIG4sIGUpLCBhID0gQ3QobiwgbywgZSksIGwgPSBDdChvLCB0LCBlKSwgYyA9IEN0KHIsIGEsIGUpLCBoID0gQ3QoYSwgbCwgZSk7XG4gIHJldHVybiBDdChjLCBoLCBlKTtcbn1cbmNvbnN0IGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIEhyKGksIHQpIHtcbiAgdCA9IHQgfHwge307XG4gIGNvbnN0IGUgPSBpICsgSlNPTi5zdHJpbmdpZnkodCk7XG4gIGxldCBzID0gaHMuZ2V0KGUpO1xuICByZXR1cm4gcyB8fCAocyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChpLCB0KSwgaHMuc2V0KGUsIHMpKSwgcztcbn1cbmZ1bmN0aW9uIGRlKGksIHQsIGUpIHtcbiAgcmV0dXJuIEhyKHQsIGUpLmZvcm1hdChpKTtcbn1cbmNvbnN0IGpyID0gZnVuY3Rpb24oaSwgdCkge1xuICByZXR1cm4ge1xuICAgIHgoZSkge1xuICAgICAgcmV0dXJuIGkgKyBpICsgdCAtIGU7XG4gICAgfSxcbiAgICBzZXRXaWR0aChlKSB7XG4gICAgICB0ID0gZTtcbiAgICB9LFxuICAgIHRleHRBbGlnbihlKSB7XG4gICAgICByZXR1cm4gZSA9PT0gXCJjZW50ZXJcIiA/IGUgOiBlID09PSBcInJpZ2h0XCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9LFxuICAgIHhQbHVzKGUsIHMpIHtcbiAgICAgIHJldHVybiBlIC0gcztcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoZSwgcykge1xuICAgICAgcmV0dXJuIGUgLSBzO1xuICAgIH1cbiAgfTtcbn0sICRyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgeChpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgIHNldFdpZHRoKGkpIHtcbiAgICB9LFxuICAgIHRleHRBbGlnbihpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgIHhQbHVzKGksIHQpIHtcbiAgICAgIHJldHVybiBpICsgdDtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoaSwgdCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHp0KGksIHQsIGUpIHtcbiAgcmV0dXJuIGkgPyBqcih0LCBlKSA6ICRyKCk7XG59XG5mdW5jdGlvbiBUbihpLCB0KSB7XG4gIGxldCBlLCBzO1xuICAodCA9PT0gXCJsdHJcIiB8fCB0ID09PSBcInJ0bFwiKSAmJiAoZSA9IGkuY2FudmFzLnN0eWxlLCBzID0gW1xuICAgIGUuZ2V0UHJvcGVydHlWYWx1ZShcImRpcmVjdGlvblwiKSxcbiAgICBlLmdldFByb3BlcnR5UHJpb3JpdHkoXCJkaXJlY3Rpb25cIilcbiAgXSwgZS5zZXRQcm9wZXJ0eShcImRpcmVjdGlvblwiLCB0LCBcImltcG9ydGFudFwiKSwgaS5wcmV2VGV4dERpcmVjdGlvbiA9IHMpO1xufVxuZnVuY3Rpb24gTG4oaSwgdCkge1xuICB0ICE9PSB2b2lkIDAgJiYgKGRlbGV0ZSBpLnByZXZUZXh0RGlyZWN0aW9uLCBpLmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eShcImRpcmVjdGlvblwiLCB0WzBdLCB0WzFdKSk7XG59XG5mdW5jdGlvbiBSbihpKSB7XG4gIHJldHVybiBpID09PSBcImFuZ2xlXCIgPyB7XG4gICAgYmV0d2Vlbjogb2UsXG4gICAgY29tcGFyZTogQW8sXG4gICAgbm9ybWFsaXplOiBaXG4gIH0gOiB7XG4gICAgYmV0d2VlbjogdXQsXG4gICAgY29tcGFyZTogKHQsIGUpID0+IHQgLSBlLFxuICAgIG5vcm1hbGl6ZTogKHQpID0+IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRzKHsgc3RhcnQ6IGksIGVuZDogdCwgY291bnQ6IGUsIGxvb3A6IHMsIHN0eWxlOiBuIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaSAlIGUsXG4gICAgZW5kOiB0ICUgZSxcbiAgICBsb29wOiBzICYmICh0IC0gaSArIDEpICUgZSA9PT0gMCxcbiAgICBzdHlsZTogblxuICB9O1xufVxuZnVuY3Rpb24gWXIoaSwgdCwgZSkge1xuICBjb25zdCB7IHByb3BlcnR5OiBzLCBzdGFydDogbiwgZW5kOiBvIH0gPSBlLCB7IGJldHdlZW46IHIsIG5vcm1hbGl6ZTogYSB9ID0gUm4ocyksIGwgPSB0Lmxlbmd0aDtcbiAgbGV0IHsgc3RhcnQ6IGMsIGVuZDogaCwgbG9vcDogZCB9ID0gaSwgdSwgZjtcbiAgaWYgKGQpIHtcbiAgICBmb3IgKGMgKz0gbCwgaCArPSBsLCB1ID0gMCwgZiA9IGw7IHUgPCBmICYmIHIoYSh0W2MgJSBsXVtzXSksIG4sIG8pOyArK3UpXG4gICAgICBjLS0sIGgtLTtcbiAgICBjICU9IGwsIGggJT0gbDtcbiAgfVxuICByZXR1cm4gaCA8IGMgJiYgKGggKz0gbCksIHsgc3RhcnQ6IGMsIGVuZDogaCwgbG9vcDogZCwgc3R5bGU6IGkuc3R5bGUgfTtcbn1cbmZ1bmN0aW9uIEVuKGksIHQsIGUpIHtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBbaV07XG4gIGNvbnN0IHsgcHJvcGVydHk6IHMsIHN0YXJ0OiBuLCBlbmQ6IG8gfSA9IGUsIHIgPSB0Lmxlbmd0aCwgeyBjb21wYXJlOiBhLCBiZXR3ZWVuOiBsLCBub3JtYWxpemU6IGMgfSA9IFJuKHMpLCB7IHN0YXJ0OiBoLCBlbmQ6IGQsIGxvb3A6IHUsIHN0eWxlOiBmIH0gPSBZcihpLCB0LCBlKSwgZyA9IFtdO1xuICBsZXQgcCA9ICExLCBtID0gbnVsbCwgYiwgeCwgdjtcbiAgY29uc3QgeSA9ICgpID0+IGwobiwgdiwgYikgJiYgYShuLCB2KSAhPT0gMCwgXyA9ICgpID0+IGEobywgYikgPT09IDAgfHwgbChvLCB2LCBiKSwgTSA9ICgpID0+IHAgfHwgeSgpLCBrID0gKCkgPT4gIXAgfHwgXygpO1xuICBmb3IgKGxldCBTID0gaCwgdyA9IGg7IFMgPD0gZDsgKytTKVxuICAgIHggPSB0W1MgJSByXSwgIXguc2tpcCAmJiAoYiA9IGMoeFtzXSksIGIgIT09IHYgJiYgKHAgPSBsKGIsIG4sIG8pLCBtID09PSBudWxsICYmIE0oKSAmJiAobSA9IGEoYiwgbikgPT09IDAgPyBTIDogdyksIG0gIT09IG51bGwgJiYgaygpICYmIChnLnB1c2goZHMoeyBzdGFydDogbSwgZW5kOiBTLCBsb29wOiB1LCBjb3VudDogciwgc3R5bGU6IGYgfSkpLCBtID0gbnVsbCksIHcgPSBTLCB2ID0gYikpO1xuICByZXR1cm4gbSAhPT0gbnVsbCAmJiBnLnB1c2goZHMoeyBzdGFydDogbSwgZW5kOiBkLCBsb29wOiB1LCBjb3VudDogciwgc3R5bGU6IGYgfSkpLCBnO1xufVxuZnVuY3Rpb24gRm4oaSwgdCkge1xuICBjb25zdCBlID0gW10sIHMgPSBpLnNlZ21lbnRzO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBvID0gRW4oc1tuXSwgaS5wb2ludHMsIHQpO1xuICAgIG8ubGVuZ3RoICYmIGUucHVzaCguLi5vKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFhyKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSAwLCBvID0gdCAtIDE7XG4gIGlmIChlICYmICFzKVxuICAgIGZvciAoOyBuIDwgdCAmJiAhaVtuXS5za2lwOyApXG4gICAgICBuKys7XG4gIGZvciAoOyBuIDwgdCAmJiBpW25dLnNraXA7IClcbiAgICBuKys7XG4gIGZvciAobiAlPSB0LCBlICYmIChvICs9IG4pOyBvID4gbiAmJiBpW28gJSB0XS5za2lwOyApXG4gICAgby0tO1xuICByZXR1cm4gbyAlPSB0LCB7IHN0YXJ0OiBuLCBlbmQ6IG8gfTtcbn1cbmZ1bmN0aW9uIFVyKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkubGVuZ3RoLCBvID0gW107XG4gIGxldCByID0gdCwgYSA9IGlbdF0sIGw7XG4gIGZvciAobCA9IHQgKyAxOyBsIDw9IGU7ICsrbCkge1xuICAgIGNvbnN0IGMgPSBpW2wgJSBuXTtcbiAgICBjLnNraXAgfHwgYy5zdG9wID8gYS5za2lwIHx8IChzID0gITEsIG8ucHVzaCh7IHN0YXJ0OiB0ICUgbiwgZW5kOiAobCAtIDEpICUgbiwgbG9vcDogcyB9KSwgdCA9IHIgPSBjLnN0b3AgPyBsIDogbnVsbCkgOiAociA9IGwsIGEuc2tpcCAmJiAodCA9IGwpKSwgYSA9IGM7XG4gIH1cbiAgcmV0dXJuIHIgIT09IG51bGwgJiYgby5wdXNoKHsgc3RhcnQ6IHQgJSBuLCBlbmQ6IHIgJSBuLCBsb29wOiBzIH0pLCBvO1xufVxuZnVuY3Rpb24gS3IoaSwgdCkge1xuICBjb25zdCBlID0gaS5wb2ludHMsIHMgPSBpLm9wdGlvbnMuc3BhbkdhcHMsIG4gPSBlLmxlbmd0aDtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgbyA9ICEhaS5fbG9vcCwgeyBzdGFydDogciwgZW5kOiBhIH0gPSBYcihlLCBuLCBvLCBzKTtcbiAgaWYgKHMgPT09ICEwKVxuICAgIHJldHVybiB1cyhpLCBbeyBzdGFydDogciwgZW5kOiBhLCBsb29wOiBvIH1dLCBlLCB0KTtcbiAgY29uc3QgbCA9IGEgPCByID8gYSArIG4gOiBhLCBjID0gISFpLl9mdWxsTG9vcCAmJiByID09PSAwICYmIGEgPT09IG4gLSAxO1xuICByZXR1cm4gdXMoaSwgVXIoZSwgciwgbCwgYyksIGUsIHQpO1xufVxuZnVuY3Rpb24gdXMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gIXMgfHwgIXMuc2V0Q29udGV4dCB8fCAhZSA/IHQgOiBxcihpLCB0LCBlLCBzKTtcbn1cbmZ1bmN0aW9uIHFyKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuX2NoYXJ0LmdldENvbnRleHQoKSwgbyA9IGZzKGkub3B0aW9ucyksIHsgX2RhdGFzZXRJbmRleDogciwgb3B0aW9uczogeyBzcGFuR2FwczogYSB9IH0gPSBpLCBsID0gZS5sZW5ndGgsIGMgPSBbXTtcbiAgbGV0IGggPSBvLCBkID0gdFswXS5zdGFydCwgdSA9IGQ7XG4gIGZ1bmN0aW9uIGYoZywgcCwgbSwgYikge1xuICAgIGNvbnN0IHggPSBhID8gLTEgOiAxO1xuICAgIGlmIChnICE9PSBwKSB7XG4gICAgICBmb3IgKGcgKz0gbDsgZVtnICUgbF0uc2tpcDsgKVxuICAgICAgICBnIC09IHg7XG4gICAgICBmb3IgKDsgZVtwICUgbF0uc2tpcDsgKVxuICAgICAgICBwICs9IHg7XG4gICAgICBnICUgbCAhPT0gcCAlIGwgJiYgKGMucHVzaCh7IHN0YXJ0OiBnICUgbCwgZW5kOiBwICUgbCwgbG9vcDogbSwgc3R5bGU6IGIgfSksIGggPSBiLCBkID0gcCAlIGwpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGcgb2YgdCkge1xuICAgIGQgPSBhID8gZCA6IGcuc3RhcnQ7XG4gICAgbGV0IHAgPSBlW2QgJSBsXSwgbTtcbiAgICBmb3IgKHUgPSBkICsgMTsgdSA8PSBnLmVuZDsgdSsrKSB7XG4gICAgICBjb25zdCBiID0gZVt1ICUgbF07XG4gICAgICBtID0gZnMocy5zZXRDb250ZXh0KHZ0KG4sIHtcbiAgICAgICAgdHlwZTogXCJzZWdtZW50XCIsXG4gICAgICAgIHAwOiBwLFxuICAgICAgICBwMTogYixcbiAgICAgICAgcDBEYXRhSW5kZXg6ICh1IC0gMSkgJSBsLFxuICAgICAgICBwMURhdGFJbmRleDogdSAlIGwsXG4gICAgICAgIGRhdGFzZXRJbmRleDogclxuICAgICAgfSkpKSwgR3IobSwgaCkgJiYgZihkLCB1IC0gMSwgZy5sb29wLCBoKSwgcCA9IGIsIGggPSBtO1xuICAgIH1cbiAgICBkIDwgdSAtIDEgJiYgZihkLCB1IC0gMSwgZy5sb29wLCBoKTtcbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGZzKGkpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGkuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBpLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IGkuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBpLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBpLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogaS5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogaS5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gR3IoaSwgdCkge1xuICByZXR1cm4gdCAmJiBKU09OLnN0cmluZ2lmeShpKSAhPT0gSlNPTi5zdHJpbmdpZnkodCk7XG59XG4vKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmNsYXNzIFpyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGwsIHRoaXMuX2NoYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX3J1bm5pbmcgPSAhMSwgdGhpcy5fbGFzdERhdGUgPSB2b2lkIDA7XG4gIH1cbiAgX25vdGlmeSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IGUubGlzdGVuZXJzW25dLCByID0gZS5kdXJhdGlvbjtcbiAgICBvLmZvckVhY2goKGEpID0+IGEoe1xuICAgICAgY2hhcnQ6IHQsXG4gICAgICBpbml0aWFsOiBlLmluaXRpYWwsXG4gICAgICBudW1TdGVwczogcixcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihzIC0gZS5zdGFydCwgcilcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVxdWVzdCB8fCAodGhpcy5fcnVubmluZyA9ICEwLCB0aGlzLl9yZXF1ZXN0ID0gZm4uY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9yZXF1ZXN0ID0gbnVsbCwgdGhpcy5fcnVubmluZyAmJiB0aGlzLl9yZWZyZXNoKCk7XG4gICAgfSkpO1xuICB9XG4gIF91cGRhdGUodCA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKHMsIG4pID0+IHtcbiAgICAgIGlmICghcy5ydW5uaW5nIHx8ICFzLml0ZW1zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IHMuaXRlbXM7XG4gICAgICBsZXQgciA9IG8ubGVuZ3RoIC0gMSwgYSA9ICExLCBsO1xuICAgICAgZm9yICg7IHIgPj0gMDsgLS1yKVxuICAgICAgICBsID0gb1tyXSwgbC5fYWN0aXZlID8gKGwuX3RvdGFsID4gcy5kdXJhdGlvbiAmJiAocy5kdXJhdGlvbiA9IGwuX3RvdGFsKSwgbC50aWNrKHQpLCBhID0gITApIDogKG9bcl0gPSBvW28ubGVuZ3RoIC0gMV0sIG8ucG9wKCkpO1xuICAgICAgYSAmJiAobi5kcmF3KCksIHRoaXMuX25vdGlmeShuLCBzLCB0LCBcInByb2dyZXNzXCIpKSwgby5sZW5ndGggfHwgKHMucnVubmluZyA9ICExLCB0aGlzLl9ub3RpZnkobiwgcywgdCwgXCJjb21wbGV0ZVwiKSwgcy5pbml0aWFsID0gITEpLCBlICs9IG8ubGVuZ3RoO1xuICAgIH0pLCB0aGlzLl9sYXN0RGF0ZSA9IHQsIGUgPT09IDAgJiYgKHRoaXMuX3J1bm5pbmcgPSAhMSk7XG4gIH1cbiAgX2dldEFuaW1zKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBzID0gZS5nZXQodCk7XG4gICAgcmV0dXJuIHMgfHwgKHMgPSB7XG4gICAgICBydW5uaW5nOiAhMSxcbiAgICAgIGluaXRpYWw6ICEwLFxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICB9XG4gICAgfSwgZS5zZXQodCwgcykpLCBzO1xuICB9XG4gIGxpc3Rlbih0LCBlLCBzKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXModCkubGlzdGVuZXJzW2VdLnB1c2gocyk7XG4gIH1cbiAgYWRkKHQsIGUpIHtcbiAgICAhZSB8fCAhZS5sZW5ndGggfHwgdGhpcy5fZ2V0QW5pbXModCkuaXRlbXMucHVzaCguLi5lKTtcbiAgfVxuICBoYXModCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyh0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXJ0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2hhcnRzLmdldCh0KTtcbiAgICBlICYmIChlLnJ1bm5pbmcgPSAhMCwgZS5zdGFydCA9IERhdGUubm93KCksIGUuZHVyYXRpb24gPSBlLml0ZW1zLnJlZHVjZSgocywgbikgPT4gTWF0aC5tYXgocywgbi5fZHVyYXRpb24pLCAwKSwgdGhpcy5fcmVmcmVzaCgpKTtcbiAgfVxuICBydW5uaW5nKHQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NoYXJ0cy5nZXQodCk7XG4gICAgcmV0dXJuICEoIWUgfHwgIWUucnVubmluZyB8fCAhZS5pdGVtcy5sZW5ndGgpO1xuICB9XG4gIHN0b3AodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jaGFydHMuZ2V0KHQpO1xuICAgIGlmICghZSB8fCAhZS5pdGVtcy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IGUuaXRlbXM7XG4gICAgbGV0IG4gPSBzLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IG4gPj0gMDsgLS1uKVxuICAgICAgc1tuXS5jYW5jZWwoKTtcbiAgICBlLml0ZW1zID0gW10sIHRoaXMuX25vdGlmeSh0LCBlLCBEYXRlLm5vdygpLCBcImNvbXBsZXRlXCIpO1xuICB9XG4gIHJlbW92ZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUodCk7XG4gIH1cbn1cbnZhciBhdCA9IG5ldyBacigpO1xuY29uc3QgZ3MgPSBcInRyYW5zcGFyZW50XCIsIEpyID0ge1xuICBib29sZWFuKGksIHQsIGUpIHtcbiAgICByZXR1cm4gZSA+IDAuNSA/IHQgOiBpO1xuICB9LFxuICBjb2xvcihpLCB0LCBlKSB7XG4gICAgY29uc3QgcyA9IG5zKGkgfHwgZ3MpLCBuID0gcy52YWxpZCAmJiBucyh0IHx8IGdzKTtcbiAgICByZXR1cm4gbiAmJiBuLnZhbGlkID8gbi5taXgocywgZSkuaGV4U3RyaW5nKCkgOiB0O1xuICB9LFxuICBudW1iZXIoaSwgdCwgZSkge1xuICAgIHJldHVybiBpICsgKHQgLSBpKSAqIGU7XG4gIH1cbn07XG5jbGFzcyBJbiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gZVtzXTtcbiAgICBuID0gWnQoW3QudG8sIG4sIG8sIHQuZnJvbV0pO1xuICAgIGNvbnN0IHIgPSBadChbdC5mcm9tLCBvLCBuXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gITAsIHRoaXMuX2ZuID0gdC5mbiB8fCBKclt0LnR5cGUgfHwgdHlwZW9mIHJdLCB0aGlzLl9lYXNpbmcgPSBlZVt0LmVhc2luZ10gfHwgZWUubGluZWFyLCB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArICh0LmRlbGF5IHx8IDApKSwgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IodC5kdXJhdGlvbiksIHRoaXMuX2xvb3AgPSAhIXQubG9vcCwgdGhpcy5fdGFyZ2V0ID0gZSwgdGhpcy5fcHJvcCA9IHMsIHRoaXMuX2Zyb20gPSByLCB0aGlzLl90byA9IG4sIHRoaXMuX3Byb21pc2VzID0gdm9pZCAwO1xuICB9XG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHVwZGF0ZSh0LCBlLCBzKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KCExKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF0sIG8gPSBzIC0gdGhpcy5fc3RhcnQsIHIgPSB0aGlzLl9kdXJhdGlvbiAtIG87XG4gICAgICB0aGlzLl9zdGFydCA9IHMsIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyLCB0LmR1cmF0aW9uKSksIHRoaXMuX3RvdGFsICs9IG8sIHRoaXMuX2xvb3AgPSAhIXQubG9vcCwgdGhpcy5fdG8gPSBadChbdC50bywgZSwgbiwgdC5mcm9tXSksIHRoaXMuX2Zyb20gPSBadChbdC5mcm9tLCBuLCBlXSk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9hY3RpdmUgJiYgKHRoaXMudGljayhEYXRlLm5vdygpKSwgdGhpcy5fYWN0aXZlID0gITEsIHRoaXMuX25vdGlmeSghMSkpO1xuICB9XG4gIHRpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0IC0gdGhpcy5fc3RhcnQsIHMgPSB0aGlzLl9kdXJhdGlvbiwgbiA9IHRoaXMuX3Byb3AsIG8gPSB0aGlzLl9mcm9tLCByID0gdGhpcy5fbG9vcCwgYSA9IHRoaXMuX3RvO1xuICAgIGxldCBsO1xuICAgIGlmICh0aGlzLl9hY3RpdmUgPSBvICE9PSBhICYmIChyIHx8IGUgPCBzKSwgIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W25dID0gYSwgdGhpcy5fbm90aWZ5KCEwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbbl0gPSBvO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsID0gZSAvIHMgJSAyLCBsID0gciAmJiBsID4gMSA/IDIgLSBsIDogbCwgbCA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBsKSkpLCB0aGlzLl90YXJnZXRbbl0gPSB0aGlzLl9mbihvLCBhLCBsKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChlLCBzKSA9PiB7XG4gICAgICB0LnB1c2goeyByZXM6IGUsIHJlajogcyB9KTtcbiAgICB9KTtcbiAgfVxuICBfbm90aWZ5KHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFwicmVzXCIgOiBcInJlalwiLCBzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKVxuICAgICAgc1tuXVtlXSgpO1xuICB9XG59XG5jb25zdCBRciA9IFtcInhcIiwgXCJ5XCIsIFwiYm9yZGVyV2lkdGhcIiwgXCJyYWRpdXNcIiwgXCJ0ZW5zaW9uXCJdLCB0YSA9IFtcImNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIl07XG5PLnNldChcImFuaW1hdGlvblwiLCB7XG4gIGRlbGF5OiB2b2lkIDAsXG4gIGR1cmF0aW9uOiAxZTMsXG4gIGVhc2luZzogXCJlYXNlT3V0UXVhcnRcIixcbiAgZm46IHZvaWQgMCxcbiAgZnJvbTogdm9pZCAwLFxuICBsb29wOiB2b2lkIDAsXG4gIHRvOiB2b2lkIDAsXG4gIHR5cGU6IHZvaWQgMFxufSk7XG5jb25zdCBlYSA9IE9iamVjdC5rZXlzKE8uYW5pbWF0aW9uKTtcbk8uZGVzY3JpYmUoXCJhbmltYXRpb25cIiwge1xuICBfZmFsbGJhY2s6ICExLFxuICBfaW5kZXhhYmxlOiAhMSxcbiAgX3NjcmlwdGFibGU6IChpKSA9PiBpICE9PSBcIm9uUHJvZ3Jlc3NcIiAmJiBpICE9PSBcIm9uQ29tcGxldGVcIiAmJiBpICE9PSBcImZuXCJcbn0pO1xuTy5zZXQoXCJhbmltYXRpb25zXCIsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIHByb3BlcnRpZXM6IHRhXG4gIH0sXG4gIG51bWJlcnM6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHByb3BlcnRpZXM6IFFyXG4gIH1cbn0pO1xuTy5kZXNjcmliZShcImFuaW1hdGlvbnNcIiwge1xuICBfZmFsbGJhY2s6IFwiYW5pbWF0aW9uXCJcbn0pO1xuTy5zZXQoXCJ0cmFuc2l0aW9uc1wiLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiBcInRyYW5zcGFyZW50XCJcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogXCJ0cmFuc3BhcmVudFwiXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBmbjogKGkpID0+IGkgfCAwXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmNsYXNzIE5pIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2NoYXJ0ID0gdCwgdGhpcy5fcHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuY29uZmlndXJlKGUpO1xuICB9XG4gIGNvbmZpZ3VyZSh0KSB7XG4gICAgaWYgKCFEKHQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0W3NdO1xuICAgICAgaWYgKCFEKG4pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0ge307XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgZWEpXG4gICAgICAgIG9bcl0gPSBuW3JdO1xuICAgICAgKHoobi5wcm9wZXJ0aWVzKSAmJiBuLnByb3BlcnRpZXMgfHwgW3NdKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIChyID09PSBzIHx8ICFlLmhhcyhyKSkgJiYgZS5zZXQociwgbyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModCwgZSkge1xuICAgIGNvbnN0IHMgPSBlLm9wdGlvbnMsIG4gPSBzYSh0LCBzKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMobiwgcyk7XG4gICAgcmV0dXJuIHMuJHNoYXJlZCAmJiBpYSh0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIHMpLnRoZW4oKCkgPT4ge1xuICAgICAgdC5vcHRpb25zID0gcztcbiAgICB9LCAoKSA9PiB7XG4gICAgfSksIG87XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9wcm9wZXJ0aWVzLCBuID0gW10sIG8gPSB0LiRhbmltYXRpb25zIHx8ICh0LiRhbmltYXRpb25zID0ge30pLCByID0gT2JqZWN0LmtleXMoZSksIGEgPSBEYXRlLm5vdygpO1xuICAgIGxldCBsO1xuICAgIGZvciAobCA9IHIubGVuZ3RoIC0gMTsgbCA+PSAwOyAtLWwpIHtcbiAgICAgIGNvbnN0IGMgPSByW2xdO1xuICAgICAgaWYgKGMuY2hhckF0KDApID09PSBcIiRcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoYyA9PT0gXCJvcHRpb25zXCIpIHtcbiAgICAgICAgbi5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHQsIGUpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoID0gZVtjXTtcbiAgICAgIGxldCBkID0gb1tjXTtcbiAgICAgIGNvbnN0IHUgPSBzLmdldChjKTtcbiAgICAgIGlmIChkKVxuICAgICAgICBpZiAodSAmJiBkLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZC51cGRhdGUodSwgaCwgYSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGQuY2FuY2VsKCk7XG4gICAgICBpZiAoIXUgfHwgIXUuZHVyYXRpb24pIHtcbiAgICAgICAgdFtjXSA9IGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb1tjXSA9IGQgPSBuZXcgSW4odSwgdCwgYywgaCksIG4ucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgdXBkYXRlKHQsIGUpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHQsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0LCBlKTtcbiAgICBpZiAocy5sZW5ndGgpXG4gICAgICByZXR1cm4gYXQuYWRkKHRoaXMuX2NoYXJ0LCBzKSwgITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlhKGksIHQpIHtcbiAgY29uc3QgZSA9IFtdLCBzID0gT2JqZWN0LmtleXModCk7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IG8gPSBpW3Nbbl1dO1xuICAgIG8gJiYgby5hY3RpdmUoKSAmJiBlLnB1c2goby53YWl0KCkpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChlKTtcbn1cbmZ1bmN0aW9uIHNhKGksIHQpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybjtcbiAgbGV0IGUgPSBpLm9wdGlvbnM7XG4gIGlmICghZSkge1xuICAgIGkub3B0aW9ucyA9IHQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBlLiRzaGFyZWQgJiYgKGkub3B0aW9ucyA9IGUgPSBPYmplY3QuYXNzaWduKHt9LCBlLCB7ICRzaGFyZWQ6ICExLCAkYW5pbWF0aW9uczoge30gfSkpLCBlO1xufVxuZnVuY3Rpb24gcHMoaSwgdCkge1xuICBjb25zdCBlID0gaSAmJiBpLm9wdGlvbnMgfHwge30sIHMgPSBlLnJldmVyc2UsIG4gPSBlLm1pbiA9PT0gdm9pZCAwID8gdCA6IDAsIG8gPSBlLm1heCA9PT0gdm9pZCAwID8gdCA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHMgPyBvIDogbixcbiAgICBlbmQ6IHMgPyBuIDogb1xuICB9O1xufVxuZnVuY3Rpb24gbmEoaSwgdCwgZSkge1xuICBpZiAoZSA9PT0gITEpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzID0gcHMoaSwgZSksIG4gPSBwcyh0LCBlKTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG4uZW5kLFxuICAgIHJpZ2h0OiBzLmVuZCxcbiAgICBib3R0b206IG4uc3RhcnQsXG4gICAgbGVmdDogcy5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gb2EoaSkge1xuICBsZXQgdCwgZSwgcywgbjtcbiAgcmV0dXJuIEQoaSkgPyAodCA9IGkudG9wLCBlID0gaS5yaWdodCwgcyA9IGkuYm90dG9tLCBuID0gaS5sZWZ0KSA6IHQgPSBlID0gcyA9IG4gPSBpLCB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiBlLFxuICAgIGJvdHRvbTogcyxcbiAgICBsZWZ0OiBuLFxuICAgIGRpc2FibGVkOiBpID09PSAhMVxuICB9O1xufVxuZnVuY3Rpb24gem4oaSwgdCkge1xuICBjb25zdCBlID0gW10sIHMgPSBpLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModCk7XG4gIGxldCBuLCBvO1xuICBmb3IgKG4gPSAwLCBvID0gcy5sZW5ndGg7IG4gPCBvOyArK24pXG4gICAgZS5wdXNoKHNbbl0uaW5kZXgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG1zKGksIHQsIGUsIHMgPSB7fSkge1xuICBjb25zdCBuID0gaS5rZXlzLCBvID0gcy5tb2RlID09PSBcInNpbmdsZVwiO1xuICBsZXQgciwgYSwgbCwgYztcbiAgaWYgKHQgIT09IG51bGwpIHtcbiAgICBmb3IgKHIgPSAwLCBhID0gbi5sZW5ndGg7IHIgPCBhOyArK3IpIHtcbiAgICAgIGlmIChsID0gK25bcl0sIGwgPT09IGUpIHtcbiAgICAgICAgaWYgKHMuYWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGMgPSBpLnZhbHVlc1tsXSwgTihjKSAmJiAobyB8fCB0ID09PSAwIHx8IGx0KHQpID09PSBsdChjKSkgJiYgKHQgKz0gYyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG59XG5mdW5jdGlvbiByYShpKSB7XG4gIGNvbnN0IHQgPSBPYmplY3Qua2V5cyhpKSwgZSA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gIGxldCBzLCBuLCBvO1xuICBmb3IgKHMgPSAwLCBuID0gdC5sZW5ndGg7IHMgPCBuOyArK3MpXG4gICAgbyA9IHRbc10sIGVbc10gPSB7XG4gICAgICB4OiBvLFxuICAgICAgeTogaVtvXVxuICAgIH07XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gYnMoaSwgdCkge1xuICBjb25zdCBlID0gaSAmJiBpLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIGUgfHwgZSA9PT0gdm9pZCAwICYmIHQuc3RhY2sgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGFhKGksIHQsIGUpIHtcbiAgcmV0dXJuIGAke2kuaWR9LiR7dC5pZH0uJHtlLnN0YWNrIHx8IGUudHlwZX1gO1xufVxuZnVuY3Rpb24gbGEoaSkge1xuICBjb25zdCB7IG1pbjogdCwgbWF4OiBlLCBtaW5EZWZpbmVkOiBzLCBtYXhEZWZpbmVkOiBuIH0gPSBpLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IHMgPyB0IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbiA/IGUgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGlbdF0gfHwgKGlbdF0gPSB7fSk7XG4gIHJldHVybiBzW2VdIHx8IChzW2VdID0ge30pO1xufVxuZnVuY3Rpb24geHMoaSwgdCwgZSwgcykge1xuICBmb3IgKGNvbnN0IG4gb2YgdC5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhzKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCBvID0gaVtuLmluZGV4XTtcbiAgICBpZiAoZSAmJiBvID4gMCB8fCAhZSAmJiBvIDwgMClcbiAgICAgIHJldHVybiBuLmluZGV4O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3MoaSwgdCkge1xuICBjb25zdCB7IGNoYXJ0OiBlLCBfY2FjaGVkTWV0YTogcyB9ID0gaSwgbiA9IGUuX3N0YWNrcyB8fCAoZS5fc3RhY2tzID0ge30pLCB7IGlTY2FsZTogbywgdlNjYWxlOiByLCBpbmRleDogYSB9ID0gcywgbCA9IG8uYXhpcywgYyA9IHIuYXhpcywgaCA9IGFhKG8sIHIsIHMpLCBkID0gdC5sZW5ndGg7XG4gIGxldCB1O1xuICBmb3IgKGxldCBmID0gMDsgZiA8IGQ7ICsrZikge1xuICAgIGNvbnN0IGcgPSB0W2ZdLCB7IFtsXTogcCwgW2NdOiBtIH0gPSBnLCBiID0gZy5fc3RhY2tzIHx8IChnLl9zdGFja3MgPSB7fSk7XG4gICAgdSA9IGJbY10gPSBjYShuLCBoLCBwKSwgdVthXSA9IG0sIHUuX3RvcCA9IHhzKHUsIHIsICEwLCBzLnR5cGUpLCB1Ll9ib3R0b20gPSB4cyh1LCByLCAhMSwgcy50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gbGkoaSwgdCkge1xuICBjb25zdCBlID0gaS5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5maWx0ZXIoKHMpID0+IGVbc10uYXhpcyA9PT0gdCkuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGhhKGksIHQpIHtcbiAgcmV0dXJuIHZ0KFxuICAgIGksXG4gICAge1xuICAgICAgYWN0aXZlOiAhMSxcbiAgICAgIGRhdGFzZXQ6IHZvaWQgMCxcbiAgICAgIGRhdGFzZXRJbmRleDogdCxcbiAgICAgIGluZGV4OiB0LFxuICAgICAgbW9kZTogXCJkZWZhdWx0XCIsXG4gICAgICB0eXBlOiBcImRhdGFzZXRcIlxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGRhKGksIHQsIGUpIHtcbiAgcmV0dXJuIHZ0KGksIHtcbiAgICBhY3RpdmU6ICExLFxuICAgIGRhdGFJbmRleDogdCxcbiAgICBwYXJzZWQ6IHZvaWQgMCxcbiAgICByYXc6IHZvaWQgMCxcbiAgICBlbGVtZW50OiBlLFxuICAgIGluZGV4OiB0LFxuICAgIG1vZGU6IFwiZGVmYXVsdFwiLFxuICAgIHR5cGU6IFwiZGF0YVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gWXQoaSwgdCkge1xuICBjb25zdCBlID0gaS5jb250cm9sbGVyLmluZGV4LCBzID0gaS52U2NhbGUgJiYgaS52U2NhbGUuYXhpcztcbiAgaWYgKHMpIHtcbiAgICB0ID0gdCB8fCBpLl9wYXJzZWQ7XG4gICAgZm9yIChjb25zdCBuIG9mIHQpIHtcbiAgICAgIGNvbnN0IG8gPSBuLl9zdGFja3M7XG4gICAgICBpZiAoIW8gfHwgb1tzXSA9PT0gdm9pZCAwIHx8IG9bc11bZV0gPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVsZXRlIG9bc11bZV07XG4gICAgfVxuICB9XG59XG5jb25zdCBjaSA9IChpKSA9PiBpID09PSBcInJlc2V0XCIgfHwgaSA9PT0gXCJub25lXCIsIHlzID0gKGksIHQpID0+IHQgPyBpIDogT2JqZWN0LmFzc2lnbih7fSwgaSksIHVhID0gKGksIHQsIGUpID0+IGkgJiYgIXQuaGlkZGVuICYmIHQuX3N0YWNrZWQgJiYgeyBrZXlzOiB6bihlLCAhMCksIHZhbHVlczogbnVsbCB9O1xuY2xhc3MgaXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5jaGFydCA9IHQsIHRoaXMuX2N0eCA9IHQuY3R4LCB0aGlzLmluZGV4ID0gZSwgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fSwgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpLCB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuX3BhcnNpbmcgPSAhMSwgdGhpcy5fZGF0YSA9IHZvaWQgMCwgdGhpcy5fb2JqZWN0RGF0YSA9IHZvaWQgMCwgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHZvaWQgMCwgdGhpcy5fZHJhd1N0YXJ0ID0gdm9pZCAwLCB0aGlzLl9kcmF3Q291bnQgPSB2b2lkIDAsIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICExLCB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9ICExLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCB0aGlzLl9zeW5jTGlzdCA9IFtdLCB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCksIHRoaXMubGlua1NjYWxlcygpLCB0Ll9zdGFja2VkID0gYnModC52U2NhbGUsIHQpLCB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlSW5kZXgodCkge1xuICAgIHRoaXMuaW5kZXggIT09IHQgJiYgWXQodGhpcy5fY2FjaGVkTWV0YSksIHRoaXMuaW5kZXggPSB0O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2hhcnQsIGUgPSB0aGlzLl9jYWNoZWRNZXRhLCBzID0gdGhpcy5nZXREYXRhc2V0KCksIG4gPSAoZCwgdSwgZiwgZykgPT4gZCA9PT0gXCJ4XCIgPyB1IDogZCA9PT0gXCJyXCIgPyBnIDogZiwgbyA9IGUueEF4aXNJRCA9IEMocy54QXhpc0lELCBsaSh0LCBcInhcIikpLCByID0gZS55QXhpc0lEID0gQyhzLnlBeGlzSUQsIGxpKHQsIFwieVwiKSksIGEgPSBlLnJBeGlzSUQgPSBDKHMuckF4aXNJRCwgbGkodCwgXCJyXCIpKSwgbCA9IGUuaW5kZXhBeGlzLCBjID0gZS5pQXhpc0lEID0gbihsLCBvLCByLCBhKSwgaCA9IGUudkF4aXNJRCA9IG4obCwgciwgbywgYSk7XG4gICAgZS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQobyksIGUueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHIpLCBlLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChhKSwgZS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoYyksIGUudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGgpO1xuICB9XG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG4gIGdldFNjYWxlRm9ySWQodCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1t0XTtcbiAgfVxuICBfZ2V0T3RoZXJTY2FsZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHQgPT09IGUuaVNjYWxlID8gZS52U2NhbGUgOiBlLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoXCJyZXNldFwiKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhICYmIFppKHRoaXMuX2RhdGEsIHRoaXMpLCB0Ll9zdGFja2VkICYmIFl0KHQpO1xuICB9XG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0RGF0YXNldCgpLCBlID0gdC5kYXRhIHx8ICh0LmRhdGEgPSBbXSksIHMgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChEKGUpKVxuICAgICAgdGhpcy5fZGF0YSA9IHJhKGUpO1xuICAgIGVsc2UgaWYgKHMgIT09IGUpIHtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIFppKHMsIHRoaXMpO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgWXQobiksIG4uX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgZSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGUpICYmIEVvKGUsIHRoaXMpLCB0aGlzLl9zeW5jTGlzdCA9IFtdLCB0aGlzLl9kYXRhID0gZTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCksIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmICh0LmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgcyA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBuID0gITE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3QgbyA9IGUuX3N0YWNrZWQ7XG4gICAgZS5fc3RhY2tlZCA9IGJzKGUudlNjYWxlLCBlKSwgZS5zdGFjayAhPT0gcy5zdGFjayAmJiAobiA9ICEwLCBZdChlKSwgZS5zdGFjayA9IHMuc3RhY2spLCB0aGlzLl9yZXN5bmNFbGVtZW50cyh0KSwgKG4gfHwgbyAhPT0gZS5fc3RhY2tlZCkgJiYgX3ModGhpcywgZS5fcGFyc2VkKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2hhcnQuY29uZmlnLCBlID0gdC5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpLCBzID0gdC5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIGUsICEwKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0LmNyZWF0ZVJlc29sdmVyKHMsIHRoaXMuZ2V0Q29udGV4dCgpKSwgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nLCB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHQsIGUpIHtcbiAgICBjb25zdCB7IF9jYWNoZWRNZXRhOiBzLCBfZGF0YTogbiB9ID0gdGhpcywgeyBpU2NhbGU6IG8sIF9zdGFja2VkOiByIH0gPSBzLCBhID0gby5heGlzO1xuICAgIGxldCBsID0gdCA9PT0gMCAmJiBlID09PSBuLmxlbmd0aCA/ICEwIDogcy5fc29ydGVkLCBjID0gdCA+IDAgJiYgcy5fcGFyc2VkW3QgLSAxXSwgaCwgZCwgdTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gITEpXG4gICAgICBzLl9wYXJzZWQgPSBuLCBzLl9zb3J0ZWQgPSAhMCwgdSA9IG47XG4gICAgZWxzZSB7XG4gICAgICB6KG5bdF0pID8gdSA9IHRoaXMucGFyc2VBcnJheURhdGEocywgbiwgdCwgZSkgOiBEKG5bdF0pID8gdSA9IHRoaXMucGFyc2VPYmplY3REYXRhKHMsIG4sIHQsIGUpIDogdSA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKHMsIG4sIHQsIGUpO1xuICAgICAgY29uc3QgZiA9ICgpID0+IGRbYV0gPT09IG51bGwgfHwgYyAmJiBkW2FdIDwgY1thXTtcbiAgICAgIGZvciAoaCA9IDA7IGggPCBlOyArK2gpXG4gICAgICAgIHMuX3BhcnNlZFtoICsgdF0gPSBkID0gdVtoXSwgbCAmJiAoZigpICYmIChsID0gITEpLCBjID0gZCk7XG4gICAgICBzLl9zb3J0ZWQgPSBsO1xuICAgIH1cbiAgICByICYmIF9zKHRoaXMsIHUpO1xuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyBpU2NhbGU6IG8sIHZTY2FsZTogciB9ID0gdCwgYSA9IG8uYXhpcywgbCA9IHIuYXhpcywgYyA9IG8uZ2V0TGFiZWxzKCksIGggPSBvID09PSByLCBkID0gbmV3IEFycmF5KG4pO1xuICAgIGxldCB1LCBmLCBnO1xuICAgIGZvciAodSA9IDAsIGYgPSBuOyB1IDwgZjsgKyt1KVxuICAgICAgZyA9IHUgKyBzLCBkW3VdID0ge1xuICAgICAgICBbYV06IGggfHwgby5wYXJzZShjW2ddLCBnKSxcbiAgICAgICAgW2xdOiByLnBhcnNlKGVbZ10sIGcpXG4gICAgICB9O1xuICAgIHJldHVybiBkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCB7IHhTY2FsZTogbywgeVNjYWxlOiByIH0gPSB0LCBhID0gbmV3IEFycmF5KG4pO1xuICAgIGxldCBsLCBjLCBoLCBkO1xuICAgIGZvciAobCA9IDAsIGMgPSBuOyBsIDwgYzsgKytsKVxuICAgICAgaCA9IGwgKyBzLCBkID0gZVtoXSwgYVtsXSA9IHtcbiAgICAgICAgeDogby5wYXJzZShkWzBdLCBoKSxcbiAgICAgICAgeTogci5wYXJzZShkWzFdLCBoKVxuICAgICAgfTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgeFNjYWxlOiBvLCB5U2NhbGU6IHIgfSA9IHQsIHsgeEF4aXNLZXk6IGEgPSBcInhcIiwgeUF4aXNLZXk6IGwgPSBcInlcIiB9ID0gdGhpcy5fcGFyc2luZywgYyA9IG5ldyBBcnJheShuKTtcbiAgICBsZXQgaCwgZCwgdSwgZjtcbiAgICBmb3IgKGggPSAwLCBkID0gbjsgaCA8IGQ7ICsraClcbiAgICAgIHUgPSBoICsgcywgZiA9IGVbdV0sIGNbaF0gPSB7XG4gICAgICAgIHg6IG8ucGFyc2UoX3QoZiwgYSksIHUpLFxuICAgICAgICB5OiByLnBhcnNlKF90KGYsIGwpLCB1KVxuICAgICAgfTtcbiAgICByZXR1cm4gYztcbiAgfVxuICBnZXRQYXJzZWQodCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbdF07XG4gIH1cbiAgZ2V0RGF0YUVsZW1lbnQodCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbdF07XG4gIH1cbiAgYXBwbHlTdGFjayh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuY2hhcnQsIG8gPSB0aGlzLl9jYWNoZWRNZXRhLCByID0gZVt0LmF4aXNdLCBhID0ge1xuICAgICAga2V5czogem4obiwgITApLFxuICAgICAgdmFsdWVzOiBlLl9zdGFja3NbdC5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIG1zKGEsIHIsIG8uaW5kZXgsIHsgbW9kZTogcyB9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBzW2UuYXhpc107XG4gICAgbGV0IHIgPSBvID09PSBudWxsID8gTmFOIDogbztcbiAgICBjb25zdCBhID0gbiAmJiBzLl9zdGFja3NbZS5heGlzXTtcbiAgICBuICYmIGEgJiYgKG4udmFsdWVzID0gYSwgciA9IG1zKG4sIG8sIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpKSwgdC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgciksIHQubWF4ID0gTWF0aC5tYXgodC5tYXgsIHIpO1xuICB9XG4gIGdldE1pbk1heCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX2NhY2hlZE1ldGEsIG4gPSBzLl9wYXJzZWQsIG8gPSBzLl9zb3J0ZWQgJiYgdCA9PT0gcy5pU2NhbGUsIHIgPSBuLmxlbmd0aCwgYSA9IHRoaXMuX2dldE90aGVyU2NhbGUodCksIGwgPSB1YShlLCBzLCB0aGlzLmNoYXJ0KSwgYyA9IHsgbWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIH0sIHsgbWluOiBoLCBtYXg6IGQgfSA9IGxhKGEpO1xuICAgIGxldCB1LCBmO1xuICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICBmID0gblt1XTtcbiAgICAgIGNvbnN0IHAgPSBmW2EuYXhpc107XG4gICAgICByZXR1cm4gIU4oZlt0LmF4aXNdKSB8fCBoID4gcCB8fCBkIDwgcDtcbiAgICB9XG4gICAgZm9yICh1ID0gMDsgdSA8IHIgJiYgISghZygpICYmICh0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChjLCB0LCBmLCBsKSwgbykpOyArK3UpXG4gICAgICA7XG4gICAgaWYgKG8pIHtcbiAgICAgIGZvciAodSA9IHIgLSAxOyB1ID49IDA7IC0tdSlcbiAgICAgICAgaWYgKCFnKCkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChjLCB0LCBmLCBsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuICBnZXRBbGxQYXJzZWRWYWx1ZXModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQsIHMgPSBbXTtcbiAgICBsZXQgbiwgbywgcjtcbiAgICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pXG4gICAgICByID0gZVtuXVt0LmF4aXNdLCBOKHIpICYmIHMucHVzaChyKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHMgPSBlLmlTY2FsZSwgbiA9IGUudlNjYWxlLCBvID0gdGhpcy5nZXRQYXJzZWQodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBzID8gXCJcIiArIHMuZ2V0TGFiZWxGb3JWYWx1ZShvW3MuYXhpc10pIDogXCJcIixcbiAgICAgIHZhbHVlOiBuID8gXCJcIiArIG4uZ2V0TGFiZWxGb3JWYWx1ZShvW24uYXhpc10pIDogXCJcIlxuICAgIH07XG4gIH1cbiAgX3VwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGUodCB8fCBcImRlZmF1bHRcIiksIGUuX2NsaXAgPSBvYShDKHRoaXMub3B0aW9ucy5jbGlwLCBuYShlLnhTY2FsZSwgZS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2N0eCwgZSA9IHRoaXMuY2hhcnQsIHMgPSB0aGlzLl9jYWNoZWRNZXRhLCBuID0gcy5kYXRhIHx8IFtdLCBvID0gZS5jaGFydEFyZWEsIHIgPSBbXSwgYSA9IHRoaXMuX2RyYXdTdGFydCB8fCAwLCBsID0gdGhpcy5fZHJhd0NvdW50IHx8IG4ubGVuZ3RoIC0gYSwgYyA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaDtcbiAgICBmb3IgKHMuZGF0YXNldCAmJiBzLmRhdGFzZXQuZHJhdyh0LCBvLCBhLCBsKSwgaCA9IGE7IGggPCBhICsgbDsgKytoKSB7XG4gICAgICBjb25zdCBkID0gbltoXTtcbiAgICAgIGQuaGlkZGVuIHx8IChkLmFjdGl2ZSAmJiBjID8gci5wdXNoKGQpIDogZC5kcmF3KHQsIG8pKTtcbiAgICB9XG4gICAgZm9yIChoID0gMDsgaCA8IHIubGVuZ3RoOyArK2gpXG4gICAgICByW2hdLmRyYXcodCwgbyk7XG4gIH1cbiAgZ2V0U3R5bGUodCwgZSkge1xuICAgIGNvbnN0IHMgPSBlID8gXCJhY3RpdmVcIiA6IFwiZGVmYXVsdFwiO1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0ID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHMpIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQgfHwgMCwgcyk7XG4gIH1cbiAgZ2V0Q29udGV4dCh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBvO1xuICAgIGlmICh0ID49IDAgJiYgdCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbdF07XG4gICAgICBvID0gci4kY29udGV4dCB8fCAoci4kY29udGV4dCA9IGRhKHRoaXMuZ2V0Q29udGV4dCgpLCB0LCByKSksIG8ucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQodCksIG8ucmF3ID0gbi5kYXRhW3RdLCBvLmluZGV4ID0gby5kYXRhSW5kZXggPSB0O1xuICAgIH0gZWxzZVxuICAgICAgbyA9IHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBoYSh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpLCBvLmRhdGFzZXQgPSBuLCBvLmluZGV4ID0gby5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHJldHVybiBvLmFjdGl2ZSA9ICEhZSwgby5tb2RlID0gcywgbztcbiAgfVxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCB0KTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBlLCB0KTtcbiAgfVxuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHQsIGUgPSBcImRlZmF1bHRcIiwgcykge1xuICAgIGNvbnN0IG4gPSBlID09PSBcImFjdGl2ZVwiLCBvID0gdGhpcy5fY2FjaGVkRGF0YU9wdHMsIHIgPSB0ICsgXCItXCIgKyBlLCBhID0gb1tyXSwgbCA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBldChzKTtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiB5cyhhLCBsKTtcbiAgICBjb25zdCBjID0gdGhpcy5jaGFydC5jb25maWcsIGggPSBjLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIHQpLCBkID0gbiA/IFtgJHt0fUhvdmVyYCwgXCJob3ZlclwiLCB0LCBcIlwiXSA6IFt0LCBcIlwiXSwgdSA9IGMuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBoKSwgZiA9IE9iamVjdC5rZXlzKE8uZWxlbWVudHNbdF0pLCBnID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KHMsIG4pLCBwID0gYy5yZXNvbHZlTmFtZWRPcHRpb25zKHUsIGYsIGcsIGQpO1xuICAgIHJldHVybiBwLiRzaGFyZWQgJiYgKHAuJHNoYXJlZCA9IGwsIG9bcl0gPSBPYmplY3QuZnJlZXplKHlzKHAsIGwpKSksIHA7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jaGFydCwgbyA9IHRoaXMuX2NhY2hlZERhdGFPcHRzLCByID0gYGFuaW1hdGlvbi0ke2V9YCwgYSA9IG9bcl07XG4gICAgaWYgKGEpXG4gICAgICByZXR1cm4gYTtcbiAgICBsZXQgbDtcbiAgICBpZiAobi5vcHRpb25zLmFuaW1hdGlvbiAhPT0gITEpIHtcbiAgICAgIGNvbnN0IGggPSB0aGlzLmNoYXJ0LmNvbmZpZywgZCA9IGguZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCBlKSwgdSA9IGguZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBkKTtcbiAgICAgIGwgPSBoLmNyZWF0ZVJlc29sdmVyKHUsIHRoaXMuZ2V0Q29udGV4dCh0LCBzLCBlKSk7XG4gICAgfVxuICAgIGNvbnN0IGMgPSBuZXcgTmkobiwgbCAmJiBsLmFuaW1hdGlvbnMpO1xuICAgIHJldHVybiBsICYmIGwuX2NhY2hlYWJsZSAmJiAob1tyXSA9IE9iamVjdC5mcmVlemUoYykpLCBjO1xuICB9XG4gIGdldFNoYXJlZE9wdGlvbnModCkge1xuICAgIGlmICh0LiRzaGFyZWQpXG4gICAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHQpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyh0LCBlKSB7XG4gICAgcmV0dXJuICFlIHx8IGNpKHQpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuICBfZ2V0U2hhcmVkT3B0aW9ucyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh0LCBlKSwgbiA9IHRoaXMuX3NoYXJlZE9wdGlvbnMsIG8gPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMocyksIHIgPSB0aGlzLmluY2x1ZGVPcHRpb25zKGUsIG8pIHx8IG8gIT09IG47XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhvLCBlLCBzKSwgeyBzaGFyZWRPcHRpb25zOiBvLCBpbmNsdWRlT3B0aW9uczogciB9O1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQodCwgZSwgcywgbikge1xuICAgIGNpKG4pID8gT2JqZWN0LmFzc2lnbih0LCBzKSA6IHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGUsIG4pLnVwZGF0ZSh0LCBzKTtcbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHQsIGUsIHMpIHtcbiAgICB0ICYmICFjaShlKSAmJiB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh2b2lkIDAsIGUpLnVwZGF0ZSh0LCBzKTtcbiAgfVxuICBfc2V0U3R5bGUodCwgZSwgcywgbikge1xuICAgIHQuYWN0aXZlID0gbjtcbiAgICBjb25zdCBvID0gdGhpcy5nZXRTdHlsZShlLCBuKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhlLCBzLCBuKS51cGRhdGUodCwge1xuICAgICAgb3B0aW9uczogIW4gJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG8pIHx8IG9cbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKHQsIGUsIHMpIHtcbiAgICB0aGlzLl9zZXRTdHlsZSh0LCBzLCBcImFjdGl2ZVwiLCAhMSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZSh0LCBlLCBzKSB7XG4gICAgdGhpcy5fc2V0U3R5bGUodCwgcywgXCJhY3RpdmVcIiwgITApO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIHQgJiYgdGhpcy5fc2V0U3R5bGUodCwgdm9pZCAwLCBcImFjdGl2ZVwiLCAhMSk7XG4gIH1cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgdCAmJiB0aGlzLl9zZXRTdHlsZSh0LCB2b2lkIDAsIFwiYWN0aXZlXCIsICEwKTtcbiAgfVxuICBfcmVzeW5jRWxlbWVudHModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9kYXRhLCBzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGZvciAoY29uc3QgW2EsIGwsIGNdIG9mIHRoaXMuX3N5bmNMaXN0KVxuICAgICAgdGhpc1thXShsLCBjKTtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG4gPSBzLmxlbmd0aCwgbyA9IGUubGVuZ3RoLCByID0gTWF0aC5taW4obywgbik7XG4gICAgciAmJiB0aGlzLnBhcnNlKDAsIHIpLCBvID4gbiA/IHRoaXMuX2luc2VydEVsZW1lbnRzKG4sIG8gLSBuLCB0KSA6IG8gPCBuICYmIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG8sIG4gLSBvKTtcbiAgfVxuICBfaW5zZXJ0RWxlbWVudHModCwgZSwgcyA9ICEwKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2NhY2hlZE1ldGEsIG8gPSBuLmRhdGEsIHIgPSB0ICsgZTtcbiAgICBsZXQgYTtcbiAgICBjb25zdCBsID0gKGMpID0+IHtcbiAgICAgIGZvciAoYy5sZW5ndGggKz0gZSwgYSA9IGMubGVuZ3RoIC0gMTsgYSA+PSByOyBhLS0pXG4gICAgICAgIGNbYV0gPSBjW2EgLSBlXTtcbiAgICB9O1xuICAgIGZvciAobChvKSwgYSA9IHQ7IGEgPCByOyArK2EpXG4gICAgICBvW2FdID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgdGhpcy5fcGFyc2luZyAmJiBsKG4uX3BhcnNlZCksIHRoaXMucGFyc2UodCwgZSksIHMgJiYgdGhpcy51cGRhdGVFbGVtZW50cyhvLCB0LCBlLCBcInJlc2V0XCIpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgfVxuICBfcmVtb3ZlRWxlbWVudHModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCBuID0gcy5fcGFyc2VkLnNwbGljZSh0LCBlKTtcbiAgICAgIHMuX3N0YWNrZWQgJiYgWXQocywgbik7XG4gICAgfVxuICAgIHMuZGF0YS5zcGxpY2UodCwgZSk7XG4gIH1cbiAgX3N5bmModCkge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKVxuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaCh0KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IFtlLCBzLCBuXSA9IHQ7XG4gICAgICB0aGlzW2VdKHMsIG4pO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi50XSk7XG4gIH1cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgdCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbXCJfaW5zZXJ0RWxlbWVudHNcIiwgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSB0LCB0XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCAwLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNwbGljZSh0LCBlKSB7XG4gICAgZSAmJiB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCB0LCBlXSk7XG4gICAgY29uc3QgcyA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIHMgJiYgdGhpcy5fc3luYyhbXCJfaW5zZXJ0RWxlbWVudHNcIiwgdCwgc10pO1xuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoW1wiX2luc2VydEVsZW1lbnRzXCIsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcbiAgfVxufVxuaXQuZGVmYXVsdHMgPSB7fTtcbml0LnByb3RvdHlwZS5kYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuaXQucHJvdG90eXBlLmRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5mdW5jdGlvbiBmYShpLCB0KSB7XG4gIGlmICghaS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IGUgPSBpLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHQpO1xuICAgIGxldCBzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87IG4rKylcbiAgICAgIHMgPSBzLmNvbmNhdChlW25dLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKGkpKTtcbiAgICBpLl9jYWNoZS4kYmFyID0gdW4ocy5zb3J0KChuLCBvKSA9PiBuIC0gbykpO1xuICB9XG4gIHJldHVybiBpLl9jYWNoZS4kYmFyO1xufVxuZnVuY3Rpb24gZ2EoaSkge1xuICBjb25zdCB0ID0gaS5pU2NhbGUsIGUgPSBmYSh0LCBpLnR5cGUpO1xuICBsZXQgcyA9IHQuX2xlbmd0aCwgbiwgbywgciwgYTtcbiAgY29uc3QgbCA9ICgpID0+IHtcbiAgICByID09PSAzMjc2NyB8fCByID09PSAtMzI3NjggfHwgKGV0KGEpICYmIChzID0gTWF0aC5taW4ocywgTWF0aC5hYnMociAtIGEpIHx8IHMpKSwgYSA9IHIpO1xuICB9O1xuICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pXG4gICAgciA9IHQuZ2V0UGl4ZWxGb3JWYWx1ZShlW25dKSwgbCgpO1xuICBmb3IgKGEgPSB2b2lkIDAsIG4gPSAwLCBvID0gdC50aWNrcy5sZW5ndGg7IG4gPCBvOyArK24pXG4gICAgciA9IHQuZ2V0UGl4ZWxGb3JUaWNrKG4pLCBsKCk7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcGEoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gZS5iYXJUaGlja25lc3M7XG4gIGxldCBvLCByO1xuICByZXR1cm4gVChuKSA/IChvID0gdC5taW4gKiBlLmNhdGVnb3J5UGVyY2VudGFnZSwgciA9IGUuYmFyUGVyY2VudGFnZSkgOiAobyA9IG4gKiBzLCByID0gMSksIHtcbiAgICBjaHVuazogbyAvIHMsXG4gICAgcmF0aW86IHIsXG4gICAgc3RhcnQ6IHQucGl4ZWxzW2ldIC0gbyAvIDJcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IHQucGl4ZWxzLCBvID0gbltpXTtcbiAgbGV0IHIgPSBpID4gMCA/IG5baSAtIDFdIDogbnVsbCwgYSA9IGkgPCBuLmxlbmd0aCAtIDEgPyBuW2kgKyAxXSA6IG51bGw7XG4gIGNvbnN0IGwgPSBlLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgciA9PT0gbnVsbCAmJiAociA9IG8gLSAoYSA9PT0gbnVsbCA/IHQuZW5kIC0gdC5zdGFydCA6IGEgLSBvKSksIGEgPT09IG51bGwgJiYgKGEgPSBvICsgbyAtIHIpO1xuICBjb25zdCBjID0gbyAtIChvIC0gTWF0aC5taW4ociwgYSkpIC8gMiAqIGw7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IE1hdGguYWJzKGEgLSByKSAvIDIgKiBsIC8gcyxcbiAgICByYXRpbzogZS5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0OiBjXG4gIH07XG59XG5mdW5jdGlvbiBiYShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBlLnBhcnNlKGlbMF0sIHMpLCBvID0gZS5wYXJzZShpWzFdLCBzKSwgciA9IE1hdGgubWluKG4sIG8pLCBhID0gTWF0aC5tYXgobiwgbyk7XG4gIGxldCBsID0gciwgYyA9IGE7XG4gIE1hdGguYWJzKHIpID4gTWF0aC5hYnMoYSkgJiYgKGwgPSBhLCBjID0gciksIHRbZS5heGlzXSA9IGMsIHQuX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydDogbCxcbiAgICBiYXJFbmQ6IGMsXG4gICAgc3RhcnQ6IG4sXG4gICAgZW5kOiBvLFxuICAgIG1pbjogcixcbiAgICBtYXg6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIEJuKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHooaSkgPyBiYShpLCB0LCBlLCBzKSA6IHRbZS5heGlzXSA9IGUucGFyc2UoaSwgcyksIHQ7XG59XG5mdW5jdGlvbiB2cyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBpLmlTY2FsZSwgbyA9IGkudlNjYWxlLCByID0gbi5nZXRMYWJlbHMoKSwgYSA9IG4gPT09IG8sIGwgPSBbXTtcbiAgbGV0IGMsIGgsIGQsIHU7XG4gIGZvciAoYyA9IGUsIGggPSBlICsgczsgYyA8IGg7ICsrYylcbiAgICB1ID0gdFtjXSwgZCA9IHt9LCBkW24uYXhpc10gPSBhIHx8IG4ucGFyc2UocltjXSwgYyksIGwucHVzaChCbih1LCBkLCBvLCBjKSk7XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24gaGkoaSkge1xuICByZXR1cm4gaSAmJiBpLmJhclN0YXJ0ICE9PSB2b2lkIDAgJiYgaS5iYXJFbmQgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHhhKGksIHQsIGUpIHtcbiAgcmV0dXJuIGkgIT09IDAgPyBsdChpKSA6ICh0LmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh0Lm1pbiA+PSBlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIF9hKGkpIHtcbiAgbGV0IHQsIGUsIHMsIG4sIG87XG4gIHJldHVybiBpLmhvcml6b250YWwgPyAodCA9IGkuYmFzZSA+IGkueCwgZSA9IFwibGVmdFwiLCBzID0gXCJyaWdodFwiKSA6ICh0ID0gaS5iYXNlIDwgaS55LCBlID0gXCJib3R0b21cIiwgcyA9IFwidG9wXCIpLCB0ID8gKG4gPSBcImVuZFwiLCBvID0gXCJzdGFydFwiKSA6IChuID0gXCJzdGFydFwiLCBvID0gXCJlbmRcIiksIHsgc3RhcnQ6IGUsIGVuZDogcywgcmV2ZXJzZTogdCwgdG9wOiBuLCBib3R0b206IG8gfTtcbn1cbmZ1bmN0aW9uIHlhKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSB0LmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB7fTtcbiAgaWYgKCFuKSB7XG4gICAgaS5ib3JkZXJTa2lwcGVkID0gbztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG4gPT09ICEwKSB7XG4gICAgaS5ib3JkZXJTa2lwcGVkID0geyB0b3A6ICEwLCByaWdodDogITAsIGJvdHRvbTogITAsIGxlZnQ6ICEwIH07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgc3RhcnQ6IHIsIGVuZDogYSwgcmV2ZXJzZTogbCwgdG9wOiBjLCBib3R0b206IGggfSA9IF9hKGkpO1xuICBuID09PSBcIm1pZGRsZVwiICYmIGUgJiYgKGkuZW5hYmxlQm9yZGVyUmFkaXVzID0gITAsIChlLl90b3AgfHwgMCkgPT09IHMgPyBuID0gYyA6IChlLl9ib3R0b20gfHwgMCkgPT09IHMgPyBuID0gaCA6IChvW01zKGgsIHIsIGEsIGwpXSA9ICEwLCBuID0gYykpLCBvW01zKG4sIHIsIGEsIGwpXSA9ICEwLCBpLmJvcmRlclNraXBwZWQgPSBvO1xufVxuZnVuY3Rpb24gTXMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gcyA/IChpID0gdmEoaSwgdCwgZSksIGkgPSBrcyhpLCBlLCB0KSkgOiBpID0ga3MoaSwgdCwgZSksIGk7XG59XG5mdW5jdGlvbiB2YShpLCB0LCBlKSB7XG4gIHJldHVybiBpID09PSB0ID8gZSA6IGkgPT09IGUgPyB0IDogaTtcbn1cbmZ1bmN0aW9uIGtzKGksIHQsIGUpIHtcbiAgcmV0dXJuIGkgPT09IFwic3RhcnRcIiA/IHQgOiBpID09PSBcImVuZFwiID8gZSA6IGk7XG59XG5mdW5jdGlvbiBNYShpLCB7IGluZmxhdGVBbW91bnQ6IHQgfSwgZSkge1xuICBpLmluZmxhdGVBbW91bnQgPSB0ID09PSBcImF1dG9cIiA/IGUgPT09IDEgPyAwLjMzIDogMCA6IHQ7XG59XG5jbGFzcyB1ZSBleHRlbmRzIGl0IHtcbiAgcGFyc2VQcmltaXRpdmVEYXRhKHQsIGUsIHMsIG4pIHtcbiAgICByZXR1cm4gdnModCwgZSwgcywgbik7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEodCwgZSwgcywgbikge1xuICAgIHJldHVybiB2cyh0LCBlLCBzLCBuKTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgaVNjYWxlOiBvLCB2U2NhbGU6IHIgfSA9IHQsIHsgeEF4aXNLZXk6IGEgPSBcInhcIiwgeUF4aXNLZXk6IGwgPSBcInlcIiB9ID0gdGhpcy5fcGFyc2luZywgYyA9IG8uYXhpcyA9PT0gXCJ4XCIgPyBhIDogbCwgaCA9IHIuYXhpcyA9PT0gXCJ4XCIgPyBhIDogbCwgZCA9IFtdO1xuICAgIGxldCB1LCBmLCBnLCBwO1xuICAgIGZvciAodSA9IHMsIGYgPSBzICsgbjsgdSA8IGY7ICsrdSlcbiAgICAgIHAgPSBlW3VdLCBnID0ge30sIGdbby5heGlzXSA9IG8ucGFyc2UoX3QocCwgYyksIHUpLCBkLnB1c2goQm4oX3QocCwgaCksIGcsIHIsIHUpKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQodCwgZSwgcywgbikge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZCh0LCBlLCBzLCBuKTtcbiAgICBjb25zdCBvID0gcy5fY3VzdG9tO1xuICAgIG8gJiYgZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUgJiYgKHQubWluID0gTWF0aC5taW4odC5taW4sIG8ubWluKSwgdC5tYXggPSBNYXRoLm1heCh0Lm1heCwgby5tYXgpKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgeyBpU2NhbGU6IHMsIHZTY2FsZTogbiB9ID0gZSwgbyA9IHRoaXMuZ2V0UGFyc2VkKHQpLCByID0gby5fY3VzdG9tLCBhID0gaGkocikgPyBcIltcIiArIHIuc3RhcnQgKyBcIiwgXCIgKyByLmVuZCArIFwiXVwiIDogXCJcIiArIG4uZ2V0TGFiZWxGb3JWYWx1ZShvW24uYXhpc10pO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogXCJcIiArIHMuZ2V0TGFiZWxGb3JWYWx1ZShvW3MuYXhpc10pLFxuICAgICAgdmFsdWU6IGFcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gITAsIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0LnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGUuZGF0YSwgMCwgZS5kYXRhLmxlbmd0aCwgdCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBuID09PSBcInJlc2V0XCIsIHsgaW5kZXg6IHIsIF9jYWNoZWRNZXRhOiB7IHZTY2FsZTogYSB9IH0gPSB0aGlzLCBsID0gYS5nZXRCYXNlUGl4ZWwoKSwgYyA9IGEuaXNIb3Jpem9udGFsKCksIGggPSB0aGlzLl9nZXRSdWxlcigpLCB7IHNoYXJlZE9wdGlvbnM6IGQsIGluY2x1ZGVPcHRpb25zOiB1IH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKGUsIG4pO1xuICAgIGZvciAobGV0IGYgPSBlOyBmIDwgZSArIHM7IGYrKykge1xuICAgICAgY29uc3QgZyA9IHRoaXMuZ2V0UGFyc2VkKGYpLCBwID0gbyB8fCBUKGdbYS5heGlzXSkgPyB7IGJhc2U6IGwsIGhlYWQ6IGwgfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGYpLCBtID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoZiwgaCksIGIgPSAoZy5fc3RhY2tzIHx8IHt9KVthLmF4aXNdLCB4ID0ge1xuICAgICAgICBob3Jpem9udGFsOiBjLFxuICAgICAgICBiYXNlOiBwLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIWIgfHwgaGkoZy5fY3VzdG9tKSB8fCByID09PSBiLl90b3AgfHwgciA9PT0gYi5fYm90dG9tLFxuICAgICAgICB4OiBjID8gcC5oZWFkIDogbS5jZW50ZXIsXG4gICAgICAgIHk6IGMgPyBtLmNlbnRlciA6IHAuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBjID8gbS5zaXplIDogTWF0aC5hYnMocC5zaXplKSxcbiAgICAgICAgd2lkdGg6IGMgPyBNYXRoLmFicyhwLnNpemUpIDogbS5zaXplXG4gICAgICB9O1xuICAgICAgdSAmJiAoeC5vcHRpb25zID0gZCB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZiwgdFtmXS5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbikpO1xuICAgICAgY29uc3QgdiA9IHgub3B0aW9ucyB8fCB0W2ZdLm9wdGlvbnM7XG4gICAgICB5YSh4LCB2LCBiLCByKSwgTWEoeCwgdiwgaC5yYXRpbyksIHRoaXMudXBkYXRlRWxlbWVudCh0W2ZdLCBmLCB4LCBuKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyh0LCBlKSB7XG4gICAgY29uc3QgeyBpU2NhbGU6IHMgfSA9IHRoaXMuX2NhY2hlZE1ldGEsIG4gPSBzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpLmZpbHRlcigobCkgPT4gbC5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCksIG8gPSBzLm9wdGlvbnMuc3RhY2tlZCwgciA9IFtdLCBhID0gKGwpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBsLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGUpLCBoID0gYyAmJiBjW2wudlNjYWxlLmF4aXNdO1xuICAgICAgaWYgKFQoaCkgfHwgaXNOYU4oaCkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbCBvZiBuKVxuICAgICAgaWYgKCEoZSAhPT0gdm9pZCAwICYmIGEobCkpICYmICgobyA9PT0gITEgfHwgci5pbmRleE9mKGwuc3RhY2spID09PSAtMSB8fCBvID09PSB2b2lkIDAgJiYgbC5zdGFjayA9PT0gdm9pZCAwKSAmJiByLnB1c2gobC5zdGFjayksIGwuaW5kZXggPT09IHQpKVxuICAgICAgICBicmVhaztcbiAgICByZXR1cm4gci5sZW5ndGggfHwgci5wdXNoKHZvaWQgMCksIHI7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQodCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3Modm9pZCAwLCB0KS5sZW5ndGg7XG4gIH1cbiAgX2dldFN0YWNrSW5kZXgodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRTdGFja3ModCwgcyksIG8gPSBlICE9PSB2b2lkIDAgPyBuLmluZGV4T2YoZSkgOiAtMTtcbiAgICByZXR1cm4gbyA9PT0gLTEgPyBuLmxlbmd0aCAtIDEgOiBvO1xuICB9XG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgcyA9IGUuaVNjYWxlLCBuID0gW107XG4gICAgbGV0IG8sIHI7XG4gICAgZm9yIChvID0gMCwgciA9IGUuZGF0YS5sZW5ndGg7IG8gPCByOyArK28pXG4gICAgICBuLnB1c2gocy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKG8pW3MuYXhpc10sIG8pKTtcbiAgICBjb25zdCBhID0gdC5iYXJUaGlja25lc3M7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogYSB8fCBnYShlKSxcbiAgICAgIHBpeGVsczogbixcbiAgICAgIHN0YXJ0OiBzLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBzLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBzLFxuICAgICAgZ3JvdXBlZDogdC5ncm91cGVkLFxuICAgICAgcmF0aW86IGEgPyAxIDogdC5jYXRlZ29yeVBlcmNlbnRhZ2UgKiB0LmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyh0KSB7XG4gICAgY29uc3QgeyBfY2FjaGVkTWV0YTogeyB2U2NhbGU6IGUsIF9zdGFja2VkOiBzIH0sIG9wdGlvbnM6IHsgYmFzZTogbiwgbWluQmFyTGVuZ3RoOiBvIH0gfSA9IHRoaXMsIHIgPSBuIHx8IDAsIGEgPSB0aGlzLmdldFBhcnNlZCh0KSwgbCA9IGEuX2N1c3RvbSwgYyA9IGhpKGwpO1xuICAgIGxldCBoID0gYVtlLmF4aXNdLCBkID0gMCwgdSA9IHMgPyB0aGlzLmFwcGx5U3RhY2soZSwgYSwgcykgOiBoLCBmLCBnO1xuICAgIHUgIT09IGggJiYgKGQgPSB1IC0gaCwgdSA9IGgpLCBjICYmIChoID0gbC5iYXJTdGFydCwgdSA9IGwuYmFyRW5kIC0gbC5iYXJTdGFydCwgaCAhPT0gMCAmJiBsdChoKSAhPT0gbHQobC5iYXJFbmQpICYmIChkID0gMCksIGQgKz0gaCk7XG4gICAgY29uc3QgcCA9ICFUKG4pICYmICFjID8gbiA6IGQ7XG4gICAgbGV0IG0gPSBlLmdldFBpeGVsRm9yVmFsdWUocCk7XG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkodCkgPyBmID0gZS5nZXRQaXhlbEZvclZhbHVlKGQgKyB1KSA6IGYgPSBtLCBnID0gZiAtIG0sIE1hdGguYWJzKGcpIDwgbykge1xuICAgICAgZyA9IHhhKGcsIGUsIHIpICogbywgaCA9PT0gciAmJiAobSAtPSBnIC8gMik7XG4gICAgICBjb25zdCBiID0gZS5nZXRQaXhlbEZvckRlY2ltYWwoMCksIHggPSBlLmdldFBpeGVsRm9yRGVjaW1hbCgxKSwgdiA9IE1hdGgubWluKGIsIHgpLCB5ID0gTWF0aC5tYXgoYiwgeCk7XG4gICAgICBtID0gTWF0aC5tYXgoTWF0aC5taW4obSwgeSksIHYpLCBmID0gbSArIGc7XG4gICAgfVxuICAgIGlmIChtID09PSBlLmdldFBpeGVsRm9yVmFsdWUocikpIHtcbiAgICAgIGNvbnN0IGIgPSBsdChnKSAqIGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUocikgLyAyO1xuICAgICAgbSArPSBiLCBnIC09IGI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplOiBnLFxuICAgICAgYmFzZTogbSxcbiAgICAgIGhlYWQ6IGYsXG4gICAgICBjZW50ZXI6IGYgKyBnIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKHQsIGUpIHtcbiAgICBjb25zdCBzID0gZS5zY2FsZSwgbiA9IHRoaXMub3B0aW9ucywgbyA9IG4uc2tpcE51bGwsIHIgPSBDKG4ubWF4QmFyVGhpY2tuZXNzLCAxIC8gMCk7XG4gICAgbGV0IGEsIGw7XG4gICAgaWYgKGUuZ3JvdXBlZCkge1xuICAgICAgY29uc3QgYyA9IG8gPyB0aGlzLl9nZXRTdGFja0NvdW50KHQpIDogZS5zdGFja0NvdW50LCBoID0gbi5iYXJUaGlja25lc3MgPT09IFwiZmxleFwiID8gbWEodCwgZSwgbiwgYykgOiBwYSh0LCBlLCBuLCBjKSwgZCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgbyA/IHQgOiB2b2lkIDApO1xuICAgICAgYSA9IGguc3RhcnQgKyBoLmNodW5rICogZCArIGguY2h1bmsgLyAyLCBsID0gTWF0aC5taW4ociwgaC5jaHVuayAqIGgucmF0aW8pO1xuICAgIH0gZWxzZVxuICAgICAgYSA9IHMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZCh0KVtzLmF4aXNdLCB0KSwgbCA9IE1hdGgubWluKHIsIGUubWluICogZS5yYXRpbyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGEgLSBsIC8gMixcbiAgICAgIGhlYWQ6IGEgKyBsIC8gMixcbiAgICAgIGNlbnRlcjogYSxcbiAgICAgIHNpemU6IGxcbiAgICB9O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGEsIGUgPSB0LnZTY2FsZSwgcyA9IHQuZGF0YSwgbiA9IHMubGVuZ3RoO1xuICAgIGxldCBvID0gMDtcbiAgICBmb3IgKDsgbyA8IG47ICsrbylcbiAgICAgIHRoaXMuZ2V0UGFyc2VkKG8pW2UuYXhpc10gIT09IG51bGwgJiYgc1tvXS5kcmF3KHRoaXMuX2N0eCk7XG4gIH1cbn1cbnVlLmlkID0gXCJiYXJcIjtcbnVlLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwiYmFyXCIsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6ICEwLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IFtcInhcIiwgXCJ5XCIsIFwiYmFzZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdXG4gICAgfVxuICB9XG59O1xudWUub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICBvZmZzZXQ6ICEwLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6ICEwXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgYmVnaW5BdFplcm86ICEwXG4gICAgfVxuICB9XG59O1xuY2xhc3MgZmUgZXh0ZW5kcyBpdCB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gITAsIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEodCwgZSwgcywgbik7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBvLmxlbmd0aDsgcisrKVxuICAgICAgb1tyXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHIgKyBzKS5yYWRpdXM7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgcGFyc2VBcnJheURhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBzdXBlci5wYXJzZUFycmF5RGF0YSh0LCBlLCBzLCBuKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG8ubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSBlW3MgKyByXTtcbiAgICAgIG9bcl0uX2N1c3RvbSA9IEMoYVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHIgKyBzKS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBzdXBlci5wYXJzZU9iamVjdERhdGEodCwgZSwgcywgbik7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBvLmxlbmd0aDsgcisrKSB7XG4gICAgICBjb25zdCBhID0gZVtzICsgcl07XG4gICAgICBvW3JdLl9jdXN0b20gPSBDKGEgJiYgYS5yICYmICthLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhyICsgcykucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IHQubGVuZ3RoIC0gMTsgcyA+PSAwOyAtLXMpXG4gICAgICBlID0gTWF0aC5tYXgoZSwgdFtzXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzKSkgLyAyKTtcbiAgICByZXR1cm4gZSA+IDAgJiYgZTtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgeyB4U2NhbGU6IHMsIHlTY2FsZTogbiB9ID0gZSwgbyA9IHRoaXMuZ2V0UGFyc2VkKHQpLCByID0gcy5nZXRMYWJlbEZvclZhbHVlKG8ueCksIGEgPSBuLmdldExhYmVsRm9yVmFsdWUoby55KSwgbCA9IG8uX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGUubGFiZWwsXG4gICAgICB2YWx1ZTogXCIoXCIgKyByICsgXCIsIFwiICsgYSArIChsID8gXCIsIFwiICsgbCA6IFwiXCIpICsgXCIpXCJcbiAgICB9O1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGUsIDAsIGUubGVuZ3RoLCB0KTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IG4gPT09IFwicmVzZXRcIiwgeyBpU2NhbGU6IHIsIHZTY2FsZTogYSB9ID0gdGhpcy5fY2FjaGVkTWV0YSwgeyBzaGFyZWRPcHRpb25zOiBsLCBpbmNsdWRlT3B0aW9uczogYyB9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKSwgaCA9IHIuYXhpcywgZCA9IGEuYXhpcztcbiAgICBmb3IgKGxldCB1ID0gZTsgdSA8IGUgKyBzOyB1KyspIHtcbiAgICAgIGNvbnN0IGYgPSB0W3VdLCBnID0gIW8gJiYgdGhpcy5nZXRQYXJzZWQodSksIHAgPSB7fSwgbSA9IHBbaF0gPSBvID8gci5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHIuZ2V0UGl4ZWxGb3JWYWx1ZShnW2hdKSwgYiA9IHBbZF0gPSBvID8gYS5nZXRCYXNlUGl4ZWwoKSA6IGEuZ2V0UGl4ZWxGb3JWYWx1ZShnW2RdKTtcbiAgICAgIHAuc2tpcCA9IGlzTmFOKG0pIHx8IGlzTmFOKGIpLCBjICYmIChwLm9wdGlvbnMgPSBsIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh1LCBmLmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSwgbyAmJiAocC5vcHRpb25zLnJhZGl1cyA9IDApKSwgdGhpcy51cGRhdGVFbGVtZW50KGYsIHUsIHAsIG4pO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5nZXRQYXJzZWQodCk7XG4gICAgbGV0IG4gPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQsIGUpO1xuICAgIG4uJHNoYXJlZCAmJiAobiA9IE9iamVjdC5hc3NpZ24oe30sIG4sIHsgJHNoYXJlZDogITEgfSkpO1xuICAgIGNvbnN0IG8gPSBuLnJhZGl1cztcbiAgICByZXR1cm4gZSAhPT0gXCJhY3RpdmVcIiAmJiAobi5yYWRpdXMgPSAwKSwgbi5yYWRpdXMgKz0gQyhzICYmIHMuX2N1c3RvbSwgbyksIG47XG4gIH1cbn1cbmZlLmlkID0gXCJidWJibGVcIjtcbmZlLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwicG9pbnRcIixcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBbXCJ4XCIsIFwieVwiLCBcImJvcmRlcldpZHRoXCIsIFwicmFkaXVzXCJdXG4gICAgfVxuICB9XG59O1xuZmUub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiXG4gICAgfVxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24ga2EoaSwgdCwgZSkge1xuICBsZXQgcyA9IDEsIG4gPSAxLCBvID0gMCwgciA9IDA7XG4gIGlmICh0IDwgRikge1xuICAgIGNvbnN0IGEgPSBpLCBsID0gYSArIHQsIGMgPSBNYXRoLmNvcyhhKSwgaCA9IE1hdGguc2luKGEpLCBkID0gTWF0aC5jb3MobCksIHUgPSBNYXRoLnNpbihsKSwgZiA9ICh2LCB5LCBfKSA9PiBvZSh2LCBhLCBsLCAhMCkgPyAxIDogTWF0aC5tYXgoeSwgeSAqIGUsIF8sIF8gKiBlKSwgZyA9ICh2LCB5LCBfKSA9PiBvZSh2LCBhLCBsLCAhMCkgPyAtMSA6IE1hdGgubWluKHksIHkgKiBlLCBfLCBfICogZSksIHAgPSBmKDAsIGMsIGQpLCBtID0gZihWLCBoLCB1KSwgYiA9IGcoQiwgYywgZCksIHggPSBnKEIgKyBWLCBoLCB1KTtcbiAgICBzID0gKHAgLSBiKSAvIDIsIG4gPSAobSAtIHgpIC8gMiwgbyA9IC0ocCArIGIpIC8gMiwgciA9IC0obSArIHgpIC8gMjtcbiAgfVxuICByZXR1cm4geyByYXRpb1g6IHMsIHJhdGlvWTogbiwgb2Zmc2V0WDogbywgb2Zmc2V0WTogciB9O1xufVxuY2xhc3MgTHQgZXh0ZW5kcyBpdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0LCBlKSwgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gITAsIHRoaXMuaW5uZXJSYWRpdXMgPSB2b2lkIDAsIHRoaXMub3V0ZXJSYWRpdXMgPSB2b2lkIDAsIHRoaXMub2Zmc2V0WCA9IHZvaWQgMCwgdGhpcy5vZmZzZXRZID0gdm9pZCAwO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhLCBuID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gITEpXG4gICAgICBuLl9wYXJzZWQgPSBzO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IG8gPSAobCkgPT4gK3NbbF07XG4gICAgICBpZiAoRChzW3RdKSkge1xuICAgICAgICBjb25zdCB7IGtleTogbCA9IFwidmFsdWVcIiB9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgbyA9IChjKSA9PiArX3Qoc1tjXSwgbCk7XG4gICAgICB9XG4gICAgICBsZXQgciwgYTtcbiAgICAgIGZvciAociA9IHQsIGEgPSB0ICsgZTsgciA8IGE7ICsrcilcbiAgICAgICAgbi5fcGFyc2VkW3JdID0gbyhyKTtcbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiBudCh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIG50KHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCB0ID0gRiwgZSA9IC1GO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytzKVxuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShzKSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShzKS5jb250cm9sbGVyLCBvID0gbi5fZ2V0Um90YXRpb24oKSwgciA9IG4uX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgdCA9IE1hdGgubWluKHQsIG8pLCBlID0gTWF0aC5tYXgoZSwgbyArIHIpO1xuICAgICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogdCxcbiAgICAgIGNpcmN1bWZlcmVuY2U6IGUgLSB0XG4gICAgfTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNoYXJ0LCB7IGNoYXJ0QXJlYTogcyB9ID0gZSwgbiA9IHRoaXMuX2NhY2hlZE1ldGEsIG8gPSBuLmRhdGEsIHIgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChvKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nLCBhID0gTWF0aC5tYXgoKE1hdGgubWluKHMud2lkdGgsIHMuaGVpZ2h0KSAtIHIpIC8gMiwgMCksIGwgPSBNYXRoLm1pbih5byh0aGlzLm9wdGlvbnMuY3V0b3V0LCBhKSwgMSksIGMgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpLCB7IGNpcmN1bWZlcmVuY2U6IGgsIHJvdGF0aW9uOiBkIH0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKSwgeyByYXRpb1g6IHUsIHJhdGlvWTogZiwgb2Zmc2V0WDogZywgb2Zmc2V0WTogcCB9ID0ga2EoZCwgaCwgbCksIG0gPSAocy53aWR0aCAtIHIpIC8gdSwgYiA9IChzLmhlaWdodCAtIHIpIC8gZiwgeCA9IE1hdGgubWF4KE1hdGgubWluKG0sIGIpIC8gMiwgMCksIHYgPSBhbih0aGlzLm9wdGlvbnMucmFkaXVzLCB4KSwgeSA9IE1hdGgubWF4KHYgKiBsLCAwKSwgXyA9ICh2IC0geSkgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gZyAqIHYsIHRoaXMub2Zmc2V0WSA9IHAgKiB2LCBuLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpLCB0aGlzLm91dGVyUmFkaXVzID0gdiAtIF8gKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpLCB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIF8gKiBjLCAwKSwgdGhpcy51cGRhdGVFbGVtZW50cyhvLCAwLCBvLmxlbmd0aCwgdCk7XG4gIH1cbiAgX2NpcmN1bWZlcmVuY2UodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLm9wdGlvbnMsIG4gPSB0aGlzLl9jYWNoZWRNZXRhLCBvID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIHJldHVybiBlICYmIHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkodCkgfHwgbi5fcGFyc2VkW3RdID09PSBudWxsIHx8IG4uZGF0YVt0XS5oaWRkZW4gPyAwIDogdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG4uX3BhcnNlZFt0XSAqIG8gLyBGKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IG4gPT09IFwicmVzZXRcIiwgciA9IHRoaXMuY2hhcnQsIGEgPSByLmNoYXJ0QXJlYSwgYyA9IHIub3B0aW9ucy5hbmltYXRpb24sIGggPSAoYS5sZWZ0ICsgYS5yaWdodCkgLyAyLCBkID0gKGEudG9wICsgYS5ib3R0b20pIC8gMiwgdSA9IG8gJiYgYy5hbmltYXRlU2NhbGUsIGYgPSB1ID8gMCA6IHRoaXMuaW5uZXJSYWRpdXMsIGcgPSB1ID8gMCA6IHRoaXMub3V0ZXJSYWRpdXMsIHsgc2hhcmVkT3B0aW9uczogcCwgaW5jbHVkZU9wdGlvbnM6IG0gfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoZSwgbik7XG4gICAgbGV0IGIgPSB0aGlzLl9nZXRSb3RhdGlvbigpLCB4O1xuICAgIGZvciAoeCA9IDA7IHggPCBlOyArK3gpXG4gICAgICBiICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoeCwgbyk7XG4gICAgZm9yICh4ID0gZTsgeCA8IGUgKyBzOyArK3gpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKHgsIG8pLCB5ID0gdFt4XSwgXyA9IHtcbiAgICAgICAgeDogaCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogZCArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZTogYixcbiAgICAgICAgZW5kQW5nbGU6IGIgKyB2LFxuICAgICAgICBjaXJjdW1mZXJlbmNlOiB2LFxuICAgICAgICBvdXRlclJhZGl1czogZyxcbiAgICAgICAgaW5uZXJSYWRpdXM6IGZcbiAgICAgIH07XG4gICAgICBtICYmIChfLm9wdGlvbnMgPSBwIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh4LCB5LmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSksIGIgKz0gdiwgdGhpcy51cGRhdGVFbGVtZW50KHksIHgsIF8sIG4pO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YSwgZSA9IHQuZGF0YTtcbiAgICBsZXQgcyA9IDAsIG47XG4gICAgZm9yIChuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IG8gPSB0Ll9wYXJzZWRbbl07XG4gICAgICBvICE9PSBudWxsICYmICFpc05hTihvKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KG4pICYmICFlW25dLmhpZGRlbiAmJiAocyArPSBNYXRoLmFicyhvKSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIHJldHVybiBlID4gMCAmJiAhaXNOYU4odCkgPyBGICogKE1hdGguYWJzKHQpIC8gZSkgOiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLCBzID0gdGhpcy5jaGFydCwgbiA9IHMuZGF0YS5sYWJlbHMgfHwgW10sIG8gPSBkZShlLl9wYXJzZWRbdF0sIHMub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogblt0XSB8fCBcIlwiLFxuICAgICAgdmFsdWU6IG9cbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKHQpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgY29uc3QgcyA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IG4sIG8sIHIsIGEsIGw7XG4gICAgaWYgKCF0KSB7XG4gICAgICBmb3IgKG4gPSAwLCBvID0gcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICAgICAgaWYgKHMuaXNEYXRhc2V0VmlzaWJsZShuKSkge1xuICAgICAgICAgIHIgPSBzLmdldERhdGFzZXRNZXRhKG4pLCB0ID0gci5kYXRhLCBhID0gci5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdClcbiAgICAgIHJldHVybiAwO1xuICAgIGZvciAobiA9IDAsIG8gPSB0Lmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICAgIGwgPSBhLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMobiksIGwuYm9yZGVyQWxpZ24gIT09IFwiaW5uZXJcIiAmJiAoZSA9IE1hdGgubWF4KGUsIGwuYm9yZGVyV2lkdGggfHwgMCwgbC5ob3ZlckJvcmRlcldpZHRoIHx8IDApKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXRNYXhPZmZzZXQodCkge1xuICAgIGxldCBlID0gMDtcbiAgICBmb3IgKGxldCBzID0gMCwgbiA9IHQubGVuZ3RoOyBzIDwgbjsgKytzKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHMpO1xuICAgICAgZSA9IE1hdGgubWF4KGUsIG8ub2Zmc2V0IHx8IDAsIG8uaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHQpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0OyArK3MpXG4gICAgICB0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUocykgJiYgKGUgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChzKSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQodCkge1xuICAgIHJldHVybiBNYXRoLm1heChDKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG5MdC5pZCA9IFwiZG91Z2hudXRcIjtcbkx0LmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwiYXJjXCIsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6ICEwLFxuICAgIGFuaW1hdGVTY2FsZTogITFcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBbXCJjaXJjdW1mZXJlbmNlXCIsIFwiZW5kQW5nbGVcIiwgXCJpbm5lclJhZGl1c1wiLCBcIm91dGVyUmFkaXVzXCIsIFwic3RhcnRBbmdsZVwiLCBcInhcIiwgXCJ5XCIsIFwib2Zmc2V0XCIsIFwiYm9yZGVyV2lkdGhcIiwgXCJzcGFjaW5nXCJdXG4gICAgfVxuICB9LFxuICBjdXRvdXQ6IFwiNTAlXCIsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogXCIxMDAlXCIsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogXCJyXCJcbn07XG5MdC5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IChpKSA9PiBpICE9PSBcInNwYWNpbmdcIixcbiAgX2luZGV4YWJsZTogKGkpID0+IGkgIT09IFwic3BhY2luZ1wiXG59O1xuTHQub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGkpIHtcbiAgICAgICAgICBjb25zdCB0ID0gaS5kYXRhO1xuICAgICAgICAgIGlmICh0LmxhYmVscy5sZW5ndGggJiYgdC5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxzOiB7IHBvaW50U3R5bGU6IGUgfSB9ID0gaS5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB0LmxhYmVscy5tYXAoKHMsIG4pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IGkuZ2V0RGF0YXNldE1ldGEoMCkuY29udHJvbGxlci5nZXRTdHlsZShuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBzLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogci5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHIuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiByLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhaS5nZXREYXRhVmlzaWJpbGl0eShuKSxcbiAgICAgICAgICAgICAgICBpbmRleDogblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soaSwgdCwgZSkge1xuICAgICAgICBlLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KHQuaW5kZXgpLCBlLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpKSB7XG4gICAgICAgICAgbGV0IHQgPSBpLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IGUgPSBcIjogXCIgKyBpLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIHJldHVybiB6KHQpID8gKHQgPSB0LnNsaWNlKCksIHRbMF0gKz0gZSkgOiB0ICs9IGUsIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5jbGFzcyBnZSBleHRlbmRzIGl0IHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMCwgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSAhMCwgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHsgZGF0YXNldDogcywgZGF0YTogbiA9IFtdLCBfZGF0YXNldDogbyB9ID0gZSwgciA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQgeyBzdGFydDogYSwgY291bnQ6IGwgfSA9IHBuKGUsIG4sIHIpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IGEsIHRoaXMuX2RyYXdDb3VudCA9IGwsIG1uKGUpICYmIChhID0gMCwgbCA9IG4ubGVuZ3RoKSwgcy5fY2hhcnQgPSB0aGlzLmNoYXJ0LCBzLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4LCBzLl9kZWNpbWF0ZWQgPSAhIW8uX2RlY2ltYXRlZCwgcy5wb2ludHMgPSBuO1xuICAgIGNvbnN0IGMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnModCk7XG4gICAgdGhpcy5vcHRpb25zLnNob3dMaW5lIHx8IChjLmJvcmRlcldpZHRoID0gMCksIGMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50LCB0aGlzLnVwZGF0ZUVsZW1lbnQocywgdm9pZCAwLCB7XG4gICAgICBhbmltYXRlZDogIXIsXG4gICAgICBvcHRpb25zOiBjXG4gICAgfSwgdCksIHRoaXMudXBkYXRlRWxlbWVudHMobiwgYSwgbCwgdCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBuID09PSBcInJlc2V0XCIsIHsgaVNjYWxlOiByLCB2U2NhbGU6IGEsIF9zdGFja2VkOiBsLCBfZGF0YXNldDogYyB9ID0gdGhpcy5fY2FjaGVkTWV0YSwgeyBzaGFyZWRPcHRpb25zOiBoLCBpbmNsdWRlT3B0aW9uczogZCB9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKSwgdSA9IHIuYXhpcywgZiA9IGEuYXhpcywgeyBzcGFuR2FwczogZywgc2VnbWVudDogcCB9ID0gdGhpcy5vcHRpb25zLCBtID0gQnQoZykgPyBnIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBiID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IG8gfHwgbiA9PT0gXCJub25lXCI7XG4gICAgbGV0IHggPSBlID4gMCAmJiB0aGlzLmdldFBhcnNlZChlIC0gMSk7XG4gICAgZm9yIChsZXQgdiA9IGU7IHYgPCBlICsgczsgKyt2KSB7XG4gICAgICBjb25zdCB5ID0gdFt2XSwgXyA9IHRoaXMuZ2V0UGFyc2VkKHYpLCBNID0gYiA/IHkgOiB7fSwgayA9IFQoX1tmXSksIFMgPSBNW3VdID0gci5nZXRQaXhlbEZvclZhbHVlKF9bdV0sIHYpLCB3ID0gTVtmXSA9IG8gfHwgayA/IGEuZ2V0QmFzZVBpeGVsKCkgOiBhLmdldFBpeGVsRm9yVmFsdWUobCA/IHRoaXMuYXBwbHlTdGFjayhhLCBfLCBsKSA6IF9bZl0sIHYpO1xuICAgICAgTS5za2lwID0gaXNOYU4oUykgfHwgaXNOYU4odykgfHwgaywgTS5zdG9wID0gdiA+IDAgJiYgTWF0aC5hYnMoX1t1XSAtIHhbdV0pID4gbSwgcCAmJiAoTS5wYXJzZWQgPSBfLCBNLnJhdyA9IGMuZGF0YVt2XSksIGQgJiYgKE0ub3B0aW9ucyA9IGggfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHYsIHkuYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKSwgYiB8fCB0aGlzLnVwZGF0ZUVsZW1lbnQoeSwgdiwgTSwgbiksIHggPSBfO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YSwgZSA9IHQuZGF0YXNldCwgcyA9IGUub3B0aW9ucyAmJiBlLm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgbiA9IHQuZGF0YSB8fCBbXTtcbiAgICBpZiAoIW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIHM7XG4gICAgY29uc3QgbyA9IG5bMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpLCByID0gbltuLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKG4ubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChzLCBvLCByKSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0LmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgdC5pU2NhbGUuYXhpcyksIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuZ2UuaWQgPSBcImxpbmVcIjtcbmdlLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IFwibGluZVwiLFxuICBkYXRhRWxlbWVudFR5cGU6IFwicG9pbnRcIixcbiAgc2hvd0xpbmU6ICEwLFxuICBzcGFuR2FwczogITFcbn07XG5nZS5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIlxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH1cbiAgfVxufTtcbmNsYXNzIHBlIGV4dGVuZHMgaXQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCwgZSksIHRoaXMuaW5uZXJSYWRpdXMgPSB2b2lkIDAsIHRoaXMub3V0ZXJSYWRpdXMgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHMgPSB0aGlzLmNoYXJ0LCBuID0gcy5kYXRhLmxhYmVscyB8fCBbXSwgbyA9IGRlKGUuX3BhcnNlZFt0XS5yLCBzLm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG5bdF0gfHwgXCJcIixcbiAgICAgIHZhbHVlOiBvXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgIHJldHVybiBEbi5iaW5kKHRoaXMpKHQsIGUsIHMsIG4pO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKSwgdGhpcy51cGRhdGVFbGVtZW50cyhlLCAwLCBlLmxlbmd0aCwgdCk7XG4gIH1cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLCBlID0geyBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgfTtcbiAgICByZXR1cm4gdC5kYXRhLmZvckVhY2goKHMsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmdldFBhcnNlZChuKS5yO1xuICAgICAgIWlzTmFOKG8pICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkobikgJiYgKG8gPCBlLm1pbiAmJiAoZS5taW4gPSBvKSwgbyA+IGUubWF4ICYmIChlLm1heCA9IG8pKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNoYXJ0LCBlID0gdC5jaGFydEFyZWEsIHMgPSB0Lm9wdGlvbnMsIG4gPSBNYXRoLm1pbihlLnJpZ2h0IC0gZS5sZWZ0LCBlLmJvdHRvbSAtIGUudG9wKSwgbyA9IE1hdGgubWF4KG4gLyAyLCAwKSwgciA9IE1hdGgubWF4KHMuY3V0b3V0UGVyY2VudGFnZSA/IG8gLyAxMDAgKiBzLmN1dG91dFBlcmNlbnRhZ2UgOiAxLCAwKSwgYSA9IChvIC0gcikgLyB0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gbyAtIGEgKiB0aGlzLmluZGV4LCB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIGE7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBuID09PSBcInJlc2V0XCIsIHIgPSB0aGlzLmNoYXJ0LCBsID0gci5vcHRpb25zLmFuaW1hdGlvbiwgYyA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlLCBoID0gYy54Q2VudGVyLCBkID0gYy55Q2VudGVyLCB1ID0gYy5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogQjtcbiAgICBsZXQgZiA9IHUsIGc7XG4gICAgY29uc3QgcCA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGcgPSAwOyBnIDwgZTsgKytnKVxuICAgICAgZiArPSB0aGlzLl9jb21wdXRlQW5nbGUoZywgbiwgcCk7XG4gICAgZm9yIChnID0gZTsgZyA8IGUgKyBzOyBnKyspIHtcbiAgICAgIGNvbnN0IG0gPSB0W2ddO1xuICAgICAgbGV0IGIgPSBmLCB4ID0gZiArIHRoaXMuX2NvbXB1dGVBbmdsZShnLCBuLCBwKSwgdiA9IHIuZ2V0RGF0YVZpc2liaWxpdHkoZykgPyBjLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGcpLnIpIDogMDtcbiAgICAgIGYgPSB4LCBvICYmIChsLmFuaW1hdGVTY2FsZSAmJiAodiA9IDApLCBsLmFuaW1hdGVSb3RhdGUgJiYgKGIgPSB4ID0gdSkpO1xuICAgICAgY29uc3QgeSA9IHtcbiAgICAgICAgeDogaCxcbiAgICAgICAgeTogZCxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzOiB2LFxuICAgICAgICBzdGFydEFuZ2xlOiBiLFxuICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGcsIG0uYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KG0sIGcsIHksIG4pO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgZSA9IDA7XG4gICAgcmV0dXJuIHQuZGF0YS5mb3JFYWNoKChzLCBuKSA9PiB7XG4gICAgICAhaXNOYU4odGhpcy5nZXRQYXJzZWQobikucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShuKSAmJiBlKys7XG4gICAgfSksIGU7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZSh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkodCkgPyBudCh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSkuYW5nbGUgfHwgcykgOiAwO1xuICB9XG59XG5wZS5pZCA9IFwicG9sYXJBcmVhXCI7XG5wZS5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiBcImFyY1wiLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiAhMCxcbiAgICBhbmltYXRlU2NhbGU6ICEwXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgcHJvcGVydGllczogW1wieFwiLCBcInlcIiwgXCJzdGFydEFuZ2xlXCIsIFwiZW5kQW5nbGVcIiwgXCJpbm5lclJhZGl1c1wiLCBcIm91dGVyUmFkaXVzXCJdXG4gICAgfVxuICB9LFxuICBpbmRleEF4aXM6IFwiclwiLFxuICBzdGFydEFuZ2xlOiAwXG59O1xucGUub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGkpIHtcbiAgICAgICAgICBjb25zdCB0ID0gaS5kYXRhO1xuICAgICAgICAgIGlmICh0LmxhYmVscy5sZW5ndGggJiYgdC5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxzOiB7IHBvaW50U3R5bGU6IGUgfSB9ID0gaS5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB0LmxhYmVscy5tYXAoKHMsIG4pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IGkuZ2V0RGF0YXNldE1ldGEoMCkuY29udHJvbGxlci5nZXRTdHlsZShuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBzLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogci5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHIuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiByLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhaS5nZXREYXRhVmlzaWJpbGl0eShuKSxcbiAgICAgICAgICAgICAgICBpbmRleDogblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soaSwgdCwgZSkge1xuICAgICAgICBlLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KHQuaW5kZXgpLCBlLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpKSB7XG4gICAgICAgICAgcmV0dXJuIGkuY2hhcnQuZGF0YS5sYWJlbHNbaS5kYXRhSW5kZXhdICsgXCI6IFwiICsgaS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogXCJyYWRpYWxMaW5lYXJcIixcbiAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgZGlzcGxheTogITFcbiAgICAgIH0sXG4gICAgICBiZWdpbkF0WmVybzogITAsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiAhMFxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6ICExXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcbmNsYXNzIHFlIGV4dGVuZHMgTHQge1xufVxucWUuaWQgPSBcInBpZVwiO1xucWUuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiBcIjEwMCVcIlxufTtcbmNsYXNzIG1lIGV4dGVuZHMgaXQge1xuICBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUsIHMgPSB0aGlzLmdldFBhcnNlZCh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGUuZ2V0TGFiZWxzKClbdF0sXG4gICAgICB2YWx1ZTogXCJcIiArIGUuZ2V0TGFiZWxGb3JWYWx1ZShzW2UuYXhpc10pXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgIHJldHVybiBEbi5iaW5kKHRoaXMpKHQsIGUsIHMsIG4pO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHMgPSBlLmRhdGFzZXQsIG4gPSBlLmRhdGEgfHwgW10sIG8gPSBlLmlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBpZiAocy5wb2ludHMgPSBuLCB0ICE9PSBcInJlc2l6ZVwiKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHQpO1xuICAgICAgdGhpcy5vcHRpb25zLnNob3dMaW5lIHx8IChyLmJvcmRlcldpZHRoID0gMCk7XG4gICAgICBjb25zdCBhID0ge1xuICAgICAgICBfbG9vcDogITAsXG4gICAgICAgIF9mdWxsTG9vcDogby5sZW5ndGggPT09IG4ubGVuZ3RoLFxuICAgICAgICBvcHRpb25zOiByXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHMsIHZvaWQgMCwgYSwgdCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobiwgMCwgbi5sZW5ndGgsIHQpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGUsIHIgPSBuID09PSBcInJlc2V0XCI7XG4gICAgZm9yIChsZXQgYSA9IGU7IGEgPCBlICsgczsgYSsrKSB7XG4gICAgICBjb25zdCBsID0gdFthXSwgYyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhLCBsLmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSwgaCA9IG8uZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGEsIHRoaXMuZ2V0UGFyc2VkKGEpLnIpLCBkID0gciA/IG8ueENlbnRlciA6IGgueCwgdSA9IHIgPyBvLnlDZW50ZXIgOiBoLnksIGYgPSB7XG4gICAgICAgIHg6IGQsXG4gICAgICAgIHk6IHUsXG4gICAgICAgIGFuZ2xlOiBoLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTihkKSB8fCBpc05hTih1KSxcbiAgICAgICAgb3B0aW9uczogY1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsLCBhLCBmLCBuKTtcbiAgICB9XG4gIH1cbn1cbm1lLmlkID0gXCJyYWRhclwiO1xubWUuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogXCJsaW5lXCIsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJwb2ludFwiLFxuICBpbmRleEF4aXM6IFwiclwiLFxuICBzaG93TGluZTogITAsXG4gIGVsZW1lbnRzOiB7XG4gICAgbGluZToge1xuICAgICAgZmlsbDogXCJzdGFydFwiXG4gICAgfVxuICB9XG59O1xubWUub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogXCJyYWRpYWxMaW5lYXJcIlxuICAgIH1cbiAgfVxufTtcbmNsYXNzIHN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54ID0gdm9pZCAwLCB0aGlzLnkgPSB2b2lkIDAsIHRoaXMuYWN0aXZlID0gITEsIHRoaXMub3B0aW9ucyA9IHZvaWQgMCwgdGhpcy4kYW5pbWF0aW9ucyA9IHZvaWQgMDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odCkge1xuICAgIGNvbnN0IHsgeDogZSwgeTogcyB9ID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiXSwgdCk7XG4gICAgcmV0dXJuIHsgeDogZSwgeTogcyB9O1xuICB9XG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBCdCh0aGlzLngpICYmIEJ0KHRoaXMueSk7XG4gIH1cbiAgZ2V0UHJvcHModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZSB8fCAhcylcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBuW29dID0gc1tvXSAmJiBzW29dLmFjdGl2ZSgpID8gc1tvXS5fdG8gOiB0aGlzW29dO1xuICAgIH0pLCBuO1xuICB9XG59XG5zdC5kZWZhdWx0cyA9IHt9O1xuc3QuZGVmYXVsdFJvdXRlcyA9IHZvaWQgMDtcbmNvbnN0IFZuID0ge1xuICB2YWx1ZXMoaSkge1xuICAgIHJldHVybiB6KGkpID8gaSA6IFwiXCIgKyBpO1xuICB9LFxuICBudW1lcmljKGksIHQsIGUpIHtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICBjb25zdCBzID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbiwgbyA9IGk7XG4gICAgaWYgKGUubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgYyA9IE1hdGgubWF4KE1hdGguYWJzKGVbMF0udmFsdWUpLCBNYXRoLmFicyhlW2UubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIChjIDwgMWUtNCB8fCBjID4gMWUxNSkgJiYgKG4gPSBcInNjaWVudGlmaWNcIiksIG8gPSB3YShpLCBlKTtcbiAgICB9XG4gICAgY29uc3QgciA9IHR0KE1hdGguYWJzKG8pKSwgYSA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihyKSwgMjApLCAwKSwgbCA9IHsgbm90YXRpb246IG4sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogYSwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBhIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obCwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCksIGRlKGksIHMsIGwpO1xuICB9LFxuICBsb2dhcml0aG1pYyhpLCB0LCBlKSB7XG4gICAgaWYgKGkgPT09IDApXG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgY29uc3QgcyA9IGkgLyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcih0dChpKSkpO1xuICAgIHJldHVybiBzID09PSAxIHx8IHMgPT09IDIgfHwgcyA9PT0gNSA/IFZuLm51bWVyaWMuY2FsbCh0aGlzLCBpLCB0LCBlKSA6IFwiXCI7XG4gIH1cbn07XG5mdW5jdGlvbiB3YShpLCB0KSB7XG4gIGxldCBlID0gdC5sZW5ndGggPiAzID8gdFsyXS52YWx1ZSAtIHRbMV0udmFsdWUgOiB0WzFdLnZhbHVlIC0gdFswXS52YWx1ZTtcbiAgcmV0dXJuIE1hdGguYWJzKGUpID49IDEgJiYgaSAhPT0gTWF0aC5mbG9vcihpKSAmJiAoZSA9IGkgLSBNYXRoLmZsb29yKGkpKSwgZTtcbn1cbnZhciBiZSA9IHsgZm9ybWF0dGVyczogVm4gfTtcbk8uc2V0KFwic2NhbGVcIiwge1xuICBkaXNwbGF5OiAhMCxcbiAgb2Zmc2V0OiAhMSxcbiAgcmV2ZXJzZTogITEsXG4gIGJlZ2luQXRaZXJvOiAhMSxcbiAgYm91bmRzOiBcInRpY2tzXCIsXG4gIGdyYWNlOiAwLFxuICBncmlkOiB7XG4gICAgZGlzcGxheTogITAsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6ICEwLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogITAsXG4gICAgZHJhd1RpY2tzOiAhMCxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKGksIHQpID0+IHQubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKGksIHQpID0+IHQuY29sb3IsXG4gICAgb2Zmc2V0OiAhMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogITEsXG4gICAgdGV4dDogXCJcIixcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogITEsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogXCJcIixcbiAgICBwYWRkaW5nOiAzLFxuICAgIGRpc3BsYXk6ICEwLFxuICAgIGF1dG9Ta2lwOiAhMCxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IGJlLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgY3Jvc3NBbGlnbjogXCJuZWFyXCIsXG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6ICExLFxuICAgIGJhY2tkcm9wQ29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KVwiLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMlxuICB9XG59KTtcbk8ucm91dGUoXCJzY2FsZS50aWNrc1wiLCBcImNvbG9yXCIsIFwiXCIsIFwiY29sb3JcIik7XG5PLnJvdXRlKFwic2NhbGUuZ3JpZFwiLCBcImNvbG9yXCIsIFwiXCIsIFwiYm9yZGVyQ29sb3JcIik7XG5PLnJvdXRlKFwic2NhbGUuZ3JpZFwiLCBcImJvcmRlckNvbG9yXCIsIFwiXCIsIFwiYm9yZGVyQ29sb3JcIik7XG5PLnJvdXRlKFwic2NhbGUudGl0bGVcIiwgXCJjb2xvclwiLCBcIlwiLCBcImNvbG9yXCIpO1xuTy5kZXNjcmliZShcInNjYWxlXCIsIHtcbiAgX2ZhbGxiYWNrOiAhMSxcbiAgX3NjcmlwdGFibGU6IChpKSA9PiAhaS5zdGFydHNXaXRoKFwiYmVmb3JlXCIpICYmICFpLnN0YXJ0c1dpdGgoXCJhZnRlclwiKSAmJiBpICE9PSBcImNhbGxiYWNrXCIgJiYgaSAhPT0gXCJwYXJzZXJcIixcbiAgX2luZGV4YWJsZTogKGkpID0+IGkgIT09IFwiYm9yZGVyRGFzaFwiICYmIGkgIT09IFwidGlja0JvcmRlckRhc2hcIlxufSk7XG5PLmRlc2NyaWJlKFwic2NhbGVzXCIsIHtcbiAgX2ZhbGxiYWNrOiBcInNjYWxlXCJcbn0pO1xuTy5kZXNjcmliZShcInNjYWxlLnRpY2tzXCIsIHtcbiAgX3NjcmlwdGFibGU6IChpKSA9PiBpICE9PSBcImJhY2tkcm9wUGFkZGluZ1wiICYmIGkgIT09IFwiY2FsbGJhY2tcIixcbiAgX2luZGV4YWJsZTogKGkpID0+IGkgIT09IFwiYmFja2Ryb3BQYWRkaW5nXCJcbn0pO1xuZnVuY3Rpb24gU2EoaSwgdCkge1xuICBjb25zdCBlID0gaS5vcHRpb25zLnRpY2tzLCBzID0gZS5tYXhUaWNrc0xpbWl0IHx8IFBhKGkpLCBuID0gZS5tYWpvci5lbmFibGVkID8gRGEodCkgOiBbXSwgbyA9IG4ubGVuZ3RoLCByID0gblswXSwgYSA9IG5bbyAtIDFdLCBsID0gW107XG4gIGlmIChvID4gcylcbiAgICByZXR1cm4gT2EodCwgbCwgbiwgbyAvIHMpLCBsO1xuICBjb25zdCBjID0gQ2EobiwgdCwgcyk7XG4gIGlmIChvID4gMCkge1xuICAgIGxldCBoLCBkO1xuICAgIGNvbnN0IHUgPSBvID4gMSA/IE1hdGgucm91bmQoKGEgLSByKSAvIChvIC0gMSkpIDogbnVsbDtcbiAgICBmb3IgKE9lKHQsIGwsIGMsIFQodSkgPyAwIDogciAtIHUsIHIpLCBoID0gMCwgZCA9IG8gLSAxOyBoIDwgZDsgaCsrKVxuICAgICAgT2UodCwgbCwgYywgbltoXSwgbltoICsgMV0pO1xuICAgIHJldHVybiBPZSh0LCBsLCBjLCBhLCBUKHUpID8gdC5sZW5ndGggOiBhICsgdSksIGw7XG4gIH1cbiAgcmV0dXJuIE9lKHQsIGwsIGMpLCBsO1xufVxuZnVuY3Rpb24gUGEoaSkge1xuICBjb25zdCB0ID0gaS5vcHRpb25zLm9mZnNldCwgZSA9IGkuX3RpY2tTaXplKCksIHMgPSBpLl9sZW5ndGggLyBlICsgKHQgPyAwIDogMSksIG4gPSBpLl9tYXhMZW5ndGggLyBlO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihzLCBuKSk7XG59XG5mdW5jdGlvbiBDYShpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBBYShpKSwgbiA9IHQubGVuZ3RoIC8gZTtcbiAgaWYgKCFzKVxuICAgIHJldHVybiBNYXRoLm1heChuLCAxKTtcbiAgY29uc3QgbyA9IERvKHMpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoIC0gMTsgciA8IGE7IHIrKykge1xuICAgIGNvbnN0IGwgPSBvW3JdO1xuICAgIGlmIChsID4gbilcbiAgICAgIHJldHVybiBsO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChuLCAxKTtcbn1cbmZ1bmN0aW9uIERhKGkpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBsZXQgZSwgcztcbiAgZm9yIChlID0gMCwgcyA9IGkubGVuZ3RoOyBlIDwgczsgZSsrKVxuICAgIGlbZV0ubWFqb3IgJiYgdC5wdXNoKGUpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIE9hKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSAwLCBvID0gZVswXSwgcjtcbiAgZm9yIChzID0gTWF0aC5jZWlsKHMpLCByID0gMDsgciA8IGkubGVuZ3RoOyByKyspXG4gICAgciA9PT0gbyAmJiAodC5wdXNoKGlbcl0pLCBuKyssIG8gPSBlW24gKiBzXSk7XG59XG5mdW5jdGlvbiBPZShpLCB0LCBlLCBzLCBuKSB7XG4gIGNvbnN0IG8gPSBDKHMsIDApLCByID0gTWF0aC5taW4oQyhuLCBpLmxlbmd0aCksIGkubGVuZ3RoKTtcbiAgbGV0IGEgPSAwLCBsLCBjLCBoO1xuICBmb3IgKGUgPSBNYXRoLmNlaWwoZSksIG4gJiYgKGwgPSBuIC0gcywgZSA9IGwgLyBNYXRoLmZsb29yKGwgLyBlKSksIGggPSBvOyBoIDwgMDsgKVxuICAgIGErKywgaCA9IE1hdGgucm91bmQobyArIGEgKiBlKTtcbiAgZm9yIChjID0gTWF0aC5tYXgobywgMCk7IGMgPCByOyBjKyspXG4gICAgYyA9PT0gaCAmJiAodC5wdXNoKGlbY10pLCBhKyssIGggPSBNYXRoLnJvdW5kKG8gKyBhICogZSkpO1xufVxuZnVuY3Rpb24gQWEoaSkge1xuICBjb25zdCB0ID0gaS5sZW5ndGg7XG4gIGxldCBlLCBzO1xuICBpZiAodCA8IDIpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKHMgPSBpWzBdLCBlID0gMTsgZSA8IHQ7ICsrZSlcbiAgICBpZiAoaVtlXSAtIGlbZSAtIDFdICE9PSBzKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gcztcbn1cbmNvbnN0IFRhID0gKGkpID0+IGkgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogaSA9PT0gXCJyaWdodFwiID8gXCJsZWZ0XCIgOiBpLCB3cyA9IChpLCB0LCBlKSA9PiB0ID09PSBcInRvcFwiIHx8IHQgPT09IFwibGVmdFwiID8gaVt0XSArIGUgOiBpW3RdIC0gZTtcbmZ1bmN0aW9uIFNzKGksIHQpIHtcbiAgY29uc3QgZSA9IFtdLCBzID0gaS5sZW5ndGggLyB0LCBuID0gaS5sZW5ndGg7XG4gIGxldCBvID0gMDtcbiAgZm9yICg7IG8gPCBuOyBvICs9IHMpXG4gICAgZS5wdXNoKGlbTWF0aC5mbG9vcihvKV0pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIExhKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkudGlja3MubGVuZ3RoLCBuID0gTWF0aC5taW4odCwgcyAtIDEpLCBvID0gaS5fc3RhcnRQaXhlbCwgciA9IGkuX2VuZFBpeGVsLCBhID0gMWUtNjtcbiAgbGV0IGwgPSBpLmdldFBpeGVsRm9yVGljayhuKSwgYztcbiAgaWYgKCEoZSAmJiAocyA9PT0gMSA/IGMgPSBNYXRoLm1heChsIC0gbywgciAtIGwpIDogdCA9PT0gMCA/IGMgPSAoaS5nZXRQaXhlbEZvclRpY2soMSkgLSBsKSAvIDIgOiBjID0gKGwgLSBpLmdldFBpeGVsRm9yVGljayhuIC0gMSkpIC8gMiwgbCArPSBuIDwgdCA/IGMgOiAtYywgbCA8IG8gLSBhIHx8IGwgPiByICsgYSkpKVxuICAgIHJldHVybiBsO1xufVxuZnVuY3Rpb24gUmEoaSwgdCkge1xuICBFKGksIChlKSA9PiB7XG4gICAgY29uc3QgcyA9IGUuZ2MsIG4gPSBzLmxlbmd0aCAvIDI7XG4gICAgbGV0IG87XG4gICAgaWYgKG4gPiB0KSB7XG4gICAgICBmb3IgKG8gPSAwOyBvIDwgbjsgKytvKVxuICAgICAgICBkZWxldGUgZS5kYXRhW3Nbb11dO1xuICAgICAgcy5zcGxpY2UoMCwgbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFh0KGkpIHtcbiAgcmV0dXJuIGkuZHJhd1RpY2tzID8gaS50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIFBzKGksIHQpIHtcbiAgaWYgKCFpLmRpc3BsYXkpXG4gICAgcmV0dXJuIDA7XG4gIGNvbnN0IGUgPSAkKGkuZm9udCwgdCksIHMgPSBLKGkucGFkZGluZyk7XG4gIHJldHVybiAoeihpLnRleHQpID8gaS50ZXh0Lmxlbmd0aCA6IDEpICogZS5saW5lSGVpZ2h0ICsgcy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBFYShpLCB0KSB7XG4gIHJldHVybiB2dChpLCB7XG4gICAgc2NhbGU6IHQsXG4gICAgdHlwZTogXCJzY2FsZVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gRmEoaSwgdCwgZSkge1xuICByZXR1cm4gdnQoaSwge1xuICAgIHRpY2s6IGUsXG4gICAgaW5kZXg6IHQsXG4gICAgdHlwZTogXCJ0aWNrXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBJYShpLCB0LCBlKSB7XG4gIGxldCBzID0gTGkoaSk7XG4gIHJldHVybiAoZSAmJiB0ICE9PSBcInJpZ2h0XCIgfHwgIWUgJiYgdCA9PT0gXCJyaWdodFwiKSAmJiAocyA9IFRhKHMpKSwgcztcbn1cbmZ1bmN0aW9uIHphKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyB0b3A6IG4sIGxlZnQ6IG8sIGJvdHRvbTogciwgcmlnaHQ6IGEsIGNoYXJ0OiBsIH0gPSBpLCB7IGNoYXJ0QXJlYTogYywgc2NhbGVzOiBoIH0gPSBsO1xuICBsZXQgZCA9IDAsIHUsIGYsIGc7XG4gIGNvbnN0IHAgPSByIC0gbiwgbSA9IGEgLSBvO1xuICBpZiAoaS5pc0hvcml6b250YWwoKSkge1xuICAgIGlmIChmID0gVShzLCBvLCBhKSwgRChlKSkge1xuICAgICAgY29uc3QgYiA9IE9iamVjdC5rZXlzKGUpWzBdLCB4ID0gZVtiXTtcbiAgICAgIGcgPSBoW2JdLmdldFBpeGVsRm9yVmFsdWUoeCkgKyBwIC0gdDtcbiAgICB9IGVsc2VcbiAgICAgIGUgPT09IFwiY2VudGVyXCIgPyBnID0gKGMuYm90dG9tICsgYy50b3ApIC8gMiArIHAgLSB0IDogZyA9IHdzKGksIGUsIHQpO1xuICAgIHUgPSBhIC0gbztcbiAgfSBlbHNlIHtcbiAgICBpZiAoRChlKSkge1xuICAgICAgY29uc3QgYiA9IE9iamVjdC5rZXlzKGUpWzBdLCB4ID0gZVtiXTtcbiAgICAgIGYgPSBoW2JdLmdldFBpeGVsRm9yVmFsdWUoeCkgLSBtICsgdDtcbiAgICB9IGVsc2VcbiAgICAgIGUgPT09IFwiY2VudGVyXCIgPyBmID0gKGMubGVmdCArIGMucmlnaHQpIC8gMiAtIG0gKyB0IDogZiA9IHdzKGksIGUsIHQpO1xuICAgIGcgPSBVKHMsIHIsIG4pLCBkID0gZSA9PT0gXCJsZWZ0XCIgPyAtViA6IFY7XG4gIH1cbiAgcmV0dXJuIHsgdGl0bGVYOiBmLCB0aXRsZVk6IGcsIG1heFdpZHRoOiB1LCByb3RhdGlvbjogZCB9O1xufVxuY2xhc3MgTXQgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlkID0gdC5pZCwgdGhpcy50eXBlID0gdC50eXBlLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuY3R4ID0gdC5jdHgsIHRoaXMuY2hhcnQgPSB0LmNoYXJ0LCB0aGlzLnRvcCA9IHZvaWQgMCwgdGhpcy5ib3R0b20gPSB2b2lkIDAsIHRoaXMubGVmdCA9IHZvaWQgMCwgdGhpcy5yaWdodCA9IHZvaWQgMCwgdGhpcy53aWR0aCA9IHZvaWQgMCwgdGhpcy5oZWlnaHQgPSB2b2lkIDAsIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCB0aGlzLm1heFdpZHRoID0gdm9pZCAwLCB0aGlzLm1heEhlaWdodCA9IHZvaWQgMCwgdGhpcy5wYWRkaW5nVG9wID0gdm9pZCAwLCB0aGlzLnBhZGRpbmdCb3R0b20gPSB2b2lkIDAsIHRoaXMucGFkZGluZ0xlZnQgPSB2b2lkIDAsIHRoaXMucGFkZGluZ1JpZ2h0ID0gdm9pZCAwLCB0aGlzLmF4aXMgPSB2b2lkIDAsIHRoaXMubGFiZWxSb3RhdGlvbiA9IHZvaWQgMCwgdGhpcy5taW4gPSB2b2lkIDAsIHRoaXMubWF4ID0gdm9pZCAwLCB0aGlzLl9yYW5nZSA9IHZvaWQgMCwgdGhpcy50aWNrcyA9IFtdLCB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbCwgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGwsIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsLCB0aGlzLl9sZW5ndGggPSAwLCB0aGlzLl9tYXhMZW5ndGggPSAwLCB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge30sIHRoaXMuX3N0YXJ0UGl4ZWwgPSB2b2lkIDAsIHRoaXMuX2VuZFBpeGVsID0gdm9pZCAwLCB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gITEsIHRoaXMuX3VzZXJNYXggPSB2b2lkIDAsIHRoaXMuX3VzZXJNaW4gPSB2b2lkIDAsIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHZvaWQgMCwgdGhpcy5fc3VnZ2VzdGVkTWluID0gdm9pZCAwLCB0aGlzLl90aWNrc0xlbmd0aCA9IDAsIHRoaXMuX2JvcmRlclZhbHVlID0gMCwgdGhpcy5fY2FjaGUgPSB7fSwgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9ICExLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwO1xuICB9XG4gIGluaXQodCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksIHRoaXMuYXhpcyA9IHQuYXhpcywgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2UodC5taW4pLCB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZSh0Lm1heCksIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2UodC5zdWdnZXN0ZWRNaW4pLCB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKHQuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZSh0LCBlKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQgeyBfdXNlck1pbjogdCwgX3VzZXJNYXg6IGUsIF9zdWdnZXN0ZWRNaW46IHMsIF9zdWdnZXN0ZWRNYXg6IG4gfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPSBRKHQsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSksIGUgPSBRKGUsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSksIHMgPSBRKHMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSksIG4gPSBRKG4sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSksIHtcbiAgICAgIG1pbjogUSh0LCBzKSxcbiAgICAgIG1heDogUShlLCBuKSxcbiAgICAgIG1pbkRlZmluZWQ6IE4odCksXG4gICAgICBtYXhEZWZpbmVkOiBOKGUpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgodCkge1xuICAgIGxldCB7IG1pbjogZSwgbWF4OiBzLCBtaW5EZWZpbmVkOiBuLCBtYXhEZWZpbmVkOiBvIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKSwgcjtcbiAgICBpZiAobiAmJiBvKVxuICAgICAgcmV0dXJuIHsgbWluOiBlLCBtYXg6IHMgfTtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGwgPSAwLCBjID0gYS5sZW5ndGg7IGwgPCBjOyArK2wpXG4gICAgICByID0gYVtsXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCB0KSwgbiB8fCAoZSA9IE1hdGgubWluKGUsIHIubWluKSksIG8gfHwgKHMgPSBNYXRoLm1heChzLCByLm1heCkpO1xuICAgIHJldHVybiBlID0gbyAmJiBlID4gcyA/IHMgOiBlLCBzID0gbiAmJiBlID4gcyA/IGUgOiBzLCB7XG4gICAgICBtaW46IFEoZSwgUShzLCBlKSksXG4gICAgICBtYXg6IFEocywgUShlLCBzKSlcbiAgICB9O1xuICB9XG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdC54TGFiZWxzIDogdC55TGFiZWxzKSB8fCB0LmxhYmVscyB8fCBbXTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fSwgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9ICExO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgdXBkYXRlKHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IGJlZ2luQXRaZXJvOiBuLCBncmFjZTogbywgdGlja3M6IHIgfSA9IHRoaXMub3B0aW9ucywgYSA9IHIuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpLCB0aGlzLm1heFdpZHRoID0gdCwgdGhpcy5tYXhIZWlnaHQgPSBlLCB0aGlzLl9tYXJnaW5zID0gcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgcyksIHRoaXMudGlja3MgPSBudWxsLCB0aGlzLl9sYWJlbFNpemVzID0gbnVsbCwgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGwsIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsLCB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKSwgdGhpcy5zZXREaW1lbnNpb25zKCksIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCksIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoICsgcy5sZWZ0ICsgcy5yaWdodCA6IHRoaXMuaGVpZ2h0ICsgcy50b3AgKyBzLmJvdHRvbSwgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCB8fCAodGhpcy5iZWZvcmVEYXRhTGltaXRzKCksIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpLCB0aGlzLmFmdGVyRGF0YUxpbWl0cygpLCB0aGlzLl9yYW5nZSA9IG1yKHRoaXMsIG8sIG4pLCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gITApLCB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKSwgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdLCB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgIGNvbnN0IGwgPSBhIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMobCA/IFNzKHRoaXMudGlja3MsIGEpIDogdGhpcy50aWNrcyksIHRoaXMuY29uZmlndXJlKCksIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpLCB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSwgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSwgci5kaXNwbGF5ICYmIChyLmF1dG9Ta2lwIHx8IHIuc291cmNlID09PSBcImF1dG9cIikgJiYgKHRoaXMudGlja3MgPSBTYSh0aGlzLCB0aGlzLnRpY2tzKSwgdGhpcy5fbGFiZWxTaXplcyA9IG51bGwsIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpKSwgbCAmJiB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKSwgdGhpcy5iZWZvcmVGaXQoKSwgdGhpcy5maXQoKSwgdGhpcy5hZnRlckZpdCgpLCB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCB0ID0gdGhpcy5vcHRpb25zLnJldmVyc2UsIGUsIHM7XG4gICAgdGhpcy5pc0hvcml6b250YWwoKSA/IChlID0gdGhpcy5sZWZ0LCBzID0gdGhpcy5yaWdodCkgOiAoZSA9IHRoaXMudG9wLCBzID0gdGhpcy5ib3R0b20sIHQgPSAhdCksIHRoaXMuX3N0YXJ0UGl4ZWwgPSBlLCB0aGlzLl9lbmRQaXhlbCA9IHMsIHRoaXMuX3JldmVyc2VQaXhlbHMgPSB0LCB0aGlzLl9sZW5ndGggPSBzIC0gZSwgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIEkodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAodGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGgsIHRoaXMubGVmdCA9IDAsIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoKSA6ICh0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0LCB0aGlzLnRvcCA9IDAsIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQpLCB0aGlzLnBhZGRpbmdMZWZ0ID0gMCwgdGhpcy5wYWRkaW5nVG9wID0gMCwgdGhpcy5wYWRkaW5nUmlnaHQgPSAwLCB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgX2NhbGxIb29rcyh0KSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKHQsIHRoaXMuZ2V0Q29udGV4dCgpKSwgSSh0aGlzLm9wdGlvbnNbdF0sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoXCJiZWZvcmVEYXRhTGltaXRzXCIpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gIH1cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcyhcImFmdGVyRGF0YUxpbWl0c1wiKTtcbiAgfVxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcyhcImJlZm9yZUJ1aWxkVGlja3NcIik7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcyhcImFmdGVyQnVpbGRUaWNrc1wiKTtcbiAgfVxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgcywgbiwgbztcbiAgICBmb3IgKHMgPSAwLCBuID0gdC5sZW5ndGg7IHMgPCBuOyBzKyspXG4gICAgICBvID0gdFtzXSwgby5sYWJlbCA9IEkoZS5jYWxsYmFjaywgW28udmFsdWUsIHMsIHRdLCB0aGlzKTtcbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLCBlID0gdC50aWNrcywgcyA9IHRoaXMudGlja3MubGVuZ3RoLCBuID0gZS5taW5Sb3RhdGlvbiB8fCAwLCBvID0gZS5tYXhSb3RhdGlvbjtcbiAgICBsZXQgciA9IG4sIGEsIGwsIGM7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZS5kaXNwbGF5IHx8IG4gPj0gbyB8fCBzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG47XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGggPSB0aGlzLl9nZXRMYWJlbFNpemVzKCksIGQgPSBoLndpZGVzdC53aWR0aCwgdSA9IGguaGlnaGVzdC5oZWlnaHQsIGYgPSBZKHRoaXMuY2hhcnQud2lkdGggLSBkLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICBhID0gdC5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gcyA6IGYgLyAocyAtIDEpLCBkICsgNiA+IGEgJiYgKGEgPSBmIC8gKHMgLSAodC5vZmZzZXQgPyAwLjUgOiAxKSksIGwgPSB0aGlzLm1heEhlaWdodCAtIFh0KHQuZ3JpZCkgLSBlLnBhZGRpbmcgLSBQcyh0LnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCksIGMgPSBNYXRoLnNxcnQoZCAqIGQgKyB1ICogdSksIHIgPSBBaShNYXRoLm1pbihcbiAgICAgIE1hdGguYXNpbihZKChoLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyBhLCAtMSwgMSkpLFxuICAgICAgTWF0aC5hc2luKFkobCAvIGMsIC0xLCAxKSkgLSBNYXRoLmFzaW4oWSh1IC8gYywgLTEsIDEpKVxuICAgICkpLCByID0gTWF0aC5tYXgobiwgTWF0aC5taW4obywgcikpKSwgdGhpcy5sYWJlbFJvdGF0aW9uID0gcjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gIH1cbiAgYmVmb3JlRml0KCkge1xuICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSwgeyBjaGFydDogZSwgb3B0aW9uczogeyB0aWNrczogcywgdGl0bGU6IG4sIGdyaWQ6IG8gfSB9ID0gdGhpcywgciA9IHRoaXMuX2lzVmlzaWJsZSgpLCBhID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgbCA9IFBzKG4sIGUub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChhID8gKHQud2lkdGggPSB0aGlzLm1heFdpZHRoLCB0LmhlaWdodCA9IFh0KG8pICsgbCkgOiAodC5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCwgdC53aWR0aCA9IFh0KG8pICsgbCksIHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7IGZpcnN0OiBjLCBsYXN0OiBoLCB3aWRlc3Q6IGQsIGhpZ2hlc3Q6IHUgfSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSwgZiA9IHMucGFkZGluZyAqIDIsIGcgPSBudCh0aGlzLmxhYmVsUm90YXRpb24pLCBwID0gTWF0aC5jb3MoZyksIG0gPSBNYXRoLnNpbihnKTtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICBjb25zdCBiID0gcy5taXJyb3IgPyAwIDogbSAqIGQud2lkdGggKyBwICogdS5oZWlnaHQ7XG4gICAgICAgICAgdC5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgdC5oZWlnaHQgKyBiICsgZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYiA9IHMubWlycm9yID8gMCA6IHAgKiBkLndpZHRoICsgbSAqIHUuaGVpZ2h0O1xuICAgICAgICAgIHQud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCB0LndpZHRoICsgYiArIGYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoYywgaCwgbSwgcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKSwgYSA/ICh0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gZS53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQsIHRoaXMuaGVpZ2h0ID0gdC5oZWlnaHQpIDogKHRoaXMud2lkdGggPSB0LndpZHRoLCB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGUuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gIH1cbiAgX2NhbGN1bGF0ZVBhZGRpbmcodCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgdGlja3M6IHsgYWxpZ246IG8sIHBhZGRpbmc6IHIgfSwgcG9zaXRpb246IGEgfSA9IHRoaXMub3B0aW9ucywgbCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMCwgYyA9IGEgIT09IFwidG9wXCIgJiYgdGhpcy5heGlzID09PSBcInhcIjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3QgaCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0LCBkID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgdSA9IDAsIGYgPSAwO1xuICAgICAgbCA/IGMgPyAodSA9IG4gKiB0LndpZHRoLCBmID0gcyAqIGUuaGVpZ2h0KSA6ICh1ID0gcyAqIHQuaGVpZ2h0LCBmID0gbiAqIGUud2lkdGgpIDogbyA9PT0gXCJzdGFydFwiID8gZiA9IGUud2lkdGggOiBvID09PSBcImVuZFwiID8gdSA9IHQud2lkdGggOiBvICE9PSBcImlubmVyXCIgJiYgKHUgPSB0LndpZHRoIC8gMiwgZiA9IGUud2lkdGggLyAyKSwgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KCh1IC0gaCArIHIpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gaCksIDApLCB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChmIC0gZCArIHIpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gZCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaCA9IGUuaGVpZ2h0IC8gMiwgZCA9IHQuaGVpZ2h0IC8gMjtcbiAgICAgIG8gPT09IFwic3RhcnRcIiA/IChoID0gMCwgZCA9IHQuaGVpZ2h0KSA6IG8gPT09IFwiZW5kXCIgJiYgKGggPSBlLmhlaWdodCwgZCA9IDApLCB0aGlzLnBhZGRpbmdUb3AgPSBoICsgciwgdGhpcy5wYWRkaW5nQm90dG9tID0gZCArIHI7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIHRoaXMuX21hcmdpbnMgJiYgKHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCksIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCksIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCksIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSkpO1xuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIEkodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7IGF4aXM6IHQsIHBvc2l0aW9uOiBlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIGUgPT09IFwidG9wXCIgfHwgZSA9PT0gXCJib3R0b21cIiB8fCB0ID09PSBcInhcIjtcbiAgfVxuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHQpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpLCB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0KTtcbiAgICBsZXQgZSwgcztcbiAgICBmb3IgKGUgPSAwLCBzID0gdC5sZW5ndGg7IGUgPCBzOyBlKyspXG4gICAgICBUKHRbZV0ubGFiZWwpICYmICh0LnNwbGljZShlLCAxKSwgcy0tLCBlLS0pO1xuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgcyA9IHRoaXMudGlja3M7XG4gICAgICBlIDwgcy5sZW5ndGggJiYgKHMgPSBTcyhzLCBlKSksIHRoaXMuX2xhYmVsU2l6ZXMgPSB0ID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXMocywgcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY29tcHV0ZUxhYmVsU2l6ZXModCwgZSkge1xuICAgIGNvbnN0IHsgY3R4OiBzLCBfbG9uZ2VzdFRleHRDYWNoZTogbiB9ID0gdGhpcywgbyA9IFtdLCByID0gW107XG4gICAgbGV0IGEgPSAwLCBsID0gMCwgYywgaCwgZCwgdSwgZiwgZywgcCwgbSwgYiwgeCwgdjtcbiAgICBmb3IgKGMgPSAwOyBjIDwgZTsgKytjKSB7XG4gICAgICBpZiAodSA9IHRbY10ubGFiZWwsIGYgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGMpLCBzLmZvbnQgPSBnID0gZi5zdHJpbmcsIHAgPSBuW2ddID0gbltnXSB8fCB7IGRhdGE6IHt9LCBnYzogW10gfSwgbSA9IGYubGluZUhlaWdodCwgYiA9IHggPSAwLCAhVCh1KSAmJiAheih1KSlcbiAgICAgICAgYiA9IE5lKHMsIHAuZGF0YSwgcC5nYywgYiwgdSksIHggPSBtO1xuICAgICAgZWxzZSBpZiAoeih1KSlcbiAgICAgICAgZm9yIChoID0gMCwgZCA9IHUubGVuZ3RoOyBoIDwgZDsgKytoKVxuICAgICAgICAgIHYgPSB1W2hdLCAhVCh2KSAmJiAheih2KSAmJiAoYiA9IE5lKHMsIHAuZGF0YSwgcC5nYywgYiwgdiksIHggKz0gbSk7XG4gICAgICBvLnB1c2goYiksIHIucHVzaCh4KSwgYSA9IE1hdGgubWF4KGIsIGEpLCBsID0gTWF0aC5tYXgoeCwgbCk7XG4gICAgfVxuICAgIFJhKG4sIGUpO1xuICAgIGNvbnN0IHkgPSBvLmluZGV4T2YoYSksIF8gPSByLmluZGV4T2YobCksIE0gPSAoaykgPT4gKHsgd2lkdGg6IG9ba10gfHwgMCwgaGVpZ2h0OiByW2tdIHx8IDAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiBNKDApLFxuICAgICAgbGFzdDogTShlIC0gMSksXG4gICAgICB3aWRlc3Q6IE0oeSksXG4gICAgICBoaWdoZXN0OiBNKF8pLFxuICAgICAgd2lkdGhzOiBvLFxuICAgICAgaGVpZ2h0czogclxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh0LCBlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRpY2tzO1xuICAgIHJldHVybiB0IDwgMCB8fCB0ID4gZS5sZW5ndGggLSAxID8gbnVsbCA6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZShlW3RdLnZhbHVlKTtcbiAgfVxuICBnZXRQaXhlbEZvckRlY2ltYWwodCkge1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgJiYgKHQgPSAxIC0gdCk7XG4gICAgY29uc3QgZSA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyB0ICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBUbyh0aGlzLl9hbGlnblRvUGl4ZWxzID8gd3QodGhpcy5jaGFydCwgZSwgMCkgOiBlKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwodCkge1xuICAgIGNvbnN0IGUgPSAodCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGUgOiBlO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7IG1pbjogdCwgbWF4OiBlIH0gPSB0aGlzO1xuICAgIHJldHVybiB0IDwgMCAmJiBlIDwgMCA/IGUgOiB0ID4gMCAmJiBlID4gMCA/IHQgOiAwO1xuICB9XG4gIGdldENvbnRleHQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRpY2tzIHx8IFtdO1xuICAgIGlmICh0ID49IDAgJiYgdCA8IGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzID0gZVt0XTtcbiAgICAgIHJldHVybiBzLiRjb250ZXh0IHx8IChzLiRjb250ZXh0ID0gRmEodGhpcy5nZXRDb250ZXh0KCksIHQsIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBFYSh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnRpY2tzLCBlID0gbnQodGhpcy5sYWJlbFJvdGF0aW9uKSwgcyA9IE1hdGguYWJzKE1hdGguY29zKGUpKSwgbiA9IE1hdGguYWJzKE1hdGguc2luKGUpKSwgbyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSwgciA9IHQuYXV0b1NraXBQYWRkaW5nIHx8IDAsIGEgPSBvID8gby53aWRlc3Qud2lkdGggKyByIDogMCwgbCA9IG8gPyBvLmhpZ2hlc3QuaGVpZ2h0ICsgciA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCkgPyBsICogcyA+IGEgKiBuID8gYSAvIHMgOiBsIC8gbiA6IGwgKiBuIDwgYSAqIHMgPyBsIC8gcyA6IGEgLyBuO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIHJldHVybiB0ICE9PSBcImF1dG9cIiA/ICEhdCA6IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXhpcywgcyA9IHRoaXMuY2hhcnQsIG4gPSB0aGlzLm9wdGlvbnMsIHsgZ3JpZDogbywgcG9zaXRpb246IHIgfSA9IG4sIGEgPSBvLm9mZnNldCwgbCA9IHRoaXMuaXNIb3Jpem9udGFsKCksIGggPSB0aGlzLnRpY2tzLmxlbmd0aCArIChhID8gMSA6IDApLCBkID0gWHQobyksIHUgPSBbXSwgZiA9IG8uc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksIGcgPSBmLmRyYXdCb3JkZXIgPyBmLmJvcmRlcldpZHRoIDogMCwgcCA9IGcgLyAyLCBtID0gZnVuY3Rpb24oUCkge1xuICAgICAgcmV0dXJuIHd0KHMsIFAsIGcpO1xuICAgIH07XG4gICAgbGV0IGIsIHgsIHYsIHksIF8sIE0sIGssIFMsIHcsIEwsIFIsIEE7XG4gICAgaWYgKHIgPT09IFwidG9wXCIpXG4gICAgICBiID0gbSh0aGlzLmJvdHRvbSksIE0gPSB0aGlzLmJvdHRvbSAtIGQsIFMgPSBiIC0gcCwgTCA9IG0odC50b3ApICsgcCwgQSA9IHQuYm90dG9tO1xuICAgIGVsc2UgaWYgKHIgPT09IFwiYm90dG9tXCIpXG4gICAgICBiID0gbSh0aGlzLnRvcCksIEwgPSB0LnRvcCwgQSA9IG0odC5ib3R0b20pIC0gcCwgTSA9IGIgKyBwLCBTID0gdGhpcy50b3AgKyBkO1xuICAgIGVsc2UgaWYgKHIgPT09IFwibGVmdFwiKVxuICAgICAgYiA9IG0odGhpcy5yaWdodCksIF8gPSB0aGlzLnJpZ2h0IC0gZCwgayA9IGIgLSBwLCB3ID0gbSh0LmxlZnQpICsgcCwgUiA9IHQucmlnaHQ7XG4gICAgZWxzZSBpZiAociA9PT0gXCJyaWdodFwiKVxuICAgICAgYiA9IG0odGhpcy5sZWZ0KSwgdyA9IHQubGVmdCwgUiA9IG0odC5yaWdodCkgLSBwLCBfID0gYiArIHAsIGsgPSB0aGlzLmxlZnQgKyBkO1xuICAgIGVsc2UgaWYgKGUgPT09IFwieFwiKSB7XG4gICAgICBpZiAociA9PT0gXCJjZW50ZXJcIilcbiAgICAgICAgYiA9IG0oKHQudG9wICsgdC5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICBlbHNlIGlmIChEKHIpKSB7XG4gICAgICAgIGNvbnN0IFAgPSBPYmplY3Qua2V5cyhyKVswXSwgaiA9IHJbUF07XG4gICAgICAgIGIgPSBtKHRoaXMuY2hhcnQuc2NhbGVzW1BdLmdldFBpeGVsRm9yVmFsdWUoaikpO1xuICAgICAgfVxuICAgICAgTCA9IHQudG9wLCBBID0gdC5ib3R0b20sIE0gPSBiICsgcCwgUyA9IE0gKyBkO1xuICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ5XCIpIHtcbiAgICAgIGlmIChyID09PSBcImNlbnRlclwiKVxuICAgICAgICBiID0gbSgodC5sZWZ0ICsgdC5yaWdodCkgLyAyKTtcbiAgICAgIGVsc2UgaWYgKEQocikpIHtcbiAgICAgICAgY29uc3QgUCA9IE9iamVjdC5rZXlzKHIpWzBdLCBqID0gcltQXTtcbiAgICAgICAgYiA9IG0odGhpcy5jaGFydC5zY2FsZXNbUF0uZ2V0UGl4ZWxGb3JWYWx1ZShqKSk7XG4gICAgICB9XG4gICAgICBfID0gYiAtIHAsIGsgPSBfIC0gZCwgdyA9IHQubGVmdCwgUiA9IHQucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IEggPSBDKG4udGlja3MubWF4VGlja3NMaW1pdCwgaCksIHEgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoaCAvIEgpKTtcbiAgICBmb3IgKHggPSAwOyB4IDwgaDsgeCArPSBxKSB7XG4gICAgICBjb25zdCBQID0gby5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCh4KSksIGogPSBQLmxpbmVXaWR0aCwgVyA9IFAuY29sb3IsIGt0ID0gUC5ib3JkZXJEYXNoIHx8IFtdLCB0aSA9IFAuYm9yZGVyRGFzaE9mZnNldCwgUnQgPSBQLnRpY2tXaWR0aCwga2UgPSBQLnRpY2tDb2xvciwgRXQgPSBQLnRpY2tCb3JkZXJEYXNoIHx8IFtdLCBqdCA9IFAudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICB2ID0gTGEodGhpcywgeCwgYSksIHYgIT09IHZvaWQgMCAmJiAoeSA9IHd0KHMsIHYsIGopLCBsID8gXyA9IGsgPSB3ID0gUiA9IHkgOiBNID0gUyA9IEwgPSBBID0geSwgdS5wdXNoKHtcbiAgICAgICAgdHgxOiBfLFxuICAgICAgICB0eTE6IE0sXG4gICAgICAgIHR4MjogayxcbiAgICAgICAgdHkyOiBTLFxuICAgICAgICB4MTogdyxcbiAgICAgICAgeTE6IEwsXG4gICAgICAgIHgyOiBSLFxuICAgICAgICB5MjogQSxcbiAgICAgICAgd2lkdGg6IGosXG4gICAgICAgIGNvbG9yOiBXLFxuICAgICAgICBib3JkZXJEYXNoOiBrdCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogdGksXG4gICAgICAgIHRpY2tXaWR0aDogUnQsXG4gICAgICAgIHRpY2tDb2xvcjoga2UsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoOiBFdCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQ6IGp0XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aWNrc0xlbmd0aCA9IGgsIHRoaXMuX2JvcmRlclZhbHVlID0gYiwgdTtcbiAgfVxuICBfY29tcHV0ZUxhYmVsSXRlbXModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmF4aXMsIHMgPSB0aGlzLm9wdGlvbnMsIHsgcG9zaXRpb246IG4sIHRpY2tzOiBvIH0gPSBzLCByID0gdGhpcy5pc0hvcml6b250YWwoKSwgYSA9IHRoaXMudGlja3MsIHsgYWxpZ246IGwsIGNyb3NzQWxpZ246IGMsIHBhZGRpbmc6IGgsIG1pcnJvcjogZCB9ID0gbywgdSA9IFh0KHMuZ3JpZCksIGYgPSB1ICsgaCwgZyA9IGQgPyAtaCA6IGYsIHAgPSAtbnQodGhpcy5sYWJlbFJvdGF0aW9uKSwgbSA9IFtdO1xuICAgIGxldCBiLCB4LCB2LCB5LCBfLCBNLCBrLCBTLCB3LCBMLCBSLCBBLCBIID0gXCJtaWRkbGVcIjtcbiAgICBpZiAobiA9PT0gXCJ0b3BcIilcbiAgICAgIE0gPSB0aGlzLmJvdHRvbSAtIGcsIGsgPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgZWxzZSBpZiAobiA9PT0gXCJib3R0b21cIilcbiAgICAgIE0gPSB0aGlzLnRvcCArIGcsIGsgPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgZWxzZSBpZiAobiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIGNvbnN0IFAgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHUpO1xuICAgICAgayA9IFAudGV4dEFsaWduLCBfID0gUC54O1xuICAgIH0gZWxzZSBpZiAobiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICBjb25zdCBQID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh1KTtcbiAgICAgIGsgPSBQLnRleHRBbGlnbiwgXyA9IFAueDtcbiAgICB9IGVsc2UgaWYgKGUgPT09IFwieFwiKSB7XG4gICAgICBpZiAobiA9PT0gXCJjZW50ZXJcIilcbiAgICAgICAgTSA9ICh0LnRvcCArIHQuYm90dG9tKSAvIDIgKyBmO1xuICAgICAgZWxzZSBpZiAoRChuKSkge1xuICAgICAgICBjb25zdCBQID0gT2JqZWN0LmtleXMobilbMF0sIGogPSBuW1BdO1xuICAgICAgICBNID0gdGhpcy5jaGFydC5zY2FsZXNbUF0uZ2V0UGl4ZWxGb3JWYWx1ZShqKSArIGY7XG4gICAgICB9XG4gICAgICBrID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ5XCIpIHtcbiAgICAgIGlmIChuID09PSBcImNlbnRlclwiKVxuICAgICAgICBfID0gKHQubGVmdCArIHQucmlnaHQpIC8gMiAtIGY7XG4gICAgICBlbHNlIGlmIChEKG4pKSB7XG4gICAgICAgIGNvbnN0IFAgPSBPYmplY3Qua2V5cyhuKVswXSwgaiA9IG5bUF07XG4gICAgICAgIF8gPSB0aGlzLmNoYXJ0LnNjYWxlc1tQXS5nZXRQaXhlbEZvclZhbHVlKGopO1xuICAgICAgfVxuICAgICAgayA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodSkudGV4dEFsaWduO1xuICAgIH1cbiAgICBlID09PSBcInlcIiAmJiAobCA9PT0gXCJzdGFydFwiID8gSCA9IFwidG9wXCIgOiBsID09PSBcImVuZFwiICYmIChIID0gXCJib3R0b21cIikpO1xuICAgIGNvbnN0IHEgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChiID0gMCwgeCA9IGEubGVuZ3RoOyBiIDwgeDsgKytiKSB7XG4gICAgICB2ID0gYVtiXSwgeSA9IHYubGFiZWw7XG4gICAgICBjb25zdCBQID0gby5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChiKSk7XG4gICAgICBTID0gdGhpcy5nZXRQaXhlbEZvclRpY2soYikgKyBvLmxhYmVsT2Zmc2V0LCB3ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhiKSwgTCA9IHcubGluZUhlaWdodCwgUiA9IHooeSkgPyB5Lmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBqID0gUiAvIDIsIFcgPSBQLmNvbG9yLCBrdCA9IFAudGV4dFN0cm9rZUNvbG9yLCB0aSA9IFAudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IFJ0ID0gaztcbiAgICAgIHIgPyAoXyA9IFMsIGsgPT09IFwiaW5uZXJcIiAmJiAoYiA9PT0geCAtIDEgPyBSdCA9IHRoaXMub3B0aW9ucy5yZXZlcnNlID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgOiBiID09PSAwID8gUnQgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IFwicmlnaHRcIiA6IFwibGVmdFwiIDogUnQgPSBcImNlbnRlclwiKSwgbiA9PT0gXCJ0b3BcIiA/IGMgPT09IFwibmVhclwiIHx8IHAgIT09IDAgPyBBID0gLVIgKiBMICsgTCAvIDIgOiBjID09PSBcImNlbnRlclwiID8gQSA9IC1xLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGogKiBMICsgTCA6IEEgPSAtcS5oaWdoZXN0LmhlaWdodCArIEwgLyAyIDogYyA9PT0gXCJuZWFyXCIgfHwgcCAhPT0gMCA/IEEgPSBMIC8gMiA6IGMgPT09IFwiY2VudGVyXCIgPyBBID0gcS5oaWdoZXN0LmhlaWdodCAvIDIgLSBqICogTCA6IEEgPSBxLmhpZ2hlc3QuaGVpZ2h0IC0gUiAqIEwsIGQgJiYgKEEgKj0gLTEpKSA6IChNID0gUywgQSA9ICgxIC0gUikgKiBMIC8gMik7XG4gICAgICBsZXQga2U7XG4gICAgICBpZiAoUC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBFdCA9IEsoUC5iYWNrZHJvcFBhZGRpbmcpLCBqdCA9IHEuaGVpZ2h0c1tiXSwgZWkgPSBxLndpZHRoc1tiXTtcbiAgICAgICAgbGV0IGlpID0gTSArIEEgLSBFdC50b3AsIHNpID0gXyAtIEV0LmxlZnQ7XG4gICAgICAgIHN3aXRjaCAoSCkge1xuICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgICAgIGlpIC09IGp0IC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIGlpIC09IGp0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgc2kgLT0gZWkgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICBzaSAtPSBlaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGtlID0ge1xuICAgICAgICAgIGxlZnQ6IHNpLFxuICAgICAgICAgIHRvcDogaWksXG4gICAgICAgICAgd2lkdGg6IGVpICsgRXQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBqdCArIEV0LmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogUC5iYWNrZHJvcENvbG9yXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtLnB1c2goe1xuICAgICAgICByb3RhdGlvbjogcCxcbiAgICAgICAgbGFiZWw6IHksXG4gICAgICAgIGZvbnQ6IHcsXG4gICAgICAgIGNvbG9yOiBXLFxuICAgICAgICBzdHJva2VDb2xvcjoga3QsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aSxcbiAgICAgICAgdGV4dE9mZnNldDogQSxcbiAgICAgICAgdGV4dEFsaWduOiBSdCxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBILFxuICAgICAgICB0cmFuc2xhdGlvbjogW18sIE1dLFxuICAgICAgICBiYWNrZHJvcDoga2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7IHBvc2l0aW9uOiB0LCB0aWNrczogZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgtbnQodGhpcy5sYWJlbFJvdGF0aW9uKSlcbiAgICAgIHJldHVybiB0ID09PSBcInRvcFwiID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgbGV0IG4gPSBcImNlbnRlclwiO1xuICAgIHJldHVybiBlLmFsaWduID09PSBcInN0YXJ0XCIgPyBuID0gXCJsZWZ0XCIgOiBlLmFsaWduID09PSBcImVuZFwiID8gbiA9IFwicmlnaHRcIiA6IGUuYWxpZ24gPT09IFwiaW5uZXJcIiAmJiAobiA9IFwiaW5uZXJcIiksIG47XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodCkge1xuICAgIGNvbnN0IHsgcG9zaXRpb246IGUsIHRpY2tzOiB7IGNyb3NzQWxpZ246IHMsIG1pcnJvcjogbiwgcGFkZGluZzogbyB9IH0gPSB0aGlzLm9wdGlvbnMsIHIgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCksIGEgPSB0ICsgbywgbCA9IHIud2lkZXN0LndpZHRoO1xuICAgIGxldCBjLCBoO1xuICAgIHJldHVybiBlID09PSBcImxlZnRcIiA/IG4gPyAoaCA9IHRoaXMucmlnaHQgKyBvLCBzID09PSBcIm5lYXJcIiA/IGMgPSBcImxlZnRcIiA6IHMgPT09IFwiY2VudGVyXCIgPyAoYyA9IFwiY2VudGVyXCIsIGggKz0gbCAvIDIpIDogKGMgPSBcInJpZ2h0XCIsIGggKz0gbCkpIDogKGggPSB0aGlzLnJpZ2h0IC0gYSwgcyA9PT0gXCJuZWFyXCIgPyBjID0gXCJyaWdodFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCAtPSBsIC8gMikgOiAoYyA9IFwibGVmdFwiLCBoID0gdGhpcy5sZWZ0KSkgOiBlID09PSBcInJpZ2h0XCIgPyBuID8gKGggPSB0aGlzLmxlZnQgKyBvLCBzID09PSBcIm5lYXJcIiA/IGMgPSBcInJpZ2h0XCIgOiBzID09PSBcImNlbnRlclwiID8gKGMgPSBcImNlbnRlclwiLCBoIC09IGwgLyAyKSA6IChjID0gXCJsZWZ0XCIsIGggLT0gbCkpIDogKGggPSB0aGlzLmxlZnQgKyBhLCBzID09PSBcIm5lYXJcIiA/IGMgPSBcImxlZnRcIiA6IHMgPT09IFwiY2VudGVyXCIgPyAoYyA9IFwiY2VudGVyXCIsIGggKz0gbCAvIDIpIDogKGMgPSBcInJpZ2h0XCIsIGggPSB0aGlzLnJpZ2h0KSkgOiBjID0gXCJyaWdodFwiLCB7IHRleHRBbGlnbjogYywgeDogaCB9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmNoYXJ0LCBlID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChlID09PSBcImxlZnRcIiB8fCBlID09PSBcInJpZ2h0XCIpXG4gICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiB0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHQgfTtcbiAgICBpZiAoZSA9PT0gXCJ0b3BcIiB8fCBlID09PSBcImJvdHRvbVwiKVxuICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IHQud2lkdGggfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7IGN0eDogdCwgb3B0aW9uczogeyBiYWNrZ3JvdW5kQ29sb3I6IGUgfSwgbGVmdDogcywgdG9wOiBuLCB3aWR0aDogbywgaGVpZ2h0OiByIH0gPSB0aGlzO1xuICAgIGUgJiYgKHQuc2F2ZSgpLCB0LmZpbGxTdHlsZSA9IGUsIHQuZmlsbFJlY3QocywgbiwgbywgciksIHQucmVzdG9yZSgpKTtcbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWUuZGlzcGxheSlcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IG4gPSB0aGlzLnRpY2tzLmZpbmRJbmRleCgobykgPT4gby52YWx1ZSA9PT0gdCk7XG4gICAgcmV0dXJuIG4gPj0gMCA/IGUuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQobikpLmxpbmVXaWR0aCA6IDA7XG4gIH1cbiAgZHJhd0dyaWQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuZ3JpZCwgcyA9IHRoaXMuY3R4LCBuID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKHQpKTtcbiAgICBsZXQgbywgcjtcbiAgICBjb25zdCBhID0gKGwsIGMsIGgpID0+IHtcbiAgICAgICFoLndpZHRoIHx8ICFoLmNvbG9yIHx8IChzLnNhdmUoKSwgcy5saW5lV2lkdGggPSBoLndpZHRoLCBzLnN0cm9rZVN0eWxlID0gaC5jb2xvciwgcy5zZXRMaW5lRGFzaChoLmJvcmRlckRhc2ggfHwgW10pLCBzLmxpbmVEYXNoT2Zmc2V0ID0gaC5ib3JkZXJEYXNoT2Zmc2V0LCBzLmJlZ2luUGF0aCgpLCBzLm1vdmVUbyhsLngsIGwueSksIHMubGluZVRvKGMueCwgYy55KSwgcy5zdHJva2UoKSwgcy5yZXN0b3JlKCkpO1xuICAgIH07XG4gICAgaWYgKGUuZGlzcGxheSlcbiAgICAgIGZvciAobyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7ICsrbykge1xuICAgICAgICBjb25zdCBsID0gbltvXTtcbiAgICAgICAgZS5kcmF3T25DaGFydEFyZWEgJiYgYShcbiAgICAgICAgICB7IHg6IGwueDEsIHk6IGwueTEgfSxcbiAgICAgICAgICB7IHg6IGwueDIsIHk6IGwueTIgfSxcbiAgICAgICAgICBsXG4gICAgICAgICksIGUuZHJhd1RpY2tzICYmIGEoXG4gICAgICAgICAgeyB4OiBsLnR4MSwgeTogbC50eTEgfSxcbiAgICAgICAgICB7IHg6IGwudHgyLCB5OiBsLnR5MiB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbG9yOiBsLnRpY2tDb2xvcixcbiAgICAgICAgICAgIHdpZHRoOiBsLnRpY2tXaWR0aCxcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IGwudGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBsLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3QgeyBjaGFydDogdCwgY3R4OiBlLCBvcHRpb25zOiB7IGdyaWQ6IHMgfSB9ID0gdGhpcywgbiA9IHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksIG8gPSBzLmRyYXdCb3JkZXIgPyBuLmJvcmRlcldpZHRoIDogMDtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aCwgYSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCBsLCBjLCBoLCBkO1xuICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAobCA9IHd0KHQsIHRoaXMubGVmdCwgbykgLSBvIC8gMiwgYyA9IHd0KHQsIHRoaXMucmlnaHQsIHIpICsgciAvIDIsIGggPSBkID0gYSkgOiAoaCA9IHd0KHQsIHRoaXMudG9wLCBvKSAtIG8gLyAyLCBkID0gd3QodCwgdGhpcy5ib3R0b20sIHIpICsgciAvIDIsIGwgPSBjID0gYSksIGUuc2F2ZSgpLCBlLmxpbmVXaWR0aCA9IG4uYm9yZGVyV2lkdGgsIGUuc3Ryb2tlU3R5bGUgPSBuLmJvcmRlckNvbG9yLCBlLmJlZ2luUGF0aCgpLCBlLm1vdmVUbyhsLCBoKSwgZS5saW5lVG8oYywgZCksIGUuc3Ryb2tlKCksIGUucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHModCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnRpY2tzLmRpc3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IHRoaXMuY3R4LCBuID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIG4gJiYgWGUocywgbik7XG4gICAgY29uc3QgbyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyh0KSk7XG4gICAgbGV0IHIsIGE7XG4gICAgZm9yIChyID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgKytyKSB7XG4gICAgICBjb25zdCBsID0gb1tyXSwgYyA9IGwuZm9udCwgaCA9IGwubGFiZWw7XG4gICAgICBsLmJhY2tkcm9wICYmIChzLmZpbGxTdHlsZSA9IGwuYmFja2Ryb3AuY29sb3IsIHMuZmlsbFJlY3QobC5iYWNrZHJvcC5sZWZ0LCBsLmJhY2tkcm9wLnRvcCwgbC5iYWNrZHJvcC53aWR0aCwgbC5iYWNrZHJvcC5oZWlnaHQpKTtcbiAgICAgIGxldCBkID0gbC50ZXh0T2Zmc2V0O1xuICAgICAgVHQocywgaCwgMCwgZCwgYywgbCk7XG4gICAgfVxuICAgIG4gJiYgVWUocyk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHsgY3R4OiB0LCBvcHRpb25zOiB7IHBvc2l0aW9uOiBlLCB0aXRsZTogcywgcmV2ZXJzZTogbiB9IH0gPSB0aGlzO1xuICAgIGlmICghcy5kaXNwbGF5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSAkKHMuZm9udCksIHIgPSBLKHMucGFkZGluZyksIGEgPSBzLmFsaWduO1xuICAgIGxldCBsID0gby5saW5lSGVpZ2h0IC8gMjtcbiAgICBlID09PSBcImJvdHRvbVwiIHx8IGUgPT09IFwiY2VudGVyXCIgfHwgRChlKSA/IChsICs9IHIuYm90dG9tLCB6KHMudGV4dCkgJiYgKGwgKz0gby5saW5lSGVpZ2h0ICogKHMudGV4dC5sZW5ndGggLSAxKSkpIDogbCArPSByLnRvcDtcbiAgICBjb25zdCB7IHRpdGxlWDogYywgdGl0bGVZOiBoLCBtYXhXaWR0aDogZCwgcm90YXRpb246IHUgfSA9IHphKHRoaXMsIGwsIGUsIGEpO1xuICAgIFR0KHQsIHMudGV4dCwgMCwgMCwgbywge1xuICAgICAgY29sb3I6IHMuY29sb3IsXG4gICAgICBtYXhXaWR0aDogZCxcbiAgICAgIHJvdGF0aW9uOiB1LFxuICAgICAgdGV4dEFsaWduOiBJYShhLCBlLCBuKSxcbiAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgIHRyYW5zbGF0aW9uOiBbYywgaF1cbiAgICB9KTtcbiAgfVxuICBkcmF3KHQpIHtcbiAgICB0aGlzLl9pc1Zpc2libGUoKSAmJiAodGhpcy5kcmF3QmFja2dyb3VuZCgpLCB0aGlzLmRyYXdHcmlkKHQpLCB0aGlzLmRyYXdCb3JkZXIoKSwgdGhpcy5kcmF3VGl0bGUoKSwgdGhpcy5kcmF3TGFiZWxzKHQpKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0LnRpY2tzICYmIHQudGlja3MueiB8fCAwLCBzID0gQyh0LmdyaWQgJiYgdC5ncmlkLnosIC0xKTtcbiAgICByZXR1cm4gIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gTXQucHJvdG90eXBlLmRyYXcgPyBbe1xuICAgICAgejogZSxcbiAgICAgIGRyYXc6IChuKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhdyhuKTtcbiAgICAgIH1cbiAgICB9XSA6IFt7XG4gICAgICB6OiBzLFxuICAgICAgZHJhdzogKG4pID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpLCB0aGlzLmRyYXdHcmlkKG4pLCB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHMgKyAxLFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBlLFxuICAgICAgZHJhdzogKG4pID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKG4pO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCksIHMgPSB0aGlzLmF4aXMgKyBcIkF4aXNJRFwiLCBuID0gW107XG4gICAgbGV0IG8sIHI7XG4gICAgZm9yIChvID0gMCwgciA9IGUubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgICBjb25zdCBhID0gZVtvXTtcbiAgICAgIGFbc10gPT09IHRoaXMuaWQgJiYgKCF0IHx8IGEudHlwZSA9PT0gdCkgJiYgbi5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCh0KSk7XG4gICAgcmV0dXJuICQoZS5mb250KTtcbiAgfVxuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIHQ7XG4gIH1cbn1cbmNsYXNzIEFlIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcykge1xuICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuc2NvcGUgPSBlLCB0aGlzLm92ZXJyaWRlID0gcywgdGhpcy5pdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHQucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3Rlcih0KSB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgICBsZXQgcztcbiAgICBXYShlKSAmJiAocyA9IHRoaXMucmVnaXN0ZXIoZSkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLml0ZW1zLCBvID0gdC5pZCwgciA9IHRoaXMuc2NvcGUgKyBcIi5cIiArIG87XG4gICAgaWYgKCFvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogXCIgKyB0KTtcbiAgICByZXR1cm4gbyBpbiBuIHx8IChuW29dID0gdCwgQmEodCwgciwgcyksIHRoaXMub3ZlcnJpZGUgJiYgTy5vdmVycmlkZSh0LmlkLCB0Lm92ZXJyaWRlcykpLCByO1xuICB9XG4gIGdldCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbdF07XG4gIH1cbiAgdW5yZWdpc3Rlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlbXMsIHMgPSB0LmlkLCBuID0gdGhpcy5zY29wZTtcbiAgICBzIGluIGUgJiYgZGVsZXRlIGVbc10sIG4gJiYgcyBpbiBPW25dICYmIChkZWxldGUgT1tuXVtzXSwgdGhpcy5vdmVycmlkZSAmJiBkZWxldGUgQXRbc10pO1xuICB9XG59XG5mdW5jdGlvbiBCYShpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBuZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIGUgPyBPLmdldChlKSA6IHt9LFxuICAgIE8uZ2V0KHQpLFxuICAgIGkuZGVmYXVsdHNcbiAgXSk7XG4gIE8uc2V0KHQsIHMpLCBpLmRlZmF1bHRSb3V0ZXMgJiYgVmEodCwgaS5kZWZhdWx0Um91dGVzKSwgaS5kZXNjcmlwdG9ycyAmJiBPLmRlc2NyaWJlKHQsIGkuZGVzY3JpcHRvcnMpO1xufVxuZnVuY3Rpb24gVmEoaSwgdCkge1xuICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgcyA9IGUuc3BsaXQoXCIuXCIpLCBuID0gcy5wb3AoKSwgbyA9IFtpXS5jb25jYXQocykuam9pbihcIi5cIiksIHIgPSB0W2VdLnNwbGl0KFwiLlwiKSwgYSA9IHIucG9wKCksIGwgPSByLmpvaW4oXCIuXCIpO1xuICAgIE8ucm91dGUobywgbiwgbCwgYSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gV2EoaSkge1xuICByZXR1cm4gXCJpZFwiIGluIGkgJiYgXCJkZWZhdWx0c1wiIGluIGk7XG59XG5jbGFzcyBOYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgQWUoaXQsIFwiZGF0YXNldHNcIiwgITApLCB0aGlzLmVsZW1lbnRzID0gbmV3IEFlKHN0LCBcImVsZW1lbnRzXCIpLCB0aGlzLnBsdWdpbnMgPSBuZXcgQWUoT2JqZWN0LCBcInBsdWdpbnNcIiksIHRoaXMuc2NhbGVzID0gbmV3IEFlKE10LCBcInNjYWxlc1wiKSwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBhZGQoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0KTtcbiAgfVxuICByZW1vdmUoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLnQpIHtcbiAgICB0aGlzLl9lYWNoKFwicmVnaXN0ZXJcIiwgdCwgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgYWRkRWxlbWVudHMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLnQpIHtcbiAgICB0aGlzLl9lYWNoKFwicmVnaXN0ZXJcIiwgdCwgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgZ2V0Q29udHJvbGxlcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLmNvbnRyb2xsZXJzLCBcImNvbnRyb2xsZXJcIik7XG4gIH1cbiAgZ2V0RWxlbWVudCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLmVsZW1lbnRzLCBcImVsZW1lbnRcIik7XG4gIH1cbiAgZ2V0UGx1Z2luKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHQsIHRoaXMucGx1Z2lucywgXCJwbHVnaW5cIik7XG4gIH1cbiAgZ2V0U2NhbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQodCwgdGhpcy5zY2FsZXMsIFwic2NhbGVcIik7XG4gIH1cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLnQpIHtcbiAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLnQpIHtcbiAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIHJlbW92ZVNjYWxlcyguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCwgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKHQsIGUsIHMpIHtcbiAgICBbLi4uZV0uZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IHMgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKG4pO1xuICAgICAgcyB8fCBvLmlzRm9yVHlwZShuKSB8fCBvID09PSB0aGlzLnBsdWdpbnMgJiYgbi5pZCA/IHRoaXMuX2V4ZWModCwgbywgbikgOiBFKG4sIChyKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBzIHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShyKTtcbiAgICAgICAgdGhpcy5fZXhlYyh0LCBhLCByKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9leGVjKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gT2kodCk7XG4gICAgSShzW1wiYmVmb3JlXCIgKyBuXSwgW10sIHMpLCBlW3RdKHMpLCBJKHNbXCJhZnRlclwiICsgbl0sIFtdLCBzKTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHQpIHtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGUrKykge1xuICAgICAgY29uc3QgcyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tlXTtcbiAgICAgIGlmIChzLmlzRm9yVHlwZSh0KSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cbiAgX2dldCh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IGUuZ2V0KHQpO1xuICAgIGlmIChuID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgcyArIFwiLlwiKTtcbiAgICByZXR1cm4gbjtcbiAgfVxufVxudmFyIG90ID0gbmV3IE5hKCk7XG5jbGFzcyB4ZSBleHRlbmRzIGl0IHtcbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgeyBkYXRhOiBzID0gW10gfSA9IGUsIG4gPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHsgc3RhcnQ6IG8sIGNvdW50OiByIH0gPSBwbihlLCBzLCBuKTtcbiAgICBpZiAodGhpcy5fZHJhd1N0YXJ0ID0gbywgdGhpcy5fZHJhd0NvdW50ID0gciwgbW4oZSkgJiYgKG8gPSAwLCByID0gcy5sZW5ndGgpLCB0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YXNldDogYSwgX2RhdGFzZXQ6IGwgfSA9IGU7XG4gICAgICBhLl9jaGFydCA9IHRoaXMuY2hhcnQsIGEuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXgsIGEuX2RlY2ltYXRlZCA9ICEhbC5fZGVjaW1hdGVkLCBhLnBvaW50cyA9IHM7XG4gICAgICBjb25zdCBjID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHQpO1xuICAgICAgYy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQsIHRoaXMudXBkYXRlRWxlbWVudChhLCB2b2lkIDAsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFuLFxuICAgICAgICBvcHRpb25zOiBjXG4gICAgICB9LCB0KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhzLCBvLCByLCB0KTtcbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7IHNob3dMaW5lOiB0IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHQgJiYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gb3QuZ2V0RWxlbWVudChcImxpbmVcIikpLCBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gbiA9PT0gXCJyZXNldFwiLCB7IGlTY2FsZTogciwgdlNjYWxlOiBhLCBfc3RhY2tlZDogbCwgX2RhdGFzZXQ6IGMgfSA9IHRoaXMuX2NhY2hlZE1ldGEsIGggPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZSwgbiksIGQgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoaCksIHUgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG4sIGQpLCBmID0gci5heGlzLCBnID0gYS5heGlzLCB7IHNwYW5HYXBzOiBwLCBzZWdtZW50OiBtIH0gPSB0aGlzLm9wdGlvbnMsIGIgPSBCdChwKSA/IHAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHggPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgbyB8fCBuID09PSBcIm5vbmVcIjtcbiAgICBsZXQgdiA9IGUgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKGUgLSAxKTtcbiAgICBmb3IgKGxldCB5ID0gZTsgeSA8IGUgKyBzOyArK3kpIHtcbiAgICAgIGNvbnN0IF8gPSB0W3ldLCBNID0gdGhpcy5nZXRQYXJzZWQoeSksIGsgPSB4ID8gXyA6IHt9LCBTID0gVChNW2ddKSwgdyA9IGtbZl0gPSByLmdldFBpeGVsRm9yVmFsdWUoTVtmXSwgeSksIEwgPSBrW2ddID0gbyB8fCBTID8gYS5nZXRCYXNlUGl4ZWwoKSA6IGEuZ2V0UGl4ZWxGb3JWYWx1ZShsID8gdGhpcy5hcHBseVN0YWNrKGEsIE0sIGwpIDogTVtnXSwgeSk7XG4gICAgICBrLnNraXAgPSBpc05hTih3KSB8fCBpc05hTihMKSB8fCBTLCBrLnN0b3AgPSB5ID4gMCAmJiBNYXRoLmFicyhNW2ZdIC0gdltmXSkgPiBiLCBtICYmIChrLnBhcnNlZCA9IE0sIGsucmF3ID0gYy5kYXRhW3ldKSwgdSAmJiAoay5vcHRpb25zID0gZCB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoeSwgXy5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbikpLCB4IHx8IHRoaXMudXBkYXRlRWxlbWVudChfLCB5LCBrLCBuKSwgdiA9IE07XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhkLCBuLCBoKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YSwgZSA9IHQuZGF0YSB8fCBbXTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IGEgPSAwO1xuICAgICAgZm9yIChsZXQgbCA9IGUubGVuZ3RoIC0gMTsgbCA+PSAwOyAtLWwpXG4gICAgICAgIGEgPSBNYXRoLm1heChhLCBlW2xdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGwpKSAvIDIpO1xuICAgICAgcmV0dXJuIGEgPiAwICYmIGE7XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0LmRhdGFzZXQsIG4gPSBzLm9wdGlvbnMgJiYgcy5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgaWYgKCFlLmxlbmd0aClcbiAgICAgIHJldHVybiBuO1xuICAgIGNvbnN0IG8gPSBlWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKSwgciA9IGVbZS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhlLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgobiwgbywgcikgLyAyO1xuICB9XG59XG54ZS5pZCA9IFwic2NhdHRlclwiO1xueGUuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogITEsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJwb2ludFwiLFxuICBzaG93TGluZTogITEsXG4gIGZpbGw6ICExXG59O1xueGUub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6IFwicG9pbnRcIlxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiKFwiICsgaS5sYWJlbCArIFwiLCBcIiArIGkuZm9ybWF0dGVkVmFsdWUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH1cbiAgfVxufTtcbnZhciBXbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBCYXJDb250cm9sbGVyOiB1ZSxcbiAgQnViYmxlQ29udHJvbGxlcjogZmUsXG4gIERvdWdobnV0Q29udHJvbGxlcjogTHQsXG4gIExpbmVDb250cm9sbGVyOiBnZSxcbiAgUG9sYXJBcmVhQ29udHJvbGxlcjogcGUsXG4gIFBpZUNvbnRyb2xsZXI6IHFlLFxuICBSYWRhckNvbnRyb2xsZXI6IG1lLFxuICBTY2F0dGVyQ29udHJvbGxlcjogeGVcbn0pO1xuZnVuY3Rpb24gU3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC5cIik7XG59XG5jbGFzcyB2aSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB0IHx8IHt9O1xuICB9XG4gIGluaXQodCkge1xuICB9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIFN0KCk7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIHJldHVybiBTdCgpO1xuICB9XG4gIGZvcm1hdCh0LCBlKSB7XG4gICAgcmV0dXJuIFN0KCk7XG4gIH1cbiAgYWRkKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxuICBkaWZmKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxuICBzdGFydE9mKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxuICBlbmRPZih0LCBlKSB7XG4gICAgcmV0dXJuIFN0KCk7XG4gIH1cbn1cbnZpLm92ZXJyaWRlID0gZnVuY3Rpb24oaSkge1xuICBPYmplY3QuYXNzaWduKHZpLnByb3RvdHlwZSwgaSk7XG59O1xudmFyIE5uID0ge1xuICBfZGF0ZTogdmlcbn07XG5mdW5jdGlvbiBIYShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgY29udHJvbGxlcjogbiwgZGF0YTogbywgX3NvcnRlZDogciB9ID0gaSwgYSA9IG4uX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoYSAmJiB0ID09PSBhLmF4aXMgJiYgdCAhPT0gXCJyXCIgJiYgciAmJiBvLmxlbmd0aCkge1xuICAgIGNvbnN0IGwgPSBhLl9yZXZlcnNlUGl4ZWxzID8gTG8gOiBmdDtcbiAgICBpZiAocykge1xuICAgICAgaWYgKG4uX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYyA9IG9bMF0sIGggPSB0eXBlb2YgYy5nZXRSYW5nZSA9PSBcImZ1bmN0aW9uXCIgJiYgYy5nZXRSYW5nZSh0KTtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBjb25zdCBkID0gbChvLCB0LCBlIC0gaCksIHUgPSBsKG8sIHQsIGUgKyBoKTtcbiAgICAgICAgICByZXR1cm4geyBsbzogZC5sbywgaGk6IHUuaGkgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIGwobywgdCwgZSk7XG4gIH1cbiAgcmV0dXJuIHsgbG86IDAsIGhpOiBvLmxlbmd0aCAtIDEgfTtcbn1cbmZ1bmN0aW9uIF9lKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgbyA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLCByID0gZVt0XTtcbiAgZm9yIChsZXQgYSA9IDAsIGwgPSBvLmxlbmd0aDsgYSA8IGw7ICsrYSkge1xuICAgIGNvbnN0IHsgaW5kZXg6IGMsIGRhdGE6IGggfSA9IG9bYV0sIHsgbG86IGQsIGhpOiB1IH0gPSBIYShvW2FdLCB0LCByLCBuKTtcbiAgICBmb3IgKGxldCBmID0gZDsgZiA8PSB1OyArK2YpIHtcbiAgICAgIGNvbnN0IGcgPSBoW2ZdO1xuICAgICAgZy5za2lwIHx8IHMoZywgYywgZik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBqYShpKSB7XG4gIGNvbnN0IHQgPSBpLmluZGV4T2YoXCJ4XCIpICE9PSAtMSwgZSA9IGkuaW5kZXhPZihcInlcIikgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24ocywgbikge1xuICAgIGNvbnN0IG8gPSB0ID8gTWF0aC5hYnMocy54IC0gbi54KSA6IDAsIHIgPSBlID8gTWF0aC5hYnMocy55IC0gbi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhvLCAyKSArIE1hdGgucG93KHIsIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgbyA9IFtdO1xuICByZXR1cm4gIW4gJiYgIWkuaXNQb2ludEluQXJlYSh0KSB8fCBfZShpLCBlLCB0LCBmdW5jdGlvbihhLCBsLCBjKSB7XG4gICAgIW4gJiYgIXJlKGEsIGkuY2hhcnRBcmVhLCAwKSB8fCBhLmluUmFuZ2UodC54LCB0LnksIHMpICYmIG8ucHVzaCh7IGVsZW1lbnQ6IGEsIGRhdGFzZXRJbmRleDogbCwgaW5kZXg6IGMgfSk7XG4gIH0sICEwKSwgbztcbn1cbmZ1bmN0aW9uICRhKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSBbXTtcbiAgZnVuY3Rpb24gbyhyLCBhLCBsKSB7XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlOiBjLCBlbmRBbmdsZTogaCB9ID0gci5nZXRQcm9wcyhbXCJzdGFydEFuZ2xlXCIsIFwiZW5kQW5nbGVcIl0sIHMpLCB7IGFuZ2xlOiBkIH0gPSBobihyLCB7IHg6IHQueCwgeTogdC55IH0pO1xuICAgIG9lKGQsIGMsIGgpICYmIG4ucHVzaCh7IGVsZW1lbnQ6IHIsIGRhdGFzZXRJbmRleDogYSwgaW5kZXg6IGwgfSk7XG4gIH1cbiAgcmV0dXJuIF9lKGksIGUsIHQsIG8pLCBuO1xufVxuZnVuY3Rpb24gWWEoaSwgdCwgZSwgcywgbiwgbykge1xuICBsZXQgciA9IFtdO1xuICBjb25zdCBhID0gamEoZSk7XG4gIGxldCBsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBmdW5jdGlvbiBjKGgsIGQsIHUpIHtcbiAgICBjb25zdCBmID0gaC5pblJhbmdlKHQueCwgdC55LCBuKTtcbiAgICBpZiAocyAmJiAhZilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBnID0gaC5nZXRDZW50ZXJQb2ludChuKTtcbiAgICBpZiAoISghIW8gfHwgaS5pc1BvaW50SW5BcmVhKGcpKSAmJiAhZilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBtID0gYSh0LCBnKTtcbiAgICBtIDwgbCA/IChyID0gW3sgZWxlbWVudDogaCwgZGF0YXNldEluZGV4OiBkLCBpbmRleDogdSB9XSwgbCA9IG0pIDogbSA9PT0gbCAmJiByLnB1c2goeyBlbGVtZW50OiBoLCBkYXRhc2V0SW5kZXg6IGQsIGluZGV4OiB1IH0pO1xuICB9XG4gIHJldHVybiBfZShpLCBlLCB0LCBjKSwgcjtcbn1cbmZ1bmN0aW9uIHVpKGksIHQsIGUsIHMsIG4sIG8pIHtcbiAgcmV0dXJuICFvICYmICFpLmlzUG9pbnRJbkFyZWEodCkgPyBbXSA6IGUgPT09IFwiclwiICYmICFzID8gJGEoaSwgdCwgZSwgbikgOiBZYShpLCB0LCBlLCBzLCBuLCBvKTtcbn1cbmZ1bmN0aW9uIENzKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgbyA9IFtdLCByID0gZSA9PT0gXCJ4XCIgPyBcImluWFJhbmdlXCIgOiBcImluWVJhbmdlXCI7XG4gIGxldCBhID0gITE7XG4gIHJldHVybiBfZShpLCBlLCB0LCAobCwgYywgaCkgPT4ge1xuICAgIGxbcl0odFtlXSwgbikgJiYgKG8ucHVzaCh7IGVsZW1lbnQ6IGwsIGRhdGFzZXRJbmRleDogYywgaW5kZXg6IGggfSksIGEgPSBhIHx8IGwuaW5SYW5nZSh0LngsIHQueSwgbikpO1xuICB9KSwgcyAmJiAhYSA/IFtdIDogbztcbn1cbnZhciBIbiA9IHtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zOiBfZSxcbiAgbW9kZXM6IHtcbiAgICBpbmRleChpLCB0LCBlLCBzKSB7XG4gICAgICBjb25zdCBuID0gUHQodCwgaSksIG8gPSBlLmF4aXMgfHwgXCJ4XCIsIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITEsIGEgPSBlLmludGVyc2VjdCA/IGRpKGksIG4sIG8sIHMsIHIpIDogdWkoaSwgbiwgbywgITEsIHMsIHIpLCBsID0gW107XG4gICAgICByZXR1cm4gYS5sZW5ndGggPyAoaS5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBoID0gYVswXS5pbmRleCwgZCA9IGMuZGF0YVtoXTtcbiAgICAgICAgZCAmJiAhZC5za2lwICYmIGwucHVzaCh7IGVsZW1lbnQ6IGQsIGRhdGFzZXRJbmRleDogYy5pbmRleCwgaW5kZXg6IGggfSk7XG4gICAgICB9KSwgbCkgOiBbXTtcbiAgICB9LFxuICAgIGRhdGFzZXQoaSwgdCwgZSwgcykge1xuICAgICAgY29uc3QgbiA9IFB0KHQsIGkpLCBvID0gZS5heGlzIHx8IFwieHlcIiwgciA9IGUuaW5jbHVkZUludmlzaWJsZSB8fCAhMTtcbiAgICAgIGxldCBhID0gZS5pbnRlcnNlY3QgPyBkaShpLCBuLCBvLCBzLCByKSA6IHVpKGksIG4sIG8sICExLCBzLCByKTtcbiAgICAgIGlmIChhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbCA9IGFbMF0uZGF0YXNldEluZGV4LCBjID0gaS5nZXREYXRhc2V0TWV0YShsKS5kYXRhO1xuICAgICAgICBhID0gW107XG4gICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgYy5sZW5ndGg7ICsraClcbiAgICAgICAgICBhLnB1c2goeyBlbGVtZW50OiBjW2hdLCBkYXRhc2V0SW5kZXg6IGwsIGluZGV4OiBoIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcbiAgICBwb2ludChpLCB0LCBlLCBzKSB7XG4gICAgICBjb25zdCBuID0gUHQodCwgaSksIG8gPSBlLmF4aXMgfHwgXCJ4eVwiLCByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExO1xuICAgICAgcmV0dXJuIGRpKGksIG4sIG8sIHMsIHIpO1xuICAgIH0sXG4gICAgbmVhcmVzdChpLCB0LCBlLCBzKSB7XG4gICAgICBjb25zdCBuID0gUHQodCwgaSksIG8gPSBlLmF4aXMgfHwgXCJ4eVwiLCByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExO1xuICAgICAgcmV0dXJuIHVpKGksIG4sIG8sIGUuaW50ZXJzZWN0LCBzLCByKTtcbiAgICB9LFxuICAgIHgoaSwgdCwgZSwgcykge1xuICAgICAgY29uc3QgbiA9IFB0KHQsIGkpO1xuICAgICAgcmV0dXJuIENzKGksIG4sIFwieFwiLCBlLmludGVyc2VjdCwgcyk7XG4gICAgfSxcbiAgICB5KGksIHQsIGUsIHMpIHtcbiAgICAgIGNvbnN0IG4gPSBQdCh0LCBpKTtcbiAgICAgIHJldHVybiBDcyhpLCBuLCBcInlcIiwgZS5pbnRlcnNlY3QsIHMpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGpuID0gW1wibGVmdFwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdO1xuZnVuY3Rpb24gVXQoaSwgdCkge1xuICByZXR1cm4gaS5maWx0ZXIoKGUpID0+IGUucG9zID09PSB0KTtcbn1cbmZ1bmN0aW9uIERzKGksIHQpIHtcbiAgcmV0dXJuIGkuZmlsdGVyKChlKSA9PiBqbi5pbmRleE9mKGUucG9zKSA9PT0gLTEgJiYgZS5ib3guYXhpcyA9PT0gdCk7XG59XG5mdW5jdGlvbiBLdChpLCB0KSB7XG4gIHJldHVybiBpLnNvcnQoKGUsIHMpID0+IHtcbiAgICBjb25zdCBuID0gdCA/IHMgOiBlLCBvID0gdCA/IGUgOiBzO1xuICAgIHJldHVybiBuLndlaWdodCA9PT0gby53ZWlnaHQgPyBuLmluZGV4IC0gby5pbmRleCA6IG4ud2VpZ2h0IC0gby53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gWGEoaSkge1xuICBjb25zdCB0ID0gW107XG4gIGxldCBlLCBzLCBuLCBvLCByLCBhO1xuICBmb3IgKGUgPSAwLCBzID0gKGkgfHwgW10pLmxlbmd0aDsgZSA8IHM7ICsrZSlcbiAgICBuID0gaVtlXSwgeyBwb3NpdGlvbjogbywgb3B0aW9uczogeyBzdGFjazogciwgc3RhY2tXZWlnaHQ6IGEgPSAxIH0gfSA9IG4sIHQucHVzaCh7XG4gICAgICBpbmRleDogZSxcbiAgICAgIGJveDogbixcbiAgICAgIHBvczogbyxcbiAgICAgIGhvcml6b250YWw6IG4uaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IG4ud2VpZ2h0LFxuICAgICAgc3RhY2s6IHIgJiYgbyArIHIsXG4gICAgICBzdGFja1dlaWdodDogYVxuICAgIH0pO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFVhKGkpIHtcbiAgY29uc3QgdCA9IHt9O1xuICBmb3IgKGNvbnN0IGUgb2YgaSkge1xuICAgIGNvbnN0IHsgc3RhY2s6IHMsIHBvczogbiwgc3RhY2tXZWlnaHQ6IG8gfSA9IGU7XG4gICAgaWYgKCFzIHx8ICFqbi5pbmNsdWRlcyhuKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHIgPSB0W3NdIHx8ICh0W3NdID0geyBjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDAgfSk7XG4gICAgci5jb3VudCsrLCByLndlaWdodCArPSBvO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gS2EoaSwgdCkge1xuICBjb25zdCBlID0gVWEoaSksIHsgdkJveE1heFdpZHRoOiBzLCBoQm94TWF4SGVpZ2h0OiBuIH0gPSB0O1xuICBsZXQgbywgciwgYTtcbiAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgYSA9IGlbb107XG4gICAgY29uc3QgeyBmdWxsU2l6ZTogbCB9ID0gYS5ib3gsIGMgPSBlW2Euc3RhY2tdLCBoID0gYyAmJiBhLnN0YWNrV2VpZ2h0IC8gYy53ZWlnaHQ7XG4gICAgYS5ob3Jpem9udGFsID8gKGEud2lkdGggPSBoID8gaCAqIHMgOiBsICYmIHQuYXZhaWxhYmxlV2lkdGgsIGEuaGVpZ2h0ID0gbikgOiAoYS53aWR0aCA9IHMsIGEuaGVpZ2h0ID0gaCA/IGggKiBuIDogbCAmJiB0LmF2YWlsYWJsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxYShpKSB7XG4gIGNvbnN0IHQgPSBYYShpKSwgZSA9IEt0KHQuZmlsdGVyKChjKSA9PiBjLmJveC5mdWxsU2l6ZSksICEwKSwgcyA9IEt0KFV0KHQsIFwibGVmdFwiKSwgITApLCBuID0gS3QoVXQodCwgXCJyaWdodFwiKSksIG8gPSBLdChVdCh0LCBcInRvcFwiKSwgITApLCByID0gS3QoVXQodCwgXCJib3R0b21cIikpLCBhID0gRHModCwgXCJ4XCIpLCBsID0gRHModCwgXCJ5XCIpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplOiBlLFxuICAgIGxlZnRBbmRUb3A6IHMuY29uY2F0KG8pLFxuICAgIHJpZ2h0QW5kQm90dG9tOiBuLmNvbmNhdChsKS5jb25jYXQocikuY29uY2F0KGEpLFxuICAgIGNoYXJ0QXJlYTogVXQodCwgXCJjaGFydEFyZWFcIiksXG4gICAgdmVydGljYWw6IHMuY29uY2F0KG4pLmNvbmNhdChsKSxcbiAgICBob3Jpem9udGFsOiBvLmNvbmNhdChyKS5jb25jYXQoYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIE9zKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGlbZV0sIHRbZV0pICsgTWF0aC5tYXgoaVtzXSwgdFtzXSk7XG59XG5mdW5jdGlvbiAkbihpLCB0KSB7XG4gIGkudG9wID0gTWF0aC5tYXgoaS50b3AsIHQudG9wKSwgaS5sZWZ0ID0gTWF0aC5tYXgoaS5sZWZ0LCB0LmxlZnQpLCBpLmJvdHRvbSA9IE1hdGgubWF4KGkuYm90dG9tLCB0LmJvdHRvbSksIGkucmlnaHQgPSBNYXRoLm1heChpLnJpZ2h0LCB0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIEdhKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBwb3M6IG4sIGJveDogbyB9ID0gZSwgciA9IGkubWF4UGFkZGluZztcbiAgaWYgKCFEKG4pKSB7XG4gICAgZS5zaXplICYmIChpW25dIC09IGUuc2l6ZSk7XG4gICAgY29uc3QgZCA9IHNbZS5zdGFja10gfHwgeyBzaXplOiAwLCBjb3VudDogMSB9O1xuICAgIGQuc2l6ZSA9IE1hdGgubWF4KGQuc2l6ZSwgZS5ob3Jpem9udGFsID8gby5oZWlnaHQgOiBvLndpZHRoKSwgZS5zaXplID0gZC5zaXplIC8gZC5jb3VudCwgaVtuXSArPSBlLnNpemU7XG4gIH1cbiAgby5nZXRQYWRkaW5nICYmICRuKHIsIG8uZ2V0UGFkZGluZygpKTtcbiAgY29uc3QgYSA9IE1hdGgubWF4KDAsIHQub3V0ZXJXaWR0aCAtIE9zKHIsIGksIFwibGVmdFwiLCBcInJpZ2h0XCIpKSwgbCA9IE1hdGgubWF4KDAsIHQub3V0ZXJIZWlnaHQgLSBPcyhyLCBpLCBcInRvcFwiLCBcImJvdHRvbVwiKSksIGMgPSBhICE9PSBpLncsIGggPSBsICE9PSBpLmg7XG4gIHJldHVybiBpLncgPSBhLCBpLmggPSBsLCBlLmhvcml6b250YWwgPyB7IHNhbWU6IGMsIG90aGVyOiBoIH0gOiB7IHNhbWU6IGgsIG90aGVyOiBjIH07XG59XG5mdW5jdGlvbiBaYShpKSB7XG4gIGNvbnN0IHQgPSBpLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIGUocykge1xuICAgIGNvbnN0IG4gPSBNYXRoLm1heCh0W3NdIC0gaVtzXSwgMCk7XG4gICAgcmV0dXJuIGlbc10gKz0gbiwgbjtcbiAgfVxuICBpLnkgKz0gZShcInRvcFwiKSwgaS54ICs9IGUoXCJsZWZ0XCIpLCBlKFwicmlnaHRcIiksIGUoXCJib3R0b21cIik7XG59XG5mdW5jdGlvbiBKYShpLCB0KSB7XG4gIGNvbnN0IGUgPSB0Lm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIGNvbnN0IG8gPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xuICAgIHJldHVybiBuLmZvckVhY2goKHIpID0+IHtcbiAgICAgIG9bcl0gPSBNYXRoLm1heCh0W3JdLCBlW3JdKTtcbiAgICB9KSwgbztcbiAgfVxuICByZXR1cm4gcyhpID8gW1wibGVmdFwiLCBcInJpZ2h0XCJdIDogW1widG9wXCIsIFwiYm90dG9tXCJdKTtcbn1cbmZ1bmN0aW9uIEp0KGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBsZXQgbywgciwgYSwgbCwgYywgaDtcbiAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoLCBjID0gMDsgbyA8IHI7ICsrbykge1xuICAgIGEgPSBpW29dLCBsID0gYS5ib3gsIGwudXBkYXRlKFxuICAgICAgYS53aWR0aCB8fCB0LncsXG4gICAgICBhLmhlaWdodCB8fCB0LmgsXG4gICAgICBKYShhLmhvcml6b250YWwsIHQpXG4gICAgKTtcbiAgICBjb25zdCB7IHNhbWU6IGQsIG90aGVyOiB1IH0gPSBHYSh0LCBlLCBhLCBzKTtcbiAgICBjIHw9IGQgJiYgbi5sZW5ndGgsIGggPSBoIHx8IHUsIGwuZnVsbFNpemUgfHwgbi5wdXNoKGEpO1xuICB9XG4gIHJldHVybiBjICYmIEp0KG4sIHQsIGUsIHMpIHx8IGg7XG59XG5mdW5jdGlvbiBUZShpLCB0LCBlLCBzLCBuKSB7XG4gIGkudG9wID0gZSwgaS5sZWZ0ID0gdCwgaS5yaWdodCA9IHQgKyBzLCBpLmJvdHRvbSA9IGUgKyBuLCBpLndpZHRoID0gcywgaS5oZWlnaHQgPSBuO1xufVxuZnVuY3Rpb24gQXMoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gZS5wYWRkaW5nO1xuICBsZXQgeyB4OiBvLCB5OiByIH0gPSB0O1xuICBmb3IgKGNvbnN0IGEgb2YgaSkge1xuICAgIGNvbnN0IGwgPSBhLmJveCwgYyA9IHNbYS5zdGFja10gfHwgeyBjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDEgfSwgaCA9IGEuc3RhY2tXZWlnaHQgLyBjLndlaWdodCB8fCAxO1xuICAgIGlmIChhLmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IGQgPSB0LncgKiBoLCB1ID0gYy5zaXplIHx8IGwuaGVpZ2h0O1xuICAgICAgZXQoYy5zdGFydCkgJiYgKHIgPSBjLnN0YXJ0KSwgbC5mdWxsU2l6ZSA/IFRlKGwsIG4ubGVmdCwgciwgZS5vdXRlcldpZHRoIC0gbi5yaWdodCAtIG4ubGVmdCwgdSkgOiBUZShsLCB0LmxlZnQgKyBjLnBsYWNlZCwgciwgZCwgdSksIGMuc3RhcnQgPSByLCBjLnBsYWNlZCArPSBkLCByID0gbC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGQgPSB0LmggKiBoLCB1ID0gYy5zaXplIHx8IGwud2lkdGg7XG4gICAgICBldChjLnN0YXJ0KSAmJiAobyA9IGMuc3RhcnQpLCBsLmZ1bGxTaXplID8gVGUobCwgbywgbi50b3AsIHUsIGUub3V0ZXJIZWlnaHQgLSBuLmJvdHRvbSAtIG4udG9wKSA6IFRlKGwsIG8sIHQudG9wICsgYy5wbGFjZWQsIHUsIGQpLCBjLnN0YXJ0ID0gbywgYy5wbGFjZWQgKz0gZCwgbyA9IGwucmlnaHQ7XG4gICAgfVxuICB9XG4gIHQueCA9IG8sIHQueSA9IHI7XG59XG5PLnNldChcImxheW91dFwiLCB7XG4gIGF1dG9QYWRkaW5nOiAhMCxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcbnZhciBYID0ge1xuICBhZGRCb3goaSwgdCkge1xuICAgIGkuYm94ZXMgfHwgKGkuYm94ZXMgPSBbXSksIHQuZnVsbFNpemUgPSB0LmZ1bGxTaXplIHx8ICExLCB0LnBvc2l0aW9uID0gdC5wb3NpdGlvbiB8fCBcInRvcFwiLCB0LndlaWdodCA9IHQud2VpZ2h0IHx8IDAsIHQuX2xheWVycyA9IHQuX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGUpIHtcbiAgICAgICAgICB0LmRyYXcoZSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH0sIGkuYm94ZXMucHVzaCh0KTtcbiAgfSxcbiAgcmVtb3ZlQm94KGksIHQpIHtcbiAgICBjb25zdCBlID0gaS5ib3hlcyA/IGkuYm94ZXMuaW5kZXhPZih0KSA6IC0xO1xuICAgIGUgIT09IC0xICYmIGkuYm94ZXMuc3BsaWNlKGUsIDEpO1xuICB9LFxuICBjb25maWd1cmUoaSwgdCwgZSkge1xuICAgIHQuZnVsbFNpemUgPSBlLmZ1bGxTaXplLCB0LnBvc2l0aW9uID0gZS5wb3NpdGlvbiwgdC53ZWlnaHQgPSBlLndlaWdodDtcbiAgfSxcbiAgdXBkYXRlKGksIHQsIGUsIHMpIHtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IEsoaS5vcHRpb25zLmxheW91dC5wYWRkaW5nKSwgbyA9IE1hdGgubWF4KHQgLSBuLndpZHRoLCAwKSwgciA9IE1hdGgubWF4KGUgLSBuLmhlaWdodCwgMCksIGEgPSBxYShpLmJveGVzKSwgbCA9IGEudmVydGljYWwsIGMgPSBhLmhvcml6b250YWw7XG4gICAgRShpLmJveGVzLCAocCkgPT4ge1xuICAgICAgdHlwZW9mIHAuYmVmb3JlTGF5b3V0ID09IFwiZnVuY3Rpb25cIiAmJiBwLmJlZm9yZUxheW91dCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGggPSBsLnJlZHVjZSgocCwgbSkgPT4gbS5ib3gub3B0aW9ucyAmJiBtLmJveC5vcHRpb25zLmRpc3BsYXkgPT09ICExID8gcCA6IHAgKyAxLCAwKSB8fCAxLCBkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB0LFxuICAgICAgb3V0ZXJIZWlnaHQ6IGUsXG4gICAgICBwYWRkaW5nOiBuLFxuICAgICAgYXZhaWxhYmxlV2lkdGg6IG8sXG4gICAgICBhdmFpbGFibGVIZWlnaHQ6IHIsXG4gICAgICB2Qm94TWF4V2lkdGg6IG8gLyAyIC8gaCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IHIgLyAyXG4gICAgfSksIHUgPSBPYmplY3QuYXNzaWduKHt9LCBuKTtcbiAgICAkbih1LCBLKHMpKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nOiB1LFxuICAgICAgdzogbyxcbiAgICAgIGg6IHIsXG4gICAgICB4OiBuLmxlZnQsXG4gICAgICB5OiBuLnRvcFxuICAgIH0sIG4pLCBnID0gS2EobC5jb25jYXQoYyksIGQpO1xuICAgIEp0KGEuZnVsbFNpemUsIGYsIGQsIGcpLCBKdChsLCBmLCBkLCBnKSwgSnQoYywgZiwgZCwgZykgJiYgSnQobCwgZiwgZCwgZyksIFphKGYpLCBBcyhhLmxlZnRBbmRUb3AsIGYsIGQsIGcpLCBmLnggKz0gZi53LCBmLnkgKz0gZi5oLCBBcyhhLnJpZ2h0QW5kQm90dG9tLCBmLCBkLCBnKSwgaS5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBmLmxlZnQsXG4gICAgICB0b3A6IGYudG9wLFxuICAgICAgcmlnaHQ6IGYubGVmdCArIGYudyxcbiAgICAgIGJvdHRvbTogZi50b3AgKyBmLmgsXG4gICAgICBoZWlnaHQ6IGYuaCxcbiAgICAgIHdpZHRoOiBmLndcbiAgICB9LCBFKGEuY2hhcnRBcmVhLCAocCkgPT4ge1xuICAgICAgY29uc3QgbSA9IHAuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihtLCBpLmNoYXJ0QXJlYSksIG0udXBkYXRlKGYudywgZi5oLCB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmNsYXNzIEhpIHtcbiAgYWNxdWlyZUNvbnRleHQodCwgZSkge1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KHQpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBzKSB7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlLCBzKSB7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZSh0LCBlLCBzLCBuKSB7XG4gICAgcmV0dXJuIGUgPSBNYXRoLm1heCgwLCBlIHx8IHQud2lkdGgpLCBzID0gcyB8fCB0LmhlaWdodCwge1xuICAgICAgd2lkdGg6IGUsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG4gPyBNYXRoLmZsb29yKGUgLyBuKSA6IHMpXG4gICAgfTtcbiAgfVxuICBpc0F0dGFjaGVkKHQpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKHQpIHtcbiAgfVxufVxuY2xhc3MgWW4gZXh0ZW5kcyBIaSB7XG4gIGFjcXVpcmVDb250ZXh0KHQpIHtcbiAgICByZXR1cm4gdCAmJiB0LmdldENvbnRleHQgJiYgdC5nZXRDb250ZXh0KFwiMmRcIikgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcodCkge1xuICAgIHQub3B0aW9ucy5hbmltYXRpb24gPSAhMTtcbiAgfVxufVxuY29uc3QgSWUgPSBcIiRjaGFydGpzXCIsIFFhID0ge1xuICB0b3VjaHN0YXJ0OiBcIm1vdXNlZG93blwiLFxuICB0b3VjaG1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gIHRvdWNoZW5kOiBcIm1vdXNldXBcIixcbiAgcG9pbnRlcmVudGVyOiBcIm1vdXNlZW50ZXJcIixcbiAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICBwb2ludGVybGVhdmU6IFwibW91c2VvdXRcIixcbiAgcG9pbnRlcm91dDogXCJtb3VzZW91dFwiXG59LCBUcyA9IChpKSA9PiBpID09PSBudWxsIHx8IGkgPT09IFwiXCI7XG5mdW5jdGlvbiB0bChpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLnN0eWxlLCBzID0gaS5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiksIG4gPSBpLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICBpZiAoaVtJZV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiBzLFxuICAgICAgd2lkdGg6IG4sXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9LCBlLmRpc3BsYXkgPSBlLmRpc3BsYXkgfHwgXCJibG9ja1wiLCBlLmJveFNpemluZyA9IGUuYm94U2l6aW5nIHx8IFwiYm9yZGVyLWJveFwiLCBUcyhuKSkge1xuICAgIGNvbnN0IG8gPSBjcyhpLCBcIndpZHRoXCIpO1xuICAgIG8gIT09IHZvaWQgMCAmJiAoaS53aWR0aCA9IG8pO1xuICB9XG4gIGlmIChUcyhzKSlcbiAgICBpZiAoaS5zdHlsZS5oZWlnaHQgPT09IFwiXCIpXG4gICAgICBpLmhlaWdodCA9IGkud2lkdGggLyAodCB8fCAyKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSBjcyhpLCBcImhlaWdodFwiKTtcbiAgICAgIG8gIT09IHZvaWQgMCAmJiAoaS5oZWlnaHQgPSBvKTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuY29uc3QgWG4gPSBWciA/IHsgcGFzc2l2ZTogITAgfSA6ICExO1xuZnVuY3Rpb24gZWwoaSwgdCwgZSkge1xuICBpLmFkZEV2ZW50TGlzdGVuZXIodCwgZSwgWG4pO1xufVxuZnVuY3Rpb24gaWwoaSwgdCwgZSkge1xuICBpLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGUsIFhuKTtcbn1cbmZ1bmN0aW9uIHNsKGksIHQpIHtcbiAgY29uc3QgZSA9IFFhW2kudHlwZV0gfHwgaS50eXBlLCB7IHg6IHMsIHk6IG4gfSA9IFB0KGksIHQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGUsXG4gICAgY2hhcnQ6IHQsXG4gICAgbmF0aXZlOiBpLFxuICAgIHg6IHMgIT09IHZvaWQgMCA/IHMgOiBudWxsLFxuICAgIHk6IG4gIT09IHZvaWQgMCA/IG4gOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBqZShpLCB0KSB7XG4gIGZvciAoY29uc3QgZSBvZiBpKVxuICAgIGlmIChlID09PSB0IHx8IGUuY29udGFpbnModCkpXG4gICAgICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBubChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLmNhbnZhcywgbiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChvKSA9PiB7XG4gICAgbGV0IHIgPSAhMTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgbylcbiAgICAgIHIgPSByIHx8IGplKGEuYWRkZWROb2RlcywgcyksIHIgPSByICYmICFqZShhLnJlbW92ZWROb2Rlcywgcyk7XG4gICAgciAmJiBlKCk7XG4gIH0pO1xuICByZXR1cm4gbi5vYnNlcnZlKGRvY3VtZW50LCB7IGNoaWxkTGlzdDogITAsIHN1YnRyZWU6ICEwIH0pLCBuO1xufVxuZnVuY3Rpb24gb2woaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5jYW52YXMsIG4gPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobykgPT4ge1xuICAgIGxldCByID0gITE7XG4gICAgZm9yIChjb25zdCBhIG9mIG8pXG4gICAgICByID0gciB8fCBqZShhLnJlbW92ZWROb2RlcywgcyksIHIgPSByICYmICFqZShhLmFkZGVkTm9kZXMsIHMpO1xuICAgIHIgJiYgZSgpO1xuICB9KTtcbiAgcmV0dXJuIG4ub2JzZXJ2ZShkb2N1bWVudCwgeyBjaGlsZExpc3Q6ICEwLCBzdWJ0cmVlOiAhMCB9KSwgbjtcbn1cbmNvbnN0IGxlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmxldCBMcyA9IDA7XG5mdW5jdGlvbiBVbigpIHtcbiAgY29uc3QgaSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpICE9PSBMcyAmJiAoTHMgPSBpLCBsZS5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgZS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gaSAmJiB0KCk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHJsKGksIHQpIHtcbiAgbGUuc2l6ZSB8fCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBVbiksIGxlLnNldChpLCB0KTtcbn1cbmZ1bmN0aW9uIGFsKGkpIHtcbiAgbGUuZGVsZXRlKGkpLCBsZS5zaXplIHx8IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIFVuKTtcbn1cbmZ1bmN0aW9uIGxsKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuY2FudmFzLCBuID0gcyAmJiBXaShzKTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgY29uc3QgbyA9IGduKChhLCBsKSA9PiB7XG4gICAgY29uc3QgYyA9IG4uY2xpZW50V2lkdGg7XG4gICAgZShhLCBsKSwgYyA8IG4uY2xpZW50V2lkdGggJiYgZSgpO1xuICB9LCB3aW5kb3cpLCByID0gbmV3IFJlc2l6ZU9ic2VydmVyKChhKSA9PiB7XG4gICAgY29uc3QgbCA9IGFbMF0sIGMgPSBsLmNvbnRlbnRSZWN0LndpZHRoLCBoID0gbC5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgYyA9PT0gMCAmJiBoID09PSAwIHx8IG8oYywgaCk7XG4gIH0pO1xuICByZXR1cm4gci5vYnNlcnZlKG4pLCBybChpLCBvKSwgcjtcbn1cbmZ1bmN0aW9uIGZpKGksIHQsIGUpIHtcbiAgZSAmJiBlLmRpc2Nvbm5lY3QoKSwgdCA9PT0gXCJyZXNpemVcIiAmJiBhbChpKTtcbn1cbmZ1bmN0aW9uIGNsKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuY2FudmFzLCBuID0gZ24oKG8pID0+IHtcbiAgICBpLmN0eCAhPT0gbnVsbCAmJiBlKHNsKG8sIGkpKTtcbiAgfSwgaSwgKG8pID0+IHtcbiAgICBjb25zdCByID0gb1swXTtcbiAgICByZXR1cm4gW3IsIHIub2Zmc2V0WCwgci5vZmZzZXRZXTtcbiAgfSk7XG4gIHJldHVybiBlbChzLCB0LCBuKSwgbjtcbn1cbmNsYXNzIEtuIGV4dGVuZHMgSGkge1xuICBhY3F1aXJlQ29udGV4dCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQgJiYgdC5nZXRDb250ZXh0ICYmIHQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHJldHVybiBzICYmIHMuY2FudmFzID09PSB0ID8gKHRsKHQsIGUpLCBzKSA6IG51bGw7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQodCkge1xuICAgIGNvbnN0IGUgPSB0LmNhbnZhcztcbiAgICBpZiAoIWVbSWVdKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHMgPSBlW0llXS5pbml0aWFsO1xuICAgIFtcImhlaWdodFwiLCBcIndpZHRoXCJdLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBzW29dO1xuICAgICAgVChyKSA/IGUucmVtb3ZlQXR0cmlidXRlKG8pIDogZS5zZXRBdHRyaWJ1dGUobywgcik7XG4gICAgfSk7XG4gICAgY29uc3QgbiA9IHMuc3R5bGUgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGUuc3R5bGVbb10gPSBuW29dO1xuICAgIH0pLCBlLndpZHRoID0gZS53aWR0aCwgZGVsZXRlIGVbSWVdLCAhMDtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHQsIGUsIHMpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSk7XG4gICAgY29uc3QgbiA9IHQuJHByb3hpZXMgfHwgKHQuJHByb3hpZXMgPSB7fSksIHIgPSB7XG4gICAgICBhdHRhY2g6IG5sLFxuICAgICAgZGV0YWNoOiBvbCxcbiAgICAgIHJlc2l6ZTogbGxcbiAgICB9W2VdIHx8IGNsO1xuICAgIG5bZV0gPSByKHQsIGUsIHMpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0LiRwcm94aWVzIHx8ICh0LiRwcm94aWVzID0ge30pLCBuID0gc1tlXTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgKHtcbiAgICAgIGF0dGFjaDogZmksXG4gICAgICBkZXRhY2g6IGZpLFxuICAgICAgcmVzaXplOiBmaVxuICAgIH1bZV0gfHwgaWwpKHQsIGUsIG4pLCBzW2VdID0gdm9pZCAwO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKHQsIGUsIHMsIG4pIHtcbiAgICByZXR1cm4gQnIodCwgZSwgcywgbik7XG4gIH1cbiAgaXNBdHRhY2hlZCh0KSB7XG4gICAgY29uc3QgZSA9IFdpKHQpO1xuICAgIHJldHVybiAhIShlICYmIGUuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5mdW5jdGlvbiBxbihpKSB7XG4gIHJldHVybiAhQW4oKSB8fCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzIDwgXCJ1XCIgJiYgaSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyA/IFluIDogS247XG59XG5jbGFzcyBobCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkodCwgZSwgcywgbikge1xuICAgIGUgPT09IFwiYmVmb3JlSW5pdFwiICYmICh0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnModCwgITApLCB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgdCwgXCJpbnN0YWxsXCIpKTtcbiAgICBjb25zdCBvID0gbiA/IHRoaXMuX2Rlc2NyaXB0b3JzKHQpLmZpbHRlcihuKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKHQpLCByID0gdGhpcy5fbm90aWZ5KG8sIHQsIGUsIHMpO1xuICAgIHJldHVybiBlID09PSBcImFmdGVyRGVzdHJveVwiICYmICh0aGlzLl9ub3RpZnkobywgdCwgXCJzdG9wXCIpLCB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgdCwgXCJ1bmluc3RhbGxcIikpLCByO1xuICB9XG4gIF9ub3RpZnkodCwgZSwgcywgbikge1xuICAgIG4gPSBuIHx8IHt9O1xuICAgIGZvciAoY29uc3QgbyBvZiB0KSB7XG4gICAgICBjb25zdCByID0gby5wbHVnaW4sIGEgPSByW3NdLCBsID0gW2UsIG4sIG8ub3B0aW9uc107XG4gICAgICBpZiAoSShhLCBsLCByKSA9PT0gITEgJiYgbi5jYW5jZWxhYmxlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIFQodGhpcy5fY2FjaGUpIHx8ICh0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlLCB0aGlzLl9jYWNoZSA9IHZvaWQgMCk7XG4gIH1cbiAgX2Rlc2NyaXB0b3JzKHQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnModCk7XG4gICAgcmV0dXJuIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyh0KSwgZTtcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0ICYmIHQuY29uZmlnLCBuID0gQyhzLm9wdGlvbnMgJiYgcy5vcHRpb25zLnBsdWdpbnMsIHt9KSwgbyA9IGRsKHMpO1xuICAgIHJldHVybiBuID09PSAhMSAmJiAhZSA/IFtdIDogZmwodCwgbywgbiwgZSk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29sZENhY2hlIHx8IFtdLCBzID0gdGhpcy5fY2FjaGUsIG4gPSAobywgcikgPT4gby5maWx0ZXIoKGEpID0+ICFyLnNvbWUoKGwpID0+IGEucGx1Z2luLmlkID09PSBsLnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShuKGUsIHMpLCB0LCBcInN0b3BcIiksIHRoaXMuX25vdGlmeShuKHMsIGUpLCB0LCBcInN0YXJ0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBkbChpKSB7XG4gIGNvbnN0IHQgPSB7fSwgZSA9IFtdLCBzID0gT2JqZWN0LmtleXMob3QucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICBlLnB1c2gob3QuZ2V0UGx1Z2luKHNbb10pKTtcbiAgY29uc3QgbiA9IGkucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKSB7XG4gICAgY29uc3QgciA9IG5bb107XG4gICAgZS5pbmRleE9mKHIpID09PSAtMSAmJiAoZS5wdXNoKHIpLCB0W3IuaWRdID0gITApO1xuICB9XG4gIHJldHVybiB7IHBsdWdpbnM6IGUsIGxvY2FsSWRzOiB0IH07XG59XG5mdW5jdGlvbiB1bChpLCB0KSB7XG4gIHJldHVybiAhdCAmJiBpID09PSAhMSA/IG51bGwgOiBpID09PSAhMCA/IHt9IDogaTtcbn1cbmZ1bmN0aW9uIGZsKGksIHsgcGx1Z2luczogdCwgbG9jYWxJZHM6IGUgfSwgcywgbikge1xuICBjb25zdCBvID0gW10sIHIgPSBpLmdldENvbnRleHQoKTtcbiAgZm9yIChjb25zdCBhIG9mIHQpIHtcbiAgICBjb25zdCBsID0gYS5pZCwgYyA9IHVsKHNbbF0sIG4pO1xuICAgIGMgIT09IG51bGwgJiYgby5wdXNoKHtcbiAgICAgIHBsdWdpbjogYSxcbiAgICAgIG9wdGlvbnM6IGdsKGkuY29uZmlnLCB7IHBsdWdpbjogYSwgbG9jYWw6IGVbbF0gfSwgYywgcilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGdsKGksIHsgcGx1Z2luOiB0LCBsb2NhbDogZSB9LCBzLCBuKSB7XG4gIGNvbnN0IG8gPSBpLnBsdWdpblNjb3BlS2V5cyh0KSwgciA9IGkuZ2V0T3B0aW9uU2NvcGVzKHMsIG8pO1xuICByZXR1cm4gZSAmJiB0LmRlZmF1bHRzICYmIHIucHVzaCh0LmRlZmF1bHRzKSwgaS5jcmVhdGVSZXNvbHZlcihyLCBuLCBbXCJcIl0sIHtcbiAgICBzY3JpcHRhYmxlOiAhMSxcbiAgICBpbmRleGFibGU6ICExLFxuICAgIGFsbEtleXM6ICEwXG4gIH0pO1xufVxuZnVuY3Rpb24gTWkoaSwgdCkge1xuICBjb25zdCBlID0gTy5kYXRhc2V0c1tpXSB8fCB7fTtcbiAgcmV0dXJuICgodC5kYXRhc2V0cyB8fCB7fSlbaV0gfHwge30pLmluZGV4QXhpcyB8fCB0LmluZGV4QXhpcyB8fCBlLmluZGV4QXhpcyB8fCBcInhcIjtcbn1cbmZ1bmN0aW9uIHBsKGksIHQpIHtcbiAgbGV0IGUgPSBpO1xuICByZXR1cm4gaSA9PT0gXCJfaW5kZXhfXCIgPyBlID0gdCA6IGkgPT09IFwiX3ZhbHVlX1wiICYmIChlID0gdCA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiKSwgZTtcbn1cbmZ1bmN0aW9uIG1sKGksIHQpIHtcbiAgcmV0dXJuIGkgPT09IHQgPyBcIl9pbmRleF9cIiA6IFwiX3ZhbHVlX1wiO1xufVxuZnVuY3Rpb24gYmwoaSkge1xuICBpZiAoaSA9PT0gXCJ0b3BcIiB8fCBpID09PSBcImJvdHRvbVwiKVxuICAgIHJldHVybiBcInhcIjtcbiAgaWYgKGkgPT09IFwibGVmdFwiIHx8IGkgPT09IFwicmlnaHRcIilcbiAgICByZXR1cm4gXCJ5XCI7XG59XG5mdW5jdGlvbiBraShpLCB0KSB7XG4gIHJldHVybiBpID09PSBcInhcIiB8fCBpID09PSBcInlcIiA/IGkgOiB0LmF4aXMgfHwgYmwodC5wb3NpdGlvbikgfHwgaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHhsKGksIHQpIHtcbiAgY29uc3QgZSA9IEF0W2kudHlwZV0gfHwgeyBzY2FsZXM6IHt9IH0sIHMgPSB0LnNjYWxlcyB8fCB7fSwgbiA9IE1pKGkudHlwZSwgdCksIG8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gT2JqZWN0LmtleXMocykuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGwgPSBzW2FdO1xuICAgIGlmICghRChsKSlcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2F9YCk7XG4gICAgaWYgKGwuX3Byb3h5KVxuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2F9YCk7XG4gICAgY29uc3QgYyA9IGtpKGEsIGwpLCBoID0gbWwoYywgbiksIGQgPSBlLnNjYWxlcyB8fCB7fTtcbiAgICBvW2NdID0gb1tjXSB8fCBhLCByW2FdID0gUXQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIFt7IGF4aXM6IGMgfSwgbCwgZFtjXSwgZFtoXV0pO1xuICB9KSwgaS5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGEpID0+IHtcbiAgICBjb25zdCBsID0gYS50eXBlIHx8IGkudHlwZSwgYyA9IGEuaW5kZXhBeGlzIHx8IE1pKGwsIHQpLCBkID0gKEF0W2xdIHx8IHt9KS5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZCkuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgY29uc3QgZiA9IHBsKHUsIGMpLCBnID0gYVtmICsgXCJBeGlzSURcIl0gfHwgb1tmXSB8fCBmO1xuICAgICAgcltnXSA9IHJbZ10gfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIFF0KHJbZ10sIFt7IGF4aXM6IGYgfSwgc1tnXSwgZFt1XV0pO1xuICAgIH0pO1xuICB9KSwgT2JqZWN0LmtleXMocikuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGwgPSByW2FdO1xuICAgIFF0KGwsIFtPLnNjYWxlc1tsLnR5cGVdLCBPLnNjYWxlXSk7XG4gIH0pLCByO1xufVxuZnVuY3Rpb24gR24oaSkge1xuICBjb25zdCB0ID0gaS5vcHRpb25zIHx8IChpLm9wdGlvbnMgPSB7fSk7XG4gIHQucGx1Z2lucyA9IEModC5wbHVnaW5zLCB7fSksIHQuc2NhbGVzID0geGwoaSwgdCk7XG59XG5mdW5jdGlvbiBabihpKSB7XG4gIHJldHVybiBpID0gaSB8fCB7fSwgaS5kYXRhc2V0cyA9IGkuZGF0YXNldHMgfHwgW10sIGkubGFiZWxzID0gaS5sYWJlbHMgfHwgW10sIGk7XG59XG5mdW5jdGlvbiBfbChpKSB7XG4gIHJldHVybiBpID0gaSB8fCB7fSwgaS5kYXRhID0gWm4oaS5kYXRhKSwgR24oaSksIGk7XG59XG5jb25zdCBScyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIEpuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIExlKGksIHQpIHtcbiAgbGV0IGUgPSBScy5nZXQoaSk7XG4gIHJldHVybiBlIHx8IChlID0gdCgpLCBScy5zZXQoaSwgZSksIEpuLmFkZChlKSksIGU7XG59XG5jb25zdCBxdCA9IChpLCB0LCBlKSA9PiB7XG4gIGNvbnN0IHMgPSBfdCh0LCBlKTtcbiAgcyAhPT0gdm9pZCAwICYmIGkuYWRkKHMpO1xufTtcbmNsYXNzIHlsIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuX2NvbmZpZyA9IF9sKHQpLCB0aGlzLl9zY29wZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG4gIHNldCB0eXBlKHQpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHQ7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKHQpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IFpuKHQpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyh0KSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSB0O1xuICB9XG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKSwgR24odCk7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCksIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKHQpIHtcbiAgICByZXR1cm4gTGUoXG4gICAgICB0LFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7dH1gLFxuICAgICAgICBcIlwiXG4gICAgICBdXVxuICAgICk7XG4gIH1cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0LCBlKSB7XG4gICAgcmV0dXJuIExlKFxuICAgICAgYCR7dH0udHJhbnNpdGlvbi4ke2V9YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke3R9LnRyYW5zaXRpb25zLiR7ZX1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke2V9YFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7dH1gLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgXVxuICAgICAgXVxuICAgICk7XG4gIH1cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXModCwgZSkge1xuICAgIHJldHVybiBMZShcbiAgICAgIGAke3R9LSR7ZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7dH0uZWxlbWVudHMuJHtlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke3R9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZX1gLFxuICAgICAgICBcIlwiXG4gICAgICBdXVxuICAgICk7XG4gIH1cbiAgcGx1Z2luU2NvcGVLZXlzKHQpIHtcbiAgICBjb25zdCBlID0gdC5pZCwgcyA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gTGUoXG4gICAgICBgJHtzfS1wbHVnaW4tJHtlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2V9YCxcbiAgICAgICAgLi4udC5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdXG4gICAgICBdXVxuICAgICk7XG4gIH1cbiAgX2NhY2hlZFNjb3Blcyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IG4gPSBzLmdldCh0KTtcbiAgICByZXR1cm4gKCFuIHx8IGUpICYmIChuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcy5zZXQodCwgbikpLCBuO1xuICB9XG4gIGdldE9wdGlvblNjb3Blcyh0LCBlLCBzKSB7XG4gICAgY29uc3QgeyBvcHRpb25zOiBuLCB0eXBlOiBvIH0gPSB0aGlzLCByID0gdGhpcy5fY2FjaGVkU2NvcGVzKHQsIHMpLCBhID0gci5nZXQoZSk7XG4gICAgaWYgKGEpXG4gICAgICByZXR1cm4gYTtcbiAgICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBlLmZvckVhY2goKGgpID0+IHtcbiAgICAgIHQgJiYgKGwuYWRkKHQpLCBoLmZvckVhY2goKGQpID0+IHF0KGwsIHQsIGQpKSksIGguZm9yRWFjaCgoZCkgPT4gcXQobCwgbiwgZCkpLCBoLmZvckVhY2goKGQpID0+IHF0KGwsIEF0W29dIHx8IHt9LCBkKSksIGguZm9yRWFjaCgoZCkgPT4gcXQobCwgTywgZCkpLCBoLmZvckVhY2goKGQpID0+IHF0KGwsIF9pLCBkKSk7XG4gICAgfSk7XG4gICAgY29uc3QgYyA9IEFycmF5LmZyb20obCk7XG4gICAgcmV0dXJuIGMubGVuZ3RoID09PSAwICYmIGMucHVzaCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSksIEpuLmhhcyhlKSAmJiByLnNldChlLCBjKSwgYztcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHQsIHR5cGU6IGUgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHQsXG4gICAgICBBdFtlXSB8fCB7fSxcbiAgICAgIE8uZGF0YXNldHNbZV0gfHwge30sXG4gICAgICB7IHR5cGU6IGUgfSxcbiAgICAgIE8sXG4gICAgICBfaVxuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyh0LCBlLCBzLCBuID0gW1wiXCJdKSB7XG4gICAgY29uc3QgbyA9IHsgJHNoYXJlZDogITAgfSwgeyByZXNvbHZlcjogciwgc3ViUHJlZml4ZXM6IGEgfSA9IEVzKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHQsIG4pO1xuICAgIGxldCBsID0gcjtcbiAgICBpZiAoTWwociwgZSkpIHtcbiAgICAgIG8uJHNoYXJlZCA9ICExLCBzID0geXQocykgPyBzKCkgOiBzO1xuICAgICAgY29uc3QgYyA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIodCwgcywgYSk7XG4gICAgICBsID0gVnQociwgcywgYyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYyBvZiBlKVxuICAgICAgb1tjXSA9IGxbY107XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgY3JlYXRlUmVzb2x2ZXIodCwgZSwgcyA9IFtcIlwiXSwgbikge1xuICAgIGNvbnN0IHsgcmVzb2x2ZXI6IG8gfSA9IEVzKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHQsIHMpO1xuICAgIHJldHVybiBEKGUpID8gVnQobywgZSwgdm9pZCAwLCBuKSA6IG87XG4gIH1cbn1cbmZ1bmN0aW9uIEVzKGksIHQsIGUpIHtcbiAgbGV0IHMgPSBpLmdldCh0KTtcbiAgcyB8fCAocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGkuc2V0KHQsIHMpKTtcbiAgY29uc3QgbiA9IGUuam9pbigpO1xuICBsZXQgbyA9IHMuZ2V0KG4pO1xuICByZXR1cm4gbyB8fCAobyA9IHtcbiAgICByZXNvbHZlcjogemkodCwgZSksXG4gICAgc3ViUHJlZml4ZXM6IGUuZmlsdGVyKChhKSA9PiAhYS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiaG92ZXJcIikpXG4gIH0sIHMuc2V0KG4sIG8pKSwgbztcbn1cbmNvbnN0IHZsID0gKGkpID0+IEQoaSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSkucmVkdWNlKCh0LCBlKSA9PiB0IHx8IHl0KGlbZV0pLCAhMSk7XG5mdW5jdGlvbiBNbChpLCB0KSB7XG4gIGNvbnN0IHsgaXNTY3JpcHRhYmxlOiBlLCBpc0luZGV4YWJsZTogcyB9ID0gd24oaSk7XG4gIGZvciAoY29uc3QgbiBvZiB0KSB7XG4gICAgY29uc3QgbyA9IGUobiksIHIgPSBzKG4pLCBhID0gKHIgfHwgbykgJiYgaVtuXTtcbiAgICBpZiAobyAmJiAoeXQoYSkgfHwgdmwoYSkpIHx8IHIgJiYgeihhKSlcbiAgICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIga2wgPSBcIjMuOS4xXCI7XG5jb25zdCB3bCA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImNoYXJ0QXJlYVwiXTtcbmZ1bmN0aW9uIEZzKGksIHQpIHtcbiAgcmV0dXJuIGkgPT09IFwidG9wXCIgfHwgaSA9PT0gXCJib3R0b21cIiB8fCB3bC5pbmRleE9mKGkpID09PSAtMSAmJiB0ID09PSBcInhcIjtcbn1cbmZ1bmN0aW9uIElzKGksIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIHMpIHtcbiAgICByZXR1cm4gZVtpXSA9PT0gc1tpXSA/IGVbdF0gLSBzW3RdIDogZVtpXSAtIHNbaV07XG4gIH07XG59XG5mdW5jdGlvbiB6cyhpKSB7XG4gIGNvbnN0IHQgPSBpLmNoYXJ0LCBlID0gdC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgdC5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJSZW5kZXJcIiksIEkoZSAmJiBlLm9uQ29tcGxldGUsIFtpXSwgdCk7XG59XG5mdW5jdGlvbiBTbChpKSB7XG4gIGNvbnN0IHQgPSBpLmNoYXJ0LCBlID0gdC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgSShlICYmIGUub25Qcm9ncmVzcywgW2ldLCB0KTtcbn1cbmZ1bmN0aW9uIFFuKGkpIHtcbiAgcmV0dXJuIEFuKCkgJiYgdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IGkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpKSA6IGkgJiYgaS5sZW5ndGggJiYgKGkgPSBpWzBdKSwgaSAmJiBpLmNhbnZhcyAmJiAoaSA9IGkuY2FudmFzKSwgaTtcbn1cbmNvbnN0ICRlID0ge30sIHRvID0gKGkpID0+IHtcbiAgY29uc3QgdCA9IFFuKGkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcygkZSkuZmlsdGVyKChlKSA9PiBlLmNhbnZhcyA9PT0gdCkucG9wKCk7XG59O1xuZnVuY3Rpb24gUGwoaSwgdCwgZSkge1xuICBjb25zdCBzID0gT2JqZWN0LmtleXMoaSk7XG4gIGZvciAoY29uc3QgbiBvZiBzKSB7XG4gICAgY29uc3QgbyA9ICtuO1xuICAgIGlmIChvID49IHQpIHtcbiAgICAgIGNvbnN0IHIgPSBpW25dO1xuICAgICAgZGVsZXRlIGlbbl0sIChlID4gMCB8fCBvID4gdCkgJiYgKGlbbyArIGVdID0gcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDbChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiAhZSB8fCBpLnR5cGUgPT09IFwibW91c2VvdXRcIiA/IG51bGwgOiBzID8gdCA6IGk7XG59XG5jbGFzcyBqaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5jb25maWcgPSBuZXcgeWwoZSksIG4gPSBRbih0KSwgbyA9IHRvKG4pO1xuICAgIGlmIChvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCAnXCIgKyBvLmlkICsgXCInIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgJ1wiICsgby5jYW52YXMuaWQgKyBcIicgY2FuIGJlIHJldXNlZC5cIlxuICAgICAgKTtcbiAgICBjb25zdCByID0gcy5jcmVhdGVSZXNvbHZlcihzLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChzLnBsYXRmb3JtIHx8IHFuKG4pKSgpLCB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhzKTtcbiAgICBjb25zdCBhID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChuLCByLmFzcGVjdFJhdGlvKSwgbCA9IGEgJiYgYS5jYW52YXMsIGMgPSBsICYmIGwuaGVpZ2h0LCBoID0gbCAmJiBsLndpZHRoO1xuICAgIGlmICh0aGlzLmlkID0gX28oKSwgdGhpcy5jdHggPSBhLCB0aGlzLmNhbnZhcyA9IGwsIHRoaXMud2lkdGggPSBoLCB0aGlzLmhlaWdodCA9IGMsIHRoaXMuX29wdGlvbnMgPSByLCB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW8sIHRoaXMuX2xheWVycyA9IFtdLCB0aGlzLl9tZXRhc2V0cyA9IFtdLCB0aGlzLl9zdGFja3MgPSB2b2lkIDAsIHRoaXMuYm94ZXMgPSBbXSwgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHZvaWQgMCwgdGhpcy5jaGFydEFyZWEgPSB2b2lkIDAsIHRoaXMuX2FjdGl2ZSA9IFtdLCB0aGlzLl9sYXN0RXZlbnQgPSB2b2lkIDAsIHRoaXMuX2xpc3RlbmVycyA9IHt9LCB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdm9pZCAwLCB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdLCB0aGlzLnNjYWxlcyA9IHt9LCB0aGlzLl9wbHVnaW5zID0gbmV3IGhsKCksIHRoaXMuJHByb3hpZXMgPSB7fSwgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9LCB0aGlzLmF0dGFjaGVkID0gITEsIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHZvaWQgMCwgdGhpcy4kY29udGV4dCA9IHZvaWQgMCwgdGhpcy5fZG9SZXNpemUgPSBGbygoZCkgPT4gdGhpcy51cGRhdGUoZCksIHIucmVzaXplRGVsYXkgfHwgMCksIHRoaXMuX2RhdGFDaGFuZ2VzID0gW10sICRlW3RoaXMuaWRdID0gdGhpcywgIWEgfHwgIWwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXQubGlzdGVuKHRoaXMsIFwiY29tcGxldGVcIiwgenMpLCBhdC5saXN0ZW4odGhpcywgXCJwcm9ncmVzc1wiLCBTbCksIHRoaXMuX2luaXRpYWxpemUoKSwgdGhpcy5hdHRhY2hlZCAmJiB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHsgYXNwZWN0UmF0aW86IHQsIG1haW50YWluQXNwZWN0UmF0aW86IGUgfSwgd2lkdGg6IHMsIGhlaWdodDogbiwgX2FzcGVjdFJhdGlvOiBvIH0gPSB0aGlzO1xuICAgIHJldHVybiBUKHQpID8gZSAmJiBvID8gbyA6IG4gPyBzIC8gbiA6IG51bGwgOiB0O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKHQpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gdDtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyh0KSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHQ7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUluaXRcIiksIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlID8gdGhpcy5yZXNpemUoKSA6IGxzKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKSwgdGhpcy5iaW5kRXZlbnRzKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVySW5pdFwiKSwgdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICByZXR1cm4gb3ModGhpcy5jYW52YXMsIHRoaXMuY3R4KSwgdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIHJldHVybiBhdC5zdG9wKHRoaXMpLCB0aGlzO1xuICB9XG4gIHJlc2l6ZSh0LCBlKSB7XG4gICAgYXQucnVubmluZyh0aGlzKSA/IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7IHdpZHRoOiB0LCBoZWlnaHQ6IGUgfSA6IHRoaXMuX3Jlc2l6ZSh0LCBlKTtcbiAgfVxuICBfcmVzaXplKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5vcHRpb25zLCBuID0gdGhpcy5jYW52YXMsIG8gPSBzLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbywgciA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUobiwgdCwgZSwgbyksIGEgPSBzLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCksIGwgPSB0aGlzLndpZHRoID8gXCJyZXNpemVcIiA6IFwiYXR0YWNoXCI7XG4gICAgdGhpcy53aWR0aCA9IHIud2lkdGgsIHRoaXMuaGVpZ2h0ID0gci5oZWlnaHQsIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbywgbHModGhpcywgYSwgITApICYmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJyZXNpemVcIiwgeyBzaXplOiByIH0pLCBJKHMub25SZXNpemUsIFt0aGlzLCByXSwgdGhpcyksIHRoaXMuYXR0YWNoZWQgJiYgdGhpcy5fZG9SZXNpemUobCkgJiYgdGhpcy5yZW5kZXIoKSk7XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBFKGUsIChzLCBuKSA9PiB7XG4gICAgICBzLmlkID0gbjtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0LnNjYWxlcywgcyA9IHRoaXMuc2NhbGVzLCBuID0gT2JqZWN0LmtleXMocykucmVkdWNlKChyLCBhKSA9PiAoclthXSA9ICExLCByKSwge30pO1xuICAgIGxldCBvID0gW107XG4gICAgZSAmJiAobyA9IG8uY29uY2F0KFxuICAgICAgT2JqZWN0LmtleXMoZSkubWFwKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBlW3JdLCBsID0ga2kociwgYSksIGMgPSBsID09PSBcInJcIiwgaCA9IGwgPT09IFwieFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IGEsXG4gICAgICAgICAgZHBvc2l0aW9uOiBjID8gXCJjaGFydEFyZWFcIiA6IGggPyBcImJvdHRvbVwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgZHR5cGU6IGMgPyBcInJhZGlhbExpbmVhclwiIDogaCA/IFwiY2F0ZWdvcnlcIiA6IFwibGluZWFyXCJcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKSksIEUobywgKHIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByLm9wdGlvbnMsIGwgPSBhLmlkLCBjID0ga2kobCwgYSksIGggPSBDKGEudHlwZSwgci5kdHlwZSk7XG4gICAgICAoYS5wb3NpdGlvbiA9PT0gdm9pZCAwIHx8IEZzKGEucG9zaXRpb24sIGMpICE9PSBGcyhyLmRwb3NpdGlvbikpICYmIChhLnBvc2l0aW9uID0gci5kcG9zaXRpb24pLCBuW2xdID0gITA7XG4gICAgICBsZXQgZCA9IG51bGw7XG4gICAgICBpZiAobCBpbiBzICYmIHNbbF0udHlwZSA9PT0gaClcbiAgICAgICAgZCA9IHNbbF07XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdSA9IG90LmdldFNjYWxlKGgpO1xuICAgICAgICBkID0gbmV3IHUoe1xuICAgICAgICAgIGlkOiBsLFxuICAgICAgICAgIHR5cGU6IGgsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KSwgc1tkLmlkXSA9IGQ7XG4gICAgICB9XG4gICAgICBkLmluaXQoYSwgdCk7XG4gICAgfSksIEUobiwgKHIsIGEpID0+IHtcbiAgICAgIHIgfHwgZGVsZXRlIHNbYV07XG4gICAgfSksIEUocywgKHIpID0+IHtcbiAgICAgIFguY29uZmlndXJlKHRoaXMsIHIsIHIub3B0aW9ucyksIFguYWRkQm94KHRoaXMsIHIpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWV0YXNldHMsIGUgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoLCBzID0gdC5sZW5ndGg7XG4gICAgaWYgKHQuc29ydCgobiwgbykgPT4gbi5pbmRleCAtIG8uaW5kZXgpLCBzID4gZSkge1xuICAgICAgZm9yIChsZXQgbiA9IGU7IG4gPCBzOyArK24pXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShuKTtcbiAgICAgIHQuc3BsaWNlKGUsIHMgLSBlKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSB0LnNsaWNlKDApLnNvcnQoSXMoXCJvcmRlclwiLCBcImluZGV4XCIpKTtcbiAgfVxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3QgeyBfbWV0YXNldHM6IHQsIGRhdGE6IHsgZGF0YXNldHM6IGUgfSB9ID0gdGhpcztcbiAgICB0Lmxlbmd0aCA+IGUubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLl9zdGFja3MsIHQuZm9yRWFjaCgocywgbikgPT4ge1xuICAgICAgZS5maWx0ZXIoKG8pID0+IG8gPT09IHMuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEobik7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IHQgPSBbXSwgZSA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgcywgbjtcbiAgICBmb3IgKHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCksIHMgPSAwLCBuID0gZS5sZW5ndGg7IHMgPCBuOyBzKyspIHtcbiAgICAgIGNvbnN0IG8gPSBlW3NdO1xuICAgICAgbGV0IHIgPSB0aGlzLmdldERhdGFzZXRNZXRhKHMpO1xuICAgICAgY29uc3QgYSA9IG8udHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgaWYgKHIudHlwZSAmJiByLnR5cGUgIT09IGEgJiYgKHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShzKSwgciA9IHRoaXMuZ2V0RGF0YXNldE1ldGEocykpLCByLnR5cGUgPSBhLCByLmluZGV4QXhpcyA9IG8uaW5kZXhBeGlzIHx8IE1pKGEsIHRoaXMub3B0aW9ucyksIHIub3JkZXIgPSBvLm9yZGVyIHx8IDAsIHIuaW5kZXggPSBzLCByLmxhYmVsID0gXCJcIiArIG8ubGFiZWwsIHIudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShzKSwgci5jb250cm9sbGVyKVxuICAgICAgICByLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgocyksIHIuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbCA9IG90LmdldENvbnRyb2xsZXIoYSksIHsgZGF0YXNldEVsZW1lbnRUeXBlOiBjLCBkYXRhRWxlbWVudFR5cGU6IGggfSA9IE8uZGF0YXNldHNbYV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24obC5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IG90LmdldEVsZW1lbnQoaCksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBjICYmIG90LmdldEVsZW1lbnQoYylcbiAgICAgICAgfSksIHIuY29udHJvbGxlciA9IG5ldyBsKHRoaXMsIHMpLCB0LnB1c2goci5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCksIHQ7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgRSh0aGlzLmRhdGEuZGF0YXNldHMsICh0LCBlKSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGUpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcInJlc2V0XCIpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29uZmlnO1xuICAgIGUudXBkYXRlKCk7XG4gICAgY29uc3QgcyA9IHRoaXMuX29wdGlvbnMgPSBlLmNyZWF0ZVJlc29sdmVyKGUuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpLCBuID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIXMuYW5pbWF0aW9uO1xuICAgIGlmICh0aGlzLl91cGRhdGVTY2FsZXMoKSwgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCksIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKSwgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZVVwZGF0ZVwiLCB7IG1vZGU6IHQsIGNhbmNlbGFibGU6ICEwIH0pID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVFbGVtZW50c1VwZGF0ZVwiKTtcbiAgICBsZXQgciA9IDA7XG4gICAgZm9yIChsZXQgYyA9IDAsIGggPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBjIDwgaDsgYysrKSB7XG4gICAgICBjb25zdCB7IGNvbnRyb2xsZXI6IGQgfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoYyksIHUgPSAhbiAmJiBvLmluZGV4T2YoZCkgPT09IC0xO1xuICAgICAgZC5idWlsZE9yVXBkYXRlRWxlbWVudHModSksIHIgPSBNYXRoLm1heCgrZC5nZXRNYXhPdmVyZmxvdygpLCByKTtcbiAgICB9XG4gICAgciA9IHRoaXMuX21pblBhZGRpbmcgPSBzLmxheW91dC5hdXRvUGFkZGluZyA/IHIgOiAwLCB0aGlzLl91cGRhdGVMYXlvdXQociksIG4gfHwgRShvLCAoYykgPT4ge1xuICAgICAgYy5yZXNldCgpO1xuICAgIH0pLCB0aGlzLl91cGRhdGVEYXRhc2V0cyh0KSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJVcGRhdGVcIiwgeyBtb2RlOiB0IH0pLCB0aGlzLl9sYXllcnMuc29ydChJcyhcInpcIiwgXCJfaWR4XCIpKTtcbiAgICBjb25zdCB7IF9hY3RpdmU6IGEsIF9sYXN0RXZlbnQ6IGwgfSA9IHRoaXM7XG4gICAgbCA/IHRoaXMuX2V2ZW50SGFuZGxlcihsLCAhMCkgOiBhLmxlbmd0aCAmJiB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhLCBhLCAhMCksIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBFKHRoaXMuc2NhbGVzLCAodCkgPT4ge1xuICAgICAgWC5yZW1vdmVCb3godGhpcywgdCk7XG4gICAgfSksIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpLCB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpLCBzID0gbmV3IFNldCh0LmV2ZW50cyk7XG4gICAgKCFVaShlLCBzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IHQucmVzcG9uc2l2ZSkgJiYgKHRoaXMudW5iaW5kRXZlbnRzKCksIHRoaXMuYmluZEV2ZW50cygpKTtcbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7IF9oaWRkZW5JbmRpY2VzOiB0IH0gPSB0aGlzLCBlID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7IG1ldGhvZDogcywgc3RhcnQ6IG4sIGNvdW50OiBvIH0gb2YgZSkge1xuICAgICAgY29uc3QgciA9IHMgPT09IFwiX3JlbW92ZUVsZW1lbnRzXCIgPyAtbyA6IG87XG4gICAgICBQbCh0LCBuLCByKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCF0IHx8ICF0Lmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoLCBzID0gKG8pID0+IG5ldyBTZXQoXG4gICAgICB0LmZpbHRlcigocikgPT4gclswXSA9PT0gbykubWFwKChyLCBhKSA9PiBhICsgXCIsXCIgKyByLnNwbGljZSgxKS5qb2luKFwiLFwiKSlcbiAgICApLCBuID0gcygwKTtcbiAgICBmb3IgKGxldCBvID0gMTsgbyA8IGU7IG8rKylcbiAgICAgIGlmICghVWkobiwgcyhvKSkpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuKS5tYXAoKG8pID0+IG8uc3BsaXQoXCIsXCIpKS5tYXAoKG8pID0+ICh7IG1ldGhvZDogb1sxXSwgc3RhcnQ6ICtvWzJdLCBjb3VudDogK29bM10gfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQodCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVMYXlvdXRcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KSA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgWC51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHQpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNoYXJ0QXJlYSwgcyA9IGUud2lkdGggPD0gMCB8fCBlLmhlaWdodCA8PSAwO1xuICAgIHRoaXMuX2xheWVycyA9IFtdLCBFKHRoaXMuYm94ZXMsIChuKSA9PiB7XG4gICAgICBzICYmIG4ucG9zaXRpb24gPT09IFwiY2hhcnRBcmVhXCIgfHwgKG4uY29uZmlndXJlICYmIG4uY29uZmlndXJlKCksIHRoaXMuX2xheWVycy5wdXNoKC4uLm4uX2xheWVycygpKSk7XG4gICAgfSwgdGhpcyksIHRoaXMuX2xheWVycy5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBuLl9pZHggPSBvO1xuICAgIH0pLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckxheW91dFwiKTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldHModCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0c1VwZGF0ZVwiLCB7IG1vZGU6IHQsIGNhbmNlbGFibGU6ICEwIH0pICE9PSAhMSkge1xuICAgICAgZm9yIChsZXQgZSA9IDAsIHMgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGUpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgICBmb3IgKGxldCBlID0gMCwgcyA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoZSwgeXQodCkgPyB0KHsgZGF0YXNldEluZGV4OiBlIH0pIDogdCk7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRhdGFzZXRzVXBkYXRlXCIsIHsgbW9kZTogdCB9KTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldERhdGFzZXRNZXRhKHQpLCBuID0geyBtZXRhOiBzLCBpbmRleDogdCwgbW9kZTogZSwgY2FuY2VsYWJsZTogITAgfTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0VXBkYXRlXCIsIG4pICE9PSAhMSAmJiAocy5jb250cm9sbGVyLl91cGRhdGUoZSksIG4uY2FuY2VsYWJsZSA9ICExLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRhdGFzZXRVcGRhdGVcIiwgbikpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVSZW5kZXJcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KSAhPT0gITEgJiYgKGF0Lmhhcyh0aGlzKSA/IHRoaXMuYXR0YWNoZWQgJiYgIWF0LnJ1bm5pbmcodGhpcykgJiYgYXQuc3RhcnQodGhpcykgOiAodGhpcy5kcmF3KCksIHpzKHsgY2hhcnQ6IHRoaXMgfSkpKTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGxldCB0O1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7IHdpZHRoOiBzLCBoZWlnaHQ6IG4gfSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICB0aGlzLl9yZXNpemUocywgbiksIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbGVhcigpLCB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCB8fCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEcmF3XCIsIHsgY2FuY2VsYWJsZTogITAgfSkgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yICh0ID0gMDsgdCA8IGUubGVuZ3RoICYmIGVbdF0ueiA8PSAwOyArK3QpXG4gICAgICBlW3RdLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIGZvciAodGhpcy5fZHJhd0RhdGFzZXRzKCk7IHQgPCBlLmxlbmd0aDsgKyt0KVxuICAgICAgZVt0XS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRyYXdcIik7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzLCBzID0gW107XG4gICAgbGV0IG4sIG87XG4gICAgZm9yIChuID0gMCwgbyA9IGUubGVuZ3RoOyBuIDwgbzsgKytuKSB7XG4gICAgICBjb25zdCByID0gZVtuXTtcbiAgICAgICghdCB8fCByLnZpc2libGUpICYmIHMucHVzaChyKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCEwKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0c0RyYXdcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KSA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGUgPSB0Lmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKVxuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQodFtlXSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0c0RyYXdcIik7XG4gIH1cbiAgX2RyYXdEYXRhc2V0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdHgsIHMgPSB0Ll9jbGlwLCBuID0gIXMuZGlzYWJsZWQsIG8gPSB0aGlzLmNoYXJ0QXJlYSwgciA9IHtcbiAgICAgIG1ldGE6IHQsXG4gICAgICBpbmRleDogdC5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0RHJhd1wiLCByKSAhPT0gITEgJiYgKG4gJiYgWGUoZSwge1xuICAgICAgbGVmdDogcy5sZWZ0ID09PSAhMSA/IDAgOiBvLmxlZnQgLSBzLmxlZnQsXG4gICAgICByaWdodDogcy5yaWdodCA9PT0gITEgPyB0aGlzLndpZHRoIDogby5yaWdodCArIHMucmlnaHQsXG4gICAgICB0b3A6IHMudG9wID09PSAhMSA/IDAgOiBvLnRvcCAtIHMudG9wLFxuICAgICAgYm90dG9tOiBzLmJvdHRvbSA9PT0gITEgPyB0aGlzLmhlaWdodCA6IG8uYm90dG9tICsgcy5ib3R0b21cbiAgICB9KSwgdC5jb250cm9sbGVyLmRyYXcoKSwgbiAmJiBVZShlKSwgci5jYW5jZWxhYmxlID0gITEsIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldERyYXdcIiwgcikpO1xuICB9XG4gIGlzUG9pbnRJbkFyZWEodCkge1xuICAgIHJldHVybiByZSh0LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IEhuLm1vZGVzW2VdO1xuICAgIHJldHVybiB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvKHRoaXMsIHQsIHMsIG4pIDogW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGEuZGF0YXNldHNbdF0sIHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbiA9IHMuZmlsdGVyKChvKSA9PiBvICYmIG8uX2RhdGFzZXQgPT09IGUpLnBvcCgpO1xuICAgIHJldHVybiBuIHx8IChuID0ge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICBoaWRkZW46IG51bGwsXG4gICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgIG9yZGVyOiBlICYmIGUub3JkZXIgfHwgMCxcbiAgICAgIGluZGV4OiB0LFxuICAgICAgX2RhdGFzZXQ6IGUsXG4gICAgICBfcGFyc2VkOiBbXSxcbiAgICAgIF9zb3J0ZWQ6ICExXG4gICAgfSwgcy5wdXNoKG4pKSwgbjtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gdnQobnVsbCwgeyBjaGFydDogdGhpcywgdHlwZTogXCJjaGFydFwiIH0pKTtcbiAgfVxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cbiAgaXNEYXRhc2V0VmlzaWJsZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YS5kYXRhc2V0c1t0XTtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCk7XG4gICAgcmV0dXJuIHR5cGVvZiBzLmhpZGRlbiA9PSBcImJvb2xlYW5cIiA/ICFzLmhpZGRlbiA6ICFlLmhpZGRlbjtcbiAgfVxuICBzZXREYXRhc2V0VmlzaWJpbGl0eSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCk7XG4gICAgcy5oaWRkZW4gPSAhZTtcbiAgfVxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eSh0KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1t0XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW3RdO1xuICB9XG4gIGdldERhdGFWaXNpYmlsaXR5KHQpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbdF07XG4gIH1cbiAgX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSBzID8gXCJzaG93XCIgOiBcImhpZGVcIiwgbyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCksIHIgPSBvLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHZvaWQgMCwgbik7XG4gICAgZXQoZSkgPyAoby5kYXRhW2VdLmhpZGRlbiA9ICFzLCB0aGlzLnVwZGF0ZSgpKSA6ICh0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KHQsIHMpLCByLnVwZGF0ZShvLCB7IHZpc2libGU6IHMgfSksIHRoaXMudXBkYXRlKChhKSA9PiBhLmRhdGFzZXRJbmRleCA9PT0gdCA/IG4gOiB2b2lkIDApKTtcbiAgfVxuICBoaWRlKHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KHQsIGUsICExKTtcbiAgfVxuICBzaG93KHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KHQsIGUsICEwKTtcbiAgfVxuICBfZGVzdHJveURhdGFzZXRNZXRhKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fbWV0YXNldHNbdF07XG4gICAgZSAmJiBlLmNvbnRyb2xsZXIgJiYgZS5jb250cm9sbGVyLl9kZXN0cm95KCksIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1t0XTtcbiAgfVxuICBfc3RvcCgpIHtcbiAgICBsZXQgdCwgZTtcbiAgICBmb3IgKHRoaXMuc3RvcCgpLCBhdC5yZW1vdmUodGhpcyksIHQgPSAwLCBlID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgdCA8IGU7ICsrdClcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YSh0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURlc3Ryb3lcIik7XG4gICAgY29uc3QgeyBjYW52YXM6IHQsIGN0eDogZSB9ID0gdGhpcztcbiAgICB0aGlzLl9zdG9wKCksIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKSwgdCAmJiAodGhpcy51bmJpbmRFdmVudHMoKSwgb3ModCwgZSksIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoZSksIHRoaXMuY2FudmFzID0gbnVsbCwgdGhpcy5jdHggPSBudWxsKSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiZGVzdHJveVwiKSwgZGVsZXRlICRlW3RoaXMuaWRdLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRlc3Ryb3lcIik7XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi50KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi50KTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKSwgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUgPyB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCkgOiB0aGlzLmF0dGFjaGVkID0gITA7XG4gIH1cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2xpc3RlbmVycywgZSA9IHRoaXMucGxhdGZvcm0sIHMgPSAobywgcikgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIG8sIHIpLCB0W29dID0gcjtcbiAgICB9LCBuID0gKG8sIHIsIGEpID0+IHtcbiAgICAgIG8ub2Zmc2V0WCA9IHIsIG8ub2Zmc2V0WSA9IGEsIHRoaXMuX2V2ZW50SGFuZGxlcihvKTtcbiAgICB9O1xuICAgIEUodGhpcy5vcHRpb25zLmV2ZW50cywgKG8pID0+IHMobywgbikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgfHwgKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fSk7XG4gICAgY29uc3QgdCA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIGUgPSB0aGlzLnBsYXRmb3JtLCBzID0gKGwsIGMpID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCBsLCBjKSwgdFtsXSA9IGM7XG4gICAgfSwgbiA9IChsLCBjKSA9PiB7XG4gICAgICB0W2xdICYmIChlLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgbCwgYyksIGRlbGV0ZSB0W2xdKTtcbiAgICB9LCBvID0gKGwsIGMpID0+IHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMucmVzaXplKGwsIGMpO1xuICAgIH07XG4gICAgbGV0IHI7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIG4oXCJhdHRhY2hcIiwgYSksIHRoaXMuYXR0YWNoZWQgPSAhMCwgdGhpcy5yZXNpemUoKSwgcyhcInJlc2l6ZVwiLCBvKSwgcyhcImRldGFjaFwiLCByKTtcbiAgICB9O1xuICAgIHIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gITEsIG4oXCJyZXNpemVcIiwgbyksIHRoaXMuX3N0b3AoKSwgdGhpcy5fcmVzaXplKDAsIDApLCBzKFwiYXR0YWNoXCIsIGEpO1xuICAgIH0sIGUuaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykgPyBhKCkgOiByKCk7XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIEUodGhpcy5fbGlzdGVuZXJzLCAodCwgZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIGUsIHQpO1xuICAgIH0pLCB0aGlzLl9saXN0ZW5lcnMgPSB7fSwgRSh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAodCwgZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIGUsIHQpO1xuICAgIH0pLCB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdm9pZCAwO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSBzID8gXCJzZXRcIiA6IFwicmVtb3ZlXCI7XG4gICAgbGV0IG8sIHIsIGEsIGw7XG4gICAgZm9yIChlID09PSBcImRhdGFzZXRcIiAmJiAobyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodFswXS5kYXRhc2V0SW5kZXgpLCBvLmNvbnRyb2xsZXJbXCJfXCIgKyBuICsgXCJEYXRhc2V0SG92ZXJTdHlsZVwiXSgpKSwgYSA9IDAsIGwgPSB0Lmxlbmd0aDsgYSA8IGw7ICsrYSkge1xuICAgICAgciA9IHRbYV07XG4gICAgICBjb25zdCBjID0gciAmJiB0aGlzLmdldERhdGFzZXRNZXRhKHIuZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgYyAmJiBjW24gKyBcIkhvdmVyU3R5bGVcIl0oci5lbGVtZW50LCByLmRhdGFzZXRJbmRleCwgci5pbmRleCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmUgfHwgW10sIHMgPSB0Lm1hcCgoeyBkYXRhc2V0SW5kZXg6IG8sIGluZGV4OiByIH0pID0+IHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKG8pO1xuICAgICAgaWYgKCFhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4IFwiICsgbyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXg6IG8sXG4gICAgICAgIGVsZW1lbnQ6IGEuZGF0YVtyXSxcbiAgICAgICAgaW5kZXg6IHJcbiAgICAgIH07XG4gICAgfSk7XG4gICAgIXplKHMsIGUpICYmICh0aGlzLl9hY3RpdmUgPSBzLCB0aGlzLl9sYXN0RXZlbnQgPSBudWxsLCB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhzLCBlKSk7XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIHQsIGUsIHMpO1xuICB9XG4gIF91cGRhdGVIb3ZlclN0eWxlcyh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMub3B0aW9ucy5ob3ZlciwgbyA9IChsLCBjKSA9PiBsLmZpbHRlcigoaCkgPT4gIWMuc29tZSgoZCkgPT4gaC5kYXRhc2V0SW5kZXggPT09IGQuZGF0YXNldEluZGV4ICYmIGguaW5kZXggPT09IGQuaW5kZXgpKSwgciA9IG8oZSwgdCksIGEgPSBzID8gdCA6IG8odCwgZSk7XG4gICAgci5sZW5ndGggJiYgdGhpcy51cGRhdGVIb3ZlclN0eWxlKHIsIG4ubW9kZSwgITEpLCBhLmxlbmd0aCAmJiBuLm1vZGUgJiYgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGEsIG4ubW9kZSwgITApO1xuICB9XG4gIF9ldmVudEhhbmRsZXIodCwgZSkge1xuICAgIGNvbnN0IHMgPSB7XG4gICAgICBldmVudDogdCxcbiAgICAgIHJlcGxheTogZSxcbiAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYSh0KVxuICAgIH0sIG4gPSAocikgPT4gKHIub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXModC5uYXRpdmUudHlwZSk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUV2ZW50XCIsIHMsIG4pID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdGhpcy5faGFuZGxlRXZlbnQodCwgZSwgcy5pbkNoYXJ0QXJlYSk7XG4gICAgcmV0dXJuIHMuY2FuY2VsYWJsZSA9ICExLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckV2ZW50XCIsIHMsIG4pLCAobyB8fCBzLmNoYW5nZWQpICYmIHRoaXMucmVuZGVyKCksIHRoaXM7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IF9hY3RpdmU6IG4gPSBbXSwgb3B0aW9uczogbyB9ID0gdGhpcywgciA9IGUsIGEgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyh0LCBuLCBzLCByKSwgbCA9IFNvKHQpLCBjID0gQ2wodCwgdGhpcy5fbGFzdEV2ZW50LCBzLCBsKTtcbiAgICBzICYmICh0aGlzLl9sYXN0RXZlbnQgPSBudWxsLCBJKG8ub25Ib3ZlciwgW3QsIGEsIHRoaXNdLCB0aGlzKSwgbCAmJiBJKG8ub25DbGljaywgW3QsIGEsIHRoaXNdLCB0aGlzKSk7XG4gICAgY29uc3QgaCA9ICF6ZShhLCBuKTtcbiAgICByZXR1cm4gKGggfHwgZSkgJiYgKHRoaXMuX2FjdGl2ZSA9IGEsIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGEsIG4sIGUpKSwgdGhpcy5fbGFzdEV2ZW50ID0gYywgaDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGlmICh0LnR5cGUgPT09IFwibW91c2VvdXRcIilcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCBvID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUodCwgby5tb2RlLCBvLCBuKTtcbiAgfVxufVxuY29uc3QgQnMgPSAoKSA9PiBFKGppLmluc3RhbmNlcywgKGkpID0+IGkuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKSwgcHQgPSAhMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGppLCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6IE9cbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6ICRlXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGU6IHB0LFxuICAgIHZhbHVlOiBBdFxuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGU6IHB0LFxuICAgIHZhbHVlOiBvdFxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6IGtsXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6IHRvXG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6ICguLi5pKSA9PiB7XG4gICAgICBvdC5hZGQoLi4uaSksIEJzKCk7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6ICguLi5pKSA9PiB7XG4gICAgICBvdC5yZW1vdmUoLi4uaSksIEJzKCk7XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGVvKGksIHQsIGUpIHtcbiAgY29uc3QgeyBzdGFydEFuZ2xlOiBzLCBwaXhlbE1hcmdpbjogbiwgeDogbywgeTogciwgb3V0ZXJSYWRpdXM6IGEsIGlubmVyUmFkaXVzOiBsIH0gPSB0O1xuICBsZXQgYyA9IG4gLyBhO1xuICBpLmJlZ2luUGF0aCgpLCBpLmFyYyhvLCByLCBhLCBzIC0gYywgZSArIGMpLCBsID4gbiA/IChjID0gbiAvIGwsIGkuYXJjKG8sIHIsIGwsIGUgKyBjLCBzIC0gYywgITApKSA6IGkuYXJjKG8sIHIsIG4sIGUgKyBWLCBzIC0gViksIGkuY2xvc2VQYXRoKCksIGkuY2xpcCgpO1xufVxuZnVuY3Rpb24gRGwoaSkge1xuICByZXR1cm4gSWkoaSwgW1wib3V0ZXJTdGFydFwiLCBcIm91dGVyRW5kXCIsIFwiaW5uZXJTdGFydFwiLCBcImlubmVyRW5kXCJdKTtcbn1cbmZ1bmN0aW9uIE9sKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IERsKGkub3B0aW9ucy5ib3JkZXJSYWRpdXMpLCBvID0gKGUgLSB0KSAvIDIsIHIgPSBNYXRoLm1pbihvLCBzICogdCAvIDIpLCBhID0gKGwpID0+IHtcbiAgICBjb25zdCBjID0gKGUgLSBNYXRoLm1pbihvLCBsKSkgKiBzIC8gMjtcbiAgICByZXR1cm4gWShsLCAwLCBNYXRoLm1pbihvLCBjKSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogYShuLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBhKG4ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IFkobi5pbm5lclN0YXJ0LCAwLCByKSxcbiAgICBpbm5lckVuZDogWShuLmlubmVyRW5kLCAwLCByKVxuICB9O1xufVxuZnVuY3Rpb24gSXQoaSwgdCwgZSwgcykge1xuICByZXR1cm4ge1xuICAgIHg6IGUgKyBpICogTWF0aC5jb3ModCksXG4gICAgeTogcyArIGkgKiBNYXRoLnNpbih0KVxuICB9O1xufVxuZnVuY3Rpb24gd2koaSwgdCwgZSwgcywgbiwgbykge1xuICBjb25zdCB7IHg6IHIsIHk6IGEsIHN0YXJ0QW5nbGU6IGwsIHBpeGVsTWFyZ2luOiBjLCBpbm5lclJhZGl1czogaCB9ID0gdCwgZCA9IE1hdGgubWF4KHQub3V0ZXJSYWRpdXMgKyBzICsgZSAtIGMsIDApLCB1ID0gaCA+IDAgPyBoICsgcyArIGUgKyBjIDogMDtcbiAgbGV0IGYgPSAwO1xuICBjb25zdCBnID0gbiAtIGw7XG4gIGlmIChzKSB7XG4gICAgY29uc3QgUCA9IGggPiAwID8gaCAtIHMgOiAwLCBqID0gZCA+IDAgPyBkIC0gcyA6IDAsIFcgPSAoUCArIGopIC8gMiwga3QgPSBXICE9PSAwID8gZyAqIFcgLyAoVyArIHMpIDogZztcbiAgICBmID0gKGcgLSBrdCkgLyAyO1xuICB9XG4gIGNvbnN0IHAgPSBNYXRoLm1heCgxZS0zLCBnICogZCAtIGUgLyBCKSAvIGQsIG0gPSAoZyAtIHApIC8gMiwgYiA9IGwgKyBtICsgZiwgeCA9IG4gLSBtIC0gZiwgeyBvdXRlclN0YXJ0OiB2LCBvdXRlckVuZDogeSwgaW5uZXJTdGFydDogXywgaW5uZXJFbmQ6IE0gfSA9IE9sKHQsIHUsIGQsIHggLSBiKSwgayA9IGQgLSB2LCBTID0gZCAtIHksIHcgPSBiICsgdiAvIGssIEwgPSB4IC0geSAvIFMsIFIgPSB1ICsgXywgQSA9IHUgKyBNLCBIID0gYiArIF8gLyBSLCBxID0geCAtIE0gLyBBO1xuICBpZiAoaS5iZWdpblBhdGgoKSwgbykge1xuICAgIGlmIChpLmFyYyhyLCBhLCBkLCB3LCBMKSwgeSA+IDApIHtcbiAgICAgIGNvbnN0IFcgPSBJdChTLCBMLCByLCBhKTtcbiAgICAgIGkuYXJjKFcueCwgVy55LCB5LCBMLCB4ICsgVik7XG4gICAgfVxuICAgIGNvbnN0IFAgPSBJdChBLCB4LCByLCBhKTtcbiAgICBpZiAoaS5saW5lVG8oUC54LCBQLnkpLCBNID4gMCkge1xuICAgICAgY29uc3QgVyA9IEl0KEEsIHEsIHIsIGEpO1xuICAgICAgaS5hcmMoVy54LCBXLnksIE0sIHggKyBWLCBxICsgTWF0aC5QSSk7XG4gICAgfVxuICAgIGlmIChpLmFyYyhyLCBhLCB1LCB4IC0gTSAvIHUsIGIgKyBfIC8gdSwgITApLCBfID4gMCkge1xuICAgICAgY29uc3QgVyA9IEl0KFIsIEgsIHIsIGEpO1xuICAgICAgaS5hcmMoVy54LCBXLnksIF8sIEggKyBNYXRoLlBJLCBiIC0gVik7XG4gICAgfVxuICAgIGNvbnN0IGogPSBJdChrLCBiLCByLCBhKTtcbiAgICBpZiAoaS5saW5lVG8oai54LCBqLnkpLCB2ID4gMCkge1xuICAgICAgY29uc3QgVyA9IEl0KGssIHcsIHIsIGEpO1xuICAgICAgaS5hcmMoVy54LCBXLnksIHYsIGIgLSBWLCB3KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaS5tb3ZlVG8ociwgYSk7XG4gICAgY29uc3QgUCA9IE1hdGguY29zKHcpICogZCArIHIsIGogPSBNYXRoLnNpbih3KSAqIGQgKyBhO1xuICAgIGkubGluZVRvKFAsIGopO1xuICAgIGNvbnN0IFcgPSBNYXRoLmNvcyhMKSAqIGQgKyByLCBrdCA9IE1hdGguc2luKEwpICogZCArIGE7XG4gICAgaS5saW5lVG8oVywga3QpO1xuICB9XG4gIGkuY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBBbChpLCB0LCBlLCBzLCBuKSB7XG4gIGNvbnN0IHsgZnVsbENpcmNsZXM6IG8sIHN0YXJ0QW5nbGU6IHIsIGNpcmN1bWZlcmVuY2U6IGEgfSA9IHQ7XG4gIGxldCBsID0gdC5lbmRBbmdsZTtcbiAgaWYgKG8pIHtcbiAgICB3aShpLCB0LCBlLCBzLCByICsgRiwgbik7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBvOyArK2MpXG4gICAgICBpLmZpbGwoKTtcbiAgICBpc05hTihhKSB8fCAobCA9IHIgKyBhICUgRiwgYSAlIEYgPT09IDAgJiYgKGwgKz0gRikpO1xuICB9XG4gIHJldHVybiB3aShpLCB0LCBlLCBzLCBsLCBuKSwgaS5maWxsKCksIGw7XG59XG5mdW5jdGlvbiBUbChpLCB0LCBlKSB7XG4gIGNvbnN0IHsgeDogcywgeTogbiwgc3RhcnRBbmdsZTogbywgcGl4ZWxNYXJnaW46IHIsIGZ1bGxDaXJjbGVzOiBhIH0gPSB0LCBsID0gTWF0aC5tYXgodC5vdXRlclJhZGl1cyAtIHIsIDApLCBjID0gdC5pbm5lclJhZGl1cyArIHI7XG4gIGxldCBoO1xuICBmb3IgKGUgJiYgZW8oaSwgdCwgbyArIEYpLCBpLmJlZ2luUGF0aCgpLCBpLmFyYyhzLCBuLCBjLCBvICsgRiwgbywgITApLCBoID0gMDsgaCA8IGE7ICsraClcbiAgICBpLnN0cm9rZSgpO1xuICBmb3IgKGkuYmVnaW5QYXRoKCksIGkuYXJjKHMsIG4sIGwsIG8sIG8gKyBGKSwgaCA9IDA7IGggPCBhOyArK2gpXG4gICAgaS5zdHJva2UoKTtcbn1cbmZ1bmN0aW9uIExsKGksIHQsIGUsIHMsIG4sIG8pIHtcbiAgY29uc3QgeyBvcHRpb25zOiByIH0gPSB0LCB7IGJvcmRlcldpZHRoOiBhLCBib3JkZXJKb2luU3R5bGU6IGwgfSA9IHIsIGMgPSByLmJvcmRlckFsaWduID09PSBcImlubmVyXCI7XG4gIGEgJiYgKGMgPyAoaS5saW5lV2lkdGggPSBhICogMiwgaS5saW5lSm9pbiA9IGwgfHwgXCJyb3VuZFwiKSA6IChpLmxpbmVXaWR0aCA9IGEsIGkubGluZUpvaW4gPSBsIHx8IFwiYmV2ZWxcIiksIHQuZnVsbENpcmNsZXMgJiYgVGwoaSwgdCwgYyksIGMgJiYgZW8oaSwgdCwgbiksIHdpKGksIHQsIGUsIHMsIG4sIG8pLCBpLnN0cm9rZSgpKTtcbn1cbmNsYXNzIHllIGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLmNpcmN1bWZlcmVuY2UgPSB2b2lkIDAsIHRoaXMuc3RhcnRBbmdsZSA9IHZvaWQgMCwgdGhpcy5lbmRBbmdsZSA9IHZvaWQgMCwgdGhpcy5pbm5lclJhZGl1cyA9IHZvaWQgMCwgdGhpcy5vdXRlclJhZGl1cyA9IHZvaWQgMCwgdGhpcy5waXhlbE1hcmdpbiA9IDAsIHRoaXMuZnVsbENpcmNsZXMgPSAwLCB0ICYmIE9iamVjdC5hc3NpZ24odGhpcywgdCk7XG4gIH1cbiAgaW5SYW5nZSh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIHMpLCB7IGFuZ2xlOiBvLCBkaXN0YW5jZTogciB9ID0gaG4obiwgeyB4OiB0LCB5OiBlIH0pLCB7IHN0YXJ0QW5nbGU6IGEsIGVuZEFuZ2xlOiBsLCBpbm5lclJhZGl1czogYywgb3V0ZXJSYWRpdXM6IGgsIGNpcmN1bWZlcmVuY2U6IGQgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgXCJzdGFydEFuZ2xlXCIsXG4gICAgICBcImVuZEFuZ2xlXCIsXG4gICAgICBcImlubmVyUmFkaXVzXCIsXG4gICAgICBcIm91dGVyUmFkaXVzXCIsXG4gICAgICBcImNpcmN1bWZlcmVuY2VcIlxuICAgIF0sIHMpLCB1ID0gdGhpcy5vcHRpb25zLnNwYWNpbmcgLyAyLCBnID0gQyhkLCBsIC0gYSkgPj0gRiB8fCBvZShvLCBhLCBsKSwgcCA9IHV0KHIsIGMgKyB1LCBoICsgdSk7XG4gICAgcmV0dXJuIGcgJiYgcDtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBzLCBzdGFydEFuZ2xlOiBuLCBlbmRBbmdsZTogbywgaW5uZXJSYWRpdXM6IHIsIG91dGVyUmFkaXVzOiBhIH0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgIFwieFwiLFxuICAgICAgXCJ5XCIsXG4gICAgICBcInN0YXJ0QW5nbGVcIixcbiAgICAgIFwiZW5kQW5nbGVcIixcbiAgICAgIFwiaW5uZXJSYWRpdXNcIixcbiAgICAgIFwib3V0ZXJSYWRpdXNcIixcbiAgICAgIFwiY2lyY3VtZmVyZW5jZVwiXG4gICAgXSwgdCksIHsgb2Zmc2V0OiBsLCBzcGFjaW5nOiBjIH0gPSB0aGlzLm9wdGlvbnMsIGggPSAobiArIG8pIC8gMiwgZCA9IChyICsgYSArIGMgKyBsKSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUgKyBNYXRoLmNvcyhoKSAqIGQsXG4gICAgICB5OiBzICsgTWF0aC5zaW4oaCkgKiBkXG4gICAgfTtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odCkge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHQpO1xuICB9XG4gIGRyYXcodCkge1xuICAgIGNvbnN0IHsgb3B0aW9uczogZSwgY2lyY3VtZmVyZW5jZTogcyB9ID0gdGhpcywgbiA9IChlLm9mZnNldCB8fCAwKSAvIDIsIG8gPSAoZS5zcGFjaW5nIHx8IDApIC8gMiwgciA9IGUuY2lyY3VsYXI7XG4gICAgaWYgKHRoaXMucGl4ZWxNYXJnaW4gPSBlLmJvcmRlckFsaWduID09PSBcImlubmVyXCIgPyAwLjMzIDogMCwgdGhpcy5mdWxsQ2lyY2xlcyA9IHMgPiBGID8gTWF0aC5mbG9vcihzIC8gRikgOiAwLCBzID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHQuc2F2ZSgpO1xuICAgIGxldCBhID0gMDtcbiAgICBpZiAobikge1xuICAgICAgYSA9IG4gLyAyO1xuICAgICAgY29uc3QgYyA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICB0LnRyYW5zbGF0ZShNYXRoLmNvcyhjKSAqIGEsIE1hdGguc2luKGMpICogYSksIHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBCICYmIChhID0gbik7XG4gICAgfVxuICAgIHQuZmlsbFN0eWxlID0gZS5iYWNrZ3JvdW5kQ29sb3IsIHQuc3Ryb2tlU3R5bGUgPSBlLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGwgPSBBbCh0LCB0aGlzLCBhLCBvLCByKTtcbiAgICBMbCh0LCB0aGlzLCBhLCBvLCBsLCByKSwgdC5yZXN0b3JlKCk7XG4gIH1cbn1cbnllLmlkID0gXCJhcmNcIjtcbnllLmRlZmF1bHRzID0ge1xuICBib3JkZXJBbGlnbjogXCJjZW50ZXJcIixcbiAgYm9yZGVyQ29sb3I6IFwiI2ZmZlwiLFxuICBib3JkZXJKb2luU3R5bGU6IHZvaWQgMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdm9pZCAwLFxuICBjaXJjdWxhcjogITBcbn07XG55ZS5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCJcbn07XG5mdW5jdGlvbiBpbyhpLCB0LCBlID0gdCkge1xuICBpLmxpbmVDYXAgPSBDKGUuYm9yZGVyQ2FwU3R5bGUsIHQuYm9yZGVyQ2FwU3R5bGUpLCBpLnNldExpbmVEYXNoKEMoZS5ib3JkZXJEYXNoLCB0LmJvcmRlckRhc2gpKSwgaS5saW5lRGFzaE9mZnNldCA9IEMoZS5ib3JkZXJEYXNoT2Zmc2V0LCB0LmJvcmRlckRhc2hPZmZzZXQpLCBpLmxpbmVKb2luID0gQyhlLmJvcmRlckpvaW5TdHlsZSwgdC5ib3JkZXJKb2luU3R5bGUpLCBpLmxpbmVXaWR0aCA9IEMoZS5ib3JkZXJXaWR0aCwgdC5ib3JkZXJXaWR0aCksIGkuc3Ryb2tlU3R5bGUgPSBDKGUuYm9yZGVyQ29sb3IsIHQuYm9yZGVyQ29sb3IpO1xufVxuZnVuY3Rpb24gUmwoaSwgdCwgZSkge1xuICBpLmxpbmVUbyhlLngsIGUueSk7XG59XG5mdW5jdGlvbiBFbChpKSB7XG4gIHJldHVybiBpLnN0ZXBwZWQgPyBsciA6IGkudGVuc2lvbiB8fCBpLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09IFwibW9ub3RvbmVcIiA/IGNyIDogUmw7XG59XG5mdW5jdGlvbiBzbyhpLCB0LCBlID0ge30pIHtcbiAgY29uc3QgcyA9IGkubGVuZ3RoLCB7IHN0YXJ0OiBuID0gMCwgZW5kOiBvID0gcyAtIDEgfSA9IGUsIHsgc3RhcnQ6IHIsIGVuZDogYSB9ID0gdCwgbCA9IE1hdGgubWF4KG4sIHIpLCBjID0gTWF0aC5taW4obywgYSksIGggPSBuIDwgciAmJiBvIDwgciB8fCBuID4gYSAmJiBvID4gYTtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogcyxcbiAgICBzdGFydDogbCxcbiAgICBsb29wOiB0Lmxvb3AsXG4gICAgaWxlbjogYyA8IGwgJiYgIWggPyBzICsgYyAtIGwgOiBjIC0gbFxuICB9O1xufVxuZnVuY3Rpb24gRmwoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IHBvaW50czogbiwgb3B0aW9uczogbyB9ID0gdCwgeyBjb3VudDogciwgc3RhcnQ6IGEsIGxvb3A6IGwsIGlsZW46IGMgfSA9IHNvKG4sIGUsIHMpLCBoID0gRWwobyk7XG4gIGxldCB7IG1vdmU6IGQgPSAhMCwgcmV2ZXJzZTogdSB9ID0gcyB8fCB7fSwgZiwgZywgcDtcbiAgZm9yIChmID0gMDsgZiA8PSBjOyArK2YpXG4gICAgZyA9IG5bKGEgKyAodSA/IGMgLSBmIDogZikpICUgcl0sICFnLnNraXAgJiYgKGQgPyAoaS5tb3ZlVG8oZy54LCBnLnkpLCBkID0gITEpIDogaChpLCBwLCBnLCB1LCBvLnN0ZXBwZWQpLCBwID0gZyk7XG4gIHJldHVybiBsICYmIChnID0gblsoYSArICh1ID8gYyA6IDApKSAlIHJdLCBoKGksIHAsIGcsIHUsIG8uc3RlcHBlZCkpLCAhIWw7XG59XG5mdW5jdGlvbiBJbChpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB0LnBvaW50cywgeyBjb3VudDogbywgc3RhcnQ6IHIsIGlsZW46IGEgfSA9IHNvKG4sIGUsIHMpLCB7IG1vdmU6IGwgPSAhMCwgcmV2ZXJzZTogYyB9ID0gcyB8fCB7fTtcbiAgbGV0IGggPSAwLCBkID0gMCwgdSwgZiwgZywgcCwgbSwgYjtcbiAgY29uc3QgeCA9ICh5KSA9PiAociArIChjID8gYSAtIHkgOiB5KSkgJSBvLCB2ID0gKCkgPT4ge1xuICAgIHAgIT09IG0gJiYgKGkubGluZVRvKGgsIG0pLCBpLmxpbmVUbyhoLCBwKSwgaS5saW5lVG8oaCwgYikpO1xuICB9O1xuICBmb3IgKGwgJiYgKGYgPSBuW3goMCldLCBpLm1vdmVUbyhmLngsIGYueSkpLCB1ID0gMDsgdSA8PSBhOyArK3UpIHtcbiAgICBpZiAoZiA9IG5beCh1KV0sIGYuc2tpcClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHkgPSBmLngsIF8gPSBmLnksIE0gPSB5IHwgMDtcbiAgICBNID09PSBnID8gKF8gPCBwID8gcCA9IF8gOiBfID4gbSAmJiAobSA9IF8pLCBoID0gKGQgKiBoICsgeSkgLyArK2QpIDogKHYoKSwgaS5saW5lVG8oeSwgXyksIGcgPSBNLCBkID0gMCwgcCA9IG0gPSBfKSwgYiA9IF87XG4gIH1cbiAgdigpO1xufVxuZnVuY3Rpb24gU2koaSkge1xuICBjb25zdCB0ID0gaS5vcHRpb25zLCBlID0gdC5ib3JkZXJEYXNoICYmIHQuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIHJldHVybiAhaS5fZGVjaW1hdGVkICYmICFpLl9sb29wICYmICF0LnRlbnNpb24gJiYgdC5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSBcIm1vbm90b25lXCIgJiYgIXQuc3RlcHBlZCAmJiAhZSA/IElsIDogRmw7XG59XG5mdW5jdGlvbiB6bChpKSB7XG4gIHJldHVybiBpLnN0ZXBwZWQgPyBXciA6IGkudGVuc2lvbiB8fCBpLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09IFwibW9ub3RvbmVcIiA/IE5yIDogQ3Q7XG59XG5mdW5jdGlvbiBCbChpLCB0LCBlLCBzKSB7XG4gIGxldCBuID0gdC5fcGF0aDtcbiAgbiB8fCAobiA9IHQuX3BhdGggPSBuZXcgUGF0aDJEKCksIHQucGF0aChuLCBlLCBzKSAmJiBuLmNsb3NlUGF0aCgpKSwgaW8oaSwgdC5vcHRpb25zKSwgaS5zdHJva2Uobik7XG59XG5mdW5jdGlvbiBWbChpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgc2VnbWVudHM6IG4sIG9wdGlvbnM6IG8gfSA9IHQsIHIgPSBTaSh0KTtcbiAgZm9yIChjb25zdCBhIG9mIG4pXG4gICAgaW8oaSwgbywgYS5zdHlsZSksIGkuYmVnaW5QYXRoKCksIHIoaSwgdCwgYSwgeyBzdGFydDogZSwgZW5kOiBlICsgcyAtIDEgfSkgJiYgaS5jbG9zZVBhdGgoKSwgaS5zdHJva2UoKTtcbn1cbmNvbnN0IFdsID0gdHlwZW9mIFBhdGgyRCA9PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBObChpLCB0LCBlLCBzKSB7XG4gIFdsICYmICF0Lm9wdGlvbnMuc2VnbWVudCA/IEJsKGksIHQsIGUsIHMpIDogVmwoaSwgdCwgZSwgcyk7XG59XG5jbGFzcyBndCBleHRlbmRzIHN0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKCksIHRoaXMuYW5pbWF0ZWQgPSAhMCwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLl9jaGFydCA9IHZvaWQgMCwgdGhpcy5fbG9vcCA9IHZvaWQgMCwgdGhpcy5fZnVsbExvb3AgPSB2b2lkIDAsIHRoaXMuX3BhdGggPSB2b2lkIDAsIHRoaXMuX3BvaW50cyA9IHZvaWQgMCwgdGhpcy5fc2VnbWVudHMgPSB2b2lkIDAsIHRoaXMuX2RlY2ltYXRlZCA9ICExLCB0aGlzLl9wb2ludHNVcGRhdGVkID0gITEsIHRoaXMuX2RhdGFzZXRJbmRleCA9IHZvaWQgMCwgdCAmJiBPYmplY3QuYXNzaWduKHRoaXMsIHQpO1xuICB9XG4gIHVwZGF0ZUNvbnRyb2xQb2ludHModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChzLnRlbnNpb24gfHwgcy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIpICYmICFzLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IG4gPSBzLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgTHIodGhpcy5fcG9pbnRzLCBzLCB0LCBuLCBlKSwgdGhpcy5fcG9pbnRzVXBkYXRlZCA9ICEwO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHQpIHtcbiAgICB0aGlzLl9wb2ludHMgPSB0LCBkZWxldGUgdGhpcy5fc2VnbWVudHMsIGRlbGV0ZSB0aGlzLl9wYXRoLCB0aGlzLl9wb2ludHNVcGRhdGVkID0gITE7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gS3IodGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuICBmaXJzdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZWdtZW50cywgZSA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiB0Lmxlbmd0aCAmJiBlW3RbMF0uc3RhcnRdO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VnbWVudHMsIGUgPSB0aGlzLnBvaW50cywgcyA9IHQubGVuZ3RoO1xuICAgIHJldHVybiBzICYmIGVbdFtzIC0gMV0uZW5kXTtcbiAgfVxuICBpbnRlcnBvbGF0ZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucywgbiA9IHRbZV0sIG8gPSB0aGlzLnBvaW50cywgciA9IEZuKHRoaXMsIHsgcHJvcGVydHk6IGUsIHN0YXJ0OiBuLCBlbmQ6IG4gfSk7XG4gICAgaWYgKCFyLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gW10sIGwgPSB6bChzKTtcbiAgICBsZXQgYywgaDtcbiAgICBmb3IgKGMgPSAwLCBoID0gci5sZW5ndGg7IGMgPCBoOyArK2MpIHtcbiAgICAgIGNvbnN0IHsgc3RhcnQ6IGQsIGVuZDogdSB9ID0gcltjXSwgZiA9IG9bZF0sIGcgPSBvW3VdO1xuICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgYS5wdXNoKGYpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBNYXRoLmFicygobiAtIGZbZV0pIC8gKGdbZV0gLSBmW2VdKSksIG0gPSBsKGYsIGcsIHAsIHMuc3RlcHBlZCk7XG4gICAgICBtW2VdID0gdFtlXSwgYS5wdXNoKG0pO1xuICAgIH1cbiAgICByZXR1cm4gYS5sZW5ndGggPT09IDEgPyBhWzBdIDogYTtcbiAgfVxuICBwYXRoU2VnbWVudCh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIFNpKHRoaXMpKHQsIHRoaXMsIGUsIHMpO1xuICB9XG4gIHBhdGgodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlZ21lbnRzLCBvID0gU2kodGhpcyk7XG4gICAgbGV0IHIgPSB0aGlzLl9sb29wO1xuICAgIGUgPSBlIHx8IDAsIHMgPSBzIHx8IHRoaXMucG9pbnRzLmxlbmd0aCAtIGU7XG4gICAgZm9yIChjb25zdCBhIG9mIG4pXG4gICAgICByICY9IG8odCwgdGhpcywgYSwgeyBzdGFydDogZSwgZW5kOiBlICsgcyAtIDEgfSk7XG4gICAgcmV0dXJuICEhcjtcbiAgfVxuICBkcmF3KHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICh0aGlzLnBvaW50cyB8fCBbXSkubGVuZ3RoICYmIG8uYm9yZGVyV2lkdGggJiYgKHQuc2F2ZSgpLCBObCh0LCB0aGlzLCBzLCBuKSwgdC5yZXN0b3JlKCkpLCB0aGlzLmFuaW1hdGVkICYmICh0aGlzLl9wb2ludHNVcGRhdGVkID0gITEsIHRoaXMuX3BhdGggPSB2b2lkIDApO1xuICB9XG59XG5ndC5pZCA9IFwibGluZVwiO1xuZ3QuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckNhcFN0eWxlOiBcImJ1dHRcIixcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogXCJtaXRlclwiLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiAhMCxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogXCJkZWZhdWx0XCIsXG4gIGZpbGw6ICExLFxuICBzcGFuR2FwczogITEsXG4gIHN0ZXBwZWQ6ICExLFxuICB0ZW5zaW9uOiAwXG59O1xuZ3QuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmRDb2xvclwiLFxuICBib3JkZXJDb2xvcjogXCJib3JkZXJDb2xvclwiXG59O1xuZ3QuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAhMCxcbiAgX2luZGV4YWJsZTogKGkpID0+IGkgIT09IFwiYm9yZGVyRGFzaFwiICYmIGkgIT09IFwiZmlsbFwiXG59O1xuZnVuY3Rpb24gVnMoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gaS5vcHRpb25zLCB7IFtlXTogbyB9ID0gaS5nZXRQcm9wcyhbZV0sIHMpO1xuICByZXR1cm4gTWF0aC5hYnModCAtIG8pIDwgbi5yYWRpdXMgKyBuLmhpdFJhZGl1cztcbn1cbmNsYXNzIHZlIGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLnBhcnNlZCA9IHZvaWQgMCwgdGhpcy5za2lwID0gdm9pZCAwLCB0aGlzLnN0b3AgPSB2b2lkIDAsIHQgJiYgT2JqZWN0LmFzc2lnbih0aGlzLCB0KTtcbiAgfVxuICBpblJhbmdlKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5vcHRpb25zLCB7IHg6IG8sIHk6IHIgfSA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIHMpO1xuICAgIHJldHVybiBNYXRoLnBvdyh0IC0gbywgMikgKyBNYXRoLnBvdyhlIC0gciwgMikgPCBNYXRoLnBvdyhuLmhpdFJhZGl1cyArIG4ucmFkaXVzLCAyKTtcbiAgfVxuICBpblhSYW5nZSh0LCBlKSB7XG4gICAgcmV0dXJuIFZzKHRoaXMsIHQsIFwieFwiLCBlKTtcbiAgfVxuICBpbllSYW5nZSh0LCBlKSB7XG4gICAgcmV0dXJuIFZzKHRoaXMsIHQsIFwieVwiLCBlKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBzIH0gPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCJdLCB0KTtcbiAgICByZXR1cm4geyB4OiBlLCB5OiBzIH07XG4gIH1cbiAgc2l6ZSh0KSB7XG4gICAgdCA9IHQgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCBlID0gdC5yYWRpdXMgfHwgMDtcbiAgICBlID0gTWF0aC5tYXgoZSwgZSAmJiB0LmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IHMgPSBlICYmIHQuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKGUgKyBzKSAqIDI7XG4gIH1cbiAgZHJhdyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnNraXAgfHwgcy5yYWRpdXMgPCAwLjEgfHwgIXJlKHRoaXMsIGUsIHRoaXMuc2l6ZShzKSAvIDIpIHx8ICh0LnN0cm9rZVN0eWxlID0gcy5ib3JkZXJDb2xvciwgdC5saW5lV2lkdGggPSBzLmJvcmRlcldpZHRoLCB0LmZpbGxTdHlsZSA9IHMuYmFja2dyb3VuZENvbG9yLCB5aSh0LCBzLCB0aGlzLngsIHRoaXMueSkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHQucmFkaXVzICsgdC5oaXRSYWRpdXM7XG4gIH1cbn1cbnZlLmlkID0gXCJwb2ludFwiO1xudmUuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiBcImNpcmNsZVwiLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59O1xudmUuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmRDb2xvclwiLFxuICBib3JkZXJDb2xvcjogXCJib3JkZXJDb2xvclwiXG59O1xuZnVuY3Rpb24gbm8oaSwgdCkge1xuICBjb25zdCB7IHg6IGUsIHk6IHMsIGJhc2U6IG4sIHdpZHRoOiBvLCBoZWlnaHQ6IHIgfSA9IGkuZ2V0UHJvcHMoW1wieFwiLCBcInlcIiwgXCJiYXNlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sIHQpO1xuICBsZXQgYSwgbCwgYywgaCwgZDtcbiAgcmV0dXJuIGkuaG9yaXpvbnRhbCA/IChkID0gciAvIDIsIGEgPSBNYXRoLm1pbihlLCBuKSwgbCA9IE1hdGgubWF4KGUsIG4pLCBjID0gcyAtIGQsIGggPSBzICsgZCkgOiAoZCA9IG8gLyAyLCBhID0gZSAtIGQsIGwgPSBlICsgZCwgYyA9IE1hdGgubWluKHMsIG4pLCBoID0gTWF0aC5tYXgocywgbikpLCB7IGxlZnQ6IGEsIHRvcDogYywgcmlnaHQ6IGwsIGJvdHRvbTogaCB9O1xufVxuZnVuY3Rpb24gYnQoaSwgdCwgZSwgcykge1xuICByZXR1cm4gaSA/IDAgOiBZKHQsIGUsIHMpO1xufVxuZnVuY3Rpb24gSGwoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5vcHRpb25zLmJvcmRlcldpZHRoLCBuID0gaS5ib3JkZXJTa2lwcGVkLCBvID0ga24ocyk7XG4gIHJldHVybiB7XG4gICAgdDogYnQobi50b3AsIG8udG9wLCAwLCBlKSxcbiAgICByOiBidChuLnJpZ2h0LCBvLnJpZ2h0LCAwLCB0KSxcbiAgICBiOiBidChuLmJvdHRvbSwgby5ib3R0b20sIDAsIGUpLFxuICAgIGw6IGJ0KG4ubGVmdCwgby5sZWZ0LCAwLCB0KVxuICB9O1xufVxuZnVuY3Rpb24gamwoaSwgdCwgZSkge1xuICBjb25zdCB7IGVuYWJsZUJvcmRlclJhZGl1czogcyB9ID0gaS5nZXRQcm9wcyhbXCJlbmFibGVCb3JkZXJSYWRpdXNcIl0pLCBuID0gaS5vcHRpb25zLmJvcmRlclJhZGl1cywgbyA9IER0KG4pLCByID0gTWF0aC5taW4odCwgZSksIGEgPSBpLmJvcmRlclNraXBwZWQsIGwgPSBzIHx8IEQobik7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogYnQoIWwgfHwgYS50b3AgfHwgYS5sZWZ0LCBvLnRvcExlZnQsIDAsIHIpLFxuICAgIHRvcFJpZ2h0OiBidCghbCB8fCBhLnRvcCB8fCBhLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCByKSxcbiAgICBib3R0b21MZWZ0OiBidCghbCB8fCBhLmJvdHRvbSB8fCBhLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgciksXG4gICAgYm90dG9tUmlnaHQ6IGJ0KCFsIHx8IGEuYm90dG9tIHx8IGEucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIHIpXG4gIH07XG59XG5mdW5jdGlvbiAkbChpKSB7XG4gIGNvbnN0IHQgPSBubyhpKSwgZSA9IHQucmlnaHQgLSB0LmxlZnQsIHMgPSB0LmJvdHRvbSAtIHQudG9wLCBuID0gSGwoaSwgZSAvIDIsIHMgLyAyKSwgbyA9IGpsKGksIGUgLyAyLCBzIC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IHQubGVmdCxcbiAgICAgIHk6IHQudG9wLFxuICAgICAgdzogZSxcbiAgICAgIGg6IHMsXG4gICAgICByYWRpdXM6IG9cbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiB0LmxlZnQgKyBuLmwsXG4gICAgICB5OiB0LnRvcCArIG4udCxcbiAgICAgIHc6IGUgLSBuLmwgLSBuLnIsXG4gICAgICBoOiBzIC0gbi50IC0gbi5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIG8udG9wTGVmdCAtIE1hdGgubWF4KG4udCwgbi5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCBvLnRvcFJpZ2h0IC0gTWF0aC5tYXgobi50LCBuLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgby5ib3R0b21MZWZ0IC0gTWF0aC5tYXgobi5iLCBuLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIG8uYm90dG9tUmlnaHQgLSBNYXRoLm1heChuLmIsIG4ucikpXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2koaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gdCA9PT0gbnVsbCwgbyA9IGUgPT09IG51bGwsIGEgPSBpICYmICEobiAmJiBvKSAmJiBubyhpLCBzKTtcbiAgcmV0dXJuIGEgJiYgKG4gfHwgdXQodCwgYS5sZWZ0LCBhLnJpZ2h0KSkgJiYgKG8gfHwgdXQoZSwgYS50b3AsIGEuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBZbChpKSB7XG4gIHJldHVybiBpLnRvcExlZnQgfHwgaS50b3BSaWdodCB8fCBpLmJvdHRvbUxlZnQgfHwgaS5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIFhsKGksIHQpIHtcbiAgaS5yZWN0KHQueCwgdC55LCB0LncsIHQuaCk7XG59XG5mdW5jdGlvbiBwaShpLCB0LCBlID0ge30pIHtcbiAgY29uc3QgcyA9IGkueCAhPT0gZS54ID8gLXQgOiAwLCBuID0gaS55ICE9PSBlLnkgPyAtdCA6IDAsIG8gPSAoaS54ICsgaS53ICE9PSBlLnggKyBlLncgPyB0IDogMCkgLSBzLCByID0gKGkueSArIGkuaCAhPT0gZS55ICsgZS5oID8gdCA6IDApIC0gbjtcbiAgcmV0dXJuIHtcbiAgICB4OiBpLnggKyBzLFxuICAgIHk6IGkueSArIG4sXG4gICAgdzogaS53ICsgbyxcbiAgICBoOiBpLmggKyByLFxuICAgIHJhZGl1czogaS5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIE1lIGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLmhvcml6b250YWwgPSB2b2lkIDAsIHRoaXMuYmFzZSA9IHZvaWQgMCwgdGhpcy53aWR0aCA9IHZvaWQgMCwgdGhpcy5oZWlnaHQgPSB2b2lkIDAsIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHZvaWQgMCwgdCAmJiBPYmplY3QuYXNzaWduKHRoaXMsIHQpO1xuICB9XG4gIGRyYXcodCkge1xuICAgIGNvbnN0IHsgaW5mbGF0ZUFtb3VudDogZSwgb3B0aW9uczogeyBib3JkZXJDb2xvcjogcywgYmFja2dyb3VuZENvbG9yOiBuIH0gfSA9IHRoaXMsIHsgaW5uZXI6IG8sIG91dGVyOiByIH0gPSAkbCh0aGlzKSwgYSA9IFlsKHIucmFkaXVzKSA/IGFlIDogWGw7XG4gICAgdC5zYXZlKCksIChyLncgIT09IG8udyB8fCByLmggIT09IG8uaCkgJiYgKHQuYmVnaW5QYXRoKCksIGEodCwgcGkociwgZSwgbykpLCB0LmNsaXAoKSwgYSh0LCBwaShvLCAtZSwgcikpLCB0LmZpbGxTdHlsZSA9IHMsIHQuZmlsbChcImV2ZW5vZGRcIikpLCB0LmJlZ2luUGF0aCgpLCBhKHQsIHBpKG8sIGUpKSwgdC5maWxsU3R5bGUgPSBuLCB0LmZpbGwoKSwgdC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZSh0LCBlLCBzKSB7XG4gICAgcmV0dXJuIGdpKHRoaXMsIHQsIGUsIHMpO1xuICB9XG4gIGluWFJhbmdlKHQsIGUpIHtcbiAgICByZXR1cm4gZ2kodGhpcywgdCwgbnVsbCwgZSk7XG4gIH1cbiAgaW5ZUmFuZ2UodCwgZSkge1xuICAgIHJldHVybiBnaSh0aGlzLCBudWxsLCB0LCBlKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBzLCBiYXNlOiBuLCBob3Jpem9udGFsOiBvIH0gPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCIsIFwiYmFzZVwiLCBcImhvcml6b250YWxcIl0sIHQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBvID8gKGUgKyBuKSAvIDIgOiBlLFxuICAgICAgeTogbyA/IHMgOiAocyArIG4pIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UodCkge1xuICAgIHJldHVybiB0ID09PSBcInhcIiA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5NZS5pZCA9IFwiYmFyXCI7XG5NZS5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogXCJzdGFydFwiLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiBcImF1dG9cIixcbiAgcG9pbnRTdHlsZTogdm9pZCAwXG59O1xuTWUuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmRDb2xvclwiLFxuICBib3JkZXJDb2xvcjogXCJib3JkZXJDb2xvclwiXG59O1xudmFyIG9vID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFyY0VsZW1lbnQ6IHllLFxuICBMaW5lRWxlbWVudDogZ3QsXG4gIFBvaW50RWxlbWVudDogdmUsXG4gIEJhckVsZW1lbnQ6IE1lXG59KTtcbmZ1bmN0aW9uIFVsKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgbyA9IG4uc2FtcGxlcyB8fCBzO1xuICBpZiAobyA+PSBlKVxuICAgIHJldHVybiBpLnNsaWNlKHQsIHQgKyBlKTtcbiAgY29uc3QgciA9IFtdLCBhID0gKGUgLSAyKSAvIChvIC0gMik7XG4gIGxldCBsID0gMDtcbiAgY29uc3QgYyA9IHQgKyBlIC0gMTtcbiAgbGV0IGggPSB0LCBkLCB1LCBmLCBnLCBwO1xuICBmb3IgKHJbbCsrXSA9IGlbaF0sIGQgPSAwOyBkIDwgbyAtIDI7IGQrKykge1xuICAgIGxldCBtID0gMCwgYiA9IDAsIHg7XG4gICAgY29uc3QgdiA9IE1hdGguZmxvb3IoKGQgKyAxKSAqIGEpICsgMSArIHQsIHkgPSBNYXRoLm1pbihNYXRoLmZsb29yKChkICsgMikgKiBhKSArIDEsIGUpICsgdCwgXyA9IHkgLSB2O1xuICAgIGZvciAoeCA9IHY7IHggPCB5OyB4KyspXG4gICAgICBtICs9IGlbeF0ueCwgYiArPSBpW3hdLnk7XG4gICAgbSAvPSBfLCBiIC89IF87XG4gICAgY29uc3QgTSA9IE1hdGguZmxvb3IoZCAqIGEpICsgMSArIHQsIGsgPSBNYXRoLm1pbihNYXRoLmZsb29yKChkICsgMSkgKiBhKSArIDEsIGUpICsgdCwgeyB4OiBTLCB5OiB3IH0gPSBpW2hdO1xuICAgIGZvciAoZiA9IGcgPSAtMSwgeCA9IE07IHggPCBrOyB4KyspXG4gICAgICBnID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChTIC0gbSkgKiAoaVt4XS55IC0gdykgLSAoUyAtIGlbeF0ueCkgKiAoYiAtIHcpXG4gICAgICApLCBnID4gZiAmJiAoZiA9IGcsIHUgPSBpW3hdLCBwID0geCk7XG4gICAgcltsKytdID0gdSwgaCA9IHA7XG4gIH1cbiAgcmV0dXJuIHJbbCsrXSA9IGlbY10sIHI7XG59XG5mdW5jdGlvbiBLbChpLCB0LCBlLCBzKSB7XG4gIGxldCBuID0gMCwgbyA9IDAsIHIsIGEsIGwsIGMsIGgsIGQsIHUsIGYsIGcsIHA7XG4gIGNvbnN0IG0gPSBbXSwgYiA9IHQgKyBlIC0gMSwgeCA9IGlbdF0ueCwgeSA9IGlbYl0ueCAtIHg7XG4gIGZvciAociA9IHQ7IHIgPCB0ICsgZTsgKytyKSB7XG4gICAgYSA9IGlbcl0sIGwgPSAoYS54IC0geCkgLyB5ICogcywgYyA9IGEueTtcbiAgICBjb25zdCBfID0gbCB8IDA7XG4gICAgaWYgKF8gPT09IGgpXG4gICAgICBjIDwgZyA/IChnID0gYywgZCA9IHIpIDogYyA+IHAgJiYgKHAgPSBjLCB1ID0gciksIG4gPSAobyAqIG4gKyBhLngpIC8gKytvO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgTSA9IHIgLSAxO1xuICAgICAgaWYgKCFUKGQpICYmICFUKHUpKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLm1pbihkLCB1KSwgUyA9IE1hdGgubWF4KGQsIHUpO1xuICAgICAgICBrICE9PSBmICYmIGsgIT09IE0gJiYgbS5wdXNoKHtcbiAgICAgICAgICAuLi5pW2tdLFxuICAgICAgICAgIHg6IG5cbiAgICAgICAgfSksIFMgIT09IGYgJiYgUyAhPT0gTSAmJiBtLnB1c2goe1xuICAgICAgICAgIC4uLmlbU10sXG4gICAgICAgICAgeDogblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHIgPiAwICYmIE0gIT09IGYgJiYgbS5wdXNoKGlbTV0pLCBtLnB1c2goYSksIGggPSBfLCBvID0gMCwgZyA9IHAgPSBjLCBkID0gdSA9IGYgPSByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHJvKGkpIHtcbiAgaWYgKGkuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IHQgPSBpLl9kYXRhO1xuICAgIGRlbGV0ZSBpLl9kZWNpbWF0ZWQsIGRlbGV0ZSBpLl9kYXRhLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJkYXRhXCIsIHsgdmFsdWU6IHQgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFdzKGkpIHtcbiAgaS5kYXRhLmRhdGFzZXRzLmZvckVhY2goKHQpID0+IHtcbiAgICBybyh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBxbChpLCB0KSB7XG4gIGNvbnN0IGUgPSB0Lmxlbmd0aDtcbiAgbGV0IHMgPSAwLCBuO1xuICBjb25zdCB7IGlTY2FsZTogbyB9ID0gaSwgeyBtaW46IHIsIG1heDogYSwgbWluRGVmaW5lZDogbCwgbWF4RGVmaW5lZDogYyB9ID0gby5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiBsICYmIChzID0gWShmdCh0LCBvLmF4aXMsIHIpLmxvLCAwLCBlIC0gMSkpLCBjID8gbiA9IFkoZnQodCwgby5heGlzLCBhKS5oaSArIDEsIHMsIGUpIC0gcyA6IG4gPSBlIC0gcywgeyBzdGFydDogcywgY291bnQ6IG4gfTtcbn1cbnZhciBhbyA9IHtcbiAgaWQ6IFwiZGVjaW1hdGlvblwiLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogXCJtaW4tbWF4XCIsXG4gICAgZW5hYmxlZDogITFcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChpLCB0LCBlKSA9PiB7XG4gICAgaWYgKCFlLmVuYWJsZWQpIHtcbiAgICAgIFdzKGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzID0gaS53aWR0aDtcbiAgICBpLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgY29uc3QgeyBfZGF0YTogciwgaW5kZXhBeGlzOiBhIH0gPSBuLCBsID0gaS5nZXREYXRhc2V0TWV0YShvKSwgYyA9IHIgfHwgbi5kYXRhO1xuICAgICAgaWYgKFp0KFthLCBpLm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09IFwieVwiIHx8ICFsLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBoID0gaS5zY2FsZXNbbC54QXhpc0lEXTtcbiAgICAgIGlmIChoLnR5cGUgIT09IFwibGluZWFyXCIgJiYgaC50eXBlICE9PSBcInRpbWVcIiB8fCBpLm9wdGlvbnMucGFyc2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHsgc3RhcnQ6IGQsIGNvdW50OiB1IH0gPSBxbChsLCBjKTtcbiAgICAgIGNvbnN0IGYgPSBlLnRocmVzaG9sZCB8fCA0ICogcztcbiAgICAgIGlmICh1IDw9IGYpIHtcbiAgICAgICAgcm8obik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFQocikgJiYgKG4uX2RhdGEgPSBjLCBkZWxldGUgbi5kYXRhLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJkYXRhXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIGxldCBnO1xuICAgICAgc3dpdGNoIChlLmFsZ29yaXRobSkge1xuICAgICAgICBjYXNlIFwibHR0YlwiOlxuICAgICAgICAgIGcgPSBVbChjLCBkLCB1LCBzLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1pbi1tYXhcIjpcbiAgICAgICAgICBnID0gS2woYywgZCwgdSwgcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtlLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG4gICAgICBuLl9kZWNpbWF0ZWQgPSBnO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGkpIHtcbiAgICBXcyhpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEdsKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuc2VnbWVudHMsIG4gPSBpLnBvaW50cywgbyA9IHQucG9pbnRzLCByID0gW107XG4gIGZvciAoY29uc3QgYSBvZiBzKSB7XG4gICAgbGV0IHsgc3RhcnQ6IGwsIGVuZDogYyB9ID0gYTtcbiAgICBjID0gJGkobCwgYywgbik7XG4gICAgY29uc3QgaCA9IFBpKGUsIG5bbF0sIG5bY10sIGEubG9vcCk7XG4gICAgaWYgKCF0LnNlZ21lbnRzKSB7XG4gICAgICByLnB1c2goe1xuICAgICAgICBzb3VyY2U6IGEsXG4gICAgICAgIHRhcmdldDogaCxcbiAgICAgICAgc3RhcnQ6IG5bbF0sXG4gICAgICAgIGVuZDogbltjXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZCA9IEZuKHQsIGgpO1xuICAgIGZvciAoY29uc3QgdSBvZiBkKSB7XG4gICAgICBjb25zdCBmID0gUGkoZSwgb1t1LnN0YXJ0XSwgb1t1LmVuZF0sIHUubG9vcCksIGcgPSBFbihhLCBuLCBmKTtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBnKVxuICAgICAgICByLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogcCxcbiAgICAgICAgICB0YXJnZXQ6IHUsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtlXTogTnMoaCwgZiwgXCJzdGFydFwiLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW2VdOiBOcyhoLCBmLCBcImVuZFwiLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFBpKGksIHQsIGUsIHMpIHtcbiAgaWYgKHMpXG4gICAgcmV0dXJuO1xuICBsZXQgbiA9IHRbaV0sIG8gPSBlW2ldO1xuICByZXR1cm4gaSA9PT0gXCJhbmdsZVwiICYmIChuID0gWihuKSwgbyA9IFoobykpLCB7IHByb3BlcnR5OiBpLCBzdGFydDogbiwgZW5kOiBvIH07XG59XG5mdW5jdGlvbiBabChpLCB0KSB7XG4gIGNvbnN0IHsgeDogZSA9IG51bGwsIHk6IHMgPSBudWxsIH0gPSBpIHx8IHt9LCBuID0gdC5wb2ludHMsIG8gPSBbXTtcbiAgcmV0dXJuIHQuc2VnbWVudHMuZm9yRWFjaCgoeyBzdGFydDogciwgZW5kOiBhIH0pID0+IHtcbiAgICBhID0gJGkociwgYSwgbik7XG4gICAgY29uc3QgbCA9IG5bcl0sIGMgPSBuW2FdO1xuICAgIHMgIT09IG51bGwgPyAoby5wdXNoKHsgeDogbC54LCB5OiBzIH0pLCBvLnB1c2goeyB4OiBjLngsIHk6IHMgfSkpIDogZSAhPT0gbnVsbCAmJiAoby5wdXNoKHsgeDogZSwgeTogbC55IH0pLCBvLnB1c2goeyB4OiBlLCB5OiBjLnkgfSkpO1xuICB9KSwgbztcbn1cbmZ1bmN0aW9uICRpKGksIHQsIGUpIHtcbiAgZm9yICg7IHQgPiBpOyB0LS0pIHtcbiAgICBjb25zdCBzID0gZVt0XTtcbiAgICBpZiAoIWlzTmFOKHMueCkgJiYgIWlzTmFOKHMueSkpXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIE5zKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIGkgJiYgdCA/IHMoaVtlXSwgdFtlXSkgOiBpID8gaVtlXSA6IHQgPyB0W2VdIDogMDtcbn1cbmZ1bmN0aW9uIGxvKGksIHQpIHtcbiAgbGV0IGUgPSBbXSwgcyA9ICExO1xuICByZXR1cm4geihpKSA/IChzID0gITAsIGUgPSBpKSA6IGUgPSBabChpLCB0KSwgZS5sZW5ndGggPyBuZXcgZ3Qoe1xuICAgIHBvaW50czogZSxcbiAgICBvcHRpb25zOiB7IHRlbnNpb246IDAgfSxcbiAgICBfbG9vcDogcyxcbiAgICBfZnVsbExvb3A6IHNcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gSHMoaSkge1xuICByZXR1cm4gaSAmJiBpLmZpbGwgIT09ICExO1xufVxuZnVuY3Rpb24gSmwoaSwgdCwgZSkge1xuICBsZXQgbiA9IGlbdF0uZmlsbDtcbiAgY29uc3QgbyA9IFt0XTtcbiAgbGV0IHI7XG4gIGlmICghZSlcbiAgICByZXR1cm4gbjtcbiAgZm9yICg7IG4gIT09ICExICYmIG8uaW5kZXhPZihuKSA9PT0gLTE7ICkge1xuICAgIGlmICghTihuKSlcbiAgICAgIHJldHVybiBuO1xuICAgIGlmIChyID0gaVtuXSwgIXIpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHIudmlzaWJsZSlcbiAgICAgIHJldHVybiBuO1xuICAgIG8ucHVzaChuKSwgbiA9IHIuZmlsbDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBRbChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBzYyhpKTtcbiAgaWYgKEQocykpXG4gICAgcmV0dXJuIGlzTmFOKHMudmFsdWUpID8gITEgOiBzO1xuICBsZXQgbiA9IHBhcnNlRmxvYXQocyk7XG4gIHJldHVybiBOKG4pICYmIE1hdGguZmxvb3IobikgPT09IG4gPyB0YyhzWzBdLCB0LCBuLCBlKSA6IFtcIm9yaWdpblwiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwic3RhY2tcIiwgXCJzaGFwZVwiXS5pbmRleE9mKHMpID49IDAgJiYgcztcbn1cbmZ1bmN0aW9uIHRjKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIChpID09PSBcIi1cIiB8fCBpID09PSBcIitcIikgJiYgKGUgPSB0ICsgZSksIGUgPT09IHQgfHwgZSA8IDAgfHwgZSA+PSBzID8gITEgOiBlO1xufVxuZnVuY3Rpb24gZWMoaSwgdCkge1xuICBsZXQgZSA9IG51bGw7XG4gIHJldHVybiBpID09PSBcInN0YXJ0XCIgPyBlID0gdC5ib3R0b20gOiBpID09PSBcImVuZFwiID8gZSA9IHQudG9wIDogRChpKSA/IGUgPSB0LmdldFBpeGVsRm9yVmFsdWUoaS52YWx1ZSkgOiB0LmdldEJhc2VQaXhlbCAmJiAoZSA9IHQuZ2V0QmFzZVBpeGVsKCkpLCBlO1xufVxuZnVuY3Rpb24gaWMoaSwgdCwgZSkge1xuICBsZXQgcztcbiAgcmV0dXJuIGkgPT09IFwic3RhcnRcIiA/IHMgPSBlIDogaSA9PT0gXCJlbmRcIiA/IHMgPSB0Lm9wdGlvbnMucmV2ZXJzZSA/IHQubWluIDogdC5tYXggOiBEKGkpID8gcyA9IGkudmFsdWUgOiBzID0gdC5nZXRCYXNlVmFsdWUoKSwgcztcbn1cbmZ1bmN0aW9uIHNjKGkpIHtcbiAgY29uc3QgdCA9IGkub3B0aW9ucywgZSA9IHQuZmlsbDtcbiAgbGV0IHMgPSBDKGUgJiYgZS50YXJnZXQsIGUpO1xuICByZXR1cm4gcyA9PT0gdm9pZCAwICYmIChzID0gISF0LmJhY2tncm91bmRDb2xvciksIHMgPT09ICExIHx8IHMgPT09IG51bGwgPyAhMSA6IHMgPT09ICEwID8gXCJvcmlnaW5cIiA6IHM7XG59XG5mdW5jdGlvbiBuYyhpKSB7XG4gIGNvbnN0IHsgc2NhbGU6IHQsIGluZGV4OiBlLCBsaW5lOiBzIH0gPSBpLCBuID0gW10sIG8gPSBzLnNlZ21lbnRzLCByID0gcy5wb2ludHMsIGEgPSBvYyh0LCBlKTtcbiAgYS5wdXNoKGxvKHsgeDogbnVsbCwgeTogdC5ib3R0b20gfSwgcykpO1xuICBmb3IgKGxldCBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspIHtcbiAgICBjb25zdCBjID0gb1tsXTtcbiAgICBmb3IgKGxldCBoID0gYy5zdGFydDsgaCA8PSBjLmVuZDsgaCsrKVxuICAgICAgcmMobiwgcltoXSwgYSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBndCh7IHBvaW50czogbiwgb3B0aW9uczoge30gfSk7XG59XG5mdW5jdGlvbiBvYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBbXSwgcyA9IGkuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoXCJsaW5lXCIpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBvID0gc1tuXTtcbiAgICBpZiAoby5pbmRleCA9PT0gdClcbiAgICAgIGJyZWFrO1xuICAgIG8uaGlkZGVuIHx8IGUudW5zaGlmdChvLmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcmMoaSwgdCwgZSkge1xuICBjb25zdCBzID0gW107XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IG8gPSBlW25dLCB7IGZpcnN0OiByLCBsYXN0OiBhLCBwb2ludDogbCB9ID0gYWMobywgdCwgXCJ4XCIpO1xuICAgIGlmICghKCFsIHx8IHIgJiYgYSkpIHtcbiAgICAgIGlmIChyKVxuICAgICAgICBzLnVuc2hpZnQobCk7XG4gICAgICBlbHNlIGlmIChpLnB1c2gobCksICFhKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaS5wdXNoKC4uLnMpO1xufVxuZnVuY3Rpb24gYWMoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5pbnRlcnBvbGF0ZSh0LCBlKTtcbiAgaWYgKCFzKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgbiA9IHNbZV0sIG8gPSBpLnNlZ21lbnRzLCByID0gaS5wb2ludHM7XG4gIGxldCBhID0gITEsIGwgPSAhMTtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBvLmxlbmd0aDsgYysrKSB7XG4gICAgY29uc3QgaCA9IG9bY10sIGQgPSByW2guc3RhcnRdW2VdLCB1ID0gcltoLmVuZF1bZV07XG4gICAgaWYgKHV0KG4sIGQsIHUpKSB7XG4gICAgICBhID0gbiA9PT0gZCwgbCA9IG4gPT09IHU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZmlyc3Q6IGEsIGxhc3Q6IGwsIHBvaW50OiBzIH07XG59XG5jbGFzcyBjbyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLnggPSB0LngsIHRoaXMueSA9IHQueSwgdGhpcy5yYWRpdXMgPSB0LnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudCh0LCBlLCBzKSB7XG4gICAgY29uc3QgeyB4OiBuLCB5OiBvLCByYWRpdXM6IHIgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUgPSBlIHx8IHsgc3RhcnQ6IDAsIGVuZDogRiB9LCB0LmFyYyhuLCBvLCByLCBlLmVuZCwgZS5zdGFydCwgITApLCAhcy5ib3VuZHM7XG4gIH1cbiAgaW50ZXJwb2xhdGUodCkge1xuICAgIGNvbnN0IHsgeDogZSwgeTogcywgcmFkaXVzOiBuIH0gPSB0aGlzLCBvID0gdC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZSArIE1hdGguY29zKG8pICogbixcbiAgICAgIHk6IHMgKyBNYXRoLnNpbihvKSAqIG4sXG4gICAgICBhbmdsZTogb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGxjKGkpIHtcbiAgY29uc3QgeyBjaGFydDogdCwgZmlsbDogZSwgbGluZTogcyB9ID0gaTtcbiAgaWYgKE4oZSkpXG4gICAgcmV0dXJuIGNjKHQsIGUpO1xuICBpZiAoZSA9PT0gXCJzdGFja1wiKVxuICAgIHJldHVybiBuYyhpKTtcbiAgaWYgKGUgPT09IFwic2hhcGVcIilcbiAgICByZXR1cm4gITA7XG4gIGNvbnN0IG4gPSBoYyhpKTtcbiAgcmV0dXJuIG4gaW5zdGFuY2VvZiBjbyA/IG4gOiBsbyhuLCBzKTtcbn1cbmZ1bmN0aW9uIGNjKGksIHQpIHtcbiAgY29uc3QgZSA9IGkuZ2V0RGF0YXNldE1ldGEodCk7XG4gIHJldHVybiBlICYmIGkuaXNEYXRhc2V0VmlzaWJsZSh0KSA/IGUuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBoYyhpKSB7XG4gIHJldHVybiAoaS5zY2FsZSB8fCB7fSkuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlID8gdWMoaSkgOiBkYyhpKTtcbn1cbmZ1bmN0aW9uIGRjKGkpIHtcbiAgY29uc3QgeyBzY2FsZTogdCA9IHt9LCBmaWxsOiBlIH0gPSBpLCBzID0gZWMoZSwgdCk7XG4gIGlmIChOKHMpKSB7XG4gICAgY29uc3QgbiA9IHQuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG4gPyBzIDogbnVsbCxcbiAgICAgIHk6IG4gPyBudWxsIDogc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1YyhpKSB7XG4gIGNvbnN0IHsgc2NhbGU6IHQsIGZpbGw6IGUgfSA9IGksIHMgPSB0Lm9wdGlvbnMsIG4gPSB0LmdldExhYmVscygpLmxlbmd0aCwgbyA9IHMucmV2ZXJzZSA/IHQubWF4IDogdC5taW4sIHIgPSBpYyhlLCB0LCBvKSwgYSA9IFtdO1xuICBpZiAocy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgbCA9IHQuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIG8pO1xuICAgIHJldHVybiBuZXcgY28oe1xuICAgICAgeDogbC54LFxuICAgICAgeTogbC55LFxuICAgICAgcmFkaXVzOiB0LmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHIpXG4gICAgfSk7XG4gIH1cbiAgZm9yIChsZXQgbCA9IDA7IGwgPCBuOyArK2wpXG4gICAgYS5wdXNoKHQuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGwsIHIpKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBtaShpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBsYyh0KSwgeyBsaW5lOiBuLCBzY2FsZTogbywgYXhpczogciB9ID0gdCwgYSA9IG4ub3B0aW9ucywgbCA9IGEuZmlsbCwgYyA9IGEuYmFja2dyb3VuZENvbG9yLCB7IGFib3ZlOiBoID0gYywgYmVsb3c6IGQgPSBjIH0gPSBsIHx8IHt9O1xuICBzICYmIG4ucG9pbnRzLmxlbmd0aCAmJiAoWGUoaSwgZSksIGZjKGksIHsgbGluZTogbiwgdGFyZ2V0OiBzLCBhYm92ZTogaCwgYmVsb3c6IGQsIGFyZWE6IGUsIHNjYWxlOiBvLCBheGlzOiByIH0pLCBVZShpKSk7XG59XG5mdW5jdGlvbiBmYyhpLCB0KSB7XG4gIGNvbnN0IHsgbGluZTogZSwgdGFyZ2V0OiBzLCBhYm92ZTogbiwgYmVsb3c6IG8sIGFyZWE6IHIsIHNjYWxlOiBhIH0gPSB0LCBsID0gZS5fbG9vcCA/IFwiYW5nbGVcIiA6IHQuYXhpcztcbiAgaS5zYXZlKCksIGwgPT09IFwieFwiICYmIG8gIT09IG4gJiYgKGpzKGksIHMsIHIudG9wKSwgJHMoaSwgeyBsaW5lOiBlLCB0YXJnZXQ6IHMsIGNvbG9yOiBuLCBzY2FsZTogYSwgcHJvcGVydHk6IGwgfSksIGkucmVzdG9yZSgpLCBpLnNhdmUoKSwganMoaSwgcywgci5ib3R0b20pKSwgJHMoaSwgeyBsaW5lOiBlLCB0YXJnZXQ6IHMsIGNvbG9yOiBvLCBzY2FsZTogYSwgcHJvcGVydHk6IGwgfSksIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24ganMoaSwgdCwgZSkge1xuICBjb25zdCB7IHNlZ21lbnRzOiBzLCBwb2ludHM6IG4gfSA9IHQ7XG4gIGxldCBvID0gITAsIHIgPSAhMTtcbiAgaS5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBhIG9mIHMpIHtcbiAgICBjb25zdCB7IHN0YXJ0OiBsLCBlbmQ6IGMgfSA9IGEsIGggPSBuW2xdLCBkID0gblskaShsLCBjLCBuKV07XG4gICAgbyA/IChpLm1vdmVUbyhoLngsIGgueSksIG8gPSAhMSkgOiAoaS5saW5lVG8oaC54LCBlKSwgaS5saW5lVG8oaC54LCBoLnkpKSwgciA9ICEhdC5wYXRoU2VnbWVudChpLCBhLCB7IG1vdmU6IHIgfSksIHIgPyBpLmNsb3NlUGF0aCgpIDogaS5saW5lVG8oZC54LCBlKTtcbiAgfVxuICBpLmxpbmVUbyh0LmZpcnN0KCkueCwgZSksIGkuY2xvc2VQYXRoKCksIGkuY2xpcCgpO1xufVxuZnVuY3Rpb24gJHMoaSwgdCkge1xuICBjb25zdCB7IGxpbmU6IGUsIHRhcmdldDogcywgcHJvcGVydHk6IG4sIGNvbG9yOiBvLCBzY2FsZTogciB9ID0gdCwgYSA9IEdsKGUsIHMsIG4pO1xuICBmb3IgKGNvbnN0IHsgc291cmNlOiBsLCB0YXJnZXQ6IGMsIHN0YXJ0OiBoLCBlbmQ6IGQgfSBvZiBhKSB7XG4gICAgY29uc3QgeyBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHUgPSBvIH0gPSB7fSB9ID0gbCwgZiA9IHMgIT09ICEwO1xuICAgIGkuc2F2ZSgpLCBpLmZpbGxTdHlsZSA9IHUsIGdjKGksIHIsIGYgJiYgUGkobiwgaCwgZCkpLCBpLmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGcgPSAhIWUucGF0aFNlZ21lbnQoaSwgbCk7XG4gICAgbGV0IHA7XG4gICAgaWYgKGYpIHtcbiAgICAgIGcgPyBpLmNsb3NlUGF0aCgpIDogWXMoaSwgcywgZCwgbik7XG4gICAgICBjb25zdCBtID0gISFzLnBhdGhTZWdtZW50KGksIGMsIHsgbW92ZTogZywgcmV2ZXJzZTogITAgfSk7XG4gICAgICBwID0gZyAmJiBtLCBwIHx8IFlzKGksIHMsIGgsIG4pO1xuICAgIH1cbiAgICBpLmNsb3NlUGF0aCgpLCBpLmZpbGwocCA/IFwiZXZlbm9kZFwiIDogXCJub256ZXJvXCIpLCBpLnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2MoaSwgdCwgZSkge1xuICBjb25zdCB7IHRvcDogcywgYm90dG9tOiBuIH0gPSB0LmNoYXJ0LmNoYXJ0QXJlYSwgeyBwcm9wZXJ0eTogbywgc3RhcnQ6IHIsIGVuZDogYSB9ID0gZSB8fCB7fTtcbiAgbyA9PT0gXCJ4XCIgJiYgKGkuYmVnaW5QYXRoKCksIGkucmVjdChyLCBzLCBhIC0gciwgbiAtIHMpLCBpLmNsaXAoKSk7XG59XG5mdW5jdGlvbiBZcyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB0LmludGVycG9sYXRlKGUsIHMpO1xuICBuICYmIGkubGluZVRvKG4ueCwgbi55KTtcbn1cbnZhciBobyA9IHtcbiAgaWQ6IFwiZmlsbGVyXCIsXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSAoaS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGgsIG4gPSBbXTtcbiAgICBsZXQgbywgciwgYSwgbDtcbiAgICBmb3IgKHIgPSAwOyByIDwgczsgKytyKVxuICAgICAgbyA9IGkuZ2V0RGF0YXNldE1ldGEociksIGEgPSBvLmRhdGFzZXQsIGwgPSBudWxsLCBhICYmIGEub3B0aW9ucyAmJiBhIGluc3RhbmNlb2YgZ3QgJiYgKGwgPSB7XG4gICAgICAgIHZpc2libGU6IGkuaXNEYXRhc2V0VmlzaWJsZShyKSxcbiAgICAgICAgaW5kZXg6IHIsXG4gICAgICAgIGZpbGw6IFFsKGEsIHIsIHMpLFxuICAgICAgICBjaGFydDogaSxcbiAgICAgICAgYXhpczogby5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICBzY2FsZTogby52U2NhbGUsXG4gICAgICAgIGxpbmU6IGFcbiAgICAgIH0pLCBvLiRmaWxsZXIgPSBsLCBuLnB1c2gobCk7XG4gICAgZm9yIChyID0gMDsgciA8IHM7ICsrcilcbiAgICAgIGwgPSBuW3JdLCAhKCFsIHx8IGwuZmlsbCA9PT0gITEpICYmIChsLmZpbGwgPSBKbChuLCByLCBlLnByb3BhZ2F0ZSkpO1xuICB9LFxuICBiZWZvcmVEcmF3KGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gZS5kcmF3VGltZSA9PT0gXCJiZWZvcmVEcmF3XCIsIG4gPSBpLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSwgbyA9IGkuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IHIgPSBuLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKSB7XG4gICAgICBjb25zdCBhID0gbltyXS4kZmlsbGVyO1xuICAgICAgYSAmJiAoYS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMobywgYS5heGlzKSwgcyAmJiBhLmZpbGwgJiYgbWkoaS5jdHgsIGEsIG8pKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhpLCB0LCBlKSB7XG4gICAgaWYgKGUuZHJhd1RpbWUgIT09IFwiYmVmb3JlRGF0YXNldHNEcmF3XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IG4gPSBzLmxlbmd0aCAtIDE7IG4gPj0gMDsgLS1uKSB7XG4gICAgICBjb25zdCBvID0gc1tuXS4kZmlsbGVyO1xuICAgICAgSHMobykgJiYgbWkoaS5jdHgsIG8sIGkuY2hhcnRBcmVhKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gdC5tZXRhLiRmaWxsZXI7XG4gICAgIUhzKHMpIHx8IGUuZHJhd1RpbWUgIT09IFwiYmVmb3JlRGF0YXNldERyYXdcIiB8fCBtaShpLmN0eCwgcywgaS5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogITAsXG4gICAgZHJhd1RpbWU6IFwiYmVmb3JlRGF0YXNldERyYXdcIlxuICB9XG59O1xuY29uc3QgWHMgPSAoaSwgdCkgPT4ge1xuICBsZXQgeyBib3hIZWlnaHQ6IGUgPSB0LCBib3hXaWR0aDogcyA9IHQgfSA9IGk7XG4gIHJldHVybiBpLnVzZVBvaW50U3R5bGUgJiYgKGUgPSBNYXRoLm1pbihlLCB0KSwgcyA9IGkucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKHMsIHQpKSwge1xuICAgIGJveFdpZHRoOiBzLFxuICAgIGJveEhlaWdodDogZSxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heCh0LCBlKVxuICB9O1xufSwgcGMgPSAoaSwgdCkgPT4gaSAhPT0gbnVsbCAmJiB0ICE9PSBudWxsICYmIGkuZGF0YXNldEluZGV4ID09PSB0LmRhdGFzZXRJbmRleCAmJiBpLmluZGV4ID09PSB0LmluZGV4O1xuY2xhc3MgVXMgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9hZGRlZCA9ICExLCB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW10sIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbCwgdGhpcy5kb3VnaG51dE1vZGUgPSAhMSwgdGhpcy5jaGFydCA9IHQuY2hhcnQsIHRoaXMub3B0aW9ucyA9IHQub3B0aW9ucywgdGhpcy5jdHggPSB0LmN0eCwgdGhpcy5sZWdlbmRJdGVtcyA9IHZvaWQgMCwgdGhpcy5jb2x1bW5TaXplcyA9IHZvaWQgMCwgdGhpcy5saW5lV2lkdGhzID0gdm9pZCAwLCB0aGlzLm1heEhlaWdodCA9IHZvaWQgMCwgdGhpcy5tYXhXaWR0aCA9IHZvaWQgMCwgdGhpcy50b3AgPSB2b2lkIDAsIHRoaXMuYm90dG9tID0gdm9pZCAwLCB0aGlzLmxlZnQgPSB2b2lkIDAsIHRoaXMucmlnaHQgPSB2b2lkIDAsIHRoaXMuaGVpZ2h0ID0gdm9pZCAwLCB0aGlzLndpZHRoID0gdm9pZCAwLCB0aGlzLl9tYXJnaW5zID0gdm9pZCAwLCB0aGlzLnBvc2l0aW9uID0gdm9pZCAwLCB0aGlzLndlaWdodCA9IHZvaWQgMCwgdGhpcy5mdWxsU2l6ZSA9IHZvaWQgMDtcbiAgfVxuICB1cGRhdGUodCwgZSwgcykge1xuICAgIHRoaXMubWF4V2lkdGggPSB0LCB0aGlzLm1heEhlaWdodCA9IGUsIHRoaXMuX21hcmdpbnMgPSBzLCB0aGlzLnNldERpbWVuc2lvbnMoKSwgdGhpcy5idWlsZExhYmVscygpLCB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgdGhpcy5pc0hvcml6b250YWwoKSA/ICh0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCwgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0LCB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aCkgOiAodGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCwgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcCwgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodCk7XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGUgPSBJKHQuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgdC5maWx0ZXIgJiYgKGUgPSBlLmZpbHRlcigocykgPT4gdC5maWx0ZXIocywgdGhpcy5jaGFydC5kYXRhKSkpLCB0LnNvcnQgJiYgKGUgPSBlLnNvcnQoKHMsIG4pID0+IHQuc29ydChzLCBuLCB0aGlzLmNoYXJ0LmRhdGEpKSksIHRoaXMub3B0aW9ucy5yZXZlcnNlICYmIGUucmV2ZXJzZSgpLCB0aGlzLmxlZ2VuZEl0ZW1zID0gZTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zOiB0LCBjdHg6IGUgfSA9IHRoaXM7XG4gICAgaWYgKCF0LmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0LmxhYmVscywgbiA9ICQocy5mb250KSwgbyA9IG4uc2l6ZSwgciA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpLCB7IGJveFdpZHRoOiBhLCBpdGVtSGVpZ2h0OiBsIH0gPSBYcyhzLCBvKTtcbiAgICBsZXQgYywgaDtcbiAgICBlLmZvbnQgPSBuLnN0cmluZywgdGhpcy5pc0hvcml6b250YWwoKSA/IChjID0gdGhpcy5tYXhXaWR0aCwgaCA9IHRoaXMuX2ZpdFJvd3MociwgbywgYSwgbCkgKyAxMCkgOiAoaCA9IHRoaXMubWF4SGVpZ2h0LCBjID0gdGhpcy5fZml0Q29scyhyLCBvLCBhLCBsKSArIDEwKSwgdGhpcy53aWR0aCA9IE1hdGgubWluKGMsIHQubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCksIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaCwgdC5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCB7IGN0eDogbywgbWF4V2lkdGg6IHIsIG9wdGlvbnM6IHsgbGFiZWxzOiB7IHBhZGRpbmc6IGEgfSB9IH0gPSB0aGlzLCBsID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdLCBjID0gdGhpcy5saW5lV2lkdGhzID0gWzBdLCBoID0gbiArIGE7XG4gICAgbGV0IGQgPSB0O1xuICAgIG8udGV4dEFsaWduID0gXCJsZWZ0XCIsIG8udGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICBsZXQgdSA9IC0xLCBmID0gLWg7XG4gICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgoZywgcCkgPT4ge1xuICAgICAgY29uc3QgbSA9IHMgKyBlIC8gMiArIG8ubWVhc3VyZVRleHQoZy50ZXh0KS53aWR0aDtcbiAgICAgIChwID09PSAwIHx8IGNbYy5sZW5ndGggLSAxXSArIG0gKyAyICogYSA+IHIpICYmIChkICs9IGgsIGNbYy5sZW5ndGggLSAocCA+IDAgPyAwIDogMSldID0gMCwgZiArPSBoLCB1KyspLCBsW3BdID0geyBsZWZ0OiAwLCB0b3A6IGYsIHJvdzogdSwgd2lkdGg6IG0sIGhlaWdodDogbiB9LCBjW2MubGVuZ3RoIC0gMV0gKz0gbSArIGE7XG4gICAgfSksIGQ7XG4gIH1cbiAgX2ZpdENvbHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgY3R4OiBvLCBtYXhIZWlnaHQ6IHIsIG9wdGlvbnM6IHsgbGFiZWxzOiB7IHBhZGRpbmc6IGEgfSB9IH0gPSB0aGlzLCBsID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdLCBjID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdLCBoID0gciAtIHQ7XG4gICAgbGV0IGQgPSBhLCB1ID0gMCwgZiA9IDAsIGcgPSAwLCBwID0gMDtcbiAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChtLCBiKSA9PiB7XG4gICAgICBjb25zdCB4ID0gcyArIGUgLyAyICsgby5tZWFzdXJlVGV4dChtLnRleHQpLndpZHRoO1xuICAgICAgYiA+IDAgJiYgZiArIG4gKyAyICogYSA+IGggJiYgKGQgKz0gdSArIGEsIGMucHVzaCh7IHdpZHRoOiB1LCBoZWlnaHQ6IGYgfSksIGcgKz0gdSArIGEsIHArKywgdSA9IGYgPSAwKSwgbFtiXSA9IHsgbGVmdDogZywgdG9wOiBmLCBjb2w6IHAsIHdpZHRoOiB4LCBoZWlnaHQ6IG4gfSwgdSA9IE1hdGgubWF4KHUsIHgpLCBmICs9IG4gKyBhO1xuICAgIH0pLCBkICs9IHUsIGMucHVzaCh7IHdpZHRoOiB1LCBoZWlnaHQ6IGYgfSksIGQ7XG4gIH1cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCksIHsgbGVnZW5kSGl0Qm94ZXM6IGUsIG9wdGlvbnM6IHsgYWxpZ246IHMsIGxhYmVsczogeyBwYWRkaW5nOiBuIH0sIHJ0bDogbyB9IH0gPSB0aGlzLCByID0genQobywgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IGEgPSAwLCBsID0gVShzLCB0aGlzLmxlZnQgKyBuLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW2FdKTtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBlKVxuICAgICAgICBhICE9PSBjLnJvdyAmJiAoYSA9IGMucm93LCBsID0gVShzLCB0aGlzLmxlZnQgKyBuLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW2FdKSksIGMudG9wICs9IHRoaXMudG9wICsgdCArIG4sIGMubGVmdCA9IHIubGVmdEZvckx0cihyLngobCksIGMud2lkdGgpLCBsICs9IGMud2lkdGggKyBuO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYSA9IDAsIGwgPSBVKHMsIHRoaXMudG9wICsgdCArIG4sIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1thXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBjIG9mIGUpXG4gICAgICAgIGMuY29sICE9PSBhICYmIChhID0gYy5jb2wsIGwgPSBVKHMsIHRoaXMudG9wICsgdCArIG4sIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1thXS5oZWlnaHQpKSwgYy50b3AgPSBsLCBjLmxlZnQgKz0gdGhpcy5sZWZ0ICsgbiwgYy5sZWZ0ID0gci5sZWZ0Rm9yTHRyKHIueChjLmxlZnQpLCBjLndpZHRoKSwgbCArPSBjLmhlaWdodCArIG47XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSBcInRvcFwiIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuY3R4O1xuICAgICAgWGUodCwgdGhpcyksIHRoaXMuX2RyYXcoKSwgVWUodCk7XG4gICAgfVxuICB9XG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHsgb3B0aW9uczogdCwgY29sdW1uU2l6ZXM6IGUsIGxpbmVXaWR0aHM6IHMsIGN0eDogbiB9ID0gdGhpcywgeyBhbGlnbjogbywgbGFiZWxzOiByIH0gPSB0LCBhID0gTy5jb2xvciwgbCA9IHp0KHQucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpLCBjID0gJChyLmZvbnQpLCB7IGNvbG9yOiBoLCBwYWRkaW5nOiBkIH0gPSByLCB1ID0gYy5zaXplLCBmID0gdSAvIDI7XG4gICAgbGV0IGc7XG4gICAgdGhpcy5kcmF3VGl0bGUoKSwgbi50ZXh0QWxpZ24gPSBsLnRleHRBbGlnbihcImxlZnRcIiksIG4udGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgbi5saW5lV2lkdGggPSAwLjUsIG4uZm9udCA9IGMuc3RyaW5nO1xuICAgIGNvbnN0IHsgYm94V2lkdGg6IHAsIGJveEhlaWdodDogbSwgaXRlbUhlaWdodDogYiB9ID0gWHMociwgdSksIHggPSBmdW5jdGlvbihrLCBTLCB3KSB7XG4gICAgICBpZiAoaXNOYU4ocCkgfHwgcCA8PSAwIHx8IGlzTmFOKG0pIHx8IG0gPCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBuLnNhdmUoKTtcbiAgICAgIGNvbnN0IEwgPSBDKHcubGluZVdpZHRoLCAxKTtcbiAgICAgIGlmIChuLmZpbGxTdHlsZSA9IEMody5maWxsU3R5bGUsIGEpLCBuLmxpbmVDYXAgPSBDKHcubGluZUNhcCwgXCJidXR0XCIpLCBuLmxpbmVEYXNoT2Zmc2V0ID0gQyh3LmxpbmVEYXNoT2Zmc2V0LCAwKSwgbi5saW5lSm9pbiA9IEMody5saW5lSm9pbiwgXCJtaXRlclwiKSwgbi5saW5lV2lkdGggPSBMLCBuLnN0cm9rZVN0eWxlID0gQyh3LnN0cm9rZVN0eWxlLCBhKSwgbi5zZXRMaW5lRGFzaChDKHcubGluZURhc2gsIFtdKSksIHIudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBSID0ge1xuICAgICAgICAgIHJhZGl1czogbSAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IHcucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogdy5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogTFxuICAgICAgICB9LCBBID0gbC54UGx1cyhrLCBwIC8gMiksIEggPSBTICsgZjtcbiAgICAgICAgTW4obiwgUiwgQSwgSCwgci5wb2ludFN0eWxlV2lkdGggJiYgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBSID0gUyArIE1hdGgubWF4KCh1IC0gbSkgLyAyLCAwKSwgQSA9IGwubGVmdEZvckx0cihrLCBwKSwgSCA9IER0KHcuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgbi5iZWdpblBhdGgoKSwgT2JqZWN0LnZhbHVlcyhIKS5zb21lKChxKSA9PiBxICE9PSAwKSA/IGFlKG4sIHtcbiAgICAgICAgICB4OiBBLFxuICAgICAgICAgIHk6IFIsXG4gICAgICAgICAgdzogcCxcbiAgICAgICAgICBoOiBtLFxuICAgICAgICAgIHJhZGl1czogSFxuICAgICAgICB9KSA6IG4ucmVjdChBLCBSLCBwLCBtKSwgbi5maWxsKCksIEwgIT09IDAgJiYgbi5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIG4ucmVzdG9yZSgpO1xuICAgIH0sIHYgPSBmdW5jdGlvbihrLCBTLCB3KSB7XG4gICAgICBUdChuLCB3LnRleHQsIGssIFMgKyBiIC8gMiwgYywge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiB3LmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBsLnRleHRBbGlnbih3LnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH0sIHkgPSB0aGlzLmlzSG9yaXpvbnRhbCgpLCBfID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgeSA/IGcgPSB7XG4gICAgICB4OiBVKG8sIHRoaXMubGVmdCArIGQsIHRoaXMucmlnaHQgLSBzWzBdKSxcbiAgICAgIHk6IHRoaXMudG9wICsgZCArIF8sXG4gICAgICBsaW5lOiAwXG4gICAgfSA6IGcgPSB7XG4gICAgICB4OiB0aGlzLmxlZnQgKyBkLFxuICAgICAgeTogVShvLCB0aGlzLnRvcCArIF8gKyBkLCB0aGlzLmJvdHRvbSAtIGVbMF0uaGVpZ2h0KSxcbiAgICAgIGxpbmU6IDBcbiAgICB9LCBUbih0aGlzLmN0eCwgdC50ZXh0RGlyZWN0aW9uKTtcbiAgICBjb25zdCBNID0gYiArIGQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChrLCBTKSA9PiB7XG4gICAgICBuLnN0cm9rZVN0eWxlID0gay5mb250Q29sb3IgfHwgaCwgbi5maWxsU3R5bGUgPSBrLmZvbnRDb2xvciB8fCBoO1xuICAgICAgY29uc3QgdyA9IG4ubWVhc3VyZVRleHQoay50ZXh0KS53aWR0aCwgTCA9IGwudGV4dEFsaWduKGsudGV4dEFsaWduIHx8IChrLnRleHRBbGlnbiA9IHIudGV4dEFsaWduKSksIFIgPSBwICsgZiArIHc7XG4gICAgICBsZXQgQSA9IGcueCwgSCA9IGcueTtcbiAgICAgIGwuc2V0V2lkdGgodGhpcy53aWR0aCksIHkgPyBTID4gMCAmJiBBICsgUiArIGQgPiB0aGlzLnJpZ2h0ICYmIChIID0gZy55ICs9IE0sIGcubGluZSsrLCBBID0gZy54ID0gVShvLCB0aGlzLmxlZnQgKyBkLCB0aGlzLnJpZ2h0IC0gc1tnLmxpbmVdKSkgOiBTID4gMCAmJiBIICsgTSA+IHRoaXMuYm90dG9tICYmIChBID0gZy54ID0gQSArIGVbZy5saW5lXS53aWR0aCArIGQsIGcubGluZSsrLCBIID0gZy55ID0gVShvLCB0aGlzLnRvcCArIF8gKyBkLCB0aGlzLmJvdHRvbSAtIGVbZy5saW5lXS5oZWlnaHQpKTtcbiAgICAgIGNvbnN0IHEgPSBsLngoQSk7XG4gICAgICB4KHEsIEgsIGspLCBBID0gSW8oTCwgQSArIHAgKyBmLCB5ID8gQSArIFIgOiB0aGlzLnJpZ2h0LCB0LnJ0bCksIHYobC54KEEpLCBILCBrKSwgeSA/IGcueCArPSBSICsgZCA6IGcueSArPSBNO1xuICAgIH0pLCBMbih0aGlzLmN0eCwgdC50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHQudGl0bGUsIHMgPSAkKGUuZm9udCksIG4gPSBLKGUucGFkZGluZyk7XG4gICAgaWYgKCFlLmRpc3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IHp0KHQucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpLCByID0gdGhpcy5jdHgsIGEgPSBlLnBvc2l0aW9uLCBsID0gcy5zaXplIC8gMiwgYyA9IG4udG9wICsgbDtcbiAgICBsZXQgaCwgZCA9IHRoaXMubGVmdCwgdSA9IHRoaXMud2lkdGg7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpXG4gICAgICB1ID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKSwgaCA9IHRoaXMudG9wICsgYywgZCA9IFUodC5hbGlnbiwgZCwgdGhpcy5yaWdodCAtIHUpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZyA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChwLCBtKSA9PiBNYXRoLm1heChwLCBtLmhlaWdodCksIDApO1xuICAgICAgaCA9IGMgKyBVKHQuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIGcgLSB0LmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCBmID0gVShhLCBkLCBkICsgdSk7XG4gICAgci50ZXh0QWxpZ24gPSBvLnRleHRBbGlnbihMaShhKSksIHIudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgci5zdHJva2VTdHlsZSA9IGUuY29sb3IsIHIuZmlsbFN0eWxlID0gZS5jb2xvciwgci5mb250ID0gcy5zdHJpbmcsIFR0KHIsIGUudGV4dCwgZiwgaCwgcyk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnRpdGxlLCBlID0gJCh0LmZvbnQpLCBzID0gSyh0LnBhZGRpbmcpO1xuICAgIHJldHVybiB0LmRpc3BsYXkgPyBlLmxpbmVIZWlnaHQgKyBzLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh0LCBlKSB7XG4gICAgbGV0IHMsIG4sIG87XG4gICAgaWYgKHV0KHQsIHRoaXMubGVmdCwgdGhpcy5yaWdodCkgJiYgdXQoZSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgZm9yIChvID0gdGhpcy5sZWdlbmRIaXRCb3hlcywgcyA9IDA7IHMgPCBvLmxlbmd0aDsgKytzKVxuICAgICAgICBpZiAobiA9IG9bc10sIHV0KHQsIG4ubGVmdCwgbi5sZWZ0ICsgbi53aWR0aCkgJiYgdXQoZSwgbi50b3AsIG4udG9wICsgbi5oZWlnaHQpKVxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW3NdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW1jKHQudHlwZSwgZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdCh0LngsIHQueSk7XG4gICAgaWYgKHQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiB8fCB0LnR5cGUgPT09IFwibW91c2VvdXRcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX2hvdmVyZWRJdGVtLCBvID0gcGMobiwgcyk7XG4gICAgICBuICYmICFvICYmIEkoZS5vbkxlYXZlLCBbdCwgbiwgdGhpc10sIHRoaXMpLCB0aGlzLl9ob3ZlcmVkSXRlbSA9IHMsIHMgJiYgIW8gJiYgSShlLm9uSG92ZXIsIFt0LCBzLCB0aGlzXSwgdGhpcyk7XG4gICAgfSBlbHNlXG4gICAgICBzICYmIEkoZS5vbkNsaWNrLCBbdCwgcywgdGhpc10sIHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBtYyhpLCB0KSB7XG4gIHJldHVybiAhISgoaSA9PT0gXCJtb3VzZW1vdmVcIiB8fCBpID09PSBcIm1vdXNlb3V0XCIpICYmICh0Lm9uSG92ZXIgfHwgdC5vbkxlYXZlKSB8fCB0Lm9uQ2xpY2sgJiYgKGkgPT09IFwiY2xpY2tcIiB8fCBpID09PSBcIm1vdXNldXBcIikpO1xufVxudmFyIHVvID0ge1xuICBpZDogXCJsZWdlbmRcIixcbiAgX2VsZW1lbnQ6IFVzLFxuICBzdGFydChpLCB0LCBlKSB7XG4gICAgY29uc3QgcyA9IGkubGVnZW5kID0gbmV3IFVzKHsgY3R4OiBpLmN0eCwgb3B0aW9uczogZSwgY2hhcnQ6IGkgfSk7XG4gICAgWC5jb25maWd1cmUoaSwgcywgZSksIFguYWRkQm94KGksIHMpO1xuICB9LFxuICBzdG9wKGkpIHtcbiAgICBYLnJlbW92ZUJveChpLCBpLmxlZ2VuZCksIGRlbGV0ZSBpLmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gaS5sZWdlbmQ7XG4gICAgWC5jb25maWd1cmUoaSwgcywgZSksIHMub3B0aW9ucyA9IGU7XG4gIH0sXG4gIGFmdGVyVXBkYXRlKGkpIHtcbiAgICBjb25zdCB0ID0gaS5sZWdlbmQ7XG4gICAgdC5idWlsZExhYmVscygpLCB0LmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoaSwgdCkge1xuICAgIHQucmVwbGF5IHx8IGkubGVnZW5kLmhhbmRsZUV2ZW50KHQuZXZlbnQpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6ICEwLFxuICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGZ1bGxTaXplOiAhMCxcbiAgICByZXZlcnNlOiAhMSxcbiAgICB3ZWlnaHQ6IDFlMyxcbiAgICBvbkNsaWNrKGksIHQsIGUpIHtcbiAgICAgIGNvbnN0IHMgPSB0LmRhdGFzZXRJbmRleCwgbiA9IGUuY2hhcnQ7XG4gICAgICBuLmlzRGF0YXNldFZpc2libGUocykgPyAobi5oaWRlKHMpLCB0LmhpZGRlbiA9ICEwKSA6IChuLnNob3cocyksIHQuaGlkZGVuID0gITEpO1xuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChpKSA9PiBpLmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGkpIHtcbiAgICAgICAgY29uc3QgdCA9IGkuZGF0YS5kYXRhc2V0cywgeyBsYWJlbHM6IHsgdXNlUG9pbnRTdHlsZTogZSwgcG9pbnRTdHlsZTogcywgdGV4dEFsaWduOiBuLCBjb2xvcjogbyB9IH0gPSBpLmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gaS5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChyKSA9PiB7XG4gICAgICAgICAgY29uc3QgYSA9IHIuY29udHJvbGxlci5nZXRTdHlsZShlID8gMCA6IHZvaWQgMCksIGwgPSBLKGEuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0W3IuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBhLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogbyxcbiAgICAgICAgICAgIGhpZGRlbjogIXIudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IGEuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogYS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IGEuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBhLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGwud2lkdGggKyBsLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IGEuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBzIHx8IGEucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBhLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiBuIHx8IGEudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiByLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChpKSA9PiBpLmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiAhMSxcbiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiLFxuICAgICAgdGV4dDogXCJcIlxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKGkpID0+ICFpLnN0YXJ0c1dpdGgoXCJvblwiKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAoaSkgPT4gIVtcImdlbmVyYXRlTGFiZWxzXCIsIFwiZmlsdGVyXCIsIFwic29ydFwiXS5pbmNsdWRlcyhpKVxuICAgIH1cbiAgfVxufTtcbmNsYXNzIFlpIGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jaGFydCA9IHQuY2hhcnQsIHRoaXMub3B0aW9ucyA9IHQub3B0aW9ucywgdGhpcy5jdHggPSB0LmN0eCwgdGhpcy5fcGFkZGluZyA9IHZvaWQgMCwgdGhpcy50b3AgPSB2b2lkIDAsIHRoaXMuYm90dG9tID0gdm9pZCAwLCB0aGlzLmxlZnQgPSB2b2lkIDAsIHRoaXMucmlnaHQgPSB2b2lkIDAsIHRoaXMud2lkdGggPSB2b2lkIDAsIHRoaXMuaGVpZ2h0ID0gdm9pZCAwLCB0aGlzLnBvc2l0aW9uID0gdm9pZCAwLCB0aGlzLndlaWdodCA9IHZvaWQgMCwgdGhpcy5mdWxsU2l6ZSA9IHZvaWQgMDtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMubGVmdCA9IDAsIHRoaXMudG9wID0gMCwgIXMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSB0LCB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gZTtcbiAgICBjb25zdCBuID0geihzLnRleHQpID8gcy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IEsocy5wYWRkaW5nKTtcbiAgICBjb25zdCBvID0gbiAqICQocy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMuaGVpZ2h0ID0gbyA6IHRoaXMud2lkdGggPSBvO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiB0ID09PSBcInRvcFwiIHx8IHQgPT09IFwiYm90dG9tXCI7XG4gIH1cbiAgX2RyYXdBcmdzKHQpIHtcbiAgICBjb25zdCB7IHRvcDogZSwgbGVmdDogcywgYm90dG9tOiBuLCByaWdodDogbywgb3B0aW9uczogciB9ID0gdGhpcywgYSA9IHIuYWxpZ247XG4gICAgbGV0IGwgPSAwLCBjLCBoLCBkO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGggPSBVKGEsIHMsIG8pLCBkID0gZSArIHQsIGMgPSBvIC0gcykgOiAoci5wb3NpdGlvbiA9PT0gXCJsZWZ0XCIgPyAoaCA9IHMgKyB0LCBkID0gVShhLCBuLCBlKSwgbCA9IEIgKiAtMC41KSA6IChoID0gbyAtIHQsIGQgPSBVKGEsIGUsIG4pLCBsID0gQiAqIDAuNSksIGMgPSBuIC0gZSksIHsgdGl0bGVYOiBoLCB0aXRsZVk6IGQsIG1heFdpZHRoOiBjLCByb3RhdGlvbjogbCB9O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3R4LCBlID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghZS5kaXNwbGF5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSAkKGUuZm9udCksIG8gPSBzLmxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3AsIHsgdGl0bGVYOiByLCB0aXRsZVk6IGEsIG1heFdpZHRoOiBsLCByb3RhdGlvbjogYyB9ID0gdGhpcy5fZHJhd0FyZ3Mobyk7XG4gICAgVHQodCwgZS50ZXh0LCAwLCAwLCBzLCB7XG4gICAgICBjb2xvcjogZS5jb2xvcixcbiAgICAgIG1heFdpZHRoOiBsLFxuICAgICAgcm90YXRpb246IGMsXG4gICAgICB0ZXh0QWxpZ246IExpKGUuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgdHJhbnNsYXRpb246IFtyLCBhXVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBiYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBuZXcgWWkoe1xuICAgIGN0eDogaS5jdHgsXG4gICAgb3B0aW9uczogdCxcbiAgICBjaGFydDogaVxuICB9KTtcbiAgWC5jb25maWd1cmUoaSwgZSwgdCksIFguYWRkQm94KGksIGUpLCBpLnRpdGxlQmxvY2sgPSBlO1xufVxudmFyIGZvID0ge1xuICBpZDogXCJ0aXRsZVwiLFxuICBfZWxlbWVudDogWWksXG4gIHN0YXJ0KGksIHQsIGUpIHtcbiAgICBiYyhpLCBlKTtcbiAgfSxcbiAgc3RvcChpKSB7XG4gICAgY29uc3QgdCA9IGkudGl0bGVCbG9jaztcbiAgICBYLnJlbW92ZUJveChpLCB0KSwgZGVsZXRlIGkudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gaS50aXRsZUJsb2NrO1xuICAgIFguY29uZmlndXJlKGksIHMsIGUpLCBzLm9wdGlvbnMgPSBlO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGRpc3BsYXk6ICExLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogXCJib2xkXCJcbiAgICB9LFxuICAgIGZ1bGxTaXplOiAhMCxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHdlaWdodDogMmUzXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogXCJjb2xvclwiXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6ICEwLFxuICAgIF9pbmRleGFibGU6ICExXG4gIH1cbn07XG5jb25zdCBSZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGdvID0ge1xuICBpZDogXCJzdWJ0aXRsZVwiLFxuICBzdGFydChpLCB0LCBlKSB7XG4gICAgY29uc3QgcyA9IG5ldyBZaSh7XG4gICAgICBjdHg6IGkuY3R4LFxuICAgICAgb3B0aW9uczogZSxcbiAgICAgIGNoYXJ0OiBpXG4gICAgfSk7XG4gICAgWC5jb25maWd1cmUoaSwgcywgZSksIFguYWRkQm94KGksIHMpLCBSZS5zZXQoaSwgcyk7XG4gIH0sXG4gIHN0b3AoaSkge1xuICAgIFgucmVtb3ZlQm94KGksIFJlLmdldChpKSksIFJlLmRlbGV0ZShpKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gUmUuZ2V0KGkpO1xuICAgIFguY29uZmlndXJlKGksIHMsIGUpLCBzLm9wdGlvbnMgPSBlO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGRpc3BsYXk6ICExLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogXCJub3JtYWxcIlxuICAgIH0sXG4gICAgZnVsbFNpemU6ICEwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246IFwidG9wXCIsXG4gICAgdGV4dDogXCJcIixcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiBcImNvbG9yXCJcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogITAsXG4gICAgX2luZGV4YWJsZTogITFcbiAgfVxufTtcbmNvbnN0IHNlID0ge1xuICBhdmVyYWdlKGkpIHtcbiAgICBpZiAoIWkubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCB0LCBlLCBzID0gMCwgbiA9IDAsIG8gPSAwO1xuICAgIGZvciAodCA9IDAsIGUgPSBpLmxlbmd0aDsgdCA8IGU7ICsrdCkge1xuICAgICAgY29uc3QgciA9IGlbdF0uZWxlbWVudDtcbiAgICAgIGlmIChyICYmIHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBhID0gci50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgcyArPSBhLngsIG4gKz0gYS55LCArK287XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBzIC8gbyxcbiAgICAgIHk6IG4gLyBvXG4gICAgfTtcbiAgfSxcbiAgbmVhcmVzdChpLCB0KSB7XG4gICAgaWYgKCFpLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgZSA9IHQueCwgcyA9IHQueSwgbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbywgciwgYTtcbiAgICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgIGNvbnN0IGwgPSBpW29dLmVsZW1lbnQ7XG4gICAgICBpZiAobCAmJiBsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgYyA9IGwuZ2V0Q2VudGVyUG9pbnQoKSwgaCA9IGJpKHQsIGMpO1xuICAgICAgICBoIDwgbiAmJiAobiA9IGgsIGEgPSBsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIGNvbnN0IGwgPSBhLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgZSA9IGwueCwgcyA9IGwueTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUsXG4gICAgICB5OiBzXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJ0KGksIHQpIHtcbiAgcmV0dXJuIHQgJiYgKHoodCkgPyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpLCB0KSA6IGkucHVzaCh0KSksIGk7XG59XG5mdW5jdGlvbiBodChpKSB7XG4gIHJldHVybiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIiB8fCBpIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBpLmluZGV4T2YoYFxuYCkgPiAtMSA/IGkuc3BsaXQoYFxuYCkgOiBpO1xufVxuZnVuY3Rpb24geGMoaSwgdCkge1xuICBjb25zdCB7IGVsZW1lbnQ6IGUsIGRhdGFzZXRJbmRleDogcywgaW5kZXg6IG4gfSA9IHQsIG8gPSBpLmdldERhdGFzZXRNZXRhKHMpLmNvbnRyb2xsZXIsIHsgbGFiZWw6IHIsIHZhbHVlOiBhIH0gPSBvLmdldExhYmVsQW5kVmFsdWUobik7XG4gIHJldHVybiB7XG4gICAgY2hhcnQ6IGksXG4gICAgbGFiZWw6IHIsXG4gICAgcGFyc2VkOiBvLmdldFBhcnNlZChuKSxcbiAgICByYXc6IGkuZGF0YS5kYXRhc2V0c1tzXS5kYXRhW25dLFxuICAgIGZvcm1hdHRlZFZhbHVlOiBhLFxuICAgIGRhdGFzZXQ6IG8uZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogbixcbiAgICBkYXRhc2V0SW5kZXg6IHMsXG4gICAgZWxlbWVudDogZVxuICB9O1xufVxuZnVuY3Rpb24gS3MoaSwgdCkge1xuICBjb25zdCBlID0gaS5jaGFydC5jdHgsIHsgYm9keTogcywgZm9vdGVyOiBuLCB0aXRsZTogbyB9ID0gaSwgeyBib3hXaWR0aDogciwgYm94SGVpZ2h0OiBhIH0gPSB0LCBsID0gJCh0LmJvZHlGb250KSwgYyA9ICQodC50aXRsZUZvbnQpLCBoID0gJCh0LmZvb3RlckZvbnQpLCBkID0gby5sZW5ndGgsIHUgPSBuLmxlbmd0aCwgZiA9IHMubGVuZ3RoLCBnID0gSyh0LnBhZGRpbmcpO1xuICBsZXQgcCA9IGcuaGVpZ2h0LCBtID0gMCwgYiA9IHMucmVkdWNlKCh5LCBfKSA9PiB5ICsgXy5iZWZvcmUubGVuZ3RoICsgXy5saW5lcy5sZW5ndGggKyBfLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGlmIChiICs9IGkuYmVmb3JlQm9keS5sZW5ndGggKyBpLmFmdGVyQm9keS5sZW5ndGgsIGQgJiYgKHAgKz0gZCAqIGMubGluZUhlaWdodCArIChkIC0gMSkgKiB0LnRpdGxlU3BhY2luZyArIHQudGl0bGVNYXJnaW5Cb3R0b20pLCBiKSB7XG4gICAgY29uc3QgeSA9IHQuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGEsIGwubGluZUhlaWdodCkgOiBsLmxpbmVIZWlnaHQ7XG4gICAgcCArPSBmICogeSArIChiIC0gZikgKiBsLmxpbmVIZWlnaHQgKyAoYiAtIDEpICogdC5ib2R5U3BhY2luZztcbiAgfVxuICB1ICYmIChwICs9IHQuZm9vdGVyTWFyZ2luVG9wICsgdSAqIGgubGluZUhlaWdodCArICh1IC0gMSkgKiB0LmZvb3RlclNwYWNpbmcpO1xuICBsZXQgeCA9IDA7XG4gIGNvbnN0IHYgPSBmdW5jdGlvbih5KSB7XG4gICAgbSA9IE1hdGgubWF4KG0sIGUubWVhc3VyZVRleHQoeSkud2lkdGggKyB4KTtcbiAgfTtcbiAgcmV0dXJuIGUuc2F2ZSgpLCBlLmZvbnQgPSBjLnN0cmluZywgRShpLnRpdGxlLCB2KSwgZS5mb250ID0gbC5zdHJpbmcsIEUoaS5iZWZvcmVCb2R5LmNvbmNhdChpLmFmdGVyQm9keSksIHYpLCB4ID0gdC5kaXNwbGF5Q29sb3JzID8gciArIDIgKyB0LmJveFBhZGRpbmcgOiAwLCBFKHMsICh5KSA9PiB7XG4gICAgRSh5LmJlZm9yZSwgdiksIEUoeS5saW5lcywgdiksIEUoeS5hZnRlciwgdik7XG4gIH0pLCB4ID0gMCwgZS5mb250ID0gaC5zdHJpbmcsIEUoaS5mb290ZXIsIHYpLCBlLnJlc3RvcmUoKSwgbSArPSBnLndpZHRoLCB7IHdpZHRoOiBtLCBoZWlnaHQ6IHAgfTtcbn1cbmZ1bmN0aW9uIF9jKGksIHQpIHtcbiAgY29uc3QgeyB5OiBlLCBoZWlnaHQ6IHMgfSA9IHQ7XG4gIHJldHVybiBlIDwgcyAvIDIgPyBcInRvcFwiIDogZSA+IGkuaGVpZ2h0IC0gcyAvIDIgPyBcImJvdHRvbVwiIDogXCJjZW50ZXJcIjtcbn1cbmZ1bmN0aW9uIHljKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyB4OiBuLCB3aWR0aDogbyB9ID0gcywgciA9IGUuY2FyZXRTaXplICsgZS5jYXJldFBhZGRpbmc7XG4gIGlmIChpID09PSBcImxlZnRcIiAmJiBuICsgbyArIHIgPiB0LndpZHRoIHx8IGkgPT09IFwicmlnaHRcIiAmJiBuIC0gbyAtIHIgPCAwKVxuICAgIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHZjKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyB4OiBuLCB3aWR0aDogbyB9ID0gZSwgeyB3aWR0aDogciwgY2hhcnRBcmVhOiB7IGxlZnQ6IGEsIHJpZ2h0OiBsIH0gfSA9IGk7XG4gIGxldCBjID0gXCJjZW50ZXJcIjtcbiAgcmV0dXJuIHMgPT09IFwiY2VudGVyXCIgPyBjID0gbiA8PSAoYSArIGwpIC8gMiA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogbiA8PSBvIC8gMiA/IGMgPSBcImxlZnRcIiA6IG4gPj0gciAtIG8gLyAyICYmIChjID0gXCJyaWdodFwiKSwgeWMoYywgaSwgdCwgZSkgJiYgKGMgPSBcImNlbnRlclwiKSwgYztcbn1cbmZ1bmN0aW9uIHFzKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGUueUFsaWduIHx8IHQueUFsaWduIHx8IF9jKGksIGUpO1xuICByZXR1cm4ge1xuICAgIHhBbGlnbjogZS54QWxpZ24gfHwgdC54QWxpZ24gfHwgdmMoaSwgdCwgZSwgcyksXG4gICAgeUFsaWduOiBzXG4gIH07XG59XG5mdW5jdGlvbiBNYyhpLCB0KSB7XG4gIGxldCB7IHg6IGUsIHdpZHRoOiBzIH0gPSBpO1xuICByZXR1cm4gdCA9PT0gXCJyaWdodFwiID8gZSAtPSBzIDogdCA9PT0gXCJjZW50ZXJcIiAmJiAoZSAtPSBzIC8gMiksIGU7XG59XG5mdW5jdGlvbiBrYyhpLCB0LCBlKSB7XG4gIGxldCB7IHk6IHMsIGhlaWdodDogbiB9ID0gaTtcbiAgcmV0dXJuIHQgPT09IFwidG9wXCIgPyBzICs9IGUgOiB0ID09PSBcImJvdHRvbVwiID8gcyAtPSBuICsgZSA6IHMgLT0gbiAvIDIsIHM7XG59XG5mdW5jdGlvbiBHcyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgY2FyZXRTaXplOiBuLCBjYXJldFBhZGRpbmc6IG8sIGNvcm5lclJhZGl1czogciB9ID0gaSwgeyB4QWxpZ246IGEsIHlBbGlnbjogbCB9ID0gZSwgYyA9IG4gKyBvLCB7IHRvcExlZnQ6IGgsIHRvcFJpZ2h0OiBkLCBib3R0b21MZWZ0OiB1LCBib3R0b21SaWdodDogZiB9ID0gRHQocik7XG4gIGxldCBnID0gTWModCwgYSk7XG4gIGNvbnN0IHAgPSBrYyh0LCBsLCBjKTtcbiAgcmV0dXJuIGwgPT09IFwiY2VudGVyXCIgPyBhID09PSBcImxlZnRcIiA/IGcgKz0gYyA6IGEgPT09IFwicmlnaHRcIiAmJiAoZyAtPSBjKSA6IGEgPT09IFwibGVmdFwiID8gZyAtPSBNYXRoLm1heChoLCB1KSArIG4gOiBhID09PSBcInJpZ2h0XCIgJiYgKGcgKz0gTWF0aC5tYXgoZCwgZikgKyBuKSwge1xuICAgIHg6IFkoZywgMCwgcy53aWR0aCAtIHQud2lkdGgpLFxuICAgIHk6IFkocCwgMCwgcy5oZWlnaHQgLSB0LmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIEVlKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IEsoZS5wYWRkaW5nKTtcbiAgcmV0dXJuIHQgPT09IFwiY2VudGVyXCIgPyBpLnggKyBpLndpZHRoIC8gMiA6IHQgPT09IFwicmlnaHRcIiA/IGkueCArIGkud2lkdGggLSBzLnJpZ2h0IDogaS54ICsgcy5sZWZ0O1xufVxuZnVuY3Rpb24gWnMoaSkge1xuICByZXR1cm4gcnQoW10sIGh0KGkpKTtcbn1cbmZ1bmN0aW9uIHdjKGksIHQsIGUpIHtcbiAgcmV0dXJuIHZ0KGksIHtcbiAgICB0b29sdGlwOiB0LFxuICAgIHRvb2x0aXBJdGVtczogZSxcbiAgICB0eXBlOiBcInRvb2x0aXBcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIEpzKGksIHQpIHtcbiAgY29uc3QgZSA9IHQgJiYgdC5kYXRhc2V0ICYmIHQuZGF0YXNldC50b29sdGlwICYmIHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIGUgPyBpLm92ZXJyaWRlKGUpIDogaTtcbn1cbmNsYXNzIENpIGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcGFjaXR5ID0gMCwgdGhpcy5fYWN0aXZlID0gW10sIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB2b2lkIDAsIHRoaXMuX3NpemUgPSB2b2lkIDAsIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB2b2lkIDAsIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdLCB0aGlzLiRhbmltYXRpb25zID0gdm9pZCAwLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCB0aGlzLmNoYXJ0ID0gdC5jaGFydCB8fCB0Ll9jaGFydCwgdGhpcy5fY2hhcnQgPSB0aGlzLmNoYXJ0LCB0aGlzLm9wdGlvbnMgPSB0Lm9wdGlvbnMsIHRoaXMuZGF0YVBvaW50cyA9IHZvaWQgMCwgdGhpcy50aXRsZSA9IHZvaWQgMCwgdGhpcy5iZWZvcmVCb2R5ID0gdm9pZCAwLCB0aGlzLmJvZHkgPSB2b2lkIDAsIHRoaXMuYWZ0ZXJCb2R5ID0gdm9pZCAwLCB0aGlzLmZvb3RlciA9IHZvaWQgMCwgdGhpcy54QWxpZ24gPSB2b2lkIDAsIHRoaXMueUFsaWduID0gdm9pZCAwLCB0aGlzLnggPSB2b2lkIDAsIHRoaXMueSA9IHZvaWQgMCwgdGhpcy5oZWlnaHQgPSB2b2lkIDAsIHRoaXMud2lkdGggPSB2b2lkIDAsIHRoaXMuY2FyZXRYID0gdm9pZCAwLCB0aGlzLmNhcmV0WSA9IHZvaWQgMCwgdGhpcy5sYWJlbENvbG9ycyA9IHZvaWQgMCwgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdm9pZCAwLCB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHZvaWQgMDtcbiAgfVxuICBpbml0aWFsaXplKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdm9pZCAwLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAodClcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGUgPSB0aGlzLmNoYXJ0LCBzID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpLCBuID0gcy5lbmFibGVkICYmIGUub3B0aW9ucy5hbmltYXRpb24gJiYgcy5hbmltYXRpb25zLCBvID0gbmV3IE5pKHRoaXMuY2hhcnQsIG4pO1xuICAgIHJldHVybiBuLl9jYWNoZWFibGUgJiYgKHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKG8pKSwgbztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gd2ModGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKHQsIGUpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrczogcyB9ID0gZSwgbiA9IHMuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW3RdKSwgbyA9IHMudGl0bGUuYXBwbHkodGhpcywgW3RdKSwgciA9IHMuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbdF0pO1xuICAgIGxldCBhID0gW107XG4gICAgcmV0dXJuIGEgPSBydChhLCBodChuKSksIGEgPSBydChhLCBodChvKSksIGEgPSBydChhLCBodChyKSksIGE7XG4gIH1cbiAgZ2V0QmVmb3JlQm9keSh0LCBlKSB7XG4gICAgcmV0dXJuIFpzKGUuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3RdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0LCBlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja3M6IHMgfSA9IGUsIG4gPSBbXTtcbiAgICByZXR1cm4gRSh0LCAobykgPT4ge1xuICAgICAgY29uc3QgciA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH0sIGEgPSBKcyhzLCBvKTtcbiAgICAgIHJ0KHIuYmVmb3JlLCBodChhLmJlZm9yZUxhYmVsLmNhbGwodGhpcywgbykpKSwgcnQoci5saW5lcywgYS5sYWJlbC5jYWxsKHRoaXMsIG8pKSwgcnQoci5hZnRlciwgaHQoYS5hZnRlckxhYmVsLmNhbGwodGhpcywgbykpKSwgbi5wdXNoKHIpO1xuICAgIH0pLCBuO1xuICB9XG4gIGdldEFmdGVyQm9keSh0LCBlKSB7XG4gICAgcmV0dXJuIFpzKGUuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdF0pKTtcbiAgfVxuICBnZXRGb290ZXIodCwgZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tzOiBzIH0gPSBlLCBuID0gcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3RdKSwgbyA9IHMuZm9vdGVyLmFwcGx5KHRoaXMsIFt0XSksIHIgPSBzLmFmdGVyRm9vdGVyLmFwcGx5KHRoaXMsIFt0XSk7XG4gICAgbGV0IGEgPSBbXTtcbiAgICByZXR1cm4gYSA9IHJ0KGEsIGh0KG4pKSwgYSA9IHJ0KGEsIGh0KG8pKSwgYSA9IHJ0KGEsIGh0KHIpKSwgYTtcbiAgfVxuICBfY3JlYXRlSXRlbXModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmUsIHMgPSB0aGlzLmNoYXJ0LmRhdGEsIG4gPSBbXSwgbyA9IFtdLCByID0gW107XG4gICAgbGV0IGEgPSBbXSwgbCwgYztcbiAgICBmb3IgKGwgPSAwLCBjID0gZS5sZW5ndGg7IGwgPCBjOyArK2wpXG4gICAgICBhLnB1c2goeGModGhpcy5jaGFydCwgZVtsXSkpO1xuICAgIHJldHVybiB0LmZpbHRlciAmJiAoYSA9IGEuZmlsdGVyKChoLCBkLCB1KSA9PiB0LmZpbHRlcihoLCBkLCB1LCBzKSkpLCB0Lml0ZW1Tb3J0ICYmIChhID0gYS5zb3J0KChoLCBkKSA9PiB0Lml0ZW1Tb3J0KGgsIGQsIHMpKSksIEUoYSwgKGgpID0+IHtcbiAgICAgIGNvbnN0IGQgPSBKcyh0LmNhbGxiYWNrcywgaCk7XG4gICAgICBuLnB1c2goZC5sYWJlbENvbG9yLmNhbGwodGhpcywgaCkpLCBvLnB1c2goZC5sYWJlbFBvaW50U3R5bGUuY2FsbCh0aGlzLCBoKSksIHIucHVzaChkLmxhYmVsVGV4dENvbG9yLmNhbGwodGhpcywgaCkpO1xuICAgIH0pLCB0aGlzLmxhYmVsQ29sb3JzID0gbiwgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbywgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSByLCB0aGlzLmRhdGFQb2ludHMgPSBhLCBhO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgbiA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgbywgciA9IFtdO1xuICAgIGlmICghbi5sZW5ndGgpXG4gICAgICB0aGlzLm9wYWNpdHkgIT09IDAgJiYgKG8gPSB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYSA9IHNlW3MucG9zaXRpb25dLmNhbGwodGhpcywgbiwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICByID0gdGhpcy5fY3JlYXRlSXRlbXMocyksIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHIsIHMpLCB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkociwgcyksIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keShyLCBzKSwgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keShyLCBzKSwgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3RlcihyLCBzKTtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLl9zaXplID0gS3ModGhpcywgcyksIGMgPSBPYmplY3QuYXNzaWduKHt9LCBhLCBsKSwgaCA9IHFzKHRoaXMuY2hhcnQsIHMsIGMpLCBkID0gR3MocywgYywgaCwgdGhpcy5jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGgueEFsaWduLCB0aGlzLnlBbGlnbiA9IGgueUFsaWduLCBvID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBkLngsXG4gICAgICAgIHk6IGQueSxcbiAgICAgICAgd2lkdGg6IGwud2lkdGgsXG4gICAgICAgIGhlaWdodDogbC5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogYS54LFxuICAgICAgICBjYXJldFk6IGEueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gciwgdGhpcy4kY29udGV4dCA9IHZvaWQgMCwgbyAmJiB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBvKSwgdCAmJiBzLmV4dGVybmFsICYmIHMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7IGNoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXk6IGUgfSk7XG4gIH1cbiAgZHJhd0NhcmV0KHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHQsIHMsIG4pO1xuICAgIGUubGluZVRvKG8ueDEsIG8ueTEpLCBlLmxpbmVUbyhvLngyLCBvLnkyKSwgZS5saW5lVG8oby54Mywgby55Myk7XG4gIH1cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0LCBlLCBzKSB7XG4gICAgY29uc3QgeyB4QWxpZ246IG4sIHlBbGlnbjogbyB9ID0gdGhpcywgeyBjYXJldFNpemU6IHIsIGNvcm5lclJhZGl1czogYSB9ID0gcywgeyB0b3BMZWZ0OiBsLCB0b3BSaWdodDogYywgYm90dG9tTGVmdDogaCwgYm90dG9tUmlnaHQ6IGQgfSA9IER0KGEpLCB7IHg6IHUsIHk6IGYgfSA9IHQsIHsgd2lkdGg6IGcsIGhlaWdodDogcCB9ID0gZTtcbiAgICBsZXQgbSwgYiwgeCwgdiwgeSwgXztcbiAgICByZXR1cm4gbyA9PT0gXCJjZW50ZXJcIiA/ICh5ID0gZiArIHAgLyAyLCBuID09PSBcImxlZnRcIiA/IChtID0gdSwgYiA9IG0gLSByLCB2ID0geSArIHIsIF8gPSB5IC0gcikgOiAobSA9IHUgKyBnLCBiID0gbSArIHIsIHYgPSB5IC0gciwgXyA9IHkgKyByKSwgeCA9IG0pIDogKG4gPT09IFwibGVmdFwiID8gYiA9IHUgKyBNYXRoLm1heChsLCBoKSArIHIgOiBuID09PSBcInJpZ2h0XCIgPyBiID0gdSArIGcgLSBNYXRoLm1heChjLCBkKSAtIHIgOiBiID0gdGhpcy5jYXJldFgsIG8gPT09IFwidG9wXCIgPyAodiA9IGYsIHkgPSB2IC0gciwgbSA9IGIgLSByLCB4ID0gYiArIHIpIDogKHYgPSBmICsgcCwgeSA9IHYgKyByLCBtID0gYiArIHIsIHggPSBiIC0gciksIF8gPSB2KSwgeyB4MTogbSwgeDI6IGIsIHgzOiB4LCB5MTogdiwgeTI6IHksIHkzOiBfIH07XG4gIH1cbiAgZHJhd1RpdGxlKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy50aXRsZSwgbyA9IG4ubGVuZ3RoO1xuICAgIGxldCByLCBhLCBsO1xuICAgIGlmIChvKSB7XG4gICAgICBjb25zdCBjID0genQocy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBmb3IgKHQueCA9IEVlKHRoaXMsIHMudGl0bGVBbGlnbiwgcyksIGUudGV4dEFsaWduID0gYy50ZXh0QWxpZ24ocy50aXRsZUFsaWduKSwgZS50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCByID0gJChzLnRpdGxlRm9udCksIGEgPSBzLnRpdGxlU3BhY2luZywgZS5maWxsU3R5bGUgPSBzLnRpdGxlQ29sb3IsIGUuZm9udCA9IHIuc3RyaW5nLCBsID0gMDsgbCA8IG87ICsrbClcbiAgICAgICAgZS5maWxsVGV4dChuW2xdLCBjLngodC54KSwgdC55ICsgci5saW5lSGVpZ2h0IC8gMiksIHQueSArPSByLmxpbmVIZWlnaHQgKyBhLCBsICsgMSA9PT0gbyAmJiAodC55ICs9IHMudGl0bGVNYXJnaW5Cb3R0b20gLSBhKTtcbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveCh0LCBlLCBzLCBuLCBvKSB7XG4gICAgY29uc3QgciA9IHRoaXMubGFiZWxDb2xvcnNbc10sIGEgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbc10sIHsgYm94SGVpZ2h0OiBsLCBib3hXaWR0aDogYywgYm94UGFkZGluZzogaCB9ID0gbywgZCA9ICQoby5ib2R5Rm9udCksIHUgPSBFZSh0aGlzLCBcImxlZnRcIiwgbyksIGYgPSBuLngodSksIGcgPSBsIDwgZC5saW5lSGVpZ2h0ID8gKGQubGluZUhlaWdodCAtIGwpIC8gMiA6IDAsIHAgPSBlLnkgKyBnO1xuICAgIGlmIChvLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYywgbCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBhLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBhLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSwgYiA9IG4ubGVmdEZvckx0cihmLCBjKSArIGMgLyAyLCB4ID0gcCArIGwgLyAyO1xuICAgICAgdC5zdHJva2VTdHlsZSA9IG8ubXVsdGlLZXlCYWNrZ3JvdW5kLCB0LmZpbGxTdHlsZSA9IG8ubXVsdGlLZXlCYWNrZ3JvdW5kLCB5aSh0LCBtLCBiLCB4KSwgdC5zdHJva2VTdHlsZSA9IHIuYm9yZGVyQ29sb3IsIHQuZmlsbFN0eWxlID0gci5iYWNrZ3JvdW5kQ29sb3IsIHlpKHQsIG0sIGIsIHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0LmxpbmVXaWR0aCA9IEQoci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHIuYm9yZGVyV2lkdGgpKSA6IHIuYm9yZGVyV2lkdGggfHwgMSwgdC5zdHJva2VTdHlsZSA9IHIuYm9yZGVyQ29sb3IsIHQuc2V0TGluZURhc2goci5ib3JkZXJEYXNoIHx8IFtdKSwgdC5saW5lRGFzaE9mZnNldCA9IHIuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgbSA9IG4ubGVmdEZvckx0cihmLCBjIC0gaCksIGIgPSBuLmxlZnRGb3JMdHIobi54UGx1cyhmLCAxKSwgYyAtIGggLSAyKSwgeCA9IER0KHIuYm9yZGVyUmFkaXVzKTtcbiAgICAgIE9iamVjdC52YWx1ZXMoeCkuc29tZSgodikgPT4gdiAhPT0gMCkgPyAodC5iZWdpblBhdGgoKSwgdC5maWxsU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgYWUodCwge1xuICAgICAgICB4OiBtLFxuICAgICAgICB5OiBwLFxuICAgICAgICB3OiBjLFxuICAgICAgICBoOiBsLFxuICAgICAgICByYWRpdXM6IHhcbiAgICAgIH0pLCB0LmZpbGwoKSwgdC5zdHJva2UoKSwgdC5maWxsU3R5bGUgPSByLmJhY2tncm91bmRDb2xvciwgdC5iZWdpblBhdGgoKSwgYWUodCwge1xuICAgICAgICB4OiBiLFxuICAgICAgICB5OiBwICsgMSxcbiAgICAgICAgdzogYyAtIDIsXG4gICAgICAgIGg6IGwgLSAyLFxuICAgICAgICByYWRpdXM6IHhcbiAgICAgIH0pLCB0LmZpbGwoKSkgOiAodC5maWxsU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgdC5maWxsUmVjdChtLCBwLCBjLCBsKSwgdC5zdHJva2VSZWN0KG0sIHAsIGMsIGwpLCB0LmZpbGxTdHlsZSA9IHIuYmFja2dyb3VuZENvbG9yLCB0LmZpbGxSZWN0KGIsIHAgKyAxLCBjIC0gMiwgbCAtIDIpKTtcbiAgICB9XG4gICAgdC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tzXTtcbiAgfVxuICBkcmF3Qm9keSh0LCBlLCBzKSB7XG4gICAgY29uc3QgeyBib2R5OiBuIH0gPSB0aGlzLCB7IGJvZHlTcGFjaW5nOiBvLCBib2R5QWxpZ246IHIsIGRpc3BsYXlDb2xvcnM6IGEsIGJveEhlaWdodDogbCwgYm94V2lkdGg6IGMsIGJveFBhZGRpbmc6IGggfSA9IHMsIGQgPSAkKHMuYm9keUZvbnQpO1xuICAgIGxldCB1ID0gZC5saW5lSGVpZ2h0LCBmID0gMDtcbiAgICBjb25zdCBnID0genQocy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCksIHAgPSBmdW5jdGlvbihTKSB7XG4gICAgICBlLmZpbGxUZXh0KFMsIGcueCh0LnggKyBmKSwgdC55ICsgdSAvIDIpLCB0LnkgKz0gdSArIG87XG4gICAgfSwgbSA9IGcudGV4dEFsaWduKHIpO1xuICAgIGxldCBiLCB4LCB2LCB5LCBfLCBNLCBrO1xuICAgIGZvciAoZS50ZXh0QWxpZ24gPSByLCBlLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIGUuZm9udCA9IGQuc3RyaW5nLCB0LnggPSBFZSh0aGlzLCBtLCBzKSwgZS5maWxsU3R5bGUgPSBzLmJvZHlDb2xvciwgRSh0aGlzLmJlZm9yZUJvZHksIHApLCBmID0gYSAmJiBtICE9PSBcInJpZ2h0XCIgPyByID09PSBcImNlbnRlclwiID8gYyAvIDIgKyBoIDogYyArIDIgKyBoIDogMCwgeSA9IDAsIE0gPSBuLmxlbmd0aDsgeSA8IE07ICsreSkge1xuICAgICAgZm9yIChiID0gblt5XSwgeCA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW3ldLCBlLmZpbGxTdHlsZSA9IHgsIEUoYi5iZWZvcmUsIHApLCB2ID0gYi5saW5lcywgYSAmJiB2Lmxlbmd0aCAmJiAodGhpcy5fZHJhd0NvbG9yQm94KGUsIHQsIHksIGcsIHMpLCB1ID0gTWF0aC5tYXgoZC5saW5lSGVpZ2h0LCBsKSksIF8gPSAwLCBrID0gdi5sZW5ndGg7IF8gPCBrOyArK18pXG4gICAgICAgIHAodltfXSksIHUgPSBkLmxpbmVIZWlnaHQ7XG4gICAgICBFKGIuYWZ0ZXIsIHApO1xuICAgIH1cbiAgICBmID0gMCwgdSA9IGQubGluZUhlaWdodCwgRSh0aGlzLmFmdGVyQm9keSwgcCksIHQueSAtPSBvO1xuICB9XG4gIGRyYXdGb290ZXIodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLmZvb3RlciwgbyA9IG4ubGVuZ3RoO1xuICAgIGxldCByLCBhO1xuICAgIGlmIChvKSB7XG4gICAgICBjb25zdCBsID0genQocy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBmb3IgKHQueCA9IEVlKHRoaXMsIHMuZm9vdGVyQWxpZ24sIHMpLCB0LnkgKz0gcy5mb290ZXJNYXJnaW5Ub3AsIGUudGV4dEFsaWduID0gbC50ZXh0QWxpZ24ocy5mb290ZXJBbGlnbiksIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgciA9ICQocy5mb290ZXJGb250KSwgZS5maWxsU3R5bGUgPSBzLmZvb3RlckNvbG9yLCBlLmZvbnQgPSByLnN0cmluZywgYSA9IDA7IGEgPCBvOyArK2EpXG4gICAgICAgIGUuZmlsbFRleHQoblthXSwgbC54KHQueCksIHQueSArIHIubGluZUhlaWdodCAvIDIpLCB0LnkgKz0gci5saW5lSGVpZ2h0ICsgcy5mb290ZXJTcGFjaW5nO1xuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZCh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyB4QWxpZ246IG8sIHlBbGlnbjogciB9ID0gdGhpcywgeyB4OiBhLCB5OiBsIH0gPSB0LCB7IHdpZHRoOiBjLCBoZWlnaHQ6IGggfSA9IHMsIHsgdG9wTGVmdDogZCwgdG9wUmlnaHQ6IHUsIGJvdHRvbUxlZnQ6IGYsIGJvdHRvbVJpZ2h0OiBnIH0gPSBEdChuLmNvcm5lclJhZGl1cyk7XG4gICAgZS5maWxsU3R5bGUgPSBuLmJhY2tncm91bmRDb2xvciwgZS5zdHJva2VTdHlsZSA9IG4uYm9yZGVyQ29sb3IsIGUubGluZVdpZHRoID0gbi5ib3JkZXJXaWR0aCwgZS5iZWdpblBhdGgoKSwgZS5tb3ZlVG8oYSArIGQsIGwpLCByID09PSBcInRvcFwiICYmIHRoaXMuZHJhd0NhcmV0KHQsIGUsIHMsIG4pLCBlLmxpbmVUbyhhICsgYyAtIHUsIGwpLCBlLnF1YWRyYXRpY0N1cnZlVG8oYSArIGMsIGwsIGEgKyBjLCBsICsgdSksIHIgPT09IFwiY2VudGVyXCIgJiYgbyA9PT0gXCJyaWdodFwiICYmIHRoaXMuZHJhd0NhcmV0KHQsIGUsIHMsIG4pLCBlLmxpbmVUbyhhICsgYywgbCArIGggLSBnKSwgZS5xdWFkcmF0aWNDdXJ2ZVRvKGEgKyBjLCBsICsgaCwgYSArIGMgLSBnLCBsICsgaCksIHIgPT09IFwiYm90dG9tXCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEgKyBmLCBsICsgaCksIGUucXVhZHJhdGljQ3VydmVUbyhhLCBsICsgaCwgYSwgbCArIGggLSBmKSwgciA9PT0gXCJjZW50ZXJcIiAmJiBvID09PSBcImxlZnRcIiAmJiB0aGlzLmRyYXdDYXJldCh0LCBlLCBzLCBuKSwgZS5saW5lVG8oYSwgbCArIGQpLCBlLnF1YWRyYXRpY0N1cnZlVG8oYSwgbCwgYSArIGQsIGwpLCBlLmNsb3NlUGF0aCgpLCBlLmZpbGwoKSwgbi5ib3JkZXJXaWR0aCA+IDAgJiYgZS5zdHJva2UoKTtcbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jaGFydCwgcyA9IHRoaXMuJGFuaW1hdGlvbnMsIG4gPSBzICYmIHMueCwgbyA9IHMgJiYgcy55O1xuICAgIGlmIChuIHx8IG8pIHtcbiAgICAgIGNvbnN0IHIgPSBzZVt0LnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl9zaXplID0gS3ModGhpcywgdCksIGwgPSBPYmplY3QuYXNzaWduKHt9LCByLCB0aGlzLl9zaXplKSwgYyA9IHFzKGUsIHQsIGwpLCBoID0gR3ModCwgbCwgYywgZSk7XG4gICAgICAobi5fdG8gIT09IGgueCB8fCBvLl90byAhPT0gaC55KSAmJiAodGhpcy54QWxpZ24gPSBjLnhBbGlnbiwgdGhpcy55QWxpZ24gPSBjLnlBbGlnbiwgdGhpcy53aWR0aCA9IGEud2lkdGgsIHRoaXMuaGVpZ2h0ID0gYS5oZWlnaHQsIHRoaXMuY2FyZXRYID0gci54LCB0aGlzLmNhcmV0WSA9IHIueSwgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgaCkpO1xuICAgIH1cbiAgfVxuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cbiAgZHJhdyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgcyA9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KGUpO1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9LCBvID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcbiAgICBzID0gTWF0aC5hYnMocykgPCAxZS0zID8gMCA6IHM7XG4gICAgY29uc3QgciA9IEsoZS5wYWRkaW5nKSwgYSA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuICAgIGUuZW5hYmxlZCAmJiBhICYmICh0LnNhdmUoKSwgdC5nbG9iYWxBbHBoYSA9IHMsIHRoaXMuZHJhd0JhY2tncm91bmQobywgdCwgbiwgZSksIFRuKHQsIGUudGV4dERpcmVjdGlvbiksIG8ueSArPSByLnRvcCwgdGhpcy5kcmF3VGl0bGUobywgdCwgZSksIHRoaXMuZHJhd0JvZHkobywgdCwgZSksIHRoaXMuZHJhd0Zvb3RlcihvLCB0LCBlKSwgTG4odCwgZS50ZXh0RGlyZWN0aW9uKSwgdC5yZXN0b3JlKCkpO1xuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9hY3RpdmUsIG4gPSB0Lm1hcCgoeyBkYXRhc2V0SW5kZXg6IGEsIGluZGV4OiBsIH0pID0+IHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGEpO1xuICAgICAgaWYgKCFjKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggXCIgKyBhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleDogYSxcbiAgICAgICAgZWxlbWVudDogYy5kYXRhW2xdLFxuICAgICAgICBpbmRleDogbFxuICAgICAgfTtcbiAgICB9KSwgbyA9ICF6ZShzLCBuKSwgciA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChuLCBlKTtcbiAgICAobyB8fCByKSAmJiAodGhpcy5fYWN0aXZlID0gbiwgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGUsIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9ICEwLCB0aGlzLnVwZGF0ZSghMCkpO1xuICB9XG4gIGhhbmRsZUV2ZW50KHQsIGUsIHMgPSAhMCkge1xuICAgIGlmIChlICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cylcbiAgICAgIHJldHVybiAhMTtcbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSAhMTtcbiAgICBjb25zdCBuID0gdGhpcy5vcHRpb25zLCBvID0gdGhpcy5fYWN0aXZlIHx8IFtdLCByID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHModCwgbywgZSwgcyksIGEgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQociwgdCksIGwgPSBlIHx8ICF6ZShyLCBvKSB8fCBhO1xuICAgIHJldHVybiBsICYmICh0aGlzLl9hY3RpdmUgPSByLCAobi5lbmFibGVkIHx8IG4uZXh0ZXJuYWwpICYmICh0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgeDogdC54LFxuICAgICAgeTogdC55XG4gICAgfSwgdGhpcy51cGRhdGUoITAsIGUpKSksIGw7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0LnR5cGUgPT09IFwibW91c2VvdXRcIilcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCByID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKHQsIG8ubW9kZSwgbywgcyk7XG4gICAgcmV0dXJuIG8ucmV2ZXJzZSAmJiByLnJldmVyc2UoKSwgcjtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKHQsIGUpIHtcbiAgICBjb25zdCB7IGNhcmV0WDogcywgY2FyZXRZOiBuLCBvcHRpb25zOiBvIH0gPSB0aGlzLCByID0gc2Vbby5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0LCBlKTtcbiAgICByZXR1cm4gciAhPT0gITEgJiYgKHMgIT09IHIueCB8fCBuICE9PSByLnkpO1xuICB9XG59XG5DaS5wb3NpdGlvbmVycyA9IHNlO1xudmFyIHBvID0ge1xuICBpZDogXCJ0b29sdGlwXCIsXG4gIF9lbGVtZW50OiBDaSxcbiAgcG9zaXRpb25lcnM6IHNlLFxuICBhZnRlckluaXQoaSwgdCwgZSkge1xuICAgIGUgJiYgKGkudG9vbHRpcCA9IG5ldyBDaSh7IGNoYXJ0OiBpLCBvcHRpb25zOiBlIH0pKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGksIHQsIGUpIHtcbiAgICBpLnRvb2x0aXAgJiYgaS50b29sdGlwLmluaXRpYWxpemUoZSk7XG4gIH0sXG4gIHJlc2V0KGksIHQsIGUpIHtcbiAgICBpLnRvb2x0aXAgJiYgaS50b29sdGlwLmluaXRpYWxpemUoZSk7XG4gIH0sXG4gIGFmdGVyRHJhdyhpKSB7XG4gICAgY29uc3QgdCA9IGkudG9vbHRpcDtcbiAgICBpZiAodCAmJiB0Ll93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIHRvb2x0aXA6IHRcbiAgICAgIH07XG4gICAgICBpZiAoaS5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlVG9vbHRpcERyYXdcIiwgZSkgPT09ICExKVxuICAgICAgICByZXR1cm47XG4gICAgICB0LmRyYXcoaS5jdHgpLCBpLm5vdGlmeVBsdWdpbnMoXCJhZnRlclRvb2x0aXBEcmF3XCIsIGUpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudChpLCB0KSB7XG4gICAgaWYgKGkudG9vbHRpcCkge1xuICAgICAgY29uc3QgZSA9IHQucmVwbGF5O1xuICAgICAgaS50b29sdGlwLmhhbmRsZUV2ZW50KHQuZXZlbnQsIGUsIHQuaW5DaGFydEFyZWEpICYmICh0LmNoYW5nZWQgPSAhMCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6ICEwLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiBcImF2ZXJhZ2VcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLDAsMCwwLjgpXCIsXG4gICAgdGl0bGVDb2xvcjogXCIjZmZmXCIsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogXCJsZWZ0XCIsXG4gICAgYm9keUNvbG9yOiBcIiNmZmZcIixcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge30sXG4gICAgYm9keUFsaWduOiBcImxlZnRcIixcbiAgICBmb290ZXJDb2xvcjogXCIjZmZmXCIsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246IFwibGVmdFwiLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoaSwgdCkgPT4gdC5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoaSwgdCkgPT4gdC5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogXCIjZmZmXCIsXG4gICAgZGlzcGxheUNvbG9yczogITAsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IFtcInhcIiwgXCJ5XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJjYXJldFhcIiwgXCJjYXJldFlcIl1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogY3QsXG4gICAgICB0aXRsZShpKSB7XG4gICAgICAgIGlmIChpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0ID0gaVswXSwgZSA9IHQuY2hhcnQuZGF0YS5sYWJlbHMsIHMgPSBlID8gZS5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkYXRhc2V0XCIpXG4gICAgICAgICAgICByZXR1cm4gdC5kYXRhc2V0LmxhYmVsIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKHQubGFiZWwpXG4gICAgICAgICAgICByZXR1cm4gdC5sYWJlbDtcbiAgICAgICAgICBpZiAocyA+IDAgJiYgdC5kYXRhSW5kZXggPCBzKVxuICAgICAgICAgICAgcmV0dXJuIGVbdC5kYXRhSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IGN0LFxuICAgICAgYmVmb3JlQm9keTogY3QsXG4gICAgICBiZWZvcmVMYWJlbDogY3QsXG4gICAgICBsYWJlbChpKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkYXRhc2V0XCIpXG4gICAgICAgICAgcmV0dXJuIGkubGFiZWwgKyBcIjogXCIgKyBpLmZvcm1hdHRlZFZhbHVlIHx8IGkuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGxldCB0ID0gaS5kYXRhc2V0LmxhYmVsIHx8IFwiXCI7XG4gICAgICAgIHQgJiYgKHQgKz0gXCI6IFwiKTtcbiAgICAgICAgY29uc3QgZSA9IGkuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIHJldHVybiBUKGUpIHx8ICh0ICs9IGUpLCB0O1xuICAgICAgfSxcbiAgICAgIGxhYmVsQ29sb3IoaSkge1xuICAgICAgICBjb25zdCBlID0gaS5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRTdHlsZShpLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBlLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICAgIH0sXG4gICAgICBsYWJlbFBvaW50U3R5bGUoaSkge1xuICAgICAgICBjb25zdCBlID0gaS5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRTdHlsZShpLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogZS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBlLnJvdGF0aW9uXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWZ0ZXJMYWJlbDogY3QsXG4gICAgICBhZnRlckJvZHk6IGN0LFxuICAgICAgYmVmb3JlRm9vdGVyOiBjdCxcbiAgICAgIGZvb3RlcjogY3QsXG4gICAgICBhZnRlckZvb3RlcjogY3RcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogXCJmb250XCIsXG4gICAgZm9vdGVyRm9udDogXCJmb250XCIsXG4gICAgdGl0bGVGb250OiBcImZvbnRcIlxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAoaSkgPT4gaSAhPT0gXCJmaWx0ZXJcIiAmJiBpICE9PSBcIml0ZW1Tb3J0XCIgJiYgaSAhPT0gXCJleHRlcm5hbFwiLFxuICAgIF9pbmRleGFibGU6ICExLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6ICExLFxuICAgICAgX2luZGV4YWJsZTogITFcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiAhMVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiBcImFuaW1hdGlvblwiXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbXCJpbnRlcmFjdGlvblwiXVxufSwgbW8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRGVjaW1hdGlvbjogYW8sXG4gIEZpbGxlcjogaG8sXG4gIExlZ2VuZDogdW8sXG4gIFN1YlRpdGxlOiBnbyxcbiAgVGl0bGU6IGZvLFxuICBUb29sdGlwOiBwb1xufSk7XG5jb25zdCBTYyA9IChpLCB0LCBlLCBzKSA9PiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IChlID0gaS5wdXNoKHQpIC0gMSwgcy51bnNoaWZ0KHsgaW5kZXg6IGUsIGxhYmVsOiB0IH0pKSA6IGlzTmFOKHQpICYmIChlID0gbnVsbCksIGUpO1xuZnVuY3Rpb24gUGMoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gaS5pbmRleE9mKHQpO1xuICBpZiAobiA9PT0gLTEpXG4gICAgcmV0dXJuIFNjKGksIHQsIGUsIHMpO1xuICBjb25zdCBvID0gaS5sYXN0SW5kZXhPZih0KTtcbiAgcmV0dXJuIG4gIT09IG8gPyBlIDogbjtcbn1cbmNvbnN0IENjID0gKGksIHQpID0+IGkgPT09IG51bGwgPyBudWxsIDogWShNYXRoLnJvdW5kKGkpLCAwLCB0KTtcbmNsYXNzIGNlIGV4dGVuZHMgTXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuX3N0YXJ0VmFsdWUgPSB2b2lkIDAsIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwLCB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG4gIGluaXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7IGluZGV4OiBuLCBsYWJlbDogbyB9IG9mIGUpXG4gICAgICAgIHNbbl0gPT09IG8gJiYgcy5zcGxpY2UobiwgMSk7XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHQpO1xuICB9XG4gIHBhcnNlKHQsIGUpIHtcbiAgICBpZiAoVCh0KSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIHJldHVybiBlID0gaXNGaW5pdGUoZSkgJiYgc1tlXSA9PT0gdCA/IGUgOiBQYyhzLCB0LCBDKGUsIHQpLCB0aGlzLl9hZGRlZExhYmVscyksIENjKGUsIHMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7IG1pbkRlZmluZWQ6IHQsIG1heERlZmluZWQ6IGUgfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7IG1pbjogcywgbWF4OiBuIH0gPSB0aGlzLmdldE1pbk1heCghMCk7XG4gICAgdGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmICh0IHx8IChzID0gMCksIGUgfHwgKG4gPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDEpKSwgdGhpcy5taW4gPSBzLCB0aGlzLm1heCA9IG47XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5taW4sIGUgPSB0aGlzLm1heCwgcyA9IHRoaXMub3B0aW9ucy5vZmZzZXQsIG4gPSBbXTtcbiAgICBsZXQgbyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgbyA9IHQgPT09IDAgJiYgZSA9PT0gby5sZW5ndGggLSAxID8gbyA6IG8uc2xpY2UodCwgZSArIDEpLCB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgoby5sZW5ndGggLSAocyA/IDAgOiAxKSwgMSksIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChzID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgciA9IHQ7IHIgPD0gZTsgcisrKVxuICAgICAgbi5wdXNoKHsgdmFsdWU6IHIgfSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgcmV0dXJuIHQgPj0gMCAmJiB0IDwgZS5sZW5ndGggPyBlW3RdIDogdDtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCksIHRoaXMuaXNIb3Jpem9udGFsKCkgfHwgKHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscyk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgJiYgKHQgPSB0aGlzLnBhcnNlKHQpKSwgdCA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh0IC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRpY2tzO1xuICAgIHJldHVybiB0IDwgMCB8fCB0ID4gZS5sZW5ndGggLSAxID8gbnVsbCA6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZShlW3RdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5jZS5pZCA9IFwiY2F0ZWdvcnlcIjtcbmNlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBjZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxuICB9XG59O1xuZnVuY3Rpb24gRGMoaSwgdCkge1xuICBjb25zdCBlID0gW10sIHsgYm91bmRzOiBuLCBzdGVwOiBvLCBtaW46IHIsIG1heDogYSwgcHJlY2lzaW9uOiBsLCBjb3VudDogYywgbWF4VGlja3M6IGgsIG1heERpZ2l0czogZCwgaW5jbHVkZUJvdW5kczogdSB9ID0gaSwgZiA9IG8gfHwgMSwgZyA9IGggLSAxLCB7IG1pbjogcCwgbWF4OiBtIH0gPSB0LCBiID0gIVQociksIHggPSAhVChhKSwgdiA9ICFUKGMpLCB5ID0gKG0gLSBwKSAvIChkICsgMSk7XG4gIGxldCBfID0gcWkoKG0gLSBwKSAvIGcgLyBmKSAqIGYsIE0sIGssIFMsIHc7XG4gIGlmIChfIDwgMWUtMTQgJiYgIWIgJiYgIXgpXG4gICAgcmV0dXJuIFt7IHZhbHVlOiBwIH0sIHsgdmFsdWU6IG0gfV07XG4gIHcgPSBNYXRoLmNlaWwobSAvIF8pIC0gTWF0aC5mbG9vcihwIC8gXyksIHcgPiBnICYmIChfID0gcWkodyAqIF8gLyBnIC8gZikgKiBmKSwgVChsKSB8fCAoTSA9IE1hdGgucG93KDEwLCBsKSwgXyA9IE1hdGguY2VpbChfICogTSkgLyBNKSwgbiA9PT0gXCJ0aWNrc1wiID8gKGsgPSBNYXRoLmZsb29yKHAgLyBfKSAqIF8sIFMgPSBNYXRoLmNlaWwobSAvIF8pICogXykgOiAoayA9IHAsIFMgPSBtKSwgYiAmJiB4ICYmIG8gJiYgT28oKGEgLSByKSAvIG8sIF8gLyAxZTMpID8gKHcgPSBNYXRoLnJvdW5kKE1hdGgubWluKChhIC0gcikgLyBfLCBoKSksIF8gPSAoYSAtIHIpIC8gdywgayA9IHIsIFMgPSBhKSA6IHYgPyAoayA9IGIgPyByIDogaywgUyA9IHggPyBhIDogUywgdyA9IGMgLSAxLCBfID0gKFMgLSBrKSAvIHcpIDogKHcgPSAoUyAtIGspIC8gXywgdGUodywgTWF0aC5yb3VuZCh3KSwgXyAvIDFlMykgPyB3ID0gTWF0aC5yb3VuZCh3KSA6IHcgPSBNYXRoLmNlaWwodykpO1xuICBjb25zdCBMID0gTWF0aC5tYXgoXG4gICAgR2koXyksXG4gICAgR2koaylcbiAgKTtcbiAgTSA9IE1hdGgucG93KDEwLCBUKGwpID8gTCA6IGwpLCBrID0gTWF0aC5yb3VuZChrICogTSkgLyBNLCBTID0gTWF0aC5yb3VuZChTICogTSkgLyBNO1xuICBsZXQgUiA9IDA7XG4gIGZvciAoYiAmJiAodSAmJiBrICE9PSByID8gKGUucHVzaCh7IHZhbHVlOiByIH0pLCBrIDwgciAmJiBSKyssIHRlKE1hdGgucm91bmQoKGsgKyBSICogXykgKiBNKSAvIE0sIHIsIFFzKHIsIHksIGkpKSAmJiBSKyspIDogayA8IHIgJiYgUisrKTsgUiA8IHc7ICsrUilcbiAgICBlLnB1c2goeyB2YWx1ZTogTWF0aC5yb3VuZCgoayArIFIgKiBfKSAqIE0pIC8gTSB9KTtcbiAgcmV0dXJuIHggJiYgdSAmJiBTICE9PSBhID8gZS5sZW5ndGggJiYgdGUoZVtlLmxlbmd0aCAtIDFdLnZhbHVlLCBhLCBRcyhhLCB5LCBpKSkgPyBlW2UubGVuZ3RoIC0gMV0udmFsdWUgPSBhIDogZS5wdXNoKHsgdmFsdWU6IGEgfSkgOiAoIXggfHwgUyA9PT0gYSkgJiYgZS5wdXNoKHsgdmFsdWU6IFMgfSksIGU7XG59XG5mdW5jdGlvbiBRcyhpLCB0LCB7IGhvcml6b250YWw6IGUsIG1pblJvdGF0aW9uOiBzIH0pIHtcbiAgY29uc3QgbiA9IG50KHMpLCBvID0gKGUgPyBNYXRoLnNpbihuKSA6IE1hdGguY29zKG4pKSB8fCAxZS0zLCByID0gMC43NSAqIHQgKiAoXCJcIiArIGkpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKHQgLyBvLCByKTtcbn1cbmNsYXNzIFllIGV4dGVuZHMgTXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuc3RhcnQgPSB2b2lkIDAsIHRoaXMuZW5kID0gdm9pZCAwLCB0aGlzLl9zdGFydFZhbHVlID0gdm9pZCAwLCB0aGlzLl9lbmRWYWx1ZSA9IHZvaWQgMCwgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIHJldHVybiBUKHQpIHx8ICh0eXBlb2YgdCA9PSBcIm51bWJlclwiIHx8IHQgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrdCkgPyBudWxsIDogK3Q7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7IGJlZ2luQXRaZXJvOiB0IH0gPSB0aGlzLm9wdGlvbnMsIHsgbWluRGVmaW5lZDogZSwgbWF4RGVmaW5lZDogcyB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHsgbWluOiBuLCBtYXg6IG8gfSA9IHRoaXM7XG4gICAgY29uc3QgciA9IChsKSA9PiBuID0gZSA/IG4gOiBsLCBhID0gKGwpID0+IG8gPSBzID8gbyA6IGw7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGwgPSBsdChuKSwgYyA9IGx0KG8pO1xuICAgICAgbCA8IDAgJiYgYyA8IDAgPyBhKDApIDogbCA+IDAgJiYgYyA+IDAgJiYgcigwKTtcbiAgICB9XG4gICAgaWYgKG4gPT09IG8pIHtcbiAgICAgIGxldCBsID0gMTtcbiAgICAgIChvID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpICYmIChsID0gTWF0aC5hYnMobyAqIDAuMDUpKSwgYShvICsgbCksIHQgfHwgcihuIC0gbCk7XG4gICAgfVxuICAgIHRoaXMubWluID0gbiwgdGhpcy5tYXggPSBvO1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7IG1heFRpY2tzTGltaXQ6IGUsIHN0ZXBTaXplOiBzIH0gPSB0LCBuO1xuICAgIHJldHVybiBzID8gKG4gPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzKSArIDEsIG4gPiAxZTMgJiYgKGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c30gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHtufSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKSwgbiA9IDFlMykpIDogKG4gPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKSwgZSA9IGUgfHwgMTEpLCBlICYmIChuID0gTWF0aC5taW4oZSwgbikpLCBuO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0LnRpY2tzO1xuICAgIGxldCBzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBzID0gTWF0aC5tYXgoMiwgcyk7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIG1heFRpY2tzOiBzLFxuICAgICAgYm91bmRzOiB0LmJvdW5kcyxcbiAgICAgIG1pbjogdC5taW4sXG4gICAgICBtYXg6IHQubWF4LFxuICAgICAgcHJlY2lzaW9uOiBlLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IGUuc3RlcFNpemUsXG4gICAgICBjb3VudDogZS5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IGUubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IGUuaW5jbHVkZUJvdW5kcyAhPT0gITFcbiAgICB9LCBvID0gdGhpcy5fcmFuZ2UgfHwgdGhpcywgciA9IERjKG4sIG8pO1xuICAgIHJldHVybiB0LmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmIGNuKHIsIHRoaXMsIFwidmFsdWVcIiksIHQucmV2ZXJzZSA/IChyLnJldmVyc2UoKSwgdGhpcy5zdGFydCA9IHRoaXMubWF4LCB0aGlzLmVuZCA9IHRoaXMubWluKSA6ICh0aGlzLnN0YXJ0ID0gdGhpcy5taW4sIHRoaXMuZW5kID0gdGhpcy5tYXgpLCByO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50aWNrcztcbiAgICBsZXQgZSA9IHRoaXMubWluLCBzID0gdGhpcy5tYXg7XG4gICAgaWYgKHN1cGVyLmNvbmZpZ3VyZSgpLCB0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuID0gKHMgLSBlKSAvIE1hdGgubWF4KHQubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgZSAtPSBuLCBzICs9IG47XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBlLCB0aGlzLl9lbmRWYWx1ZSA9IHMsIHRoaXMuX3ZhbHVlUmFuZ2UgPSBzIC0gZTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gZGUodCwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cbmNsYXNzIEdlIGV4dGVuZHMgWWUge1xuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHsgbWluOiB0LCBtYXg6IGUgfSA9IHRoaXMuZ2V0TWluTWF4KCEwKTtcbiAgICB0aGlzLm1pbiA9IE4odCkgPyB0IDogMCwgdGhpcy5tYXggPSBOKGUpID8gZSA6IDEsIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaXNIb3Jpem9udGFsKCksIGUgPSB0ID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0LCBzID0gbnQodGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKSwgbiA9ICh0ID8gTWF0aC5zaW4ocykgOiBNYXRoLmNvcyhzKSkgfHwgMWUtMywgbyA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChlIC8gTWF0aC5taW4oNDAsIG8ubGluZUhlaWdodCAvIG4pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh0IC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuR2UuaWQgPSBcImxpbmVhclwiO1xuR2UuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IGJlLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuZnVuY3Rpb24gdG4oaSkge1xuICByZXR1cm4gaSAvIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKHR0KGkpKSkgPT09IDE7XG59XG5mdW5jdGlvbiBPYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBNYXRoLmZsb29yKHR0KHQubWF4KSksIHMgPSBNYXRoLmNlaWwodC5tYXggLyBNYXRoLnBvdygxMCwgZSkpLCBuID0gW107XG4gIGxldCBvID0gUShpLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IodHQodC5taW4pKSkpLCByID0gTWF0aC5mbG9vcih0dChvKSksIGEgPSBNYXRoLmZsb29yKG8gLyBNYXRoLnBvdygxMCwgcikpLCBsID0gciA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMocikpIDogMTtcbiAgZG9cbiAgICBuLnB1c2goeyB2YWx1ZTogbywgbWFqb3I6IHRuKG8pIH0pLCArK2EsIGEgPT09IDEwICYmIChhID0gMSwgKytyLCBsID0gciA+PSAwID8gMSA6IGwpLCBvID0gTWF0aC5yb3VuZChhICogTWF0aC5wb3coMTAsIHIpICogbCkgLyBsO1xuICB3aGlsZSAociA8IGUgfHwgciA9PT0gZSAmJiBhIDwgcyk7XG4gIGNvbnN0IGMgPSBRKGkubWF4LCBvKTtcbiAgcmV0dXJuIG4ucHVzaCh7IHZhbHVlOiBjLCBtYWpvcjogdG4obykgfSksIG47XG59XG5jbGFzcyBaZSBleHRlbmRzIE10IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLnN0YXJ0ID0gdm9pZCAwLCB0aGlzLmVuZCA9IHZvaWQgMCwgdGhpcy5fc3RhcnRWYWx1ZSA9IHZvaWQgMCwgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIGNvbnN0IHMgPSBZZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3QsIGVdKTtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gTihzKSAmJiBzID4gMCA/IHMgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgeyBtaW46IHQsIG1heDogZSB9ID0gdGhpcy5nZXRNaW5NYXgoITApO1xuICAgIHRoaXMubWluID0gTih0KSA/IE1hdGgubWF4KDAsIHQpIDogbnVsbCwgdGhpcy5tYXggPSBOKGUpID8gTWF0aC5tYXgoMCwgZSkgOiBudWxsLCB0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8gJiYgKHRoaXMuX3plcm8gPSAhMCksIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3QgeyBtaW5EZWZpbmVkOiB0LCBtYXhEZWZpbmVkOiBlIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcyA9IHRoaXMubWluLCBuID0gdGhpcy5tYXg7XG4gICAgY29uc3QgbyA9IChsKSA9PiBzID0gdCA/IHMgOiBsLCByID0gKGwpID0+IG4gPSBlID8gbiA6IGwsIGEgPSAobCwgYykgPT4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IodHQobCkpICsgYyk7XG4gICAgcyA9PT0gbiAmJiAocyA8PSAwID8gKG8oMSksIHIoMTApKSA6IChvKGEocywgLTEpKSwgcihhKG4sIDEpKSkpLCBzIDw9IDAgJiYgbyhhKG4sIC0xKSksIG4gPD0gMCAmJiByKGEocywgMSkpLCB0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgcyA9PT0gYSh0aGlzLm1pbiwgMCkgJiYgbyhhKHMsIC0xKSksIHRoaXMubWluID0gcywgdGhpcy5tYXggPSBuO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH0sIHMgPSBPYyhlLCB0aGlzKTtcbiAgICByZXR1cm4gdC5ib3VuZHMgPT09IFwidGlja3NcIiAmJiBjbihzLCB0aGlzLCBcInZhbHVlXCIpLCB0LnJldmVyc2UgPyAocy5yZXZlcnNlKCksIHRoaXMuc3RhcnQgPSB0aGlzLm1heCwgdGhpcy5lbmQgPSB0aGlzLm1pbikgOiAodGhpcy5zdGFydCA9IHRoaXMubWluLCB0aGlzLmVuZCA9IHRoaXMubWF4KSwgcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gXCIwXCIgOiBkZSh0LCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpLCB0aGlzLl9zdGFydFZhbHVlID0gdHQodCksIHRoaXMuX3ZhbHVlUmFuZ2UgPSB0dCh0aGlzLm1heCkgLSB0dCh0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gKHQgPT09IHZvaWQgMCB8fCB0ID09PSAwKSAmJiAodCA9IHRoaXMubWluKSwgdCA9PT0gbnVsbCB8fCBpc05hTih0KSA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHQgPT09IHRoaXMubWluID8gMCA6ICh0dCh0KSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGUgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuWmUuaWQgPSBcImxvZ2FyaXRobWljXCI7XG5aZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogYmUuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogITBcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBEaShpKSB7XG4gIGNvbnN0IHQgPSBpLnRpY2tzO1xuICBpZiAodC5kaXNwbGF5ICYmIGkuZGlzcGxheSkge1xuICAgIGNvbnN0IGUgPSBLKHQuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gQyh0LmZvbnQgJiYgdC5mb250LnNpemUsIE8uZm9udC5zaXplKSArIGUuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQWMoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9IHooZSkgPyBlIDogW2VdLCB7XG4gICAgdzogYXIoaSwgdC5zdHJpbmcsIGUpLFxuICAgIGg6IGUubGVuZ3RoICogdC5saW5lSGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBlbihpLCB0LCBlLCBzLCBuKSB7XG4gIHJldHVybiBpID09PSBzIHx8IGkgPT09IG4gPyB7XG4gICAgc3RhcnQ6IHQgLSBlIC8gMixcbiAgICBlbmQ6IHQgKyBlIC8gMlxuICB9IDogaSA8IHMgfHwgaSA+IG4gPyB7XG4gICAgc3RhcnQ6IHQgLSBlLFxuICAgIGVuZDogdFxuICB9IDoge1xuICAgIHN0YXJ0OiB0LFxuICAgIGVuZDogdCArIGVcbiAgfTtcbn1cbmZ1bmN0aW9uIFRjKGkpIHtcbiAgY29uc3QgdCA9IHtcbiAgICBsOiBpLmxlZnQgKyBpLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogaS5yaWdodCAtIGkuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogaS50b3AgKyBpLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBpLmJvdHRvbSAtIGkuX3BhZGRpbmcuYm90dG9tXG4gIH0sIGUgPSBPYmplY3QuYXNzaWduKHt9LCB0KSwgcyA9IFtdLCBuID0gW10sIG8gPSBpLl9wb2ludExhYmVscy5sZW5ndGgsIHIgPSBpLm9wdGlvbnMucG9pbnRMYWJlbHMsIGEgPSByLmNlbnRlclBvaW50TGFiZWxzID8gQiAvIG8gOiAwO1xuICBmb3IgKGxldCBsID0gMDsgbCA8IG87IGwrKykge1xuICAgIGNvbnN0IGMgPSByLnNldENvbnRleHQoaS5nZXRQb2ludExhYmVsQ29udGV4dChsKSk7XG4gICAgbltsXSA9IGMucGFkZGluZztcbiAgICBjb25zdCBoID0gaS5nZXRQb2ludFBvc2l0aW9uKGwsIGkuZHJhd2luZ0FyZWEgKyBuW2xdLCBhKSwgZCA9ICQoYy5mb250KSwgdSA9IEFjKGkuY3R4LCBkLCBpLl9wb2ludExhYmVsc1tsXSk7XG4gICAgc1tsXSA9IHU7XG4gICAgY29uc3QgZiA9IFooaS5nZXRJbmRleEFuZ2xlKGwpICsgYSksIGcgPSBNYXRoLnJvdW5kKEFpKGYpKSwgcCA9IGVuKGcsIGgueCwgdS53LCAwLCAxODApLCBtID0gZW4oZywgaC55LCB1LmgsIDkwLCAyNzApO1xuICAgIExjKGUsIHQsIGYsIHAsIG0pO1xuICB9XG4gIGkuc2V0Q2VudGVyUG9pbnQoXG4gICAgdC5sIC0gZS5sLFxuICAgIGUuciAtIHQucixcbiAgICB0LnQgLSBlLnQsXG4gICAgZS5iIC0gdC5iXG4gICksIGkuX3BvaW50TGFiZWxJdGVtcyA9IFJjKGksIHMsIG4pO1xufVxuZnVuY3Rpb24gTGMoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCBvID0gTWF0aC5hYnMoTWF0aC5zaW4oZSkpLCByID0gTWF0aC5hYnMoTWF0aC5jb3MoZSkpO1xuICBsZXQgYSA9IDAsIGwgPSAwO1xuICBzLnN0YXJ0IDwgdC5sID8gKGEgPSAodC5sIC0gcy5zdGFydCkgLyBvLCBpLmwgPSBNYXRoLm1pbihpLmwsIHQubCAtIGEpKSA6IHMuZW5kID4gdC5yICYmIChhID0gKHMuZW5kIC0gdC5yKSAvIG8sIGkuciA9IE1hdGgubWF4KGkuciwgdC5yICsgYSkpLCBuLnN0YXJ0IDwgdC50ID8gKGwgPSAodC50IC0gbi5zdGFydCkgLyByLCBpLnQgPSBNYXRoLm1pbihpLnQsIHQudCAtIGwpKSA6IG4uZW5kID4gdC5iICYmIChsID0gKG4uZW5kIC0gdC5iKSAvIHIsIGkuYiA9IE1hdGgubWF4KGkuYiwgdC5iICsgbCkpO1xufVxuZnVuY3Rpb24gUmMoaSwgdCwgZSkge1xuICBjb25zdCBzID0gW10sIG4gPSBpLl9wb2ludExhYmVscy5sZW5ndGgsIG8gPSBpLm9wdGlvbnMsIHIgPSBEaShvKSAvIDIsIGEgPSBpLmRyYXdpbmdBcmVhLCBsID0gby5wb2ludExhYmVscy5jZW50ZXJQb2ludExhYmVscyA/IEIgLyBuIDogMDtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBuOyBjKyspIHtcbiAgICBjb25zdCBoID0gaS5nZXRQb2ludFBvc2l0aW9uKGMsIGEgKyByICsgZVtjXSwgbCksIGQgPSBNYXRoLnJvdW5kKEFpKFooaC5hbmdsZSArIFYpKSksIHUgPSB0W2NdLCBmID0gSWMoaC55LCB1LmgsIGQpLCBnID0gRWMoZCksIHAgPSBGYyhoLngsIHUudywgZyk7XG4gICAgcy5wdXNoKHtcbiAgICAgIHg6IGgueCxcbiAgICAgIHk6IGYsXG4gICAgICB0ZXh0QWxpZ246IGcsXG4gICAgICBsZWZ0OiBwLFxuICAgICAgdG9wOiBmLFxuICAgICAgcmlnaHQ6IHAgKyB1LncsXG4gICAgICBib3R0b206IGYgKyB1LmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIEVjKGkpIHtcbiAgcmV0dXJuIGkgPT09IDAgfHwgaSA9PT0gMTgwID8gXCJjZW50ZXJcIiA6IGkgPCAxODAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbn1cbmZ1bmN0aW9uIEZjKGksIHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IFwicmlnaHRcIiA/IGkgLT0gdCA6IGUgPT09IFwiY2VudGVyXCIgJiYgKGkgLT0gdCAvIDIpLCBpO1xufVxuZnVuY3Rpb24gSWMoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9PT0gOTAgfHwgZSA9PT0gMjcwID8gaSAtPSB0IC8gMiA6IChlID4gMjcwIHx8IGUgPCA5MCkgJiYgKGkgLT0gdCksIGk7XG59XG5mdW5jdGlvbiB6YyhpLCB0KSB7XG4gIGNvbnN0IHsgY3R4OiBlLCBvcHRpb25zOiB7IHBvaW50TGFiZWxzOiBzIH0gfSA9IGk7XG4gIGZvciAobGV0IG4gPSB0IC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICBjb25zdCBvID0gcy5zZXRDb250ZXh0KGkuZ2V0UG9pbnRMYWJlbENvbnRleHQobikpLCByID0gJChvLmZvbnQpLCB7IHg6IGEsIHk6IGwsIHRleHRBbGlnbjogYywgbGVmdDogaCwgdG9wOiBkLCByaWdodDogdSwgYm90dG9tOiBmIH0gPSBpLl9wb2ludExhYmVsSXRlbXNbbl0sIHsgYmFja2Ryb3BDb2xvcjogZyB9ID0gbztcbiAgICBpZiAoIVQoZykpIHtcbiAgICAgIGNvbnN0IHAgPSBEdChvLmJvcmRlclJhZGl1cyksIG0gPSBLKG8uYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgIGUuZmlsbFN0eWxlID0gZztcbiAgICAgIGNvbnN0IGIgPSBoIC0gbS5sZWZ0LCB4ID0gZCAtIG0udG9wLCB2ID0gdSAtIGggKyBtLndpZHRoLCB5ID0gZiAtIGQgKyBtLmhlaWdodDtcbiAgICAgIE9iamVjdC52YWx1ZXMocCkuc29tZSgoXykgPT4gXyAhPT0gMCkgPyAoZS5iZWdpblBhdGgoKSwgYWUoZSwge1xuICAgICAgICB4OiBiLFxuICAgICAgICB5OiB4LFxuICAgICAgICB3OiB2LFxuICAgICAgICBoOiB5LFxuICAgICAgICByYWRpdXM6IHBcbiAgICAgIH0pLCBlLmZpbGwoKSkgOiBlLmZpbGxSZWN0KGIsIHgsIHYsIHkpO1xuICAgIH1cbiAgICBUdChcbiAgICAgIGUsXG4gICAgICBpLl9wb2ludExhYmVsc1tuXSxcbiAgICAgIGEsXG4gICAgICBsICsgci5saW5lSGVpZ2h0IC8gMixcbiAgICAgIHIsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvLmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IGMsXG4gICAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBjdHg6IG4gfSA9IGk7XG4gIGlmIChlKVxuICAgIG4uYXJjKGkueENlbnRlciwgaS55Q2VudGVyLCB0LCAwLCBGKTtcbiAgZWxzZSB7XG4gICAgbGV0IG8gPSBpLmdldFBvaW50UG9zaXRpb24oMCwgdCk7XG4gICAgbi5tb3ZlVG8oby54LCBvLnkpO1xuICAgIGZvciAobGV0IHIgPSAxOyByIDwgczsgcisrKVxuICAgICAgbyA9IGkuZ2V0UG9pbnRQb3NpdGlvbihyLCB0KSwgbi5saW5lVG8oby54LCBvLnkpO1xuICB9XG59XG5mdW5jdGlvbiBCYyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBpLmN0eCwgbyA9IHQuY2lyY3VsYXIsIHsgY29sb3I6IHIsIGxpbmVXaWR0aDogYSB9ID0gdDtcbiAgIW8gJiYgIXMgfHwgIXIgfHwgIWEgfHwgZSA8IDAgfHwgKG4uc2F2ZSgpLCBuLnN0cm9rZVN0eWxlID0gciwgbi5saW5lV2lkdGggPSBhLCBuLnNldExpbmVEYXNoKHQuYm9yZGVyRGFzaCksIG4ubGluZURhc2hPZmZzZXQgPSB0LmJvcmRlckRhc2hPZmZzZXQsIG4uYmVnaW5QYXRoKCksIGJvKGksIGUsIG8sIHMpLCBuLmNsb3NlUGF0aCgpLCBuLnN0cm9rZSgpLCBuLnJlc3RvcmUoKSk7XG59XG5mdW5jdGlvbiBWYyhpLCB0LCBlKSB7XG4gIHJldHVybiB2dChpLCB7XG4gICAgbGFiZWw6IGUsXG4gICAgaW5kZXg6IHQsXG4gICAgdHlwZTogXCJwb2ludExhYmVsXCJcbiAgfSk7XG59XG5jbGFzcyBOdCBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLnhDZW50ZXIgPSB2b2lkIDAsIHRoaXMueUNlbnRlciA9IHZvaWQgMCwgdGhpcy5kcmF3aW5nQXJlYSA9IHZvaWQgMCwgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXSwgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fcGFkZGluZyA9IEsoRGkodGhpcy5vcHRpb25zKSAvIDIpLCBlID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSB0LndpZHRoLCBzID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHQuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgZSAvIDIgKyB0LmxlZnQpLCB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgcyAvIDIgKyB0LnRvcCksIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKGUsIHMpIC8gMik7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7IG1pbjogdCwgbWF4OiBlIH0gPSB0aGlzLmdldE1pbk1heCghMSk7XG4gICAgdGhpcy5taW4gPSBOKHQpICYmICFpc05hTih0KSA/IHQgOiAwLCB0aGlzLm1heCA9IE4oZSkgJiYgIWlzTmFOKGUpID8gZSA6IDAsIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gRGkodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHQpIHtcbiAgICBZZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdCksIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKS5tYXAoKGUsIHMpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBJKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW2UsIHNdLCB0aGlzKTtcbiAgICAgIHJldHVybiBuIHx8IG4gPT09IDAgPyBuIDogXCJcIjtcbiAgICB9KS5maWx0ZXIoKGUsIHMpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkocykpO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zO1xuICAgIHQuZGlzcGxheSAmJiB0LnBvaW50TGFiZWxzLmRpc3BsYXkgPyBUYyh0aGlzKSA6IHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQodCwgZSwgcywgbikge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKCh0IC0gZSkgLyAyKSwgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHMgLSBuKSAvIDIpLCB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heCh0LCBlLCBzLCBuKSk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZSh0KSB7XG4gICAgY29uc3QgZSA9IEYgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpLCBzID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gWih0ICogZSArIG50KHMpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0KSB7XG4gICAgaWYgKFQodCkpXG4gICAgICByZXR1cm4gTmFOO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICh0aGlzLm1heCAtIHQpICogZSA6ICh0IC0gdGhpcy5taW4pICogZTtcbiAgfVxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcih0KSB7XG4gICAgaWYgKFQodCkpXG4gICAgICByZXR1cm4gTmFOO1xuICAgIGNvbnN0IGUgPSB0IC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gZSA6IHRoaXMubWluICsgZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmICh0ID49IDAgJiYgdCA8IGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzID0gZVt0XTtcbiAgICAgIHJldHVybiBWYyh0aGlzLmdldENvbnRleHQoKSwgdCwgcyk7XG4gICAgfVxuICB9XG4gIGdldFBvaW50UG9zaXRpb24odCwgZSwgcyA9IDApIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRJbmRleEFuZ2xlKHQpIC0gViArIHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKG4pICogZSArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKG4pICogZSArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlOiBuXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24odCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUodCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24odCkge1xuICAgIGNvbnN0IHsgbGVmdDogZSwgdG9wOiBzLCByaWdodDogbiwgYm90dG9tOiBvIH0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbdF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGUsXG4gICAgICB0b3A6IHMsXG4gICAgICByaWdodDogbixcbiAgICAgIGJvdHRvbTogb1xuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kQ29sb3I6IHQsIGdyaWQ6IHsgY2lyY3VsYXI6IGUgfSB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5jdHg7XG4gICAgICBzLnNhdmUoKSwgcy5iZWdpblBhdGgoKSwgYm8odGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGUsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCksIHMuY2xvc2VQYXRoKCksIHMuZmlsbFN0eWxlID0gdCwgcy5maWxsKCksIHMucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jdHgsIGUgPSB0aGlzLm9wdGlvbnMsIHsgYW5nbGVMaW5lczogcywgZ3JpZDogbiB9ID0gZSwgbyA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBsZXQgciwgYSwgbDtcbiAgICBpZiAoZS5wb2ludExhYmVscy5kaXNwbGF5ICYmIHpjKHRoaXMsIG8pLCBuLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5mb3JFYWNoKChjLCBoKSA9PiB7XG4gICAgICBpZiAoaCAhPT0gMCkge1xuICAgICAgICBhID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShjLnZhbHVlKTtcbiAgICAgICAgY29uc3QgZCA9IG4uc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaCAtIDEpKTtcbiAgICAgICAgQmModGhpcywgZCwgYSwgbyk7XG4gICAgICB9XG4gICAgfSksIHMuZGlzcGxheSkge1xuICAgICAgZm9yICh0LnNhdmUoKSwgciA9IG8gLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICBjb25zdCBjID0gcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQocikpLCB7IGNvbG9yOiBoLCBsaW5lV2lkdGg6IGQgfSA9IGM7XG4gICAgICAgICFkIHx8ICFoIHx8ICh0LmxpbmVXaWR0aCA9IGQsIHQuc3Ryb2tlU3R5bGUgPSBoLCB0LnNldExpbmVEYXNoKGMuYm9yZGVyRGFzaCksIHQubGluZURhc2hPZmZzZXQgPSBjLmJvcmRlckRhc2hPZmZzZXQsIGEgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGUudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpLCBsID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKHIsIGEpLCB0LmJlZ2luUGF0aCgpLCB0Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlciksIHQubGluZVRvKGwueCwgbC55KSwgdC5zdHJva2UoKSk7XG4gICAgICB9XG4gICAgICB0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgfVxuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmN0eCwgZSA9IHRoaXMub3B0aW9ucywgcyA9IGUudGlja3M7XG4gICAgaWYgKCFzLmRpc3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgbywgcjtcbiAgICB0LnNhdmUoKSwgdC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpLCB0LnJvdGF0ZShuKSwgdC50ZXh0QWxpZ24gPSBcImNlbnRlclwiLCB0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHRoaXMudGlja3MuZm9yRWFjaCgoYSwgbCkgPT4ge1xuICAgICAgaWYgKGwgPT09IDAgJiYgIWUucmV2ZXJzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQobCkpLCBoID0gJChjLmZvbnQpO1xuICAgICAgaWYgKG8gPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbbF0udmFsdWUpLCBjLnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIHQuZm9udCA9IGguc3RyaW5nLCByID0gdC5tZWFzdXJlVGV4dChhLmxhYmVsKS53aWR0aCwgdC5maWxsU3R5bGUgPSBjLmJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IGQgPSBLKGMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgdC5maWxsUmVjdChcbiAgICAgICAgICAtciAvIDIgLSBkLmxlZnQsXG4gICAgICAgICAgLW8gLSBoLnNpemUgLyAyIC0gZC50b3AsXG4gICAgICAgICAgciArIGQud2lkdGgsXG4gICAgICAgICAgaC5zaXplICsgZC5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFR0KHQsIGEubGFiZWwsIDAsIC1vLCBoLCB7XG4gICAgICAgIGNvbG9yOiBjLmNvbG9yXG4gICAgICB9KTtcbiAgICB9KSwgdC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICB9XG59XG5OdC5pZCA9IFwicmFkaWFsTGluZWFyXCI7XG5OdC5kZWZhdWx0cyA9IHtcbiAgZGlzcGxheTogITAsXG4gIGFuaW1hdGU6ICEwLFxuICBwb3NpdGlvbjogXCJjaGFydEFyZWFcIixcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6ICEwLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICBjaXJjdWxhcjogITFcbiAgfSxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdGlja3M6IHtcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogITAsXG4gICAgY2FsbGJhY2s6IGJlLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHZvaWQgMCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogITAsXG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogMTBcbiAgICB9LFxuICAgIGNhbGxiYWNrKGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgcGFkZGluZzogNSxcbiAgICBjZW50ZXJQb2ludExhYmVsczogITFcbiAgfVxufTtcbk50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIFwiYW5nbGVMaW5lcy5jb2xvclwiOiBcImJvcmRlckNvbG9yXCIsXG4gIFwicG9pbnRMYWJlbHMuY29sb3JcIjogXCJjb2xvclwiLFxuICBcInRpY2tzLmNvbG9yXCI6IFwiY29sb3JcIlxufTtcbk50LmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiBcImdyaWRcIlxuICB9XG59O1xuY29uc3QgSmUgPSB7XG4gIG1pbGxpc2Vjb25kOiB7IGNvbW1vbjogITAsIHNpemU6IDEsIHN0ZXBzOiAxZTMgfSxcbiAgc2Vjb25kOiB7IGNvbW1vbjogITAsIHNpemU6IDFlMywgc3RlcHM6IDYwIH0sXG4gIG1pbnV0ZTogeyBjb21tb246ICEwLCBzaXplOiA2ZTQsIHN0ZXBzOiA2MCB9LFxuICBob3VyOiB7IGNvbW1vbjogITAsIHNpemU6IDM2ZTUsIHN0ZXBzOiAyNCB9LFxuICBkYXk6IHsgY29tbW9uOiAhMCwgc2l6ZTogODY0ZTUsIHN0ZXBzOiAzMCB9LFxuICB3ZWVrOiB7IGNvbW1vbjogITEsIHNpemU6IDYwNDhlNSwgc3RlcHM6IDQgfSxcbiAgbW9udGg6IHsgY29tbW9uOiAhMCwgc2l6ZTogMjYyOGU2LCBzdGVwczogMTIgfSxcbiAgcXVhcnRlcjogeyBjb21tb246ICExLCBzaXplOiA3ODg0ZTYsIHN0ZXBzOiA0IH0sXG4gIHllYXI6IHsgY29tbW9uOiAhMCwgc2l6ZTogMzE1NGU3IH1cbn0sIEcgPSBPYmplY3Qua2V5cyhKZSk7XG5mdW5jdGlvbiBXYyhpLCB0KSB7XG4gIHJldHVybiBpIC0gdDtcbn1cbmZ1bmN0aW9uIHNuKGksIHQpIHtcbiAgaWYgKFQodCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGUgPSBpLl9hZGFwdGVyLCB7IHBhcnNlcjogcywgcm91bmQ6IG4sIGlzb1dlZWtkYXk6IG8gfSA9IGkuX3BhcnNlT3B0cztcbiAgbGV0IHIgPSB0O1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIChyID0gcyhyKSksIE4ocikgfHwgKHIgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gZS5wYXJzZShyLCBzKSA6IGUucGFyc2UocikpLCByID09PSBudWxsID8gbnVsbCA6IChuICYmIChyID0gbiA9PT0gXCJ3ZWVrXCIgJiYgKEJ0KG8pIHx8IG8gPT09ICEwKSA/IGUuc3RhcnRPZihyLCBcImlzb1dlZWtcIiwgbykgOiBlLnN0YXJ0T2YociwgbikpLCArcik7XG59XG5mdW5jdGlvbiBubihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBHLmxlbmd0aDtcbiAgZm9yIChsZXQgbyA9IEcuaW5kZXhPZihpKTsgbyA8IG4gLSAxOyArK28pIHtcbiAgICBjb25zdCByID0gSmVbR1tvXV0sIGEgPSByLnN0ZXBzID8gci5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChyLmNvbW1vbiAmJiBNYXRoLmNlaWwoKGUgLSB0KSAvIChhICogci5zaXplKSkgPD0gcylcbiAgICAgIHJldHVybiBHW29dO1xuICB9XG4gIHJldHVybiBHW24gLSAxXTtcbn1cbmZ1bmN0aW9uIE5jKGksIHQsIGUsIHMsIG4pIHtcbiAgZm9yIChsZXQgbyA9IEcubGVuZ3RoIC0gMTsgbyA+PSBHLmluZGV4T2YoZSk7IG8tLSkge1xuICAgIGNvbnN0IHIgPSBHW29dO1xuICAgIGlmIChKZVtyXS5jb21tb24gJiYgaS5fYWRhcHRlci5kaWZmKG4sIHMsIHIpID49IHQgLSAxKVxuICAgICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIEdbZSA/IEcuaW5kZXhPZihlKSA6IDBdO1xufVxuZnVuY3Rpb24gSGMoaSkge1xuICBmb3IgKGxldCB0ID0gRy5pbmRleE9mKGkpICsgMSwgZSA9IEcubGVuZ3RoOyB0IDwgZTsgKyt0KVxuICAgIGlmIChKZVtHW3RdXS5jb21tb24pXG4gICAgICByZXR1cm4gR1t0XTtcbn1cbmZ1bmN0aW9uIG9uKGksIHQsIGUpIHtcbiAgaWYgKCFlKVxuICAgIGlbdF0gPSAhMDtcbiAgZWxzZSBpZiAoZS5sZW5ndGgpIHtcbiAgICBjb25zdCB7IGxvOiBzLCBoaTogbiB9ID0gVGkoZSwgdCksIG8gPSBlW3NdID49IHQgPyBlW3NdIDogZVtuXTtcbiAgICBpW29dID0gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGpjKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuX2FkYXB0ZXIsIG8gPSArbi5zdGFydE9mKHRbMF0udmFsdWUsIHMpLCByID0gdFt0Lmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgYSwgbDtcbiAgZm9yIChhID0gbzsgYSA8PSByOyBhID0gK24uYWRkKGEsIDEsIHMpKVxuICAgIGwgPSBlW2FdLCBsID49IDAgJiYgKHRbbF0ubWFqb3IgPSAhMCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gcm4oaSwgdCwgZSkge1xuICBjb25zdCBzID0gW10sIG4gPSB7fSwgbyA9IHQubGVuZ3RoO1xuICBsZXQgciwgYTtcbiAgZm9yIChyID0gMDsgciA8IG87ICsrcilcbiAgICBhID0gdFtyXSwgblthXSA9IHIsIHMucHVzaCh7XG4gICAgICB2YWx1ZTogYSxcbiAgICAgIG1ham9yOiAhMVxuICAgIH0pO1xuICByZXR1cm4gbyA9PT0gMCB8fCAhZSA/IHMgOiBqYyhpLCBzLCBuLCBlKTtcbn1cbmNsYXNzIEh0IGV4dGVuZHMgTXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH0sIHRoaXMuX3VuaXQgPSBcImRheVwiLCB0aGlzLl9tYWpvclVuaXQgPSB2b2lkIDAsIHRoaXMuX29mZnNldHMgPSB7fSwgdGhpcy5fbm9ybWFsaXplZCA9ICExLCB0aGlzLl9wYXJzZU9wdHMgPSB2b2lkIDA7XG4gIH1cbiAgaW5pdCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQudGltZSB8fCAodC50aW1lID0ge30pLCBuID0gdGhpcy5fYWRhcHRlciA9IG5ldyBObi5fZGF0ZSh0LmFkYXB0ZXJzLmRhdGUpO1xuICAgIG4uaW5pdChlKSwgUXQocy5kaXNwbGF5Rm9ybWF0cywgbi5mb3JtYXRzKCkpLCB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHMucGFyc2VyLFxuICAgICAgcm91bmQ6IHMucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiBzLmlzb1dlZWtkYXlcbiAgICB9LCBzdXBlci5pbml0KHQpLCB0aGlzLl9ub3JtYWxpemVkID0gZS5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHQsIGUpIHtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gbnVsbCA6IHNuKHRoaXMsIHQpO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKSwgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0aGlzLl9hZGFwdGVyLCBzID0gdC50aW1lLnVuaXQgfHwgXCJkYXlcIjtcbiAgICBsZXQgeyBtaW46IG4sIG1heDogbywgbWluRGVmaW5lZDogciwgbWF4RGVmaW5lZDogYSB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgZnVuY3Rpb24gbChjKSB7XG4gICAgICAhciAmJiAhaXNOYU4oYy5taW4pICYmIChuID0gTWF0aC5taW4obiwgYy5taW4pKSwgIWEgJiYgIWlzTmFOKGMubWF4KSAmJiAobyA9IE1hdGgubWF4KG8sIGMubWF4KSk7XG4gICAgfVxuICAgICghciB8fCAhYSkgJiYgKGwodGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSksICh0LmJvdW5kcyAhPT0gXCJ0aWNrc1wiIHx8IHQudGlja3Muc291cmNlICE9PSBcImxhYmVsc1wiKSAmJiBsKHRoaXMuZ2V0TWluTWF4KCExKSkpLCBuID0gTihuKSAmJiAhaXNOYU4obikgPyBuIDogK2Uuc3RhcnRPZihEYXRlLm5vdygpLCBzKSwgbyA9IE4obykgJiYgIWlzTmFOKG8pID8gbyA6ICtlLmVuZE9mKERhdGUubm93KCksIHMpICsgMSwgdGhpcy5taW4gPSBNYXRoLm1pbihuLCBvIC0gMSksIHRoaXMubWF4ID0gTWF0aC5tYXgobiArIDEsIG8pO1xuICB9XG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgcyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICByZXR1cm4gdC5sZW5ndGggJiYgKGUgPSB0WzBdLCBzID0gdFt0Lmxlbmd0aCAtIDFdKSwgeyBtaW46IGUsIG1heDogcyB9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHQudGltZSwgcyA9IHQudGlja3MsIG4gPSBzLnNvdXJjZSA9PT0gXCJsYWJlbHNcIiA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgIHQuYm91bmRzID09PSBcInRpY2tzXCIgJiYgbi5sZW5ndGggJiYgKHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCBuWzBdLCB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgbltuLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBvID0gdGhpcy5taW4sIHIgPSB0aGlzLm1heCwgYSA9IFJvKG4sIG8sIHIpO1xuICAgIHJldHVybiB0aGlzLl91bml0ID0gZS51bml0IHx8IChzLmF1dG9Ta2lwID8gbm4oZS5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobykpIDogTmModGhpcywgYS5sZW5ndGgsIGUubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSksIHRoaXMuX21ham9yVW5pdCA9ICFzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gXCJ5ZWFyXCIgPyB2b2lkIDAgOiBIYyh0aGlzLl91bml0KSwgdGhpcy5pbml0T2Zmc2V0cyhuKSwgdC5yZXZlcnNlICYmIGEucmV2ZXJzZSgpLCBybih0aGlzLCBhLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgdGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXAgJiYgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCgodCkgPT4gK3QudmFsdWUpKTtcbiAgfVxuICBpbml0T2Zmc2V0cyh0KSB7XG4gICAgbGV0IGUgPSAwLCBzID0gMCwgbiwgbztcbiAgICB0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHQubGVuZ3RoICYmIChuID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodFswXSksIHQubGVuZ3RoID09PSAxID8gZSA9IDEgLSBuIDogZSA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0WzFdKSAtIG4pIC8gMiwgbyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbdC5sZW5ndGggLSAxXSksIHQubGVuZ3RoID09PSAxID8gcyA9IG8gOiBzID0gKG8gLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0W3QubGVuZ3RoIC0gMl0pKSAvIDIpO1xuICAgIGNvbnN0IHIgPSB0Lmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIGUgPSBZKGUsIDAsIHIpLCBzID0gWShzLCAwLCByKSwgdGhpcy5fb2Zmc2V0cyA9IHsgc3RhcnQ6IGUsIGVuZDogcywgZmFjdG9yOiAxIC8gKGUgKyAxICsgcykgfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FkYXB0ZXIsIGUgPSB0aGlzLm1pbiwgcyA9IHRoaXMubWF4LCBuID0gdGhpcy5vcHRpb25zLCBvID0gbi50aW1lLCByID0gby51bml0IHx8IG5uKG8ubWluVW5pdCwgZSwgcywgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShlKSksIGEgPSBDKG8uc3RlcFNpemUsIDEpLCBsID0gciA9PT0gXCJ3ZWVrXCIgPyBvLmlzb1dlZWtkYXkgOiAhMSwgYyA9IEJ0KGwpIHx8IGwgPT09ICEwLCBoID0ge307XG4gICAgbGV0IGQgPSBlLCB1LCBmO1xuICAgIGlmIChjICYmIChkID0gK3Quc3RhcnRPZihkLCBcImlzb1dlZWtcIiwgbCkpLCBkID0gK3Quc3RhcnRPZihkLCBjID8gXCJkYXlcIiA6IHIpLCB0LmRpZmYocywgZSwgcikgPiAxZTUgKiBhKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGUgKyBcIiBhbmQgXCIgKyBzICsgXCIgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiBcIiArIGEgKyBcIiBcIiArIHIpO1xuICAgIGNvbnN0IGcgPSBuLnRpY2tzLnNvdXJjZSA9PT0gXCJkYXRhXCIgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodSA9IGQsIGYgPSAwOyB1IDwgczsgdSA9ICt0LmFkZCh1LCBhLCByKSwgZisrKVxuICAgICAgb24oaCwgdSwgZyk7XG4gICAgcmV0dXJuICh1ID09PSBzIHx8IG4uYm91bmRzID09PSBcInRpY2tzXCIgfHwgZiA9PT0gMSkgJiYgb24oaCwgdSwgZyksIE9iamVjdC5rZXlzKGgpLnNvcnQoKHAsIG0pID0+IHAgLSBtKS5tYXAoKHApID0+ICtwKTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWRhcHRlciwgcyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIHJldHVybiBzLnRvb2x0aXBGb3JtYXQgPyBlLmZvcm1hdCh0LCBzLnRvb2x0aXBGb3JtYXQpIDogZS5mb3JtYXQodCwgcy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IHRoaXMub3B0aW9ucywgciA9IG8udGltZS5kaXNwbGF5Rm9ybWF0cywgYSA9IHRoaXMuX3VuaXQsIGwgPSB0aGlzLl9tYWpvclVuaXQsIGMgPSBhICYmIHJbYV0sIGggPSBsICYmIHJbbF0sIGQgPSBzW2VdLCB1ID0gbCAmJiBoICYmIGQgJiYgZC5tYWpvciwgZiA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHQsIG4gfHwgKHUgPyBoIDogYykpLCBnID0gby50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZyA/IEkoZywgW2YsIGUsIHNdLCB0aGlzKSA6IGY7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHQpIHtcbiAgICBsZXQgZSwgcywgbjtcbiAgICBmb3IgKGUgPSAwLCBzID0gdC5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgICBuID0gdFtlXSwgbi5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihuLnZhbHVlLCBlLCB0KTtcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiB0ID09PSBudWxsID8gTmFOIDogKHQgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29mZnNldHMsIHMgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0KTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKGUuc3RhcnQgKyBzKSAqIGUuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb2Zmc2V0cywgcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpIC8gZS5mYWN0b3IgLSBlLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBzICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMudGlja3MsIHMgPSB0aGlzLmN0eC5tZWFzdXJlVGV4dCh0KS53aWR0aCwgbiA9IG50KHRoaXMuaXNIb3Jpem9udGFsKCkgPyBlLm1heFJvdGF0aW9uIDogZS5taW5Sb3RhdGlvbiksIG8gPSBNYXRoLmNvcyhuKSwgciA9IE1hdGguc2luKG4pLCBhID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiBzICogbyArIGEgKiByLFxuICAgICAgaDogcyAqIHIgKyBhICogb1xuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMudGltZSwgcyA9IGUuZGlzcGxheUZvcm1hdHMsIG4gPSBzW2UudW5pdF0gfHwgcy5taWxsaXNlY29uZCwgbyA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0LCAwLCBybih0aGlzLCBbdF0sIHRoaXMuX21ham9yVW5pdCksIG4pLCByID0gdGhpcy5fZ2V0TGFiZWxTaXplKG8pLCBhID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHIudyA6IHRoaXMuaGVpZ2h0IC8gci5oKSAtIDE7XG4gICAgcmV0dXJuIGEgPiAwID8gYSA6IDE7XG4gIH1cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdLCBlLCBzO1xuICAgIGlmICh0Lmxlbmd0aClcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbi5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGF0YSA9IG5bMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcyk7XG4gICAgZm9yIChlID0gMCwgcyA9IG4ubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgICAgdCA9IHQuY29uY2F0KG5bZV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodCk7XG4gIH1cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGUsIHM7XG4gICAgaWYgKHQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChlID0gMCwgcyA9IG4ubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgICAgdC5wdXNoKHNuKHRoaXMsIG5bZV0pKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHQgOiB0aGlzLm5vcm1hbGl6ZSh0KTtcbiAgfVxuICBub3JtYWxpemUodCkge1xuICAgIHJldHVybiB1bih0LnNvcnQoV2MpKTtcbiAgfVxufVxuSHQuaWQgPSBcInRpbWVcIjtcbkh0LmRlZmF1bHRzID0ge1xuICBib3VuZHM6IFwiZGF0YVwiLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6ICExLFxuICAgIHVuaXQ6ICExLFxuICAgIHJvdW5kOiAhMSxcbiAgICBpc29XZWVrZGF5OiAhMSxcbiAgICBtaW5Vbml0OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiBcImF1dG9cIixcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogITFcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBGZShpLCB0LCBlKSB7XG4gIGxldCBzID0gMCwgbiA9IGkubGVuZ3RoIC0gMSwgbywgciwgYSwgbDtcbiAgZSA/ICh0ID49IGlbc10ucG9zICYmIHQgPD0gaVtuXS5wb3MgJiYgKHsgbG86IHMsIGhpOiBuIH0gPSBmdChpLCBcInBvc1wiLCB0KSksIHsgcG9zOiBvLCB0aW1lOiBhIH0gPSBpW3NdLCB7IHBvczogciwgdGltZTogbCB9ID0gaVtuXSkgOiAodCA+PSBpW3NdLnRpbWUgJiYgdCA8PSBpW25dLnRpbWUgJiYgKHsgbG86IHMsIGhpOiBuIH0gPSBmdChpLCBcInRpbWVcIiwgdCkpLCB7IHRpbWU6IG8sIHBvczogYSB9ID0gaVtzXSwgeyB0aW1lOiByLCBwb3M6IGwgfSA9IGlbbl0pO1xuICBjb25zdCBjID0gciAtIG87XG4gIHJldHVybiBjID8gYSArIChsIC0gYSkgKiAodCAtIG8pIC8gYyA6IGE7XG59XG5jbGFzcyBRZSBleHRlbmRzIEh0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl90YWJsZSA9IFtdLCB0aGlzLl9taW5Qb3MgPSB2b2lkIDAsIHRoaXMuX3RhYmxlUmFuZ2UgPSB2b2lkIDA7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpLCBlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodCk7XG4gICAgdGhpcy5fbWluUG9zID0gRmUoZSwgdGhpcy5taW4pLCB0aGlzLl90YWJsZVJhbmdlID0gRmUoZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zLCBzdXBlci5pbml0T2Zmc2V0cyh0KTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHQpIHtcbiAgICBjb25zdCB7IG1pbjogZSwgbWF4OiBzIH0gPSB0aGlzLCBuID0gW10sIG8gPSBbXTtcbiAgICBsZXQgciwgYSwgbCwgYywgaDtcbiAgICBmb3IgKHIgPSAwLCBhID0gdC5sZW5ndGg7IHIgPCBhOyArK3IpXG4gICAgICBjID0gdFtyXSwgYyA+PSBlICYmIGMgPD0gcyAmJiBuLnB1c2goYyk7XG4gICAgaWYgKG4ubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgdGltZTogZSwgcG9zOiAwIH0sXG4gICAgICAgIHsgdGltZTogcywgcG9zOiAxIH1cbiAgICAgIF07XG4gICAgZm9yIChyID0gMCwgYSA9IG4ubGVuZ3RoOyByIDwgYTsgKytyKVxuICAgICAgaCA9IG5bciArIDFdLCBsID0gbltyIC0gMV0sIGMgPSBuW3JdLCBNYXRoLnJvdW5kKChoICsgbCkgLyAyKSAhPT0gYyAmJiBvLnB1c2goeyB0aW1lOiBjLCBwb3M6IHIgLyAoYSAtIDEpIH0pO1xuICAgIHJldHVybiBvO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKSwgcyA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgcmV0dXJuIGUubGVuZ3RoICYmIHMubGVuZ3RoID8gdCA9IHRoaXMubm9ybWFsaXplKGUuY29uY2F0KHMpKSA6IHQgPSBlLmxlbmd0aCA/IGUgOiBzLCB0ID0gdGhpcy5fY2FjaGUuYWxsID0gdCwgdDtcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiAoRmUodGhpcy5fdGFibGUsIHQpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29mZnNldHMsIHMgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbCh0KSAvIGUuZmFjdG9yIC0gZS5lbmQ7XG4gICAgcmV0dXJuIEZlKHRoaXMuX3RhYmxlLCBzICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgITApO1xuICB9XG59XG5RZS5pZCA9IFwidGltZXNlcmllc1wiO1xuUWUuZGVmYXVsdHMgPSBIdC5kZWZhdWx0cztcbnZhciB4byA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDYXRlZ29yeVNjYWxlOiBjZSxcbiAgTGluZWFyU2NhbGU6IEdlLFxuICBMb2dhcml0aG1pY1NjYWxlOiBaZSxcbiAgUmFkaWFsTGluZWFyU2NhbGU6IE50LFxuICBUaW1lU2NhbGU6IEh0LFxuICBUaW1lU2VyaWVzU2NhbGU6IFFlXG59KTtcbmNvbnN0ICRjID0gW1xuICBXbixcbiAgb28sXG4gIG1vLFxuICB4b1xuXSwgWWMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBbmltYXRpb246IEluLFxuICBBbmltYXRpb25zOiBOaSxcbiAgQXJjRWxlbWVudDogeWUsXG4gIEJhckNvbnRyb2xsZXI6IHVlLFxuICBCYXJFbGVtZW50OiBNZSxcbiAgQmFzZVBsYXRmb3JtOiBIaSxcbiAgQmFzaWNQbGF0Zm9ybTogWW4sXG4gIEJ1YmJsZUNvbnRyb2xsZXI6IGZlLFxuICBDYXRlZ29yeVNjYWxlOiBjZSxcbiAgQ2hhcnQ6IGppLFxuICBEYXRhc2V0Q29udHJvbGxlcjogaXQsXG4gIERlY2ltYXRpb246IGFvLFxuICBEb21QbGF0Zm9ybTogS24sXG4gIERvdWdobnV0Q29udHJvbGxlcjogTHQsXG4gIEVsZW1lbnQ6IHN0LFxuICBGaWxsZXI6IGhvLFxuICBJbnRlcmFjdGlvbjogSG4sXG4gIExlZ2VuZDogdW8sXG4gIExpbmVDb250cm9sbGVyOiBnZSxcbiAgTGluZUVsZW1lbnQ6IGd0LFxuICBMaW5lYXJTY2FsZTogR2UsXG4gIExvZ2FyaXRobWljU2NhbGU6IFplLFxuICBQaWVDb250cm9sbGVyOiBxZSxcbiAgUG9pbnRFbGVtZW50OiB2ZSxcbiAgUG9sYXJBcmVhQ29udHJvbGxlcjogcGUsXG4gIFJhZGFyQ29udHJvbGxlcjogbWUsXG4gIFJhZGlhbExpbmVhclNjYWxlOiBOdCxcbiAgU2NhbGU6IE10LFxuICBTY2F0dGVyQ29udHJvbGxlcjogeGUsXG4gIFN1YlRpdGxlOiBnbyxcbiAgVGlja3M6IGJlLFxuICBUaW1lU2NhbGU6IEh0LFxuICBUaW1lU2VyaWVzU2NhbGU6IFFlLFxuICBUaXRsZTogZm8sXG4gIFRvb2x0aXA6IHBvLFxuICBfYWRhcHRlcnM6IE5uLFxuICBfZGV0ZWN0UGxhdGZvcm06IHFuLFxuICBhbmltYXRvcjogYXQsXG4gIGNvbnRyb2xsZXJzOiBXbixcbiAgZGVmYXVsdHM6IE8sXG4gIGVsZW1lbnRzOiBvbyxcbiAgbGF5b3V0czogWCxcbiAgcGx1Z2luczogbW8sXG4gIHJlZ2lzdGVyYWJsZXM6ICRjLFxuICByZWdpc3RyeTogb3QsXG4gIHNjYWxlczogeG9cbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5leHBvcnQge1xuICB5ZSBhcyBBLFxuICBNZSBhcyBCLFxuICB2ZSBhcyBQLFxuICBLIGFzIGEsXG4gIEQgYXMgYixcbiAgSSBhcyBjLFxuICBPIGFzIGQsXG4gIEUgYXMgZSxcbiAgWWMgYXMgZixcbiAgVCBhcyBpLFxuICBuZSBhcyBtLFxuICBadCBhcyByLFxuICAkIGFzIHQsXG4gIEMgYXMgdlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tw-elements/dist/js/chart.es.js\n");

/***/ })

}]);